<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android Gradle 学习笔记一</title>
      <link href="/posts/a3b80f176756/"/>
      <url>/posts/a3b80f176756/</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要讨论 Gradle 构建项目中的细节，而非构建 Gradle 的语言 Groovy 本身。</p></blockquote><hr /><h1 id="gradle-是什么"><a class="markdownIt-Anchor" href="#gradle-是什么"></a> Gradle 是什么</h1><ol><li>Gradle 是一个构建工具。</li><li>Gradle 并非一门语言，它是使用了 Groovy 语言创造出的一个 DSL。</li></ol><h1 id="gradle-如何构建"><a class="markdownIt-Anchor" href="#gradle-如何构建"></a> Gradle 如何构建</h1><p>我们通过 Gradle 的语法，在下列文件中指定 Gradle 的规则：</p><ol><li><p><code>build.gradle</code></p></li><li><p><code>settings.gradle</code></p></li><li><p><code>gradle-warpper</code></p></li><li><p>…</p></li></ol><h1 id="groovy-语言部分特性"><a class="markdownIt-Anchor" href="#groovy-语言部分特性"></a> Groovy 语言部分特性</h1><ol><li><p>使用函数时，函数名称后面的括号可以不写。</p></li><li><p>可以通过闭包传递函数以及其他的属性。</p><blockquote><p>闭包</p><ol><li>可以理解为 Groovy 中的 Lambda 表达式。</li><li>在功能上，和 Kotlin 的 Lambda ⽐较相似，都是⼀个「可以传递的代码块」，但是具体的功能⽐ Kotlin 的 Lambda 更强⼀些，但基本的概念是⼀样的。都是由大括号包含代码块组成。</li></ol></blockquote></li><li><p>如果函数定义的最后一个参数为闭包，那么闭包便可以写在括号外面；如果该函数只有一个参数且该参数为闭包，那么小括号可以省略。</p></li><li><p>可以在每个类中定义 <code>methodMissing</code> 函数，如果在脚本中执行了一个未在该类中定义的一个函数，Groovy 便会调用该类的 <code>methodMissing</code> 函数，并在该函数中寻找我们写入的解决方案。</p><blockquote><p>例如，<code>build.gradle</code> 中的 <code>classpath</code> 便是通过调用 <code>methodMissing</code> 函数实现依赖添加的功能。</p></blockquote></li><li><p>单引号和双引号都可以表达字符串的概念。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Gradle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AutoHotKey 变量和字符串</title>
      <link href="/posts/82303f29c0e9/"/>
      <url>/posts/82303f29c0e9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Variables.htm">变量和表达式 | AutoHotkey (autoahk.com)</a></li><li><a href="https://www.autohotkey.com/boards/viewtopic.php?t=14633">String literal that spans multiple lines? - AutoHotkey Community</a></li></ul></blockquote><hr /><blockquote><p>下文中的链接皆指向 AHK 技术文档，可放心查看。</p></blockquote><hr /><h1 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h1><p>有关一般说明和变量如何工作的详细信息, 请参阅<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Concepts.htm#variables">变量</a>.</p><h2 id="给变量赋值"><a class="markdownIt-Anchor" href="#给变量赋值"></a> <strong>给变量赋值</strong></h2><p>要将字符串或数字存储在变量中, 有两种方法: <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#legacy-syntax">传统方式</a>和<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#expressions">表达式</a>. 传统方法使用<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/SetEnv.htm">等号运算符(=)</a> 来指定<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#unquoted-text"><strong>不加引号的</strong>原义字符串</a>或用百分号括起来的变量. 例如:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyNumber = <span class="number">123</span></span><br><span class="line">MyString = This is a literal string.</span><br><span class="line">CopyOfVar = <span class="variable">%Var%</span>  <span class="comment">; 和 = 运算符一起使用时, 需要使用百分号来获取变量的内容.</span></span><br></pre></td></tr></table></figure><p>与之相比, 表达式方法使用<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/SetExpression.htm">冒号等号运算符(:=)</a> 来保存数字, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#strings"><strong>加引号的</strong>字符串</a>和其他类型的<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#expressions">表达式</a>. 以下示例在功能上与前面的例子相同:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyNumber := <span class="number">123</span></span><br><span class="line">MyString := <span class="string">&quot;This is a literal string.&quot;</span></span><br><span class="line">CopyOfVar := Var  <span class="comment">; 和前面段落中与其作用相同的语句不同, 百分号不和 := 运算符一起使用.</span></span><br></pre></td></tr></table></figure><p><strong>后一种方法由于其更清晰并且与其他许多语言几乎一致的<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#expressions">表达式语法</a>成为大多数人的首选方法.</strong></p><p>从上面的例子中您可能已经想到了有两种方法来清除变量的内容(即让变量为空):</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyVar =</span><br><span class="line">MyVar := <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>上面的这对空引号只能和 := 运算符一起使用, 因为和 = 运算符一起使用时, 则会在变量中保存两个原义的引号字符.</p><h2 id="获取变量的内容"><a class="markdownIt-Anchor" href="#获取变量的内容"></a> <strong>获取变量的内容</strong></h2><p>如同赋值有两种方法, 获取变量的内容也有两种方法: <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#legacy-syntax">传统方法</a>和<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#variables">表达式方法</a>. 传统方法需要将变量名包围在百分号中来获取变量的内容. 例如:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MsgBox The value in the variable named Var is <span class="variable">%Var%</span>.</span><br><span class="line">CopyOfVar = <span class="variable">%Var%</span></span><br></pre></td></tr></table></figure><p>与之相比, 表达式方法省去了变量名两边的百分号, 但<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#strings">原义的字符串</a>必须包围在双引号中. 所以, 下面的表达式作用等同于上面的例子:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MsgBox %</span> <span class="string">&quot;The value in the variable named Var is &quot;</span> . Var . <span class="string">&quot;.&quot;</span>  <span class="comment">; 使用句点连接(join 拼接) 两个字符串.</span></span><br><span class="line">CopyOfVar := Var</span><br></pre></td></tr></table></figure><p>在上面的 MsgBox 这行, 通过使用<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#-expression">百分号和空格</a>把参数从传统模式改变为表达式模式. 因为所有的命令默认情况下使用传统模式(除了另外注明的那些), 所以这是必须的.</p><h2 id="变量的比较"><a class="markdownIt-Anchor" href="#变量的比较"></a> <strong>变量的比较</strong></h2><p>请阅读下面表达式部分中关于不同类型变量比较的重要提示, 尤其是关于何时使用小括号的内容.</p><hr /><h1 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h1><h2 id="保存带有引号的字符串"><a class="markdownIt-Anchor" href="#保存带有引号的字符串"></a> 保存带有引号的字符串</h2><p>如果我们想用变量保存一个带有双引号的字符串，需要使用 = 操作符：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var = this is <span class="string">&quot; ; 输出的字符串中包含双引号</span></span><br></pre></td></tr></table></figure><h2 id="保存多行字符串"><a class="markdownIt-Anchor" href="#保存多行字符串"></a> 保存多行字符串</h2><p>如果我们想要保存多行的字符串，可以使用 <code>()</code> 包含文本内容并使用 <code>=</code> 且 <strong>不加 <code>&quot;&quot;</code></strong> 的方式（文本中每行的字符串形式与使用 <code>=</code> 操作符保存单行字符串的形式相同）：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var = string</span><br><span class="line"></span><br><span class="line">exampleString =</span><br><span class="line">(                      <span class="comment">; 左括号右侧的字符会被自动忽略，正文从下行开始</span></span><br><span class="line">    multiple</span><br><span class="line">        lines          <span class="comment">; 该行字符的所有字符（包括空格）会全部输出</span></span><br><span class="line">                       <span class="comment">; 空行也会如实输出  </span></span><br><span class="line"><span class="built_in">    of</span></span><br><span class="line"><span class="built_in">        %</span>var%</span><br><span class="line">)                      <span class="comment">; 右括号左侧不能有其他字符，否则将报错</span></span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">MsgBox,</span> % exampleString</span><br></pre></td></tr></table></figure><p>输出结果截图（第一个非空字符前的空格将忽略）：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220723170233064.png" alt="image-20220723170233064" style="zoom: 50%;" /><p><strong>注意：</strong></p><ol><li>该方式中的 <code>()</code> 必须分别、单独在一行，不能接在其他语句末尾。且文本将严格按照输入形式输出，两个括号之间的空行和空格也会如实输出，但是第一个非空字符前的空格将忽略。</li><li>左括号右侧的字符会被自动忽略，正文从下行开始；右括号左侧不能有其他字符，否则将报错。</li><li>如果需要使用 <code>:=</code> 操作符进行多行字符串保存，请使用 ``n` 转义字符进行换行操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> AutoHotKey </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoHotKey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 标准函数</title>
      <link href="/posts/d15d647b4c31/"/>
      <url>/posts/d15d647b4c31/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Kotlin 标准函数 <code>Standard.kt</code> 源码  <code>GitHub</code> 仓库地址:</p><ul><li><a href="https://github.com/JetBrains/kotlin/blob/1.5.30/libraries/stdlib/src/kotlin/util/Standard.kt">kotlin/Standard.kt at 1.5.30 · JetBrains/kotlin (github.com)</a></li></ul></blockquote><hr /><h1 id="初始代码"><a class="markdownIt-Anchor" href="#初始代码"></a> 初始代码</h1><blockquote><p>下方给出一份初始代码，并在接下来的部分标准函数中给出使用该标准函数的修改后代码。</p><p>初始代码摘自《第一行代码 Android 第3版》。</p></blockquote><p>比如有一个水果列表，现在我们想吃完所有水果，并将结果打印出来，就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">builder.append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">    builder.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">builder.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = builder.toString()</span><br><span class="line">println(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行的结果为：</span></span><br><span class="line">Start eating fruits.</span><br><span class="line">Apple</span><br><span class="line">Banana</span><br><span class="line">Orange</span><br><span class="line">Pear</span><br><span class="line">Grape</span><br><span class="line">Ate all fruits.</span><br></pre></td></tr></table></figure><hr /><h1 id="run"><a class="markdownIt-Anchor" href="#run"></a> <code>run</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] and returns its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">run</span><span class="params">(block: () -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = run &#123;</span><br><span class="line">    <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">    builder.append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        builder.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    builder.toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><hr /><h1 id="trun"><a class="markdownIt-Anchor" href="#trun"></a> <code>T.run</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with `this` value as its receiver and returns its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = StringBuilder().run &#123;</span><br><span class="line">    append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><hr /><h1 id="with"><a class="markdownIt-Anchor" href="#with"></a> <code>with</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> receiver.block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = with(StringBuilder()) &#123;</span><br><span class="line">    append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        append(fruit).append(<span class="string">&quot;\n&quot;</span>)          </span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><hr /><h1 id="tapply"><a class="markdownIt-Anchor" href="#tapply"></a> <code>T.apply</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with `this` value as its receiver and returns `this` value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = StringBuilder().apply &#123;</span><br><span class="line">    append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(result.toString())</span><br></pre></td></tr></table></figure><hr /><h1 id="talso"><a class="markdownIt-Anchor" href="#talso"></a> <code>T.also</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with `this` value as its argument and returns `this` value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">also</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = StringBuilder().also &#123;</span><br><span class="line">    it.append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        it.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    it.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(result.toString())</span><br></pre></td></tr></table></figure><hr /><h1 id="tlet"><a class="markdownIt-Anchor" href="#tlet"></a> <code>T.let</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with `this` value as its argument and returns its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = StringBuilder().let &#123;</span><br><span class="line">    it.append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        it.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    it.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    it.toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><hr /><h1 id="ttakeif"><a class="markdownIt-Anchor" href="#ttakeif"></a> <code>T.takeIf</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn&#x27;t.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">takeIf</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (predicate(<span class="keyword">this</span>)) <span class="keyword">this</span> <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="ttakeunless"><a class="markdownIt-Anchor" href="#ttakeunless"></a> <code>T.takeUnless</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">takeUnless</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (!predicate(<span class="keyword">this</span>)) <span class="keyword">this</span> <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="trepeat"><a class="markdownIt-Anchor" href="#trepeat"></a> <code>T.repeat</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the given function [action] specified number of [times].</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A zero-based index of current iteration is passed as a parameter to [action].</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@sample</span> samples.misc.ControlFlow.repeat</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">repeat</span><span class="params">(times: <span class="type">Int</span>, action: (<span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    contract &#123; callsInPlace(action) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until times) &#123;</span><br><span class="line">        action(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="部分函数比较"><a class="markdownIt-Anchor" href="#部分函数比较"></a> 部分函数比较</h1><table><thead><tr><th style="text-align:center">标准函数 形参</th><th style="text-align:center">Lambda 形参</th><th style="text-align:center">Lambda 返回值</th><th style="text-align:center">标准函数 返回值</th><th style="text-align:center">作用域 参数</th></tr></thead><tbody><tr><td style="text-align:center"><code>run &#123;&#125;</code></td><td style="text-align:center"><code>()</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>\</code></td></tr><tr><td style="text-align:center"><code>T.run &#123;&#125;</code></td><td style="text-align:center"><code>T.()</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>(this.)</code></td></tr><tr><td style="text-align:center"><code>with(obj : T) &#123;&#125;</code></td><td style="text-align:center"><code>T.()</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>(this.)</code></td></tr><tr><td style="text-align:center"><code>T.apply &#123;&#125;</code></td><td style="text-align:center"><code>T.()</code></td><td style="text-align:center"><code>Unit</code></td><td style="text-align:center"><code>T</code></td><td style="text-align:center"><code>(this.)</code></td></tr><tr><td style="text-align:center"><code>T.also &#123;&#125;</code></td><td style="text-align:center"><code>(T)</code></td><td style="text-align:center"><code>Unit</code></td><td style="text-align:center"><code>T</code></td><td style="text-align:center"><code>it.</code></td></tr><tr><td style="text-align:center"><code>T.let &#123;&#125;</code></td><td style="text-align:center"><code>(T)</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>it.</code></td></tr></tbody></table><p>使用时可以通过简单的规则作出⼀些判断：</p><ol><li><p>返回自身 -&gt; 从 <code>apply</code> 和 <code>also</code> 中选</p><ul><li>作用域中使用 <code>this</code> 作为参数 -&gt; 选择 <code>apply</code></li><li>作用域中使用 <code>it</code> 作为参数 -&gt; 选择 <code>also</code></li></ul></li><li><p>不需要返回自身（可以返回任意类型） -&gt; 从 <code>run</code> 和 <code>let</code> 中选择</p><ul><li>作用域中使用 <code>this</code> 作为参数 -&gt; 选择 <code>run</code></li><li>作用域中使用 <code>it</code> 作为参数 -&gt; 选择 <code>let</code></li></ul></li><li><p><code>apply</code> 适合对一个对象做附加操作的时候</p></li><li><p><code>let</code> 适合配合空判断的时候 (最好是成员变量，⽽不是局部变量，局部变量更适合用 <code>if</code> )</p></li><li><p><code>with</code> 适合对同一个对象进行多次操作的时候</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AutoHotKey 类的定义与部分使用技巧</title>
      <link href="/posts/61bd48ea70cc/"/>
      <url>/posts/61bd48ea70cc/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文所使用的AHK版本为 AutoHotKey_v1 。</p></blockquote><hr /><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>本人想在 AHK 中使用面向对象的方式编写代码，但是发现在官方文档中仅有较少关于 class` 的操作代码示例，所以根据自己这两天的代码编写过程，整理出常用的一些使用技巧供大家参考。</p><hr /><h1 id="类的创建和使用"><a class="markdownIt-Anchor" href="#类的创建和使用"></a> 类的创建和使用</h1><p>类的创建使用 <code>class</code>  关键字。可以显式定义构造方法以及析构方法：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 类的创建</span></span><br><span class="line">class A &#123;</span><br><span class="line">    <span class="comment">; 静态变量的创建</span></span><br><span class="line">    static var1 := Expression1</span><br><span class="line">    <span class="comment">; 类字段的创建</span></span><br><span class="line">    var2 := Expression2</span><br><span class="line">    </span><br><span class="line">    <span class="comment">; 构造方法，可传入任意参数，也可不传入参数</span></span><br><span class="line">    __New(...) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">; 方法的创建</span></span><br><span class="line">    <span class="comment">; 可传入任意参数，参数支持默认参数值</span></span><br><span class="line">    <span class="comment">; 根据需要可不写 return</span></span><br><span class="line">    methodName(...) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">; 析构方法</span></span><br><span class="line">    __Delete() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的使用：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="keyword">new</span> A(...)   <span class="comment">; 类的实例化，根据构造方法传入对应的参数</span></span><br><span class="line">a.methodName(...) <span class="comment">; 使用变量的方法</span></span><br></pre></td></tr></table></figure><hr /><h1 id="在类中创建热键并绑定类方法"><a class="markdownIt-Anchor" href="#在类中创建热键并绑定类方法"></a> 在类中创建热键并绑定类方法</h1><p>使用面向对象的思想编写代码的话，我们或许需要在类中创建热键及其响应逻辑的方法：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    <span class="comment">; 自定义的一个方法，用于加载类中所有的热键</span></span><br><span class="line">    loadHotKey() &#123;</span><br><span class="line">        <span class="comment">; 创建响应方法的方法引用</span></span><br><span class="line">        varFunctionA := ObjBindMethod(this, <span class="string">&quot;functionA&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">; 创建 Alt + A 的热键以及绑定其响应方法</span></span><br><span class="line"><span class="built_in">        HotKey,</span> !A, % varFunctionA, On</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    functionA() &#123;</span><br><span class="line">    <span class="comment">; 热键的响应逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码便在类中创建了一个使用类中方法作为响应逻辑的热键。其中：</p><ol><li><code>varFunctionA := ObjBindMethod(this, &quot;functionA&quot;)</code> 部分：<ol><li><code>&quot;functionA&quot;</code> 中双引号必须保留，双引号中间内容为对应的方法名。</li><li><code>varFunctionName</code> 为自定义的变量名称，与第7行第3个参数相对应。</li></ol></li><li><code>HotKey, !A, % varFunctionA, On</code> 部分：<ol><li><code>!A</code> 为热键的内容，具体可以参考文档中 <strong>热键</strong> 部分内容。</li><li><code>% varFunctionA</code> 中百分号必须保留，后面的内容对应上面一行自定义的变量名。</li></ol></li></ol><p>热键的使用：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> A().loadHotKey()</span><br></pre></td></tr></table></figure><p>通过对该类的实例化并调用实例化对象的 <code>loadHotKey</code> 方法即可。</p><hr /><h1 id="在类中绘制-ui-并绑定类方法"><a class="markdownIt-Anchor" href="#在类中绘制-ui-并绑定类方法"></a> 在类中绘制 <code>UI</code> 并绑定类方法</h1><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class B &#123;</span><br><span class="line">    <span class="comment">; 自定义的一个方法，用于绘制 UI 以及绑定响应的方法</span></span><br><span class="line">    loadView() &#123;</span><br><span class="line">        <span class="comment">; 绘制了一个按钮</span></span><br><span class="line"><span class="built_in">        Gui,</span> Add, Button, w200 h35 hwndHFuncB, This is a button.</span><br><span class="line"></span><br><span class="line">        <span class="comment">; 创建了响应方法的方法引用</span></span><br><span class="line">        varFuncB := ObjBindMethod(this, <span class="string">&quot;functionB&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">; 通过 HWND 将按钮与方法绑定</span></span><br><span class="line"><span class="built_in">        GuiControl,</span> +g, <span class="variable">%HFuncB%</span>, % varFuncB</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    functionB() &#123;</span><br><span class="line">        <span class="comment">; 按钮的响应逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>Gui, Add, Button, w200 h35 hwndHFuncB, This is a button.</code> 中 <code>hwndHFuncB</code> 部分：<ol><li>形式为 <code>hwnd + 自定义变量名</code></li><li>自定义变量名与第9行中第3个参数相对应。</li></ol></li><li><code>varFuncB := ObjBindMethod(this, &quot;functionB&quot;)</code> 部分：<ol><li><code>varFuncB</code> 为另一个自定义变量名，与第9行中第4个变量名相对应。</li><li><code>&quot;functionB&quot;</code> 中双引号必须保留，双引号中间内容为对应的方法名。</li></ol></li><li><code>GuiControl, +g, %HFuncB%, % varFuncB</code> 中第3、4个参数分别为上述的两个自定义变量名。</li></ol><hr /><h1 id="代码示例"><a class="markdownIt-Anchor" href="#代码示例"></a> 代码示例</h1><blockquote><p>使用面向对象思想重构 <a href="https://luoyu-ying.github.io/posts/050a11a7817a/">通过 AutoHotKey 简化 Hexo 操作 | 洛语 の Blog (luoyu-ying.github.io)</a> 中 Deploy 部分的操作。</p></blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 加载类的 UI 以及热键</span></span><br><span class="line"><span class="keyword">new</span> Deploy().load()</span><br><span class="line"></span><br><span class="line"><span class="comment">; -------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 类的创建</span></span><br><span class="line">class Deploy &#123;</span><br><span class="line"></span><br><span class="line">    load() &#123;</span><br><span class="line">        this.loadView()</span><br><span class="line">        this.loadHotKey()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">; 本代码中 GAD -&gt; generate and deploy</span></span><br><span class="line">    </span><br><span class="line">    loadView() &#123;</span><br><span class="line"><span class="built_in">        Gui,</span> Add, Button, w200 h35 hwndHGAD, Generate &amp;&amp; Deploy</span><br><span class="line">        </span><br><span class="line">        varGAD := ObjBindMethod(this, <span class="string">&quot;generateDeploy&quot;</span>)</span><br><span class="line"><span class="built_in">        </span></span><br><span class="line"><span class="built_in">        GuiControl,</span> +g, <span class="variable">%HGAD%</span>, % varGAD</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadHotKey() &#123;</span><br><span class="line">        varGAD := ObjBindMethod(this, <span class="string">&quot;generateDeploy&quot;</span>)</span><br><span class="line"><span class="built_in">        </span></span><br><span class="line"><span class="built_in">        Hotkey,</span> CapsLock &amp; G, % varGAD, On</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    generateDeploy() &#123;</span><br><span class="line"><span class="built_in">        Run,</span> <span class="variable">%comSpec%</span> /c hexo g &amp;&amp; hexo d, , Min</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AutoHotKey </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoHotKey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AutoHotHey 问题解决记录</title>
      <link href="/posts/8f286d636eff/"/>
      <url>/posts/8f286d636eff/</url>
      
        <content type="html"><![CDATA[<blockquote><p>更多的资料请参考 AHK 官方技术文档以及 AHK 社区。</p></blockquote><hr /><h1 id="代码中有些代码总是无法运行"><a class="markdownIt-Anchor" href="#代码中有些代码总是无法运行"></a> 代码中有些代码总是无法运行</h1><blockquote><p>处理方法参考自：</p><ul><li><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Scripts.htm#auto">脚本 - 定义与使用 | AutoHotkey (autoahk.com)</a></li></ul></blockquote><blockquote><p>下文中的所有链接皆为 AHK 技术文档中该词条的链接，可正常使用。</p></blockquote><p><strong><font size="4"><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Scripts.htm#auto">脚本顶部(自动执行段)</a></font></strong></p><p>脚本加载完成后, 它会从顶行开始执行, 直到遇到 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Return.htm">Return</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Exit.htm">Exit</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Hotkeys.htm">热键/热字串标签</a> 或脚本的底部(无论最先遇到哪个). 脚本的这个顶端部分被称为 <em>自动执行段</em>.</p><blockquote><p><strong>注意:</strong> 虽然脚本的 <em>第一个</em> 热键/热字串标签与 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Return.htm">return(返回)</a> 的效果相同, 但其他热键和标签却没有.</p></blockquote><p>如果脚本不是<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/_Persistent.htm">持续运行的</a>, 它将在自动执行部分完成后终止. 否则, 它会以空闲状态持续运行, 从而对诸如<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Hotkeys.htm">热键</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Hotstrings.htm">热字串</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Gui.htm#label">GUI 事件</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Menu.htm">自定义菜单项</a>和<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/SetTimer.htm">计时器</a>等事件做出响应. 如果一个脚本包含了热键, 热字串, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/OnMessage.htm">OnMessage()</a> 或 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Gui.htm">GUI</a>, 以及一些其他情况, 它就会自动变为持续运行的. 也可以用 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/_Persistent.htm">#Persistent</a> 指令来显式地使脚本持续运行.</p><hr /><h1 id="通过函数创建热键"><a class="markdownIt-Anchor" href="#通过函数创建热键"></a> 通过函数创建热键</h1><p>通过 <code>HotKey</code> 函数动态的创建一个热键。</p><blockquote><p>具体参数可以查看文档：<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Hotkey.htm">Hotkey | AutoHotkey (autoahk.com)</a></p></blockquote><p>示例：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 创建一个 CapsLock + K 的一个热键，效果为 Sfunction Lable 中的内容</span></span><br><span class="line"><span class="built_in">HotKey,</span> CapsLocks &amp; K, function</span><br><span class="line"></span><br><span class="line">function() &#123;</span><br><span class="line"><span class="built_in">MsgBox,</span> <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="通过函数创建热字串"><a class="markdownIt-Anchor" href="#通过函数创建热字串"></a> 通过函数创建热字串</h1><p>通过 <code>HotString</code> 函数动态的创建一个热字串。</p><blockquote><p>具体的参数可以查看文档：<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Hotstring.htm">Hotstring() | AutoHotkey (autoahk.com)</a></p></blockquote><hr /><h1 id="无法正常使用分号注释符号"><a class="markdownIt-Anchor" href="#无法正常使用分号注释符号"></a> 无法正常使用分号（注释符号）</h1><p>当我们想要使用 分号 作为热键中的一部分时，我们可以使用 <code>SC027</code> 替换分号的位置，以达到分号的作用、</p><p>示例：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 创建一个 CapsLock + K 的一个热键，效果为 function Lable 中的内容</span></span><br><span class="line"><span class="built_in">HotKey,</span> CapsLocks &amp; SC027, function </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AutoHotKey </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AutoHotKey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Butterfly 添加相册</title>
      <link href="/posts/aae775e24f21/"/>
      <url>/posts/aae775e24f21/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://butterfly.js.org/posts/dc584b87/">Butterfly 安裝文檔(二) 主題頁面 | Butterfly</a></li></ul></blockquote><hr /><h1 id="gallery-相册图库"><a class="markdownIt-Anchor" href="#gallery-相册图库"></a> <code>Gallery</code> 相册图库</h1><p>图库页面只是普通的页面，你只需要：</p><ol><li><p><code>hexo n page xxxxx</code> 创建你的页面。</p></li><li><p>在 <code>index.md</code> 使用标签外挂 <code>galleryGroup</code>。</p></li></ol><h2 id="gallerygroup-模板"><a class="markdownIt-Anchor" href="#gallerygroup-模板"></a> <code>galleryGroup</code> 模板</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p>name：图库名字</p></li><li><p>description：图库描述</p></li><li><p>link：连接到对应相册的地址</p></li><li><p>img-url：图库封面的地址</p></li></ul><h2 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span><br><span class="line">&#123;% galleryGroup &#x27;封面图&#x27; &#x27;已发布文章的封面图&#x27; &#x27;/gallery/wallpaper&#x27; images/389.jpg %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/389.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">封面图</div>  <p>已发布文章的封面图</p>  <a href='/gallery/wallpaper'></a>  </figcaption>  </figure>  </div><hr /><h1 id="gallery-相册子页面"><a class="markdownIt-Anchor" href="#gallery-相册子页面"></a> <code>Gallery</code> 相册子页面</h1><p>子页面也是普通的页面，你只需要：</p><ol><li><code>hexo n page xxxxx</code> 创建你的页面。</li><li>然后使用标签外挂 <code>gallery</code>。</li></ol><h2 id="gallery-模板"><a class="markdownIt-Anchor" href="#gallery-模板"></a> <code>gallery</code> 模板</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>markdown 图片格式： <code>![]()</code> 或者 <code>&lt;img src = &quot;&quot;&gt;</code> 的格式皆可。</li></ul><h2 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](images/389.jpg)</span><br><span class="line">![](images/166.jpg)</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/250.jpg&quot;</span>&gt;</span></span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><div class="fj-gallery"><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/389.jpg" alt="" /></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/166.jpg" alt="" /></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/250.jpg">          </div><hr /><h1 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h1><p>如果你想要使用 <code>/gallery/wallpaper</code> 这样的链接显示你的图片内容。你可以把创建好的 <code>wallpaper</code> 整个文件夹移到 <code>gallery</code> 文件夹里中。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin Lambda 表达式</title>
      <link href="/posts/0ca5222da5ff/"/>
      <url>/posts/0ca5222da5ff/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li>《第一行代码 Android 第3版》</li><li><a href="https://time.geekbang.org/course/intro/100009801">快速上手 Kotlin 开发 (geekbang.org)</a></li><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li></ul></blockquote><hr /><h1 id="lambda-定义"><a class="markdownIt-Anchor" href="#lambda-定义"></a> <code>Lambda</code> 定义</h1><p><code>Lambda</code> 就是一小段可以作为参数传递的代码，也可以认为是函数的简写形式。</p><hr /><h1 id="lambda-表达式的语法结构"><a class="markdownIt-Anchor" href="#lambda-表达式的语法结构"></a> <code>Lambda</code> 表达式的语法结构</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;参数名<span class="number">1</span>: 参数类型, 参数名<span class="number">2</span>: 参数类型, ..., 参数名n: 参数类型 -&gt; 函数体&#125;</span><br></pre></td></tr></table></figure><p>这是 <code>Lambda</code> 表达式最完整的语法结构定义。</p><p>首先最外层是一对大括号，如果有参数传入到 <code>Lambda</code> 表达式中的话，我们还需要声明参数列表，参数列表的结尾使用一个 <code>-&gt;</code> 符号，表示参数列表的结束以及函数体的开始。</p><p>函数体中可以编写任意行代码（虽然不建议编写太长的代码)，<strong>并且最后一行代码会自动作为 <code>Lambda</code> 表达式的返回值</strong>，即 <code>return 最后一行代码</code>。</p><p>所以我们也可以用变量获取 <code>Lambda</code> 表达式的结果，即 <code>val result = &#123;... -&gt; ...&#125;</code> 。</p><hr /><h1 id="lambda-表达式的特点"><a class="markdownIt-Anchor" href="#lambda-表达式的特点"></a> <code>Lambda</code> 表达式的特点</h1><ol><li>最后一行代码会自动作为 <code>Lambda</code> 表达式的返回值（隐式 <code>return</code>）。</li><li>如果 <code>Lambda</code> 没有参数，那么可以省略箭头符号 <code>-&gt;</code>。</li><li>如果 <code>Lambda</code> 是函数的最后一个参数，那么可以将大括号放在小括号的外面。</li><li>如果函数只有一个参数并且这个参数就是 <code>Lambda</code> ，则可以省略小括号。</li></ol><hr /><h1 id="sam-转换"><a class="markdownIt-Anchor" href="#sam-转换"></a> <code>SAM</code> 转换</h1><blockquote><p>当一个函数的参数是 SAM 的情况下，我们同样也可以使用 Lambda 作为参数。</p><p>通过 SAM 转换，我们就可以在 Kotlin 中便携的编写如 setOnClickListener 之类的方法了。</p></blockquote><p><code>SAM</code> 是 Single Abstract Method 的缩写，意思就是只有一个抽象方法的类或者接口。但在 Kotlin 和 Java 8 里，<strong>SAM 代表着只有一个抽象方法的接口</strong>。只要是符合 SAM 要求的接口，编译器就能进行 SAM 转换，也就是我们可以使用 Lambda 表达式，来简写接口类的参数。</p><p>注意，Java 8 中的 SAM 有明确的名称，叫做函数式接口（FunctionalInterface）。FunctionalInterface 的限制如下，缺一不可：</p><ol><li>必须是接口，抽象类不行；</li><li>该接口有且仅有一个抽象的方法，抽象方法个数必须是 1，默认实现的方法可以有多个。</li></ol><p>也就是说，对于 View.java 来说，它虽然是 Java 代码，但 Kotlin 编译器知道它的参数 OnClickListener 符合 SAM 转换的条件，所以会自动做以下转换。</p><p>转换前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnClickListener</span><span class="params">(OnClickListener l)</span></span><br></pre></td></tr></table></figure><p>转换后：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(l: (<span class="type">View</span>) -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="comment">// 实际上是这样：</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(l: ((<span class="type">View</span>!) -&gt; <span class="type">Unit</span>)?)</span></span></span><br></pre></td></tr></table></figure><p>其中，((View!) -&gt; Unit)? 代表的是这个参数可能为空。</p><hr /><h1 id="lambda-表达式的写法"><a class="markdownIt-Anchor" href="#lambda-表达式的写法"></a> <code>Lambda</code> 表达式的写法</h1><p>当一个函数的参数是 <code>SAM</code> 的情况下，我们同样也可以使用 <code>Lambda</code> 作为参数。所以，我们既可以用匿名内部类的方式传参，也可以使用 <code>Lambda</code> 的方式传参。</p><p>从匿名内部类的写法到 <code>Lambda</code> 表达式最终的精简形式，在这两种写法的中间，还有 6 种“过渡状态”的写法。</p><p>下面将从匿名内部类的写法开始，一步步的过渡到 <code>Lambda</code> 的写法。</p><p><strong><font size="4">第 1 种写法</font></strong></p><p>这是原始代码，它的本质是用 <code>object</code> 关键字定义了一个匿名内部类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(<span class="keyword">object</span>: View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        gotoPreview(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 2 种写法</font></strong></p><p>在这种情况下，<code>object</code> 关键字可以被省略。这时候它在语法层面就不再是匿名内部类了，它更像是 <code>Lambda</code> 表达式了，因此它里面 <code>override</code> 的方法也要跟着删掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(View.OnClickListener &#123; v: View? -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的 <code>View.OnClickListener</code> 被称为 <code>SAM Constructor</code>（SAM 构造器），它是编译器为我们生成的。</p><p>这段代码明显简化了很多，既可以实现同样的功能，又不会造成任何歧义。因为 <code>View.OnClickListener</code> 中只有一个待实现方法,即使这里没有显式地重写 onClick() 方法，<code>Kotlin</code> 也能自动明白 <code>View.OnClickListener</code> 后面的 <code>Lambda</code> 表达式就是要在 <code>onClick()</code> 方法中实现的内容。</p><p><strong><font size="4">第 3 种写法</font></strong></p><p>如果一个 <code>Java</code> 方法的参数列表中不存在一个以上 <code>Java</code> 单抽象方法接口参数，我们还可以将接口名进行省略（且<code>Kotlin</code> 的 <code>Lambda</code> 表达式是不需要 <code>SAM Constructor</code> 的），所以它也可以被删掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123; v: View? -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 4 种写法</font></strong></p><p>由于 <code>Kotlin</code> 支持类型推导，所以 <code>View</code> 可以被删掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123; v -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 5 种写法</font></strong></p><p>当 <code>Kotlin</code> <code>Lambda</code> 表达式只有一个参数的时候，它可以被写成 <code>it</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123; it -&gt;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 6 种写法</font></strong></p><p><code>Kotlin</code> <code>Lambda</code> 的 <code>it</code> 是可以被省略的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 7 种写法</font></strong></p><p>当 <code>Kotlin</code> <code>Lambda</code> 作为函数的最后一个参数时，<code>Lambda</code> 可以被挪到外面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener() &#123;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 8 种写法</font></strong></p><p>当 <code>Kotlin</code> 只有一个 <code>Lambda</code> 作为函数参数时，<code>()</code> 可以被省略：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener &#123;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，将这 8 种写法的演进过程以动图的形式展现了出来，让你对 <code>Lambda</code> 这几种写法的差异有一个更加直观的认识。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/e441323968c0c061898257fd06db37bf.gif" alt="img" style="zoom: 50%;" />]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 函数嵌套</title>
      <link href="/posts/47063eb1b5ed/"/>
      <url>/posts/47063eb1b5ed/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li><li><a href="https://www.cnblogs.com/Anker/archive/2013/03/04/2943498.html">递归与尾递归总结 - Rabbit_Dale - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/zsp765098084/article/details/90901260">kotlin学习笔记之尾递归优化（tailrec）_mictoy_朱的博客-CSDN博客_kotlin tailrec</a></li></ul></blockquote><hr /><h1 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h1><p>在 <code>Kotlin</code> 中，我们可以在函数的代码块中创建另一个新的函数并使用该函数。并且该函数可以使用外部函数的变量。</p><p>如下方的代码；</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">outerMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算 1 + 2 + 3 + ...</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">innerMethod</span><span class="params">(c: <span class="type">Int</span> = <span class="number">10</span>)</span></span> &#123;</span><br><span class="line">        sum += c</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span>)</span><br><span class="line">        innerMethod(c - <span class="number">1</span>)</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    innerMethod()</span><br><span class="line">  println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    outerMethod()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h1><p>函数嵌套在工程中应尽量少的使用，容易造成代码可读性的降低。</p><p>但是在两种情况下可以创建内部函数：</p><ol><li>在某些情况下需要临时使用 <strong>递归</strong> 函数，如上文中的代码。</li><li>不希望被外部函数访问到的函数。</li></ol><hr /><h1 id="尾递归"><a class="markdownIt-Anchor" href="#尾递归"></a> 尾递归</h1><p>实际上，在函数式编程当中，我们有时候也会使用递归来替代循环。</p><p>我们知道，递归都是有调用栈开销的，所以我们应该尽量使用 <strong>尾递归</strong>。对于这种类型的递归，在经过栈复用优化以后，它的开销就可以忽略不计了，我们可以认为它的空间复杂度是 O(1)。</p><blockquote><p>尾递归就是从最后开始计算，每递归一次就算出相应的结果，也就是说, 函数调用出现在调用者函数的尾部，因为是尾部，所以根本没有必要去保存任何局部变量，直接让被调用的函数返回时越过调用者，返回到调用者的调用者去。</p><p><strong>尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数</strong>，深层函数所面对的不是越来越简单的问题，而是越来越复杂的问题，因为参数里带有前面若干步的运算路径。</p><p>尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。</p></blockquote><h2 id="尾递归的特点"><a class="markdownIt-Anchor" href="#尾递归的特点"></a> 尾递归的特点</h2><ul><li>递归的一种特殊形式</li><li>调用自身后无其他操作</li><li><code>tailrec</code> 关键字提示编译器尾递归优化</li></ul><p>示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>(<span class="keyword">val</span> value:<span class="built_in">Int</span>,<span class="keyword">var</span> next:ListNode? = <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findListNode</span><span class="params">(head:<span class="type">ListNode</span>?,value:<span class="type">Int</span>)</span></span>:ListNode?&#123; <span class="comment">//定义一个递归函数</span></span><br><span class="line">    head?:<span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (head.value == value) <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">return</span> findListNode(head.next,value)    <span class="comment">//return除了调用自己，没有多余的操作，所以是尾递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾递归优化的使用"><a class="markdownIt-Anchor" href="#尾递归优化的使用"></a> 尾递归优化的使用</h2><p>在 <code>Kotlin</code> 语言中，我们即使写出了符合尾递归的递归函数，编译器也不会自动帮我们进行优化。</p><p>我们需要在 <code>fun</code> 关键字前面加上 <code>tailrec</code> 关键字以表示我们需要进行尾递归优化。</p><p>示例代码1：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>(<span class="keyword">val</span> value:<span class="built_in">Int</span>,<span class="keyword">var</span> next:ListNode? = <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">findListNode</span><span class="params">(head:<span class="type">ListNode</span>?,value:<span class="type">Int</span>)</span></span>:ListNode?&#123; <span class="comment">//定义一个递归函数</span></span><br><span class="line">    head?:<span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (head.value == value) <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">return</span> findListNode(head.next,value)    <span class="comment">//return除了调用自己，没有多余的操作，所以是尾递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码2：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">recursionLoop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="comment">// 变化在这里</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line">    <span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">go</span><span class="params">(i: <span class="type">Int</span>, sum: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">10</span>) sum <span class="keyword">else</span> go(i + <span class="number">1</span>, sum + i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> go(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾递归优化的实质"><a class="markdownIt-Anchor" href="#尾递归优化的实质"></a> 尾递归优化的实质</h2><p>通过对上文中的 <code>findListNode</code> 方法对 <strong>加了 <code>tailrec</code> 关键字</strong> 与 <strong>去除 <code>tailrec</code> 关键字</strong> 的两份代码分别进行反编译，我们发现：</p><ul><li><p>没有优化的 <code>findListNode</code> 对应的 <code>Java</code> 代码依然是递归函数，并且递归运行次数较大时出现了 <code>StackOverflowError</code> 错误；</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135701617.png" alt="img" style="zoom: 90%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135611929.png" alt="img" style="zoom:87%;" /></li><li><p>优化后（即添加了 <code>tailrec</code> 关键字）的 <code>findListNode</code> 方法对应的 <code>Java</code> 代码已经不再是递归函数，而是通过循环来实现功能，这样就不会再出现 <code>stackoverflowerror</code> 了。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135710491.png" alt="img" style="zoom:90%;" /></li></ul><p>这样我们就在 <code>Kotlin</code> 中既实现了递归函数代码简洁的优势，又规避了在 <code>Java</code> 中使用递归函数容易出出现的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 空指针检查</title>
      <link href="/posts/4c7d77851d24/"/>
      <url>/posts/4c7d77851d24/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li>《第一行代码 Android 第3版》</li></ul></blockquote><hr /><h1 id="可空类型系统"><a class="markdownIt-Anchor" href="#可空类型系统"></a> 可空类型系统</h1><p>因为 <code>Kotlin</code> 默认所有的参数和变量都不可为空，所以我们直接使用定义任何变量和参数并使用的话，是没有任何的空指针风险的。</p><p>例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>)</span></span> &#123;</span><br><span class="line">    study.readBooks()</span><br><span class="line">    study.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码是没有空指针异常的，如果我们尝试向 <code>doStudy</code> 函数中传递 <code>null</code> 参数，便会直接提示错误：<code>Null can not be a value of a non-null type Study</code>。</p><p>也就是说，<code>Kotlin</code> 将空指针异常的检查提前到了编译时期，如果我们的程序存在空指针异常的风险，那么在编译的时候会直接报错，修正之后才能成功运行，这样就可以保证程序在运行时期不会出现空指针异常了。</p><p>那么如何使得这些类型变为可为空的类型系统呢？</p><p><strong>很简单，就是在类名的后面加上一个问号。</strong></p><p>比如说，<code>Int</code> 表示不可为空的整形，而 <code>Int?</code> 则表示可为空的整形；<code>String</code> 表示不可为空的字符串，而 <code>String?</code> 就表示可以为空的字符串。</p><p>当我们希望上述的代码可以传入 <code>null</code> 参数，那么我们就需要将 <code>Study</code> 改成 <code>Study?</code> ，如下文所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    study.readBooks()</span><br><span class="line">    study.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上述的代码仍然有些许错误，即使我们能够正常的传入 <code>null</code> 参数，但是 <code>null</code> 是无法调用 <code>readBooks()</code> 以及 <code>doHomework()</code> 函数的。所以我们仍需要对 <code>study</code> 进行进一步的判断：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (study != <span class="literal">null</span>) &#123;</span><br><span class="line">        study.readBooks()</span><br><span class="line">        study.doHomework()    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样的写法，我们可能会在代码中写入大量的 <code>if</code> 语句仅仅只是为了判断变量或者参数是否为空，这样会让代码变得比较啰嗦。为此，<code>Kotlin</code> 专门提供了一系列的辅助工具，方便我们更加轻松以及快速地进行判空处理。</p><hr /><h1 id="判空辅助工具"><a class="markdownIt-Anchor" href="#判空辅助工具"></a> 判空辅助工具</h1><h2 id="操作符"><a class="markdownIt-Anchor" href="#操作符"></a> <code>?.</code> 操作符</h2><p><code>?.</code> 操作符的作用就是当对象不为空的时候正常调用相应的函数，当对象为空时则什么都不做。</p><p>如下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">    a.doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 <code>?.</code> 操作符，我们便可以将其简化成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a?.doSomething()</span><br></pre></td></tr></table></figure><p>现在我们便可以对上文中的代码进行优化了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    study?.readBooks()</span><br><span class="line">    study?.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作符-2"><a class="markdownIt-Anchor" href="#操作符-2"></a> <code>?:</code> 操作符</h2><p><code>?:</code> 操作符的左右两边都接受一个表达式，如果左边表达式的结果不为空就返回左边表达式的结果，否则就返回右边表达式的结果。</p><p>如下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = <span class="keyword">if</span> (a != <span class="literal">null</span>) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><p>便可以简化成为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = a ?: b</span><br></pre></td></tr></table></figure><h2 id="操作符-3"><a class="markdownIt-Anchor" href="#操作符-3"></a> <code>!!.</code> 操作符</h2><p>如果我们想要一遍变量在使用的过程中不进行空指针检查，并在遇到空指针的时候主动的抛出空指针异常（有的时候我们可能从逻辑上已经将空指针异常处理了，但是 <code>Kotlin</code> 的编译器并不知道，这个时候它还是会编译失败），那么我们可以通过使用 <code>!!.</code> 操作符（非空断言工具）强行通过编译。写法是在对象的后面加上 <code>!!.</code>。</p><p>例如以下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg: String? = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">        printUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printUpperCase</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> upperCase = msg!!.toUpperCase()</span><br><span class="line">    println(upperCase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上文中，<code>printUpperCase</code> 函数的调用一定发生在 <code>msg</code> 不为空的情况，所以我们可以使用非空断言工具让其不进行空指针判断。</p><p>这是一种有风险的写法，意在告诉 <code>Kotlin</code>，我非常确信这里的对象不会为空，所以不用你来帮我做空指针检查了，如果出现问题，你可以直接抛出空指针异常，后果由我自己承担。</p><p>虽然这样编写代码确实可以通过编译，但是当你想要使用非空断言工具的时候，最好提醒一下自己，是不是还有更好的实现方式。</p><p><strong>你最自信这个对象不会为空的时候，其实可能就是一个潜在空指针异常发生的时候。</strong></p><hr /><h1 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h1><p>标准函数中 <code>let</code> 函数是可以处理全局变量的判空问题的，而 <code>if</code> 语句则无法做到这一点。</p><p>比如我们将 <code>doStudy()</code> 中的参数变成一个全局变量，使用 <code>let</code> 函数仍然可以正常工作，但是使用 <code>if</code> 语句则会提示错误：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220709203415002.png" alt="image" style="zoom:80%;" /><p>之所以这里会报错，是因为全局变量的值随时都有可能被其他线程所修改，即使做了判空处理，仍然无法保证 <code>if</code> 语句中的<code>study</code> 变量没有空指针风险。从这一点上也能体现出 <code>let</code> 函数的优势。</p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 扩展函数与扩展属性</title>
      <link href="/posts/ffb71c4ce53a/"/>
      <url>/posts/ffb71c4ce53a/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li></ul></blockquote><hr /><p><code>Kotlin</code> 的扩展（<code>Extension</code>），主要分为两种语法：第一个是扩展函数，第二个是扩展属性。从语法上看，扩展看起来就像是我们从类的外部为它扩展了新的成员。</p><p>这在实际编程当中是非常有用的功能。我们可以来想象一个场景：我们想修改 <code>JDK</code> 当中的 <code>String</code>，想在它的基础上增加一个方法 <code>lastElement()</code> 来获取末尾元素，如果使用 <code>Java</code>，我们是无法通过常规手段实现的，因为我们没办法修改 <code>JDK</code> 的源代码。<strong>任何第三方提供的 <code>SDK</code>，我们都无权修改。</strong></p><p>不过，借助 <code>Kotlin</code> 的扩展函数，我们就完全可以在语义层面，来为第三方 <code>SDK</code> 的类扩展新的成员方法和成员属性。不管是为 <code>JDK</code> 的 <code>String</code> 增加新的成员方法，还是为 <code>Android SDK</code> 的 <code>View</code> 增加新成员属性，我们都可以实现。</p><hr /><h1 id="扩展函数"><a class="markdownIt-Anchor" href="#扩展函数"></a> 扩展函数</h1><p>扩展函数，就是从类的外部扩展出来的一个函数，这个函数看起来就像是类的成员函数一样。这里，我们就以 <code>JDK</code> 当中的 <code>String</code> 为例，来看看如何通过 <code>Kotlin</code> 的扩展特性，为它新增一个 <code>lastElement()</code> 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ext.kt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ①    ②       ③           ④</span></span><br><span class="line"><span class="comment"> ↓     ↓       ↓            ↓      */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;</span><br><span class="line">    <span class="comment">//    ⑤</span></span><br><span class="line">    <span class="comment">//    ↓</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用扩展函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> msg = <span class="string">&quot;Hello Wolrd&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// lastElement就像String的成员方法一样可以直接调用</span></span><br><span class="line">    <span class="keyword">val</span> last = msg.lastElement() <span class="comment">// last = d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先是定义了一个 <code>String</code> 的扩展函数 <code>lastElement()</code> ，然后在 <code>main</code> 函数当中调用了这个函数。并且，这个扩展函数是直接定义在 <code>Kotlin</code> 文件里的，而不是定义在某个类当中的。这种扩展函数，我们称之为**“顶层扩展”**，这么叫它是因为它并没有嵌套在任何的类当中，它自身就在最外层。</p><p>现在，我们依次来看看上面的五处注释：</p><ol><li><p>注释①，<code>fun</code> 关键字</p><p>代表我们要定义一个函数。也就是说，不管是定义普通 <code>Kotlin</code> 函数，还是定义扩展函数，我们都需要 <code>fun</code> 关键字。</p></li><li><p>注释②，“<code>String.</code>”</p><p>代表我们的扩展函数是为 <code>String</code> 这个类定义的。在 <code>Kotlin</code> 当中，它有一个名字，叫做接收者（<code>Receiver</code>），也就是扩展函数的接收方。</p></li><li><p>注释③，<code>lastElement()</code></p><p>是我们定义的扩展函数的名称。</p></li><li><p>注释④，“<code>Char?</code>”</p><p>代表扩展函数的返回值是可能为空的 <code>Char</code> 类型。</p></li><li><p>注释⑤，“<code>this.</code>”</p><p>代表“具体的 <code>String</code> 对象”，当我们调用 <code>msg.lastElement()</code> 的时候，<code>this</code> 就代表了 <code>msg</code>。</p></li></ol><p>需要注意的是，<strong>在整个扩展函数的方法体当中，<code>this</code> 都是可以省略的</strong>。这一点，<code>Kotlin</code> 和 <code>Java</code> 是一样的，<code>this</code> 代表当前作用域，它可写可不写。即例如以下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span> : <span class="built_in">Char</span>? = <span class="keyword">if</span> (isEmpty()) <span class="literal">null</span> <span class="keyword">else</span> <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">    println(str.lastElement())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，<code>Kotlin</code> 的扩展是允许我们为“<strong>可为空的类型</strong>”进行扩展的。比如说：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不为空的接收者类型</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可为空的接收者类型</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String?.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;&#125;</span><br></pre></td></tr></table></figure><p>接受者可空的扩展在遇到空对象调用时不会抛异常，并且允许可空对象调用。</p><hr /><h1 id="扩展属性"><a class="markdownIt-Anchor" href="#扩展属性"></a> 扩展属性</h1><p>在学习了 <code>Kotlin</code> 的扩展函数以后，扩展属性就很好理解了。</p><p>扩展函数，是在类的外部为它定义一个<strong>新的成员方法</strong>；而扩展属性，则是在类的外部为它定义一个<strong>新的成员属性</strong>。</p><p>那么，在研究了扩展的实现原理后，我们知道，我们从外部定义的成员方法和属性，都只是语法层面的，并没有实际修改那个类的源代码。</p><p>还是以 <code>lastElement</code> 为例，在之前的案例当中，我们是通过扩展函数来实现的，这次我们以扩展属性的方式来实现。扩展函数的定义对比普通函数，其实就只是多了一个“接收者类型”。类似的，扩展属性，也就是在普通属性定义的时候多加一个“接收者类型”即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收者类型</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="keyword">val</span> String.lastElement: <span class="built_in">Char</span>?</span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 this 关键字也可以写成：</span></span><br><span class="line"><span class="comment">val String.lastElement : Char?</span></span><br><span class="line"><span class="comment">    get() = if (isEmpty()) null else this[length - 1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> msg = <span class="string">&quot;Hello Wolrd&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// lastElement就像String的成员属性一样可以直接调用</span></span><br><span class="line">    <span class="keyword">val</span> last = msg.lastElement <span class="comment">// last = d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段的代码中，我们为 String 类型扩展了一个新的成员属性“<code>lastElement</code>”。然后在 <code>main</code> 函数当中，我们直接通过“<code>msg.lastElement</code>”方式使用了这个扩展属性，就好像它是一个成员一样。</p><hr /><h1 id="扩展与其反编译代码"><a class="markdownIt-Anchor" href="#扩展与其反编译代码"></a> 扩展与其反编译代码</h1><p>为了看得更加清晰，我们用一张图来描述它们之间的关系。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/2a38487b61ec06e437c1425b2a69ffed.png" alt="img" /></p><p>上面的两个箭头，说明了扩展函数与扩展属性，它们最终会被 <code>Kotlin</code> 编译器转换成静态方法；下面两个箭头，说明了扩展函数和扩展属性的调用代码，最终会被 <code>Kotlin</code> 编译器转换成静态方法的调用。</p><p>所以也就是说，<code>Kotlin</code> 的扩展表面上看起来是为一个类扩展了新的成员，<strong>但是本质上，它还是静态方法</strong>。而且，不管是扩展函数还是扩展属性，它本质上都会变成一个静态的方法。</p><p><strong>那么，到底什么时候该用扩展函数，什么时候该用扩展属性呢？</strong></p><p>其实，我们只需要看扩展在语义上更适合作为函数还是属性就够了。比如这里的 <code>lastElement</code>，它更适合作为一个扩展属性。这样设计的话，在语义上，<code>lastElement</code> 就像是 <code>String</code> 类当中的属性一样，它代表了字符串里的最后一个字符。</p><hr /><h1 id="扩展的优势与局限性"><a class="markdownIt-Anchor" href="#扩展的优势与局限性"></a> 扩展的优势与局限性</h1><h2 id="扩展的优势"><a class="markdownIt-Anchor" href="#扩展的优势"></a> 扩展的优势</h2><p>当我们想要从外部为一个类扩展一些方法和属性的时候，我们就可以通过扩展来实现了。<strong>在 <code>Kotlin</code> 当中，几乎所有的类都可以被扩展</strong>，包括普通类、单例类、密封类、枚举类、伴生对象，甚至还包括第三方提供的 <code>Java</code> 类。</p><p>唯有匿名内部类，由于它本身不存在名称，我们无法指定“接收者类型”，所以不能被扩展，当然了，它也没必要被扩展。</p><p>可以说，<code>Kotlin</code> 扩展的应用范围还是非常广的。它最主要的用途，就是用来取代 <code>Java</code> 当中的各种工具类，比如 <code>StringUtils</code>、<code>DateUtils</code> 等等。</p><p>所有 <code>Java</code> 工具类能做的事情，<code>Kotlin</code> 扩展函数都可以做，并且可以做得更好。扩展函数的优势在于，开发工具可以在编写代码的时候智能提示。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/239e540b768560c6cd119b1bb9e1eb9c.gif" alt="img" style="zoom: 40%;" /><h2 id="扩展的局限性"><a class="markdownIt-Anchor" href="#扩展的局限性"></a> 扩展的局限性</h2><p><code>Kotlin</code> 的扩展，由于它本质上并没有修改接收类型的源代码，所以它的行为是无法与“类成员”完全一致的。那么它对比普通的类成员，就会有以下几个限制。</p><p><strong>第一个限制，<code>Kotlin</code> 扩展不是真正的类成员，因此它无法被它的子类重写。</strong></p><p>举个例子，我们定义一个这样的 <code>Person</code> 类，并且分别为它扩展了一个 <code>isAdult</code> 属性和 <code>walk()</code> 方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> Person.isAdult: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = age &gt;= <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.<span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;walk&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>Person</code> 类有 <code>open</code> 关键字修饰，所以我们可以继承这个 <code>Person</code> 类。</p><p>不过，当我们尝试去重写它的成员时，会发现 <code>isAdult</code> 和 <code>walk()</code> 是无法被重写的，因为它们压根就不属于 <code>Person</code> 这个类。</p><p><strong>第二个限制，扩展属性无法存储状态。</strong></p><p>就如前面代码当中的 <code>isAdult</code> 属性一般，它的值是由 <code>age</code> 这个成员属性决定的，它本身没有状态，也无法存储状态。背后的根本原因，还是因为它们都是静态方法。</p><p><strong>第三个限制，扩展的<em>访问作用域</em>仅限于两个地方。</strong></p><ol><li><p>如果扩展是顶层的扩展。</p><p>那么扩展的访问域仅限于该 <code>Kotlin</code> 文件当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展是可以被全局使用的。</p></li><li><p>如果扩展是被定义在某个类当中的。</p><p>那么该扩展的访问域仅限于该类当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展仅能在该类当中使用。</p></li></ol><hr /><h1 id="扩展的使用场景"><a class="markdownIt-Anchor" href="#扩展的使用场景"></a> 扩展的使用场景</h1><p><strong><code>Kotlin</code> 扩展的第一个典型使用场景：关注点分离。主动使用扩展，通过它来优化软件架构。</strong></p><p>所谓关注点分离，就是将我们程序的逻辑划分成不同的部分，每一个部分，都只关注自己那部分的职责。以 <code>Kotlin</code> 源码中的 <code>String</code> 类为例，<code>String.kt</code> 这个类，只关注 <code>String</code> 的核心逻辑；而 <code>Strings.kt</code> 则只关注 <code>String</code> 的操作符逻辑。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String.kt (一共只有13行代码)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> : <span class="type">Comparable</span>&lt;<span class="type">String</span>&gt;, <span class="type">CharSequence &#123;</span></span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">val</span> length: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: <span class="built_in">Char</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">subSequence</span><span class="params">(startIndex: <span class="type">Int</span>, endIndex: <span class="type">Int</span>)</span></span>: CharSequence</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Strings.kt 部分代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CharSequence.<span class="title">trim</span><span class="params">()</span></span>: CharSequence = trim(<span class="built_in">Char</span>::isWhitespace)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">expect</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">lowercase</span><span class="params">()</span></span>: String</span><br></pre></td></tr></table></figure><p><strong>扩展的第二个核心使用场景：被动使用扩展，提升可读性与开发效率。</strong></p><p>当我们无法修改外部的 <code>SDK</code> 时，对于重复的代码模式，我们将其以扩展的方式封装起来，提供给对应的接收者类型。</p><hr /><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><ol><li><code>Kotlin</code> 的扩展，从 <strong>语法角度</strong> 来看，分为扩展函数和扩展属性。定义扩展的方式，只是比普通函数、属性多了一个“扩展接收者”而已。</li><li>从 <strong>作用域</strong> 角度来看，分为顶层扩展和类内扩展。</li><li>从 <strong>本质</strong> 上来看，扩展函数和扩展属性，它们都是 <code>Java</code> 静态方法，与 <code>Java</code> 当中的工具类别无二致。对比 <code>Java</code> 工具类，扩展最大的优势就在于，<code>IDE</code> 可以为我们提供代码补全功能。</li><li>从 <strong>能力</strong> 的角度来看，<code>Kotlin</code> 扩展一共有三个限制，分别是：扩展无法被重写；扩展属性无法存储状态；扩展的作用域有限，无法访问私有成员。</li><li>从 <strong>使用场景</strong> 的角度来看，<code>Kotlin</code> 扩展主要有两个使用场景，分别是：关注点分离，优化代码架构；消灭模板代码，提高可读性和开发效率。</li></ol><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/b4a3ce7c3e0b2228161faa4769618a10.jpg" alt="img" /></p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin 类的创建与继承</title>
      <link href="/posts/8aab3d7fde77/"/>
      <url>/posts/8aab3d7fde77/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>Kotlin</code> 官方在线编程网址：</p><ul><li><a href="https://play.kotlinlang.org/">https://play.kotlinlang.org/</a></li></ul></blockquote><hr /><blockquote><p>本文参考自：</p><ul><li>《第一行代码  Android 第3版》</li><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li><li><a href="https://blog.csdn.net/c1392851600/article/details/80990570">Kotlin之类的继承及属性和方法的重写_c1392851600的博客-CSDN博客</a></li></ul></blockquote><hr /><h1 id="基本写法"><a class="markdownIt-Anchor" href="#基本写法"></a> 基本写法</h1><h2 id="创建"><a class="markdownIt-Anchor" href="#创建"></a> 创建</h2><p>通过 <code>class</code> 关键字创建一个类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is eating.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化方式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> person = Person()</span><br></pre></td></tr></table></figure><h2 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h2><p><strong>默认所有非抽象类都是不可以被继承的</strong>。</p><p>如果需要将其变为父类，则需要在 <code>class</code> 前使用 <code>open</code> 关键字。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is eating.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要继承另一个类，则使用 <code>:</code> 符号：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> grade = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重写"><a class="markdownIt-Anchor" href="#重写"></a> 重写</h2><h3 id="重写父类的方法"><a class="markdownIt-Anchor" href="#重写父类的方法"></a> 重写父类的方法</h3><p>需要注意的是如果父类的方法没有 <code>open</code> 声明，那么该方法是不允许被重写的。重写方法的时候需要使用 <code>override</code> 关键字注明。还有一点就是子类可以选择不重写父类的方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">shout</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;汪汪&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;萌萌哒&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Husky</span> : <span class="type">Dog</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 由于父类的shout方法没有写open, 也就是默认是final的, 所以这里不能重写shout方法</span></span><br><span class="line">    <span class="comment">// Error:(15, 5) Kotlin: &#x27;shout&#x27; in &#x27;Dog&#x27; is final and cannot be overridden  不能重写shout因为默认是final的</span></span><br><span class="line">    <span class="comment">/* override fun shout() &#123;</span></span><br><span class="line"><span class="comment">        println(&quot;玩明汪&quot;)</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重写父类方法的时候要加上override关键字, show方法也可以选择不进行重写</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;喵喵&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> husky =  Husky()</span><br><span class="line">    husky.shout()</span><br><span class="line">    husky.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次需要注意的是，如果一个类集成了多个类/接口，并且父类/接口中有相同名字的方法需要重写的时候，那么子类这时候必须重写该方法，并且如果子类想区分开父类的方法的时候，可以使用 <code>super</code> 关键字调用不同父类的方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">shout</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;汪汪&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;萌萌哒&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">WatchDog</span> </span>&#123;</span><br><span class="line">    <span class="comment">// interface里不用写open, 因为默认就是open的</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;看门电子狗&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用接口的时候不用写(), 是因为接口是没有构造函数的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Husky</span> : <span class="type">Dog</span></span>(), WatchDog &#123;</span><br><span class="line">    <span class="comment">// 由于父类的shout方法没有写open, 也就是默认是final的, 所以这里不能重写父类的方法</span></span><br><span class="line">    <span class="comment">// Error:(15, 5) Kotlin: &#x27;shout&#x27; in &#x27;Dog&#x27; is final and cannot be overridden  不能重写shout因为默认是final的</span></span><br><span class="line">    <span class="comment">/*override fun shout() &#123;</span></span><br><span class="line"><span class="comment">        println(&quot;玩明汪&quot;)</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重写父类方法的时候要加上override关键字</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 当重写的方法在父类中有多个实现的时候, 如果继承的多个类中, 有相同的方法需要重写的时候, 则子类必须重写该方法, 并且, 为了区分, 可以使用super关键字来调用不同的父类中的方法</span></span><br><span class="line">        <span class="keyword">super</span>&lt;WatchDog&gt;.show()  <span class="comment">// 看萌电子狗</span></span><br><span class="line">        <span class="keyword">super</span>&lt;Dog&gt;.show() <span class="comment">// 萌萌哒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> husky =  Husky()</span><br><span class="line">    husky.shout()   <span class="comment">// 汪汪</span></span><br><span class="line">    husky.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写父类的变量"><a class="markdownIt-Anchor" href="#重写父类的变量"></a> 重写父类的变量</h3><p>父类变量的重写的时候有几个需要注意的地方：</p><ol><li><p>被重写的变量也要有 <code>open</code> 的声明。</p></li><li><p>子类可以使用 <code>var</code> 类型的变量去重写父类 <code>val</code> 类型的变量，但是不能使用 <code>val</code> 类型的变量去重写父类 <code>var</code> 类型的变量。</p><p>如果使用 <code>val</code> 类型的变量去重写父类的 <code>var</code> 类型的变量, 那么子类这个 <code>val</code> 类型的变量会多一个 <code>set</code> 方法, 而 <code>val</code> 类型的变量是不允许有 <code>set</code> 方法的。</p></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> y : String = <span class="string">&quot;a&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> : <span class="type">A</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> y: String = <span class="string">&quot;b&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> : <span class="type">A</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span>  <span class="keyword">var</span> x : <span class="built_in">Int</span> = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> y : String = <span class="string">&quot;c&quot;</span> <span class="comment">// Error: Var-property public open val y: String defined in C cannot be overridden by val-property public open var y: String defined in A</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h1><p><code>Kotlin</code> 将构造函数分为了两种：主构造函数和次构造函数。</p><h2 id="主构造函数"><a class="markdownIt-Anchor" href="#主构造函数"></a> 主构造函数</h2><p>主构造函数是最常使用的构造函数，每个类默认都会有一个不带参数的主构造函数。</p><p>（特殊情况：如果在没有实现主构造函数的情况下实现了次构造函数，则会失去该不带参数的主构造函数。）</p><p>当然也是可以显式地为其指明参数。主构造函数的特点就是没有函数体，直接定义在类名的后面即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> studentNo: String, <span class="keyword">var</span> grade: <span class="built_in">Int</span>) : Person() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者可以写成</span></span><br><span class="line"><span class="comment">// class Student constructor(val studentNo: String, var grade: Int) : Person() &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>我们在实例化的时候需要传入构造函数中的所有的参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> student = Student(<span class="string">&quot;123456789&quot;</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>由于主构造函数没有函数体，所以我们无法直接在其中编写一些逻辑。但是 <code>Kotlin</code> 给我们提供了一个 <code>init</code> 结构体，所有主构造函数的逻辑都可以写在里面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> studentNo: String, <span class="keyword">var</span> grade: <span class="built_in">Int</span>) : Person() &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Student No is <span class="variable">$studentNo</span> AND grade is <span class="variable">$grade</span>.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 <code>Java</code> 语言继承特性中的一个规定：子类的构造函数必须调用父类中的构造函数。这个规定在 <code>Kotlin</code> 中也要遵守。</p><p>所以在上文中 <code>class Student : Person()</code> 以及 <code>class Student(val studentNo: String, var grade: Int) : Person()</code> 中 <code>Person</code> 类后面的一对空括号表示 <code>Student</code> 类的主构造函数在初始化的时候会调用 <code>Person</code> 类的无参数构造函数，即使在自身的主构造函数为默认的无参数的时候也是不能省略的。</p><p>现在我们将 <code>Person</code> 类改造一下，将姓名和年龄都放到主构造函数中，即：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is eating.&quot;</span>)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们自定义了主构造函数，所以默认提供的无参数的主构造函数就不存在了，所以我们也需要修改一下 <code>Student</code> 类的表示方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> studentNo: String, <span class="keyword">var</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>) :</span><br><span class="line">        Person(name, age) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Student No is <span class="variable">$studentNo</span> AND grade is <span class="variable">$grade</span>.&quot;</span>)</span><br><span class="line">    &#125;    </span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我们在 <code>Student</code> 类的主构造函数中增加 <code>name</code> 和 <code>age</code> 这两个字段时，不能再将它们声明成 <code>val</code>，因为在主构造函数中声明成 <code>val</code> 或者 <code>var</code> 的参数将自动成为该类的字段,这就会导致和父类中同名的 <code>name</code> 和 <code>age</code> 字段造成冲突。因此，<strong>这里的 <code>name</code> 和 <code>age</code> 参数前面我们不用加任何关键字,让它的作用域仅限定在主构造函数当中即可</strong> 。</p><p>现在就可以通过如下的代码来创建一个 <code>Student</code> 类的实例并使用了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> student = Student(<span class="string">&quot;123456789&quot;</span>, <span class="number">3</span>, <span class="string">&quot;LiHua&quot;</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><h2 id="次构造函数"><a class="markdownIt-Anchor" href="#次构造函数"></a> 次构造函数</h2><p>其实你几乎是用不到次构造函数的，<code>Kotlin</code> 提供了一个给函数设定参数默认值的功能，基本上可以替代次构造函数的作用。</p><p>任何一个类只能有一个主构造函数，但是可以有多个次构造函数。次构造函数也可以用于实例化一个类，这一点和主构造函数没有什么不同，只不过它是有函数体的。</p><p><code>Kotlin</code> 规定，当一个类既有主构造函数又有次构造函数时，所有的次构造函数都必须调用主构造函数（包括间接调用)。</p><p>比如以下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(name: String, age: <span class="built_in">Int</span>, <span class="keyword">val</span> studentNo: String, <span class="keyword">var</span> grade: <span class="built_in">Int</span>) : Person(name, age) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;name : <span class="variable">$name</span> AND age : <span class="variable">$age</span> AND studentNo : <span class="variable">$studentNo</span> AND grade : <span class="variable">$grade</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(name: String , age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(name, age, <span class="string">&quot;12345&quot;</span>, <span class="number">2</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="string">&quot;XiaoMei&quot;</span>, <span class="number">19</span>, <span class="string">&quot;1234567&quot;</span>, <span class="number">1</span>) &#123;&#125; <span class="comment">// 如果 &#123;&#125; 内没有内容的话，可以省略大括号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student1 = Student(<span class="string">&quot;LiHua&quot;</span>, <span class="number">20</span>, <span class="string">&quot;123456&quot;</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> student2 = Student(<span class="string">&quot;XiaoMing&quot;</span>, <span class="number">21</span>)</span><br><span class="line">    <span class="keyword">val</span> student3 = Student()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">name : LiHua AND age : <span class="number">20</span> AND studentNo : <span class="number">123456</span> AND grade : <span class="number">3</span></span><br><span class="line">name : XiaoMing AND age : <span class="number">21</span> AND studentNo : <span class="number">12345</span> AND grade : <span class="number">2</span></span><br><span class="line">name : XiaoMei AND age : <span class="number">19</span> AND studentNo : <span class="number">1234567</span> AND grade : <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>特殊情况：</strong></p><p>那么接下来我们就再来看一种非常特殊的情况：类中只有次构造函数，没有主构造函数。</p><p>这种情况真的十分少见，但在 <code>Kotlin</code> 中是允许的。</p><p><strong>当一个类没有显式地定义主构造函数且定义了次构造函数时，它就是没有主构造函数的。</strong></p><p>我们结合代码来看一下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person &#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">super</span>(name, age) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的代码变化，首先 <code>Student</code> 类的后面没有显式地定义主构造函数，同时又因为定义了次构造函数，所以现在 <code>Student</code> 类是没有主构造函数的。那么既然没有主构造函数，继承 <code>Person</code> 类的时候也就不需要再加上括号了（因为主构造函数会调用父类的构造函数）。</p><p>另外，由于没有主构造函数，次构造函数只能直接调用父类的构造函数，上述代码也是将 <code>this</code> 关键字换成了 <code>super</code> 关键字，这部分就很好理解了，因为和 <code>Java</code> 比较像，也就不再多说了。</p><hr /><h1 id="函数的命名参数以及参数默认值"><a class="markdownIt-Anchor" href="#函数的命名参数以及参数默认值"></a> 函数的命名参数以及参数默认值</h1><blockquote><p>类的构造函数同样适用于命名参数以及参数默认值，所以我们在极大多数的情况下通过这两个特性配合主构造函数来可以实现次构造函数的功能。</p></blockquote><h2 id="命名参数"><a class="markdownIt-Anchor" href="#命名参数"></a> 命名参数</h2><p>简单理解，就是它允许我们在调用函数的时候传入“形参的名字”。</p><p>如同以下形式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helloFunction(name = <span class="string">&quot;Kotlin&quot;</span>)</span><br></pre></td></tr></table></figure><p>让我们看一个更具体的使用场景：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createUser</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    age: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    gender: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    friendCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    feedCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    likeCount: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    commentCount: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过如下的方法使用函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">createUser(</span><br><span class="line">    name = <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    age = <span class="number">30</span>,</span><br><span class="line">    gender = <span class="number">1</span>,</span><br><span class="line">    friendCount = <span class="number">78</span>,</span><br><span class="line">    feedCount = <span class="number">2093</span>,</span><br><span class="line">    likeCount = <span class="number">10937</span>,</span><br><span class="line">    commentCount = <span class="number">3285</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到，在这段代码中，我们把函数的形参加了进来，形参和实参用 <code>=</code> 连接，建立了两者的对应关系。对比前面 <code>Java</code> 风格的写法，这样的代码可读性更强了。如果将来你想修改 <code>likeCount</code> 这个参数，也可以轻松做到。这其实就体现出了 <code>Kotlin</code> 命名参数的可读性与易维护性两个优势。</p><h2 id="参数默认值"><a class="markdownIt-Anchor" href="#参数默认值"></a> 参数默认值</h2><p>而除了命名参数这个特性，<code>Kotlin</code> 还支持参数默认值，这个特性在参数较多的情况下同样有很大的优势：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createUser</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    age: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    gender: <span class="type">Int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    friendCount: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    feedCount: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    likeCount: <span class="type">Long</span> = <span class="number">0</span>L,</span></span></span><br><span class="line"><span class="params"><span class="function">    commentCount: <span class="type">Int</span> = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，<code>gender</code>、<code>friendCount</code>、<code>feedCount</code>、<code>likeCount</code>、<code>commentCount</code> 这几个参数都被赋予了默认值。这样做的好处就在于，我们在调用的时候可以省很多事情。比如说，下面这段代码就只需要传 3 个参数，剩余的 4 个参数没有传，但是 <code>Kotlin</code> 编译器会自动帮我们填上默认值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">createUser(</span><br><span class="line">    name = <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    age = <span class="number">30</span>,</span><br><span class="line">    commentCount = <span class="number">3285</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于无默认值的参数，编译器会强制要求我们在调用处传参；对于有默认值的参数，则可传可不传。<code>Kotlin</code> 这样的特性，在一些场景下就可以极大地提升我们的开发效率。而如果是在 <code>Java</code> 当中要实现类似的事情，我们就必须手动定义“3 个参数的 <code>createUser</code> 函数”，或者是使用 <code>Builder</code> 设计模式。</p><h2 id="在构造函数中的使用案例"><a class="markdownIt-Anchor" href="#在构造函数中的使用案例"></a> 在构造函数中的使用案例</h2><p>通过写出如下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(</span><br><span class="line">    name: String = <span class="string">&quot;&quot;</span>, </span><br><span class="line">    age: <span class="built_in">Int</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="keyword">val</span> studentNo: String = <span class="string">&quot;&quot;</span>, </span><br><span class="line">    <span class="keyword">val</span> grade: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : Person(name, age) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在给主构造函数的每个参数都设定了默认值之后，我们就可以使用任何传参组合的方式来对 <code>Student</code> 类进行实例化，当然也包含了上文中的两种次构造函数的使用场景。</p><hr /><h1 id="函数的可见性修饰符"><a class="markdownIt-Anchor" href="#函数的可见性修饰符"></a> 函数的可见性修饰符</h1><p>熟悉 <code>Java</code> 的人一定知道，<code>Java</code> 中有 <code>public</code>、 <code>private</code>、 <code>protected</code> 和 <code>default</code>(什么都不写）这4种函数可见性修饰符。</p><p><code>Kotlin</code>中也有4种，分别是 <code>public</code>、 <code>private</code>、<code>protected</code> 和 <code>internal</code>，需要使用哪种修饰符时，直接定义在 <code>fun</code> 关键字的前面即可。</p><p>下面将详细介绍一下 <code>Java</code> 和 <code>Kotlin</code> 中这些函数可见性修饰符的异同。</p><ol><li><p><code>private</code> 修饰符在两种语言中的作用是一模一样的，都表示只对当前类内部可见。</p></li><li><p><code>public</code> 修饰符的作用虽然也是一致的，表示对所有类都可见，但是在 <code>Kotlin</code>中 <code>public</code> 修饰符是默认项，而在 <code>Java</code> 中 <code>default</code> 才是默认项。前面我们定义了那么多的函数，都没有加任何的修饰符，所以它们默认都是 <code>public</code> 的。</p></li><li><p><code>protected</code> 关键字在 <code>Java</code> 中表示对当前类、子类和同一包路径下的类可见，在 <code>Kotlin</code> 中则表示只对当前类和子类可见。</p></li><li><p><code>Kotlin</code> 抛弃了 <code>Java</code> 中的 <code>default</code> 可见性（同一包路径下的类可见），引人了一种新的可见性概念，只对同一模块中的类可见，使用的是 <code>internal</code> 修饰符。比如我们开发了一个模块给别人使用，但是有一些函数只允许在模块内部调用，不想暴露给外部，就可以将这些函数声明成 <code>internal</code> 。</p></li></ol><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220708221406391.png" alt="image" /></p><p>所以，我们可以通过 <code>private</code> 关键字将类的构造函数定义为私有属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 私有的主构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">val</span> studentNo: String, </span><br><span class="line">    <span class="keyword">var</span> grade: <span class="built_in">Int</span></span><br><span class="line">) : Person() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有的次构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>(grade: <span class="built_in">Int</span>) : <span class="keyword">this</span>(<span class="string">&quot;123&quot;</span>, grade) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解计算机系统 练习题整理</title>
      <link href="/posts/a88955f1c30b/"/>
      <url>/posts/a88955f1c30b/</url>
      
        <content type="html"><![CDATA[<blockquote><p>整理并分析了上课时的部分练习题。</p><p>题目持续更新中~</p></blockquote><h1 id="第一章"><a class="markdownIt-Anchor" href="#第一章"></a> 第一章</h1><hr /><blockquote><p>一个程序的原来使用单线程的CPU的总运行时间为1。程序中不能并行执行的部分占比40%，可以并行执行的部分为60%。如果使用一个2线程的CPU执行该程序（不考虑其他额外开销），程序运行时间为（  A  ）</p><p>A. 0.7</p><p>B. 0.6</p><p>C. 0.9</p><p>D. 0.4</p></blockquote><p>Amdahl 定律：</p><p>若系统执行某应用程序需要时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。 假设系统某部分所需执行时间与该时间的比例为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>, 而该部分性能提升比例为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>。即该部分初始所需时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>×</mo><msub><mi>T</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a \times T_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 现在所需时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>a</mi><mo>×</mo><msub><mi>T</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><mi>k</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{a \times T_{old}}{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.239191em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.894191em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.41586em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。则加速比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mfrac><msub><mi>T</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><msub><mi>T</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo>+</mo><mfrac><mi>a</mi><mi>k</mi></mfrac></mrow></mfrac></mrow><annotation encoding="application/x-tex">S = \frac{T_{old}}{T_{new}} = \frac{1}{(1-a)+ \frac{a}{k}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.35244em;vertical-align:-1.0310000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0310000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mn>0.6</mn><mo separator="true">,</mo><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">a = 0.6, k = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 带入公式中，即可得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的值为 0.7。答案为A。</p><hr /><blockquote><p>接上题，如果使用一个5线程的CPU执行该程序，计算加速比为(  B  )</p><p>A. 1/0.73</p><p>B. 1/0.52</p><p>C. 1/0.84</p><p>D. 1/0.41</p></blockquote><p>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mn>0.6</mn><mo separator="true">,</mo><mi>k</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">a = 0.6, k = 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 带入上述公式中，即可得到选项 B。</p><hr /><blockquote>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a= <span class="number">1e20</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f + %f - %f = %f\n&quot;</span>, a, b, a, a + b - a);</span><br></pre></td></tr></table></figure><p>的执行结果为(  B  )</p><p>A. 3.14</p><p>B. 0</p><p>C. 3</p><p>D. 0.01</p></blockquote><ol><li><code>float</code> 有效数字位为8位，超过第8位的数字将四舍五入。</li><li>浮点数加法第一步为调整两个浮点数的阶数，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mn>1.00</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>20</mn></msup><mo separator="true">,</mo><mtext> </mtext><mi>b</mi><mo>=</mo><mo stretchy="false">(</mo><mn>3.14</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>20</mn></mrow></msup><mo stretchy="false">)</mo><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>20</mn></msup><mo>≈</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a = 1.00 \times 10^{20}, \space b = (3.14 \times 10^{-20}) \times 10^{20} \approx 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mord">.</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1.00</mn><mo>+</mo><mn>3.14</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>20</mn></mrow></msup><mo stretchy="false">)</mo><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>20</mn></msup><mo>≈</mo><mn>1</mn><mi>e</mi><mn>20</mn></mrow><annotation encoding="application/x-tex">a + b = (1.00 + 3.14 \times 10^{-20}) \times 10^{20} \approx 1e20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">.</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">2</span><span class="mord">0</span></span></span></span>。</li><li>故 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a + b - a = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</li></ol><hr /><blockquote>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f + %f - %f = %f\n&quot;</span>, a, b, a, a + b - a);</span><br></pre></td></tr></table></figure><p>的执行结果为(  A  )</p><p>A. 3.14</p><p>B. 0</p><p>C. 3</p><p>D. 0.01</p></blockquote><p>a 的值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>e</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">1e5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">5</span></span></span></span>，小于 <code>float</code> 的有效位数，所以可以正常进行数值运算。</p><hr /><blockquote><p>单CPU中可以通过线程进行并行操作。(  A  )</p><p>A. 错误</p><p>B. 正确</p></blockquote><hr /><h1 id="第二章"><a class="markdownIt-Anchor" href="#第二章"></a> 第二章</h1><hr /><blockquote><p>十进制数：136 对应的十六进制数为（ A ）</p><p>A. 0x88</p><p>B. 0x66</p><p>C. 0x96</p><p>D. 0x78</p></blockquote><p>可以通过 <strong>除k取余法</strong> 计算 十进制转k进制问题。</p><hr /><blockquote>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">0x12345678</span>;</span><br><span class="line">byte_pointer valp = (byte_pointer) &amp; val; </span><br><span class="line">show_bytes(valp, <span class="number">1</span>); </span><br></pre></td></tr></table></figure><p>上述程序在小端法机器上调用show_bytes的输出值为（ C ）</p><p>A. 56</p><p>B. 34</p><p>C. 78</p><p>D. 12</p></blockquote><p><code>show_bytes(byte_pointer, int x)</code> 函数的作用为输出 <code>byte_pointer</code> 的第 <code>x</code> 个字节。</p><hr /><blockquote><p>已知x和y的字节值分别为0x69和0x55。计算C表达式 x &amp; y 的字节值为（  B ）</p><p>A. 0x00</p><p>B. 0x41</p><p>C. 0x01</p><p>D. 0x20</p></blockquote><p>通过计算便可得到结果。</p><hr /><blockquote><p>接上题，计算C表达式 x &amp;&amp; y 的字节值为(  C  )</p><p>A. 0x00</p><p>B. 0x41</p><p>C. 0x01</p><p>D. 0x20</p></blockquote><p><code>&amp;&amp;</code> 为逻辑判断符号，结果只能为 0 或 1。</p><hr /><blockquote><p>假设一个8位整数的补码表示为 0xef，则这个整数的真值为 (  A  )</p><p>A. -17</p><p>B. -239</p><p>C. 17</p><p>D. 239</p></blockquote><p>0xef 的二进制表示为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1110</mn><mtext> </mtext><mn>1111</mn></mrow><annotation encoding="application/x-tex">1110\space 1111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span>，高一位为符号位，表示负数，低7位通过 <strong>反码+1</strong> 可以得出值为 17。所以这个补码的真值为 -17。</p><hr /><blockquote><p>假设一个整数数据类型为4位，已知x = -5 ，函数 T2U = (  A  )</p><p>A. 11</p><p>B. -5</p><p>C. 16</p><p>D. 5</p></blockquote><p>-5 的补码为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1011</mn></mrow><annotation encoding="application/x-tex">1011</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span></span></span></span>，无符号数为 11，选项 A 正确。</p><hr /><blockquote><p>在采用补码运算的32位机器上对表达式： -2147483647-1U &gt; 2147483647   的求值结果为(  D  )</p><p>A. -1</p><p>B. 0</p><p>C. 不确定</p><p>D. 1</p></blockquote><p>由于强制类型转换，-2147483647 和 2147483647 都会处理成 无符号数。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>2147483647</mn><mo>−</mo><mn>1</mn><mi>U</mi></mrow><annotation encoding="application/x-tex">-2147483647 - 1U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span><span class="mord">7</span><span class="mord">4</span><span class="mord">8</span><span class="mord">3</span><span class="mord">6</span><span class="mord">4</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> 的值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1110</mn></mrow><annotation encoding="application/x-tex">1111\space 1111\space 1111\space 1111\space 1111\space 1111\space 1111\space 1110</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span></span></span></span>；</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2147483647</mn></mrow><annotation encoding="application/x-tex">2147483647</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span><span class="mord">7</span><span class="mord">4</span><span class="mord">8</span><span class="mord">3</span><span class="mord">6</span><span class="mord">4</span><span class="mord">7</span></span></span></span> 的值为  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn></mrow><annotation encoding="application/x-tex">0111\space 1111\space 1111\space 1111\space 1111\space 1111\space 1111\space 1111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span>。</p><p>可以得出选项 D。</p><hr /><blockquote><p>已知x = -15，y = -12，计算字长 w = 5 的补码加法：x + y = (  D  )</p><p>A. -5</p><p>B. -27</p><p>C. 27</p><p>D. 5</p></blockquote><p>x + y = -27，其补码为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><mtext> </mtext><mn>0101</mn></mrow><annotation encoding="application/x-tex">10\space 0101</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span></span></span></span>，由于 w = 5，所以截取低5位，得到的结果为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mtext> </mtext><mn>0101</mn></mrow><annotation encoding="application/x-tex">0\space 0101</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span></span></span></span>，值为 5 ，选项 D 正确。</p><hr /><blockquote>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">2</span>; </span><br><span class="line"><span class="type">int</span> y = <span class="number">2</span>; </span><br><span class="line">x &lt;&lt;= <span class="number">6</span>; </span><br><span class="line">x -= y; </span><br><span class="line">y &lt;&lt;= <span class="number">3</span>; </span><br><span class="line">x -= y; </span><br></pre></td></tr></table></figure><p>上述程序 x 的输出值为（  B  ）</p><p>A. 128</p><p>B. 110</p><p>C. 55</p><p>D. 64</p></blockquote><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><msup><mn>2</mn><mn>6</mn></msup><mo>−</mo><mn>2</mn><mo>−</mo><mn>2</mn><mo>×</mo><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>110</mn></mrow><annotation encoding="application/x-tex">2 \times 2^6 - 2 - 2 \times 2^3 = 110</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span></span></span></span>，选项 B 正确。</p><hr /><blockquote><p>二进制小数 11.0011 对应的十进制数为（  C  ）</p><p>A. 3.3</p><p>B. 11.1875</p><p>C. 3.1875</p><p>D. 11.3</p></blockquote><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mn>0</mn></msup><mo>+</mo><mn>0</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>0</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>4</mn></mrow></msup><mo>=</mo><mn>3.1875</mn></mrow><annotation encoding="application/x-tex">1 \times 2^1 + 1 \times 2^0 + 0 \times 2^{-1} + 0 \times 2^{-2} + 1 \times 2^{-3} + 1 \times 2^{-4} = 3.1875</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">.</span><span class="mord">1</span><span class="mord">8</span><span class="mord">7</span><span class="mord">5</span></span></span></span>，选项 C 正确。</p><hr /><h1 id="第三章"><a class="markdownIt-Anchor" href="#第三章"></a> 第三章</h1><hr /><blockquote><p>算术右移指令是（ A ）</p><p>A. sar</p><p>B. shl</p><p>C. shr</p><p>D. sal</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625211226169.png" alt="image-20220625211226169" style="zoom:80%;" /><hr /><blockquote><p>假设<code>%rax holds x</code>,   <code>%rcx holds y</code>，则<code>leaq (%rax, %rcx, 4), %rdx</code>的结果为（  D ）</p><p>A. <code>( x + y ) * 4</code></p><p>B. <code>4 * x + y</code></p><p>C. <code>x + y + 4</code></p><p>D. <code>x + 4 * y</code></p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625211452247.png" alt="image-20220625211452247" style="zoom: 67%;" /><hr /><blockquote><p>关于条件码，下面描述错误的是 (  C  )</p><p>A.这些位描述和记录了最近算术运算或者逻辑运算的操作结果状态。</p><p>B.该序列在专门的状态寄存器FLAGS 或者EFLAGS。</p><p>C.以8086的状态寄存器FLAGS寄存器共8位。</p><p>D.一些bit位构成的序列</p></blockquote><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/weixin_42109012/article/details/100148721">8086标志寄存器（Flag Register）_有人_295的博客-CSDN博客_8086标志寄存器</a></li></ul></blockquote><p>标志寄存器设计为16位，实际使用9位，其中6位用以存放算术逻辑单元运算后的结果特征，称为<strong>状态标志</strong>；另外3位通过人为设置，用以控制8086的三种特定操作，称为<strong>控制标志</strong>。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190829223517134.png" alt="在这里插入图片描述" style="zoom:67%;" /><p>6个状态标志位定义如下：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190830001628834.png" alt="在这里插入图片描述" style="zoom:67%;" /><p><strong>进位标志：</strong> 用于反映运算是否产生进位或借位。如果运算结果的最高位产生一个进位或借位，则CF置1，否则置0。运算结果的最高位包括字操作的第15位和字节操作的第7位。移位指令也会将操作数的最高位或最低位移入CF。</p><p><strong>奇偶标志：</strong> 用于反映运算结果低8位中“1”的个数。“1”的个数为偶数，则PF置1，否则置0。</p><p><strong>辅助进位标志：</strong> 算数操作结果的第三位（从0开始计数）如果产生了进位或者借位则将其置为1，否则置为0，常在BCD(binary-code decimal)算术运算中被使用。</p><p><strong>零标志：</strong> 用于判断结果是否为0。运算结果0，ZF置1，否则置0。</p><p><strong>符号标志：</strong> 用于反映运算结果的符号，运算结果为负，SF置1，否则置0。因为有符号数采用补码的形式表示，所以SF与运算结果的最高位相同。</p><p><strong>溢出标志：</strong> 反映有符号数加减运算是否溢出。如果运算结果超过了8位或者16位有符号数的表示范围，则OF置1，否则置0。</p><hr /><blockquote><p>关于C语言的跳转及分支，下面描述正确的是(   D   )</p><p>A. 稀疏的 switch 语句使用跳转表</p><p>B. C语言不允许 switch 语句根据一个整数索引值进行多重分支</p><p>C. 大的 switch 语句使用决策树</p><p>D. C允许使用 goto 语句</p></blockquote><p>GCC 根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句。当开关情况数量比较多（例如 4 个以上），并且值的范围跨度比较小时，就会使用跳转表。情况数量较少或者值的范围跨度比较大时，会使用非常多的 <code>CMP</code> 指令，其实在这种情况下和使用多个 <code>if-else if</code> 一样。</p><hr /><blockquote><p>对指令 <code>linux&gt; objdump -d mstore.o</code>，说法最正确的是 (  C  )</p><p>A. 与mstore.exe等价的汇编语言代码</p><p>B. 与mstore.c等价的汇编语言代码</p><p>C. 与mstore.o等价的汇编语言代码</p><p>D. 以上说法都不对</p></blockquote><hr /><blockquote><p><code>xorl</code> 指令对条件码的影响描述正确的是(  B  )</p><p>A. CF被设置为移出的最后一位</p><p>B. CF和OF置零</p><p>C. ZF和OF置零</p><p>D. 对条件码无影响</p></blockquote><hr /><blockquote><p>对于x86,指令 <code>pushq %rax</code>，描述错误的是：(  A  )</p><p>A.该指令能一次压入4个bytes</p><p>B.该指令的功能是将寄存器ax的值存在堆栈中</p><p>C.与 <code>popq %rax</code>指令操作方向相反</p><p>D.该指令能增大堆栈</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621113704881.png" alt="image-20220621113704881" style="zoom: 33%;" /><p><code>pushq</code> 能一次压入 8 个 bytes。</p><hr /><blockquote><p>下列汇编指令，错误的是(  C  )</p><p>A. movb   (%rdi, %rcx), %al</p><p>B. movw  %bp, %sp</p><p>C. movb  (%rbx), (%rsp)</p><p>D. movl    $0x4050, %eax</p></blockquote><p><code>MOV</code> 指令中源操作数和目的操作数不能同时为寄存器地址。</p><hr /><blockquote><p>对命令行：<code>linux&gt;gcc -Og -S mstore.c</code>，使用 -S 选项的作用是（ D ）</p><p>A. GCC运行编译器，并进行反汇编</p><p>B. GCC运行编译器，产生一个汇编文件 mstore.s，且会产生目标文件</p><p>C. GCC运行编译器，并进行一个标准优化</p><p>D. GCC运行编译器，产生一个汇编文件 mstore.s，但是不做其他进一步的工作</p></blockquote><hr /><blockquote><p>用C语言调用有参函数，关于其机器级代码中的参数传递，以下描述正确的是（ A ）</p><p>A. 参数传递遵循调用约定，与目标机CPU和编译器都相关</p><p>B. 参数全部用栈传送，传递顺序只能由右向左进栈</p><p>C. 参数传递只与CPU相关，与编译器没有关系</p><p>D. 参数全部用固定的寄存器传递</p></blockquote><p>x8086 架构中，前6个参数存放在寄存器中，后所有参数都存放在栈中。</p><p>参数传递遵循调用约定，与目标机CPU和编译器都相关。</p><hr /><blockquote><p>x86-64的机器代码和原始的C代码差别非常大。一些通常对C语言程序员隐藏的处理器状态都是可见的，下面描述正确的是 ( A B C D )</p><p>A. 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现if和 while语句。</p><p>B. 整数寄存器文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址(对应于C语言的指针)或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。</p><p>C. 一组向量寄存器可以存放一个或多个整数或浮点数值。</p><p>D. 程序计数器(通常称为 “PC”，在x86-64中用 %rip 表示)给出将要执行的下一条指令在内存中的地址。</p></blockquote><hr /><blockquote><p>关于C语言函数对应机器代码中寄存器，正确的是（ A D ）</p><p>A. 有的寄存器调用函数不保护，由被调用函数负责保护</p><p>B. 所有寄存器都由调用函数保护，被调用函数可以自由使用</p><p>C. 所有寄存器都由被调用函数保护，调用函数可以自由使用</p><p>D. 有的寄存器由调用函数保护，被调用函数可以自由使用</p></blockquote><p>寄存器分为调用者寄存器和被调用者寄存器。</p><hr /><blockquote><p>对命令行：<code>linux&gt; gcc -Og -c mstore.c</code>，说法正确的是（ C D ）</p><p>A. 会产生exe文件，可执行文件是汇编格式的</p><p>B. 目标代码文件在机器中是十六进制的</p><p>C. GCC会编译并汇编该代码</p><p>D. 这会产生目标代码文件mstore.o</p></blockquote><p>可执行文件是二进制文件。</p><hr /><blockquote><p>C语言的一次函数调用包含的操作有（ A B C D ）</p><p>A. 跳转到被调函数的入口</p><p>B. 从栈中弹出调用函数的返回地址</p><p>C. 跳转到调用函数的返回地址</p><p>D. 保存调用函数的返回地址到栈中</p></blockquote><hr /><h1 id="第四章"><a class="markdownIt-Anchor" href="#第四章"></a> 第四章</h1><hr /><blockquote><p>能够被硬件识别并执行的程序是（   D  ）</p><p>A. 汇编语言程序</p><p>B. 高级语言程序</p><p>C. 人工智能语言程序</p><p>D. 机器指令程序</p></blockquote><hr /><blockquote><p>从计算机系统结构上讲，机器语言程序员能看到的机器属性是（  A ）</p><p>A. 编程要用到的硬件组织</p><p>B. 计算机各部件的硬件实现</p><p>C. 计算机软件所要完成的功能</p><p>D. 计算机硬件的全部组成</p></blockquote><hr /><blockquote><p>在CPU执行指令的过程中，数据的地址由什么给出？(   B   )</p><p>A. 操作系统</p><p>B. 指令的地址码字段</p><p>C. 程序员</p><p>D. 程序计数器PC</p></blockquote><hr /><blockquote><p>下列关于指令的功能及分类叙述正确的是 (  B  )</p><p>A. 转移指令，子程序调用与返回指令，用于解决数据调用次序的需要</p><p>B. 移位操作指令，通常用于把目的操作数DEST左移或右移OPRD位</p><p>C. 特权指令，通常仅用于系统软件，这类指令一般不提供给用户</p><p>D. 算术与逻辑运算指令，通常完成算术运算或逻辑运算，都需要两个数据</p></blockquote><p>特权指令指具有特殊权限的指令。. 这类指令只用于操作系统或其他系统软件，一般不直接提供给用户使用。</p><p>转移指令是指不按程序的语句流程执行的指令，如跳转指令， call 指令、 jmp 指令等。</p><hr /><blockquote><p>关于Y86-64指令的叙述中，不正确的是 (   A   )</p><p>A. 每条指令都有寄存器指示符</p><p>B. 指令的第1个字节高4位是指令代码，低4位是功能码</p><p>C. 有些指令有一个附加的8字节常数字</p><p>D. 每条指令的第1个字节表示指令的类型</p></blockquote><p><code>ret</code>、<code>nop</code>、<code>halt</code> 指令无需操作数。</p><hr /><blockquote><p>以下关于CISC和RISC的叙述中，不正确的是(   B   )</p><p>A. CISC有些指令的延迟很差，RISC没有较长延迟的指令</p><p>B. CISC和RISC都是可变长度</p><p>C. CISC有条件码，RISC没有条件码</p><p>D. CISC指令数量多，RISC指令数量少</p></blockquote><blockquote><p>答案参考自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/346864380">简述risc和cisc的区别（转发） - 知乎 (zhihu.com)</a></li><li>《深入理解计算机系统》</li></ul></blockquote><p>CISC的英文全称为“Complex Instruction Set Computer”，即“复杂指令系统计算机”，从计算机诞生以来，人们一直沿用CISC指令集方式。目前，桌面计算机流行的x86体系结构即使用CISC。在CISC微处理器中，程序的各条指令是按顺序串行执行的，每条指令中的各个操作也是按顺序串行执行的。顺序执行的优点是控制简单，但计算机各部分的利用率不高，执行速度慢。</p><p>RISC的英文全称为“Reduced Instruction Set Computer”，即“精简指令集计算机”，是一种执行较少类型计算机指令的微处理器，RISC机中采用的微处理器统称RISC处理器。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220626154912809.png" alt="image-20220626154912809" style="zoom:67%;" /><hr /><blockquote><p>Y86-64中用十六进制表示指令 <code>rmmovq %rsp, 0x123456789abcd(%rdx)</code>的字节编码(   C   )</p><p>A. 4042000123456789abcd</p><p>B. 40420123456789abcd</p><p>C. 4042cdab896745230100</p><p>D. 4042cdab8967452301</p></blockquote><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/Chauncyxu/article/details/121943734"> CSPP学习笔记-Ch4 借助 Y86-64 理解处理器是如何工作的_Life Commander的博客-CSDN博客_硬件寄存器和程序寄存器</a></li></ul></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/B1TZjXLRgPqYd2x.png" alt="img" style="zoom: 13%;" /><p>程序寄存器存在CPU中的一个寄存器文件中。<br />在指令编码中以及在硬件设计中，当需要指明不应访问任何寄存器时，就用 ID 值 0xF 来表示。</p><table><thead><tr><th>数字</th><th>寄存器名字</th><th>数字</th><th>寄存器名字</th></tr></thead><tbody><tr><td>0</td><td><code>%rax</code></td><td>8</td><td><code>%r8</code></td></tr><tr><td>1</td><td><code>%rcx</code></td><td>9</td><td><code>%r9</code></td></tr><tr><td>2</td><td><code>%rdx</code></td><td>A</td><td><code>%r10</code></td></tr><tr><td>3</td><td><code>%rbx</code></td><td>B</td><td><code>%r11</code></td></tr><tr><td>4</td><td><code>%rsp</code></td><td>C</td><td><code>%.r12</code></td></tr><tr><td>5</td><td><code>%rbp</code></td><td>D</td><td><code>%r13</code></td></tr><tr><td>6</td><td><code>%rsi</code></td><td>E</td><td><code>%r14</code></td></tr><tr><td>7</td><td><code>%rdi</code></td><td>F</td><td>No register</td></tr></tbody></table><p>从图可以看到，<code>rmmovq</code> 的第一个字节为 <code>40</code>。源寄存器 <code>%rsp</code> 应该编码放在 <code>rA</code> 字段中，而基址寄存器 <code>%rdx</code> 应该编码放在 <code>rB</code> 字段中。</p><p>根据表中的寄存器编号，得到寄存器指示符字节 4 和 2。</p><p>偏移量编码放在 8 字节的常数中：首先在 <code>0x123456789abcd</code> 的前面填充上 0 变成 8 个字节，变成字节序列 <code>00 01 23 45 67 89 ab cd</code>，由于<strong>小端法编码</strong>，写成按字节反序就是 <code>cd ab 89 67 45 23 01 00</code>。</p><p>最后，将它们都连接起来就得到指令的编码 <code>4042cdab896745230100</code>。</p><hr /><blockquote><p>输入a和b，写出信号 xor的HCL表达式(   B   )</p><p>A. bool xor =（!a &amp;&amp; !b) || (a &amp;&amp; b)</p><p>B. bool xor =（!a &amp;&amp; b) || (a &amp;&amp; !b)</p><p>C. bool xor =（a &amp;&amp; b) || (a &amp;&amp; b)</p><p>D. bool xor =（a &amp;&amp; b) || (!a &amp;&amp; b)</p></blockquote><p>可以通过类似真值表的方式判断正确答案。</p><hr /><blockquote><p>输入a和b，控制信号输入位s，写出信号MUX的HCL表达式（  D ）</p><p>A. bool out = (s &amp;&amp; a) || (s &amp;&amp; b)</p><p>B. bool out = (!s &amp;&amp; a) || (!s &amp;&amp; b)</p><p>C. bool out = (s &amp;&amp; !a) || (s &amp;&amp; !b)</p><p>D. bool out = (s &amp;&amp; a) || (!s &amp;&amp; b)</p></blockquote><p><code>MUX</code> 为多路复用器，对 s 的不同输入情况采取不同的信号输出。</p><hr /><blockquote><p>Y86-64处理器执行一条完整指令所需的步骤有 （ A B C D E ）</p><p>A.访存</p><p>B.译码</p><p>C.执行</p><p>D.写回和更新PC</p><p>E.取指</p></blockquote><p>几乎所有的冯·诺伊曼型计算机的CPU，其工作都可以分为5个阶段：取指令、指令译码、执行指令、访存取数、结果写回。</p><p>各个阶段具体内容参考：<a href="https://blog.csdn.net/aigoogle/article/details/23750257">一条指令在cpu中的执行流程（理解CPU组成）_编码那些事儿的博客-CSDN博客</a></p><hr /><h1 id="第六章"><a class="markdownIt-Anchor" href="#第六章"></a> 第六章</h1><hr /><blockquote><p>主存储器和 CPU之间增加cache的目的是（ D ）。</p><p>A.扩大CPU中通用寄存器的数量</p><p>B.扩大主存储器的容量</p><p>C.既扩大主存容量又扩大CPU通用寄存器数量</p><p>D.解决CPU和主存之间的速度匹配问题</p></blockquote><hr /><blockquote><p>下列因素下，与cache的命中率无关的是（  D  ）。</p><p>A. cache 的组织方式</p><p>B. 块的大小</p><p>C. cache的容量</p><p>D. 主存的存取时间</p></blockquote><hr /><blockquote><p>以下哪一种情况能很好地发挥cache的作用? （  A  ）</p><p>A. 程序具有较好的访问局部性</p><p>B. 程序的大小不超过实际的内存容量</p><p>C. 程序的指令间相关度不高</p><p>D. 程序中不含有过多的I/O操作</p></blockquote><hr /><blockquote><p>在当前微机中，使用cache提高了计算机运行速度，主要是因为（  A  ）</p><p>A. cache缩短了CPU的等待时间</p><p>B. cache扩大了硬盘的容量</p><p>C. cache可以存放程序和数据</p><p>D. cache增大了内存的容量</p></blockquote><hr /><blockquote><p>在存储器层次结构中，存储器速度从最快到最慢的排列顺序是(   C   )</p><p>A.寄存器  -&gt; cache -&gt; 辅存 -&gt; 主存</p><p>B.寄存器 -&gt; 主存 -&gt; 辅存 -&gt; cache</p><p>C.寄存器 -&gt; cache -&gt; 主存 -&gt; 辅存</p><p>D.寄存器 -&gt; 主存 -&gt; cache -&gt; 辅存</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220626191551044.png" alt="image-20220626191551044" style="zoom:67%;" /><hr /><blockquote><p>在cache的地址映射中，若主存中的任意一块均可映射到cache内的任意一块的位置上，则这种方法称为（ D ）。</p><p>A. 组相联映射</p><p>B. 直接映射</p><p>C. 混合映射</p><p>D. 全相联映射</p></blockquote><hr /><blockquote><p>某计算机的cache共有16行,采用2路组相联映射方式(即每组2行)。每个主存块大小为32字节,按字节编址。主存135号单元所在主存块应装入到的cache组号是（ A ）。</p><p>A. 4</p><p>B. 2</p><p>C. 6</p><p>D. 0</p></blockquote><p>通过题目可以得出：该计算机的 cache 总共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">16 / 2 = 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 组，每组 2 行，每块 32 字节。</p><p>135 的二进制为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mtext> </mtext><mn>1000</mn><mtext> </mtext><mn>0111</mn></mrow><annotation encoding="application/x-tex">0 \space 1000 \space 0111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span>，重新调整排版后为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mtext> </mtext><mn>100</mn><mtext> </mtext><mn>00111</mn></mrow><annotation encoding="application/x-tex">0 \space 100 \space 00111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span>。</p><p>从低位向高位看：</p><ol><li>低 5 位表示每块 32 字节，即每行的偏移值。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>5</mn></msup><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">2^5 = 32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span></span></span></span>）</li><li>中 3 位表示共有 8 个组，即组索引。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">2^3=8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>）</li><li>高 t 位表示标记位，即说明这个组的哪一行包括了相关内容。</li></ol><p>所以 cache 组号为中 3 位，即为 4。</p><hr /><blockquote><p>假定主存按字节编址，cache 共有64行，采用直接映射方式，主存块大小为32字节，所有编号都从0开始。问主存第2593号单元所在主存块对应的cache行号是（ B ）</p><p>A.34</p><p>B.17</p><p>C.81</p><p>D.1</p></blockquote><p>得出的信息：</p><ol><li>共有 64 组，每组 1 行。 -&gt;  二进制中间部分位数为 6。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn><mo>=</mo><msup><mn>2</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">64 = 2^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>）</li><li>每块 32 字节。 -&gt; 二进制后面部分位数为 5。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn><mo>=</mo><msup><mn>2</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">32=2^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>）</li></ol><p>2593 的二进制为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mtext> </mtext><mn>010001</mn><mtext> </mtext><mn>00001</mn></mrow><annotation encoding="application/x-tex">1 \space 010001 \space 00001</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span></span></span></span>，所以 cache 行号为二进制中间部分，即为 17。选项 B 正确。</p><hr /><blockquote><p>假定主存按字节编址，cache 共有64行，采用4路组相联映射方式，主存块大小为32字节，所有编号都从0开始。问主存第2593号单元所在主存块对应的cache组号是（ D ）</p><p>A.34</p><p>B.17</p><p>C.81</p><p>D.1</p></blockquote><p>得出的信息：</p><ol><li>共有 16 组，每组 4 行。 -&gt;  二进制中间部分位数为 4。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn><mo>=</mo><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">16 = 2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>）</li><li>每块 32 字节。 -&gt; 二进制后面部分位数为 5。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn><mo>=</mo><msup><mn>2</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">32=2^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>）</li></ol><p>2593 的二进制为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>101</mn><mtext> </mtext><mn>0001</mn><mtext> </mtext><mn>00001</mn></mrow><annotation encoding="application/x-tex">101 \space 0001 \space 00001</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span></span></span></span>，所以 cache 行号为二进制中间部分，即为 1。选项 D 正确。</p><hr /><blockquote><p>下面的叙述中，不正确的是( B C D )。</p><p>A.重复引用相同变量的程序有良好的时间局部性</p><p>B.在CPU和主存间加入了多个cache，计算机总存储量就增加了</p><p>C.CPU要找的指令和数据都能在cache中访问到</p><p>D.主存和cache之间按主存块为单位传送数据时，主存块越大越好</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深入理解计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 自定义 Toast [转载]</title>
      <link href="/posts/e8e9356f3f9b/"/>
      <url>/posts/e8e9356f3f9b/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章转载自：</p><ul><li><a href="https://blog.csdn.net/liuwan1992/article/details/52710652">Android 自定义Toast，修改Toast样式和显示时长_liuwan1992的博客-CSDN博客</a></li></ul></blockquote><hr /><p>Android 中有一个 Toast 控件，可以用来显示提示信息，还是非常好用的，但是样式和显示时长比较局限。所以我们来自定义一个 Toast ，让它可以显示我们想要的效果，并能设置显示时长。</p><p>首先，在 res\layout 文件夹下创建自定义 Toast 的布局文件 custom_toast.xml，用来设置 Toast 的样式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:id</span>=<span class="string">&quot;@+id/toast_custom_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:id</span>=<span class="string">&quot;@+id/tvToastContent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;46dp&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;75dp&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:background</span>=<span class="string">&quot;@drawable/toast_customer_style&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:textColor</span>=<span class="string">&quot;#FFFFFF&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的自定义 Toast 其实就是一个TextView ，其中引用了 res\drawable 文件夹下的一个 shape 样式文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:shape</span>=<span class="string">&quot;rectangle&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置背景透明度和颜色 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">&quot;#99000000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置四个角为弧形 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">&quot;23dp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">padding</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:left</span>=<span class="string">&quot;23dp&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:right</span>=<span class="string">&quot;23dp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure><p>到这里，所有的布局就已经设计好了，也就是实现了自定义样式，接下来就是在代码中实现自定义 Toast 了，以及实现设置显示时长：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomToast</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">canceled</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler handler;</span><br><span class="line">    <span class="keyword">private</span> Toast toast;</span><br><span class="line">    <span class="keyword">private</span> TimeCount time;</span><br><span class="line">    <span class="keyword">private</span> TextView toast_content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomToast</span><span class="params">(Context context, ViewGroup viewGroup)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, viewGroup, <span class="keyword">new</span> <span class="title class_">Handler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomToast</span><span class="params">(Context context, ViewGroup viewGroup, Handler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line"></span><br><span class="line">        <span class="type">View</span> <span class="variable">layout</span> <span class="operator">=</span> LayoutInflater.from(context).inflate(R.layout.custom_toast, viewGroup);</span><br><span class="line">        toast_content = (TextView) layout.findViewById(R.id.tvToastContent);</span><br><span class="line">        <span class="keyword">if</span> (toast == <span class="literal">null</span>) &#123;</span><br><span class="line">            toast = <span class="keyword">new</span> <span class="title class_">Toast</span>(context);</span><br><span class="line">        &#125;</span><br><span class="line">        toast.setGravity(Gravity.BOTTOM, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        toast.setDuration(Toast.LENGTH_LONG);</span><br><span class="line">        toast.setView(layout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text     要显示的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> duration 显示的时间长</span></span><br><span class="line"><span class="comment">     *                 根据LENGTH_MAX进行判断</span></span><br><span class="line"><span class="comment">     *                 如果不匹配，进行系统显示</span></span><br><span class="line"><span class="comment">     *                 如果匹配，永久显示，直到调用hide()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String text, <span class="type">int</span> duration)</span> &#123;</span><br><span class="line">        time = <span class="keyword">new</span> <span class="title class_">TimeCount</span>(duration, <span class="number">1000</span>);</span><br><span class="line">        toast_content.setText(text);</span><br><span class="line">        <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">            time.start();</span><br><span class="line">            canceled = <span class="literal">false</span>;</span><br><span class="line">            showUntilCancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 隐藏Toast</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hide</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (toast != <span class="literal">null</span>) &#123;</span><br><span class="line">            toast.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        canceled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showUntilCancel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        toast.show();</span><br><span class="line">        handler.postDelayed(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                showUntilCancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计时器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TimeCount</span> <span class="keyword">extends</span> <span class="title class_">CountDownTimer</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TimeCount</span><span class="params">(<span class="type">long</span> millisInFuture, <span class="type">long</span> countDownInterval)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(millisInFuture, countDownInterval); <span class="comment">// 总时长,计时的时间间隔</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFinish</span><span class="params">()</span> &#123; <span class="comment">// 计时完毕时触发</span></span><br><span class="line">            hide();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTick</span><span class="params">(<span class="type">long</span> millisUntilFinished)</span> &#123; <span class="comment">// 计时过程显示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要通过一个倒计时器和异步线程来实现设置显示时长。TimeCount 有两个参数，第一个是倒计时时长，也就是 Toast 要显示的时长，第二个是间隔时间，在倒计时内每隔一定时间会回调一次 onTick 方法，倒计时结束后回调 onFinish 方法。在倒计时器中我 们要设置的只有倒计时时长，即显示时长，时间到了就 cancel() 掉 Toast。在对 Toast 初始化时，默认设置的显示时长是LENGTH_LONG ，为2.5s。那么问题来了，3s以内倒计时器可以控制显示时长，但是超过3s Toast 就自行结束了，如果我们想要显示超过三秒怎么办，所以这里通过一个异步线程，并设置一个 postDelayed 任务，推迟3s执行，在线程中调用自身的方法，实现循环调用。 这样每隔3s显示一次 Toast ，达到了一直显示的效果。然后通过 canceled 属性，将倒计时器和异步线程联系到一起，这样就可以通过 Handler 让 Toast 一直显示，再通过 TimeCount 让 Toast 结束显示，达到了自定义显示时长的效果。</p><p>具体调用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CustomToast toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">toastMessage</span><span class="params">(String content)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (toast != <span class="literal">null</span>) &#123;</span><br><span class="line">        toast.hide();</span><br><span class="line">    &#125;</span><br><span class="line">    toast = <span class="keyword">new</span> <span class="title class_">CustomToast</span>(LoginActivity.<span class="built_in">this</span>,</span><br><span class="line">                            (ViewGroup) <span class="built_in">this</span>.findViewById(R.id.toast_custom_parent));</span><br><span class="line">    toast.show(content, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以在 onClick 等事件中通过调用 toastMessage(&quot;自定义 Toast 的显示内容 &quot;); 来显示你想要给用户看到的提示内容了。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Toast </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深入理解计算机系统》 第三章 学习笔记</title>
      <link href="/posts/9d9a45889a2d/"/>
      <url>/posts/9d9a45889a2d/</url>
      
        <content type="html"><![CDATA[<h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li>《深入理解计算机系统》</li><li><a href="https://zhuanlan.zhihu.com/p/94406822">「抄书笔记」Machine Level Programming - 知乎 (zhihu.com)</a></li><li><a href="https://space.bilibili.com/354767108">九曲阑干的个人空间_哔哩哔哩_bilibili</a></li></ul><h1 id="寄存器"><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h1><h2 id="调用者保存"><a class="markdownIt-Anchor" href="#调用者保存"></a> 调用者保存</h2><p>调用者保存是指当P函数调用Q函数时，该寄存器中的内容由调用者P负责保存，Q可以直接使用该寄存器。</p><h2 id="被调用者保存"><a class="markdownIt-Anchor" href="#被调用者保存"></a> 被调用者保存</h2><p>被调用者保存是指当P函数调用Q函数时，该寄存器中的内容由被调用者Q负责保存。</p><h2 id="调用者保存寄存器caller-saved-registers"><a class="markdownIt-Anchor" href="#调用者保存寄存器caller-saved-registers"></a> 调用者保存寄存器（<code>caller saved registers</code>）</h2><p>也叫<strong>易失性寄存器</strong>，在程序调用的过程中，这些寄存器中的值不需要被保存（即压入到栈中再从栈中取出），如果某一个程序需要保存这个寄存器的值，需要调用者自己压入栈；</p><h2 id="被调用者保存寄存器callee-saved-registers"><a class="markdownIt-Anchor" href="#被调用者保存寄存器callee-saved-registers"></a> 被调用者保存寄存器（<code>callee saved registers</code>）</h2><p>也叫<strong>非易失性寄存器</strong>，在程序调用过程中，这些寄存器中的值需要被保存，不能被覆盖；当某个程序调用这些寄存器，被调用寄存器会先保存这些值然后再进行调用，且在调用结束后恢复被调用之前的值；</p><h2 id="寄存器及其功能"><a class="markdownIt-Anchor" href="#寄存器及其功能"></a> 寄存器及其功能</h2><p>其中，<code>rsp</code> 表示的是运行时栈结束的位置，即栈顶的位置。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-909063cd57cd5b2136ff8ed4d04bc5e6_1440w.jpg" alt="img" style="zoom:57%;" /><h1 id="汇编指令后缀"><a class="markdownIt-Anchor" href="#汇编指令后缀"></a> 汇编指令后缀</h1><p>如 <code>movq</code>，<code>callq</code>，<code>movl</code> 等等。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621113704881.png" alt="image-20220621113704881" style="zoom:40%;" /><h1 id="操作数格式"><a class="markdownIt-Anchor" href="#操作数格式"></a> 操作数格式</h1><p>比例因子的取值和源代码中存储对象的类型有关，且只能为1，2，4，8（分别对应着 <code>char</code>，<code>short</code>，<code>int</code>，<code>long</code>四个数据类型）。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625211452247.png" alt="image-20220625211452247" style="zoom:80%;" /><h1 id="mov-指令"><a class="markdownIt-Anchor" href="#mov-指令"></a> <code>MOV</code> 指令</h1><p>源操作数和目的操作数不能同时为寄存器地址。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621180210624.png" alt="image-20220621180210624" style="zoom: 80%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621182452659.png" alt="image-20220621182452659" style="zoom:67%;" /><h2 id="movq-movabsq"><a class="markdownIt-Anchor" href="#movq-movabsq"></a> <code>MOVQ</code> &amp; <code>MOVABSQ</code></h2><p>当出现 <code>MOVQ $Imm Destination</code> 指令时，该立即数只能是32位的补码表示，然后对该数值进行符号位扩展之后，将得到的64位数传送到目的位置。</p><p>这个限制会带来一个问题，就是如果立即数是64位时该如何处理？</p><p>这里引入了一个新的指令 <code>MOVABSQ $Imm Register</code> ，这里存放的可以是任意的64位立即数，但是目的操作数只能是寄存器。</p><h2 id="movl"><a class="markdownIt-Anchor" href="#movl"></a> <code>MOVL</code></h2><p>当 <code>MOVL</code> 的目的操作数是寄存器时，它会把该寄存器的高4字节设置为0，这是64位处理器的一个规定。即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置为0。</p><h2 id="movz-movs"><a class="markdownIt-Anchor" href="#movz-movs"></a> <code>MOVZ</code> &amp; <code>MOVS</code></h2><p>当源操作数的数位小于目的操作数时，便会对目的操作数剩余的字节进行扩展。</p><p>指令的最后两个字符表示了源操作数的大小以及目的操作数的大小。</p><p>零扩展中没有的 <code>movzlq</code> 指令可以通过 <code>movl</code> 指令实现。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-f59c8e900d14a5597a87959a6df649c7_720w.jpg" alt="img" style="zoom: 90%;" /><h1 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h1><h2 id="栈的结构"><a class="markdownIt-Anchor" href="#栈的结构"></a> 栈的结构</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621183231538.png" alt="image-20220621183231538" style="zoom: 67%;" /><p>栈的顶部在图中的底部，栈顶的元素时所有栈中元素地址最低的。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-429b736ec876e982f38a9f651303e9fa_720w.jpg" alt="img" style="zoom: 80%;" /><h2 id="push"><a class="markdownIt-Anchor" href="#push"></a> <code>PUSH</code></h2><p>使用 <code>push</code> 指令将数据压入栈内。</p><p>例如 <code>pushq %rax</code> 指令执行的过程可以分为两步：</p><ol><li>指向栈顶的寄存器 <code>rsp</code> 进行一个减法操作 <code>subq $8, %rsp</code>。</li><li>将需要保存的元素复制到新的栈顶位置 <code>movq %rax, (%rsp)</code>。</li></ol><h2 id="pop"><a class="markdownIt-Anchor" href="#pop"></a> <code>POP</code></h2><p>使用 <code>pop</code> 指令从内存中读取数据，并且修改栈顶指针。</p><p>例如 <code>popq %rbx</code> 指令就是将栈顶保存的数据复制到寄存器<code>rbx</code>中，该指令同样也可以分解成两步：</p><ol><li>从栈顶的位置读出数据，复制到寄存器 <code>rbx</code>：<code>movq (%rsp), %rbx</code>。</li><li>将栈顶的指针加8（因为 <code>q</code> 表示的是8个字节）：<code>addq $8, %rsp</code>。</li></ol><h1 id="算数和逻辑运算指令"><a class="markdownIt-Anchor" href="#算数和逻辑运算指令"></a> 算数和逻辑运算指令</h1><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-af64fab6c6832e1d6f6ff4dcebb0a07a_720w.jpg" alt="img" style="zoom: 80%;" /><h2 id="lea"><a class="markdownIt-Anchor" href="#lea"></a> <code>LEA</code></h2><p>实现的功能为加载有效的地址，即将计算出的源操作数的值直接写入到目的寄存器中。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621184454652.png" alt="image-20220621184454652" style="zoom: 67%;" /><p>其中，<code>q</code>表示为加载的地址的长度为8个字节。因为64位系统中地址的长度都是64位，所以不存在 <code>leab</code>，<code>leaw</code>这类有关大小的变种。</p><p>例如，<code>leaq 7(%rdx, %rdx, 4), %rax</code> ，它表示的含义是把有效地址复制到寄存器<code>rax</code>中。其中，有效地址的计算方式与之前讲到的内存地址的计算方式一致。</p><p>除了加载有效地址的功能，<code>leaq</code> 指令还可以用来表示加法和有限的乘法运算（比例因子的取值只能为1，2，4，8这四个数中的一个）。</p><h2 id="一元操作"><a class="markdownIt-Anchor" href="#一元操作"></a> 一元操作</h2><p>第一个操作数既是源操作数，也是目的操作数，可以是寄存器，也可以是内存地址。</p><h2 id="二元操作"><a class="markdownIt-Anchor" href="#二元操作"></a> 二元操作</h2><p>第二个操作数既是源操作数，也是目的操作数，但是其不能是立即数。</p><p>需要注意，<code>sub</code> 指令的减数和被减数的操作数位置，为第二个操作数减第一个操作数。</p><h2 id="移位操作"><a class="markdownIt-Anchor" href="#移位操作"></a> 移位操作</h2><p>两个左移的指令效果相同。</p><p>对于移位量k，可以是一个立即数，<strong>或者是放在寄存器 <code>cl</code> 中的数</strong>。</p><p>对于移位指令，只允许以特定的寄存器cl作为操作数，其他的寄存器不行，这里需要特别注意。</p><h2 id="其他特殊的算数指令"><a class="markdownIt-Anchor" href="#其他特殊的算数指令"></a> 其他特殊的算数指令</h2><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621195341299.png" alt="image-20220621195341299" /></p><h1 id="条件码寄存器"><a class="markdownIt-Anchor" href="#条件码寄存器"></a> 条件码寄存器</h1><p>ALU（算数执行单元）除了执行算数和逻辑运算指令外，还会根据该运算的结果去设置条件码寄存器。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621192149338.png" alt="image-20220621192149338" style="zoom:67%;" /><p>CPU 维护一组单个位的条件码寄存器，检测条件分支指令，描述了最近执行操作的属性。</p><ul><li><p>CF</p><blockquote><p><code>Carry Flag</code> —— 进位标志</p></blockquote><p>最近的操作让最高位进位，可以检查无符号操作数的溢出。</p></li><li><p>ZF</p><blockquote><p><code>Zero Flag</code> —— 零标志</p></blockquote><p>当最近操作的结果等于0时，需标志(ZF)会被置为1。</p></li><li><p>SF</p><blockquote><p><code>Sign Flag</code> —— 符号标志</p></blockquote><p>当最近的操作结果小于零时，符号标志(SF)会被置为1。</p></li><li><p>OF</p><blockquote><p><code>Overflow Flag</code> —— 溢出标志</p></blockquote><p>针对有符号数，最近的操作导致正溢出或者负溢出时，溢出标志(OF)会被置1（操作导致补码溢出）。</p></li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621192305450.png" alt="image-20220621192305450" style="zoom:67%;" /><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621195556936.png" alt="image-20220621195556936" /></p><h2 id="cmp"><a class="markdownIt-Anchor" href="#cmp"></a> <code>CMP</code></h2><p><code>cmp</code>指令是根据两个操作数的差来设置条件码寄存器，为第二个操作数减去第一个操作数。</p><p><code>cmp</code>指合和减法指令(<code>sub</code>)类似，也是根据两个操作数的差来设置条件码。二者不同的是cmp指令只是设置条件码寄存器，并不会更新目的寄存器的值。</p><p>指令<code>cmp</code>会根据差的结果来设置符号标志(SF)和溢出标志(OF)。</p><p>如果与 <code>CMOV</code> 指令一起使用的话，那么这个指令的含义便可以理解为，<strong>将第二个操作数与第一个操作数进行比较</strong>，比较的内容为 <code>CMOV</code> 指令中的内容。注意，一定是第二个操作数在比较符号之前，第一个操作数在符号之后。</p><h2 id="test"><a class="markdownIt-Anchor" href="#test"></a> <code>TEST</code></h2><p><code>test</code>指令和 <code>and</code> 指令类似，同样 <code>test</code> 指令只是设置条件码寄存器，并不会更新目的寄存器的值。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625160659795.png" alt="image-20220625160659795" style="zoom:67%;" /><h2 id="set"><a class="markdownIt-Anchor" href="#set"></a> <code>SET</code></h2><p>使用 <code>set</code> 指令，根据条件码寄存器中不同组合的对应的计算结果，将结果值复制到目的寄存器中。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621195516682.png" alt="SET 指令" /></p><h1 id="跳转指令与循环"><a class="markdownIt-Anchor" href="#跳转指令与循环"></a> 跳转指令与循环</h1><p>在汇编代码中，判断、循环语句的实现基本采用C语言中<code>goto</code>语句的实现方式。所以了解<code>goto</code>语句，能够更加容易掌握这部分知识。</p><h2 id="jump"><a class="markdownIt-Anchor" href="#jump"></a> <code>JUMP</code></h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621211143827.png" alt="image-20220621211143827" style="zoom:67%;" /><h3 id="跳转指令的编码"><a class="markdownIt-Anchor" href="#跳转指令的编码"></a> 跳转指令的编码</h3><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621211915713.png" alt="image-20220621211915713" /></p><h2 id="cmov"><a class="markdownIt-Anchor" href="#cmov"></a> <code>CMOV</code></h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625183509367.png" alt="image-20220625183509367" style="zoom:80%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621211422154.png" alt="image-20220621211422154" style="zoom:80%;" /><h2 id="判断语句"><a class="markdownIt-Anchor" href="#判断语句"></a> 判断语句</h2><h3 id="if-语句"><a class="markdownIt-Anchor" href="#if-语句"></a> <code>if</code> 语句</h3><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621212901469.png" alt="image-20220621212901469" style="zoom: 50%;" /><p><strong>使用例</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621212656994.png" alt="image-20220621212656994" style="zoom: 80%;" /><p>判断语句除了可以使用传统的 <code>jump</code> 指令，也可以通过更加高效的 <code>cmov</code> 指令实现。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621213135058.png" alt="image-20220621213135058" style="zoom: 67%;" /><h3 id="switch-语句"><a class="markdownIt-Anchor" href="#switch-语句"></a> <code>switch</code> 语句</h3><blockquote><p>switch（开关）语句可以根据一个整数索引值进行多重分支 (multiway branching) 。在 处理具有多种可能结果的测试时，这种语句特别有用。</p><p>它们不仅提高了 C 代码的可读性， 而且通过使用跳转表(jump table) 这种数据结构使得实现更加高效。</p><p>跳转表是一个数组，表项 i 是一个代码段的地址，这个代码段实现当开关索引值等于 i 时程序应该采取的动作。</p><p>和使用一 组很长的 if-else 语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。 当 switch 语句有上百种情况的时候，也可以只用一次跳转表访问去处理。</p><p>GCC 根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句。当开关情况数量比较多（例如 4 个以上），并且值的范围跨度比较小时，就会使用跳转表。情况数量较少或者值的范围跨度比较大时，会使用非常多的 <code>CMP</code> 指令，其实在这种情况下和使用多个 <code>if-else if</code> 一样。</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625191557467.png" alt="image-20220625191557467" style="zoom:80%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625191608408.png" alt="image-20220625191608408" style="zoom:80%;" /><h2 id="循环结构"><a class="markdownIt-Anchor" href="#循环结构"></a> 循环结构</h2><p>循环语句是通过条件测试和跳转语句的结合来实现的。</p><h3 id="do-while循环"><a class="markdownIt-Anchor" href="#do-while循环"></a> <code>do-while</code>循环</h3><p>    <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625183700482.png" alt="image-20220625183700482" style="zoom:80%;" />    <br><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625183817630.png" alt="image-20220625183817630" style="zoom:80%;" /></p><p><strong>使用例</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621213819867.png" alt="image-20220621213819867" style="zoom: 60%;" /><h3 id="while-循环"><a class="markdownIt-Anchor" href="#while-循环"></a> <code>while</code> 循环</h3><p>    <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625184638266.png" alt="image-20220625184638266" style="zoom:80%;" /></p> <p><strong>第一种翻译方法</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625184745056.png" alt="image-20220625184745056" style="zoom: 77%;" /><p><strong>第一种使用例</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625184927353.png" alt="image-20220625184927353" style="zoom:80%;" /><p><strong>第二种翻译方法</strong></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625185034919.png" alt="image-20220625185034919" style="zoom:80%;" /><br><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625185056071.png" alt="image-20220625185056071" style="zoom:80%;" /></p><p><strong>第二种使用例</strong></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625185240724.png" alt="image-20220625185240724" style="zoom:80%;" /><br><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625185305176.png" alt="image-20220625185305176" style="zoom:80%;" /><br><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625185319542.png" alt="image-20220625185319542" style="zoom:80%;" /></p><h3 id="for-循环"><a class="markdownIt-Anchor" href="#for-循环"></a> <code>for</code> 循环</h3><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625185948500.png" alt="image-20220625185948500" style="zoom:80%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625190037921.png" alt="image-20220625190037921" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深入理解计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《深入理解计算机系统》 第二章 学习笔记</title>
      <link href="/posts/c0ead3b585d4/"/>
      <url>/posts/c0ead3b585d4/</url>
      
        <content type="html"><![CDATA[<h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li>《深入理解计算机操作系统》</li><li><a href="https://space.bilibili.com/354767108">九曲阑干</a> 大佬的一系列视频<ul><li><a href="https://www.bilibili.com/video/BV1tV411U7N3">【CSAPP-深入理解计算机系统】2-1.信息的存储(上)_哔哩哔哩_bilibili</a></li><li>…</li></ul></li></ul><h1 id="信息存储"><a class="markdownIt-Anchor" href="#信息存储"></a> 信息存储</h1><h2 id="系统程序向后兼容"><a class="markdownIt-Anchor" href="#系统程序向后兼容"></a> 系统程序向后兼容</h2><ul><li>64位系统可以生成并使用32位程序。</li><li>32位系统无法使用64位程序。</li></ul><h2 id="c语言中数据类型所占用的字节数"><a class="markdownIt-Anchor" href="#c语言中数据类型所占用的字节数"></a> C语言中数据类型所占用的字节数</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614091625732.png" alt="image" style="zoom: 40%;" /><p>注意：</p><ol><li><code>long</code> 数据类型的取值范围与机器字长相关。</li></ol><h2 id="数据在内存中的存储顺序"><a class="markdownIt-Anchor" href="#数据在内存中的存储顺序"></a> 数据在内存中的存储顺序</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614091915842.png" alt="image" style="zoom: 67%;" /><ul><li>图中左边为低有效字节，右边为高有效字节。</li><li>大多数 Intel 兼容机、Linux、Android、IOS 都是采用小端模式。</li><li>IBM 和 SUN 公司的大多数机器都是采用的大端模式。</li><li>基于 ARM 架构的处理器则支持双端法，即同时支持上述两个模式。</li></ul><h2 id="布尔运算"><a class="markdownIt-Anchor" href="#布尔运算"></a> 布尔运算</h2><table><thead><tr><th>操作</th><th>符号</th></tr></thead><tbody><tr><td>与</td><td>AND</td></tr><tr><td>或</td><td>OR</td></tr><tr><td>非</td><td>NOT</td></tr><tr><td>异或</td><td>XOR</td></tr></tbody></table><h2 id="掩码"><a class="markdownIt-Anchor" href="#掩码"></a> 掩码</h2><p>掩码是一串二进制代码。对目标字段进行位与运算，从而屏蔽当前的输入位。</p><h2 id="逻辑运算"><a class="markdownIt-Anchor" href="#逻辑运算"></a> 逻辑运算</h2><table><thead><tr><th>操作</th><th>符号</th></tr></thead><tbody><tr><td>与</td><td>AND</td></tr><tr><td>或</td><td>OR</td></tr><tr><td>非</td><td>NOT</td></tr></tbody></table><p>注意：</p><ol><li>逻辑运算的结果只有 true 和 false。</li></ol><h2 id="位移运算"><a class="markdownIt-Anchor" href="#位移运算"></a> 位移运算</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614102822234.png" alt="image" style="zoom: 67%;" /><p>注意：</p><ol><li><p>算术右移高位填充的是原来数字的符号位。</p></li><li><p>几乎所有的编译器以及及其的组合都是对有符号数使用算术右移。</p></li></ol><h1 id="整数表示"><a class="markdownIt-Anchor" href="#整数表示"></a> 整数表示</h1><h2 id="无符号数编码"><a class="markdownIt-Anchor" href="#无符号数编码"></a> 无符号数编码</h2><p>无符号数只能表示非负数。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614103830722.png" alt="image" style="zoom:67%;" /><p>B2U：Binary to unsigned。</p><p>下图为无符号数的图形化表示。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614104406695.png" alt="image" style="zoom:40%;" /><h2 id="负数的编码补码"><a class="markdownIt-Anchor" href="#负数的编码补码"></a> 负数的编码（补码）</h2><p>计算机系统中存储负数基本采用补码的形式。<strong>补码 = 反码 + 1。</strong></p><p>     <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614105129560.png" alt="image" style="zoom:53%;" />    <center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614105643185.png" alt="image" style="zoom:40%;" /></center></p><p>需要注意的是最高位的权重为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><msup><mn>2</mn><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">-2^{w-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 。当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_{w-1} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，表示非负数；当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x_{w-1} = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，表示负数。</p><p>不能仅仅把最高位当成符号位看待，我们需要着重理解 <strong>负权重</strong> 的概念。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614105801516.png" alt="image" style="zoom:50%;" /><p>下图为图形化表示法，可以更加清晰的看到补码的计算过程。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614110234849.png" alt="image" style="zoom:40%;" /><p>注意：</p><ol><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 的补码和无符号数的最大数有着相同的表示形式。</li><li>对于相同的位模式，映射函数的不同，得到的数值也会不同。</li></ol><h2 id="有符号数转换为无符号数"><a class="markdownIt-Anchor" href="#有符号数转换为无符号数"></a> 有符号数转换为无符号数</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614112013343.png" alt="image-20220614" style="zoom:40%;" /><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 表示有符号数的二进制位数。</p><h2 id="无符号数转换为有符号数"><a class="markdownIt-Anchor" href="#无符号数转换为有符号数"></a> 无符号数转换为有符号数</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614112202660.png" alt="image-20220614" style="zoom:40%;" /><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 表示无符号数的二进制位数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mtext> </mtext><mi>M</mi><mi>a</mi><msub><mi>x</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">T \space Max_{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示有符号数的最大值。</p><h2 id="强制类型转换"><a class="markdownIt-Anchor" href="#强制类型转换"></a> 强制类型转换</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/usual_arithmetic_conversion.png" alt="Usual Arithmetic Conversion" style="zoom:80%;" /><h1 id="整数运算"><a class="markdownIt-Anchor" href="#整数运算"></a> 整数运算</h1><h2 id="加法运算"><a class="markdownIt-Anchor" href="#加法运算"></a> 加法运算</h2><h3 id="无符号数加法"><a class="markdownIt-Anchor" href="#无符号数加法"></a> 无符号数加法</h3><p>例如，两个 <code>unsigned char</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>127</mn><mi mathvariant="normal">、</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">127、1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span><span class="mord cjk_fallback">、</span><span class="mord">1</span></span></span></span> 相加，得到的结果不为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>128</mn></mrow><annotation encoding="application/x-tex">128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span> ，而是为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p><p>我们定义符号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>+</mo><mi>w</mi><mi>u</mi></msubsup><mi>y</mi></mrow><annotation encoding="application/x-tex">+^u_{w}y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.911392em;vertical-align:-0.247em;"></span><span class="mord"><span class="mbin">+</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 表示 <code>unsigned</code> 类型、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位的整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619194945095.png" alt="image-20220619" style="zoom: 60%;" /><p>通过程序判定是否溢出：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619195136224.png" alt="image-20220619" style="zoom:60%;" /><h3 id="有符号数加法"><a class="markdownIt-Anchor" href="#有符号数加法"></a> 有符号数加法</h3><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619195234384.png" alt="image-20220619" style="zoom:50%;" /><p>判断是否发生了溢出：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619195512632.png" alt="image" style="zoom:50%;" /><h2 id="减法运算"><a class="markdownIt-Anchor" href="#减法运算"></a> 减法运算</h2><p>减法操作在计算机中通过使用 <strong>加法逆元</strong> 实现。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619200901107.png" alt="image-20220619200901107" style="zoom:57%;" /><p>在上图中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">x&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的加法逆元，其中满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x + x&#x27; = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p><h3 id="无符号数减法"><a class="markdownIt-Anchor" href="#无符号数减法"></a> 无符号数减法</h3><p>无符号数的加法逆元为：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619201018960.png" alt="image-20220619201018960" style="zoom:67%;" /><p>由于无符号数中没有负数，我们通过溢出的方式使得两个无符号数相加和为 0。</p><h3 id="有符号数减法"><a class="markdownIt-Anchor" href="#有符号数减法"></a> 有符号数减法</h3><p>有符号数的加法逆元如下图：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619201235671.png" alt="image-20220619201235671" style="zoom:57%;" /><p>注意，有符号数的正负数表示范围并非对称，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>T</mi><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>T</mi><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>w</mi></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|T min_w|=|T max_w| + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，所以对最小值进行单独计算，得出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>T</mi><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>w</mi></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∣</mi><mi>T</mi><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">-(|T max_w| + 1) = |T min_w|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span> ，即最小值的加法逆元为其本身。</p><h2 id="乘法运算"><a class="markdownIt-Anchor" href="#乘法运算"></a> 乘法运算</h2><p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位的无符号数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，两者的乘积可能需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>w</mi></mrow><annotation encoding="application/x-tex">2w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位来表示。在 C 语言中，定义了无符号数乘法所产生的结果为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位，所以运行结果会截取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>w</mi></mrow><annotation encoding="application/x-tex">2w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 中的低 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619202338552.png" alt="image-20220619202324281" style="zoom:60%;" />]]></content>
      
      
      <categories>
          
          <category> 计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深入理解计算机系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Microsoft Word 使用自定义论文样式集</title>
      <link href="/posts/9fff5beeee26/"/>
      <url>/posts/9fff5beeee26/</url>
      
        <content type="html"><![CDATA[<blockquote><ol><li>本文仅提供设置方法，每一项的具体的字体字号根据学校的要求请另行更改。</li><li>本文将修改部分源文件，请<strong>及时备份相关文件</strong> 。</li></ol></blockquote><h1 id="效果"><a class="markdownIt-Anchor" href="#效果"></a> 效果</h1><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220609083109777.png" alt="image" style="zoom: 67%;" /><h1 id="样式设置方法"><a class="markdownIt-Anchor" href="#样式设置方法"></a> 样式设置方法</h1><h2 id="打开设置文件必做"><a class="markdownIt-Anchor" href="#打开设置文件必做"></a> 打开设置文件(必做)</h2><blockquote><p><strong>注意及时备份源文件!</strong></p></blockquote><ol><li><p>进入以下目录文件夹：<code>C:\Users\XXX\AppData\Roaming\Microsoft\Templates</code>。</p><p>如果 Microsoft Word 被安装在其他路径，请自行寻找。</p></li><li><p>打开其中的<code>Normal.dotm</code>文件。</p></li><li><p><strong>删除样式栏中所有已存在的样式。</strong></p></li></ol><h2 id="更改正文样式"><a class="markdownIt-Anchor" href="#更改正文样式"></a> 更改正文样式</h2><p>待添加…</p><h2 id="更改标题样式"><a class="markdownIt-Anchor" href="#更改标题样式"></a> 更改标题样式</h2><p>待添加…</p><h2 id="更改表格样式"><a class="markdownIt-Anchor" href="#更改表格样式"></a> 更改表格样式</h2><p>待添加…</p><h2 id="添加标题序号"><a class="markdownIt-Anchor" href="#添加标题序号"></a> 添加标题序号</h2><p>待添加…</p><h2 id="添加自定义题注"><a class="markdownIt-Anchor" href="#添加自定义题注"></a> 添加自定义题注</h2><p>待添加…</p><h1 id="其他-word-使用技巧"><a class="markdownIt-Anchor" href="#其他-word-使用技巧"></a> 其他 Word 使用技巧</h1><h2 id="页码设置"><a class="markdownIt-Anchor" href="#页码设置"></a> 页码设置</h2><p>待添加…</p><h2 id="去除标题前的小黑点"><a class="markdownIt-Anchor" href="#去除标题前的小黑点"></a> 去除标题前的小黑点</h2><p>我们以下图 <strong>标题3</strong> 前的小黑点为例：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220613184750085.png" alt="image" style="zoom: 80%;" /><ol><li><p>右击样式栏中对应的样式。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220613184856465.png" alt="image" style="zoom:67%;" /></li><li><p>依次选择：</p><p><strong>修改 &gt;&gt; 格式 &gt;&gt; 段落 &gt;&gt; 换行和分页</strong></p><p>进入下图中页面。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220613185044904.png" alt="image" style="zoom:67%;" /></li><li><p>将上图中的 <strong>与下段相同</strong> 和 <strong>段中不分页</strong> 前面的两个对号取消。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220613185210761.png" alt="image" style="zoom: 67%;" /></li><li><p>依次点击：</p><p><strong>确认 &gt;&gt; 确认</strong></p><p>返回文档编辑页面，即可发现 <strong>标题3</strong> 前面的小黑点已经消失了。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220613185459976.png" alt="image" style="zoom:80%;" /></li></ol><h1 id="如何将设置好的样式分享"><a class="markdownIt-Anchor" href="#如何将设置好的样式分享"></a> 如何将设置好的样式分享</h1><ol><li>发送该<code>Normal.dotm</code>文件到接收方。</li><li>在接收方的电脑上替换该文件。</li><li>重启 Microsoft Word，新建文档即可使用。</li></ol><h1 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h1><ol><li><p>已经创建的文档内的样式无法自动更改。</p><p>可以通过新建文档并复制原文档中的内容获取论文样式集。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Microsoft Applications </category>
          
          <category> Windows OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Microsoft Office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Butterfly 修改侧边栏分类排序规则</title>
      <link href="/posts/bd6604dc1b1f/"/>
      <url>/posts/bd6604dc1b1f/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1><p><code>Hexo Butterfly</code> 主题中，主页侧边栏中的 <code>categories</code> 默认显示顺序是按 <code>name</code> 排序，导致某些分类下虽然文章数量较少，但却排序靠前。并且默认设置下，主题中侧边 <code>categories</code> 只显示8条（如需修改可以修改<strong>主题配置文件</strong>）。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220608210201564.png" alt="image" style="zoom:67%;" /><p>便想将其修改为 <strong>按照分类内文章的数量进行降序排序</strong> 。</p><h1 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h1><blockquote><p>该方法需要修改源代码，建议及时备份需要修改的文件。</p></blockquote><ol><li><p>找到 <code>themes\butterfly\scripts\helpers\aside_categories.js</code> 文件，并修改源代码。</p></li><li><p>修改以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const orderby = options.orderby || &#x27;name&#x27; // 默认-&gt;name-&gt;按categories字母顺序</span></span><br><span class="line"><span class="keyword">const</span> orderby = options.<span class="property">orderby</span> || <span class="string">&#x27;length&#x27;</span>  <span class="comment">// length-&gt;按categories下文章数量排序</span></span><br><span class="line"><span class="comment">// const order = options.order || 1  // 默认-&gt;1-&gt;升序 -1-&gt;逆序</span></span><br><span class="line"><span class="keyword">const</span> order = options.<span class="property">order</span> || -<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>执行 <code>hexo g &amp;&amp; hexo d</code> 查看修改效果。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220608205749969.png" alt="image" style="zoom: 67%;" /></li></ol><h1 id="参考教程"><a class="markdownIt-Anchor" href="#参考教程"></a> 参考教程</h1><ul><li><a href="https://www.yanchengxu.top/hexo-categories-sort/">【Hexo-Butterfly】修改侧边栏分类排序规则 | yanchengxu</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Butterfly 字体修改</title>
      <link href="/posts/01f186841de9/"/>
      <url>/posts/01f186841de9/</url>
      
        <content type="html"><![CDATA[<h1 id="准备字体"><a class="markdownIt-Anchor" href="#准备字体"></a> 准备字体</h1><blockquote><p>注意字体的版权！</p></blockquote><p>自行下载需要的字体。</p><p>本文使用的是 <code>Intellij IDEA</code> 文件中的 <code>JetBrainsMono-Regular.ttf</code>。</p><p>在 <code>themes/butterfly/source/</code> 下创建 <code>font</code> 文件夹，将下载好的字体放入 <code>font</code> 文件夹中。</p><p>其中，<code>Hexo Butterfly</code> 已默认支持 <strong><code>Microsoft YaHei</code></strong> ，无需另行下载。</p><h1 id="创建-css-文件"><a class="markdownIt-Anchor" href="#创建-css-文件"></a> 创建 <code>CSS</code> 文件</h1><p>在<code>themes/butterfly/source/css/</code>下创建<code>article-font.css</code> 并编辑该文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;JetBrainsMono&#x27;</span>;</span><br><span class="line">    <span class="attribute">font-display</span>: swap;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;../font/JetBrainsMono-Regular.ttf&#x27;</span>) <span class="built_in">format</span>(<span class="string">&quot;truetype&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将所有非代码部分的文字更改为自定义字体 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;JetBrainsMono&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 仅将博客正文中的非代码部分的文字更改为自定义字体 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#article-container &#123;</span></span><br><span class="line"><span class="comment">    font-family: &#x27;JetBrainsMono&#x27;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>第一段代码必须写入 <code>CSS</code> 文件中。</p><ul><li><strong><code>font-family</code> ：</strong> 其他文件引用该字体的名称，更改为自己所需的名称。</li><li><strong><code>src: url()</code> ：</strong> 更改为自己准备的字体的路径。</li></ul><p>第二段和第三段代码根据自己所需的改变范围自行选择其中一个。其中第二段代码改变的范围为所有页面的所有非代码部分的文字。</p><h1 id="引入-css-文件"><a class="markdownIt-Anchor" href="#引入-css-文件"></a> 引入 <code>CSS</code> 文件</h1><p>编辑 <code>_config.butterfly.yml</code>，引入 <code>article-font.css</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class="line"><span class="comment"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/article-font.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>修改完成后，重新 <code>generate</code> 便可修改非代码部分的文字的字体了。</p><h1 id="改变代码部分的文字字体可选"><a class="markdownIt-Anchor" href="#改变代码部分的文字字体可选"></a> 改变代码部分的文字字体（可选）</h1><p>若需修改代码部分的文字的字体，编辑 <code>_config.butterfly.yml</code>，找到以下代码并将 <code>font-family</code> 中定义的名称加入<code>code-font-family</code>，重新<code>generate</code>即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global font settings</span></span><br><span class="line"><span class="comment"># Don&#x27;t modify the following settings unless you know how they work (非必要不要修改)</span></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">global-font-size:</span></span><br><span class="line">  <span class="attr">code-font-size:</span></span><br><span class="line">  <span class="attr">font-family:</span></span><br><span class="line">  <span class="attr">code-font-family:</span> <span class="string">JetBrainsMono</span></span><br></pre></td></tr></table></figure><h1 id="参考博客"><a class="markdownIt-Anchor" href="#参考博客"></a> 参考博客</h1><ul><li><a href="https://www.yanchengxu.top/hexo-font-modification/">【Hexo-Butterfly】字体修改 | yanchengxu</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo 问题解决记录</title>
      <link href="/posts/052b259f25f7/"/>
      <url>/posts/052b259f25f7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>更多 FAQ 请查看官方文档：</p><ul><li><a href="https://github.com/Molunerfinn/PicGo/blob/dev/FAQ.md">PicGo/FAQ.md at dev · Molunerfinn/PicGo (github.com)</a></li><li><a href="https://github.com/Molunerfinn/PicGo/issues">Issues · Molunerfinn/PicGo (github.com)</a></li></ul></blockquote><h1 id="相册突然无法显示图片或者上传后相册不更新"><a class="markdownIt-Anchor" href="#相册突然无法显示图片或者上传后相册不更新"></a> 相册突然无法显示图片或者上传后相册不更新</h1><p>这个原因可能是相册存储文件损坏导致的。可以找到 PicGo 配置文件所在路径下的 <code>picgo.db</code> ，将其删掉（删掉前建议备份一遍），再重启 PicGo 试试。 注意同时看看日志文件里有没有什么error，必要时可以提issue。</p><h1 id="github-图床有时能上传有时上传失败"><a class="markdownIt-Anchor" href="#github-图床有时能上传有时上传失败"></a> GitHub 图床有时能上传，有时上传失败</h1><ol><li>GitHub 图床不支持上传同名文件，如果有同名文件上传，会报错。建议开启 <code>时间戳重命名</code> 避免同名文件。</li><li>GitHub 服务器和国内 GFW 的问题会导致有时上传成功，有时上传失败，无解。想要稳定请使用付费云存储，如阿里云、腾讯云等，价格也不会贵。</li></ol><h1 id="上传失败或者是服务器出错"><a class="markdownIt-Anchor" href="#上传失败或者是服务器出错"></a> 上传失败，或者是服务器出错</h1><ol><li>PicGo 自带的图床都经过测试，上传出错一般都不是 PicGo 自身的原因。如果你用的是 GitHub 图床请参考上面的问题。</li><li>检查 PicGo 的日志（报错日志可以在 PicGo 设置 -&gt; 设置日志文件 -&gt; 点击打开 后找到），看看 <code>[PicGo Error]</code> 的报错信息里有什么关键信息<ol><li>先自行搜索 error 里的报错信息，往往你能百度或者谷歌出问题原因，不必开 issue。</li><li>如果有带有 <code>401</code> 、<code>403</code> 等 <code>40X</code> 状态码字样的，不用怀疑，就是你配置写错了，仔细检查配置，看看是否多了空格之类的。</li><li>如果带有 <code>HttpError</code>、<code>RequestError</code> 、 <code>socket hang up</code> 等字样的说明这是网络问题，我无法帮你解决网络问题，请检查你自己的网络，是否有代理，DNS 设置是否正常等。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> PicGo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PicGo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 - Android校招面试整理2022</title>
      <link href="/posts/a00ca8ffea9b/"/>
      <url>/posts/a00ca8ffea9b/</url>
      
        <content type="html"><![CDATA[<blockquote><p>答案参考自：</p><ul><li><a href="http://www.cyc2018.xyz/">CS-Notes (cyc2018.xyz)</a></li></ul></blockquote><h1 id="主机之间的通信方式"><a class="markdownIt-Anchor" href="#主机之间的通信方式"></a> 主机之间的通信方式</h1><ul><li>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/914894c2-0bc4-46b5-bef9-0316a69ef521.jpg" alt="img" style="zoom: 67%;" /><ul><li>对等（P2P）：不区分客户和服务器。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/42430e94-3137-48c0-bdb6-3cebaf9102e3.jpg" alt="img" style="zoom: 67%;" /><h1 id="计算机网络体系结构"><a class="markdownIt-Anchor" href="#计算机网络体系结构"></a> 计算机网络体系结构</h1><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" alt="img" style="zoom: 67%;" /><h2 id="五层协议"><a class="markdownIt-Anchor" href="#五层协议"></a> 五层协议</h2><ul><li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</li><li><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：<strong>传输控制协议 TCP</strong> ，提供面向连接、可靠的数据传输服务，数据单位为报文段：<strong>用户数据报协议 UDP</strong> ，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li><li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><h2 id="osi"><a class="markdownIt-Anchor" href="#osi"></a> OSI</h2><p>其中表示层和会话层用途如下：</p><ul><li><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li><li><strong>会话层</strong> ：建立及管理会话。</li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><h2 id="tcpip"><a class="markdownIt-Anchor" href="#tcpip"></a> TCP/IP</h2><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/48d79be8-085b-4862-8a9d-18402eb93b31.png" alt="img" style="zoom:67%;" /><h2 id="数据在各层之间的传递过程"><a class="markdownIt-Anchor" href="#数据在各层之间的传递过程"></a> 数据在各层之间的传递过程</h2><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p><h1 id="物理层"><a class="markdownIt-Anchor" href="#物理层"></a> 物理层</h1><h2 id="通信方式"><a class="markdownIt-Anchor" href="#通信方式"></a> 通信方式</h2><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h1 id="数据链路层"><a class="markdownIt-Anchor" href="#数据链路层"></a> 数据链路层</h1><h2 id="封装成帧"><a class="markdownIt-Anchor" href="#封装成帧"></a> 封装成帧</h2><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/29a14735-e154-4f60-9a04-c9628e5d09f4.png" alt="img" style="zoom:67%;" /><h2 id="透明传输"><a class="markdownIt-Anchor" href="#透明传输"></a> 透明传输</h2><p>透明表示一个实际存在的事物看起来好像不存在一样。</p><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/e738a3d2-f42e-4755-ae13-ca23497e7a97.png" alt="img" style="zoom: 50%;" /><h2 id="差错检测"><a class="markdownIt-Anchor" href="#差错检测"></a> 差错检测</h2><p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p><h2 id="信道分类"><a class="markdownIt-Anchor" href="#信道分类"></a> 信道分类</h2><h3 id="广播信道"><a class="markdownIt-Anchor" href="#广播信道"></a> 广播信道</h3><p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p><h3 id="点对点信道"><a class="markdownIt-Anchor" href="#点对点信道"></a> 点对点信道</h3><p>一对一通信。</p><p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p><h2 id="信道复用技术"><a class="markdownIt-Anchor" href="#信道复用技术"></a> 信道复用技术</h2><h3 id="频分复用"><a class="markdownIt-Anchor" href="#频分复用"></a> 频分复用</h3><p>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/4aa5e057-bc57-4719-ab57-c6fbc861c505.png" alt="img" style="zoom:50%;" /><h3 id="时分复用"><a class="markdownIt-Anchor" href="#时分复用"></a> 时分复用</h3><p>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/67582ade-d44a-46a6-8757-3c1296cc1ef9.png" alt="img" style="zoom:50%;" /><p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，<strong>因此这两种方式对信道的利用率都不高</strong> 。</p><h3 id="统计时分复用"><a class="markdownIt-Anchor" href="#统计时分复用"></a> 统计时分复用</h3><p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/6283be2a-814a-4a10-84bf-9592533fe6bc.png" alt="img" style="zoom:50%;" /><h3 id="波分复用"><a class="markdownIt-Anchor" href="#波分复用"></a> 波分复用</h3><p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p><h3 id="码分复用"><a class="markdownIt-Anchor" href="#码分复用"></a> 码分复用</h3><h1 id="网络层"><a class="markdownIt-Anchor" href="#网络层"></a> 网络层</h1><p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><h2 id="ip-数据报格式"><a class="markdownIt-Anchor" href="#ip-数据报格式"></a> IP 数据报格式</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" alt="img" style="zoom: 67%;" /><ul><li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li><li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li><li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li><li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li></ul><h1 id="传输层"><a class="markdownIt-Anchor" href="#传输层"></a> 传输层</h1><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。</p><h2 id="udp-和-tcp-的特点"><a class="markdownIt-Anchor" href="#udp-和-tcp-的特点"></a> UDP 和 TCP 的特点</h2><ul><li><strong>用户数据报协议 UDP（User Datagram Protocol）</strong> 是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），<strong>支持一对一、一对多、多对一和多对多的交互通信</strong> 。</li><li><strong>传输控制协议 TCP（Transmission Control Protocol）</strong> 是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），<strong>每一条 TCP 连接只能是点对点的（一对一）</strong> 。</li></ul><h2 id="udp-首部格式"><a class="markdownIt-Anchor" href="#udp-首部格式"></a> UDP 首部格式</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" alt="img" style="zoom: 50%;" /><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><h2 id="tcp-首部格式"><a class="markdownIt-Anchor" href="#tcp-首部格式"></a> TCP 首部格式</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" alt="img" style="zoom: 50%;" /><ul><li><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li><li><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li><li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li><li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li><li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ul><h2 id="tcp-的三次握手"><a class="markdownIt-Anchor" href="#tcp-的三次握手"></a> TCP 的三次握手</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="img" style="zoom: 50%;" /><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20191129144820655.png" alt="TCP三次握手" style="zoom:80%;" /><p><strong>三次握手的原因</strong></p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><p><strong>为什么不能只 进行两次挥手</strong></p><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/lengxiao1993/article/details/82771768">TCP 为什么三次握手而不是两次握手（正解版）_萧萧九宸的博客-CSDN博客_tcp为什么是三次握手不是两次握手</a></li></ul></blockquote><ul><li><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。</p></li><li><p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。少了第三次，服务端就没法确认客户端有没有收到数据包。</p></li></ul><h2 id="tcp-的四次挥手"><a class="markdownIt-Anchor" href="#tcp-的四次挥手"></a> TCP 的四次挥手</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="img" style="zoom: 67%;" /><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><p><strong>四次挥手的原因</strong></p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong></p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><p><strong>为什么不能是三次挥手?</strong></p><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/King___Ding/article/details/114873506">TCP 四次挥手的过程，为什么是四次挥手而不是三次_King-Ding的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/bytebai/article/details/22191677">TCP：半关闭_ByteBai的博客-CSDN博客_tcp 半关闭</a></li></ul></blockquote><p>因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。</p><p>如果是三次挥手会有什么问题？</p><p>等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。 不断的进行数据包重发。</p><blockquote><p>TODO : 客户端处于半关闭状态时能够主动发出消息？如不能，如何回复第三次FIN消息？</p></blockquote><h2 id="tcp-可靠传输"><a class="markdownIt-Anchor" href="#tcp-可靠传输"></a> TCP 可靠传输</h2><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><h2 id="tcp-滑动窗口"><a class="markdownIt-Anchor" href="#tcp-滑动窗口"></a> TCP 滑动窗口</h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" alt="img" style="zoom: 67%;" /><h2 id="tcp-流量控制"><a class="markdownIt-Anchor" href="#tcp-流量控制"></a> TCP 流量控制</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h1 id="http"><a class="markdownIt-Anchor" href="#http"></a> HTTP</h1><h2 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念"></a> 基础概念</h2><h3 id="请求和响应报文"><a class="markdownIt-Anchor" href="#请求和响应报文"></a> 请求和响应报文</h3><p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。</p><p>请求报文结构：</p><ul><li>第一行是包含了请求方法、URL、协议版本；</li><li>接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。</li><li>一个空行用来分隔首部和内容主体 Body</li><li>最后是请求的内容主体</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">http://www.example.com/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=0</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">If-Modified-Since</span><span class="punctuation">: </span>Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line"><span class="attribute">If-None-Match</span><span class="punctuation">: </span>&quot;3147526947+gzip&quot;</span><br><span class="line"><span class="attribute">Proxy-Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 xxx</span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">param1</span>=<span class="number">1</span>&amp;param2=<span class="number">2</span></span></span><br></pre></td></tr></table></figure><p>响应报文结构：</p><ul><li>第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了</li><li>接下来多行也是首部内容</li><li>一个空行分隔首部和内容主体</li><li>最后是响应的内容主体</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Age</span><span class="punctuation">: </span>529651</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=604800</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>648</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=UTF-8</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 02 Nov 2020 17:53:39 GMT</span><br><span class="line"><span class="attribute">Etag</span><span class="punctuation">: </span>&quot;3147526947+ident+gzip&quot;</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Mon, 09 Nov 2020 17:53:39 GMT</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>timeout=4</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line"><span class="attribute">Proxy-Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>ECS (sjc/16DF)</span><br><span class="line"><span class="attribute">Vary</span><span class="punctuation">: </span>Accept-Encoding</span><br><span class="line"><span class="attribute">X-Cache</span><span class="punctuation">: </span>HIT</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example Domain<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">// 省略... </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="url"><a class="markdownIt-Anchor" href="#url"></a> URL</h3><p>HTTP 使用 URL（ <strong>U</strong> niform <strong>R</strong>esource <strong>L</strong>ocator，统一资源定位符）来定位资源，它是 URI（<strong>U</strong>niform <strong>R</strong>esource <strong>I</strong>dentifier，统一资源标识符）的子集，URL 在 URI 的基础上增加了定位能力。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png" alt="img" style="zoom: 67%;" /><h2 id="http-方法"><a class="markdownIt-Anchor" href="#http-方法"></a> HTTP 方法</h2><h3 id="get"><a class="markdownIt-Anchor" href="#get"></a> GET</h3><blockquote><p>获取资源</p></blockquote><p>当前网络请求中，绝大部分使用的是 GET 方法。</p><h3 id="post"><a class="markdownIt-Anchor" href="#post"></a> POST</h3><blockquote><p>传输实体主体</p></blockquote><p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p><h3 id="put"><a class="markdownIt-Anchor" href="#put"></a> PUT</h3><blockquote><p>上传文件</p></blockquote><p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p><h3 id="delete"><a class="markdownIt-Anchor" href="#delete"></a> DELETE</h3><blockquote><p>删除文件</p></blockquote><p>与 PUT 功能相反，并且同样不带验证机制。</p><h2 id="http-状态码"><a class="markdownIt-Anchor" href="#http-状态码"></a> HTTP 状态码</h2><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">类别</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">1XX</td><td style="text-align:center">Informational（信息性状态码）</td><td style="text-align:center">接收的请求正在处理</td></tr><tr><td style="text-align:center">2XX</td><td style="text-align:center">Success（成功状态码）</td><td style="text-align:center">请求正常处理完毕</td></tr><tr><td style="text-align:center">3XX</td><td style="text-align:center">Redirection（重定向状态码）</td><td style="text-align:center">需要进行附加操作以完成请求</td></tr><tr><td style="text-align:center">4XX</td><td style="text-align:center">Client Error（客户端错误状态码）</td><td style="text-align:center">服务器无法处理请求</td></tr><tr><td style="text-align:center">5XX</td><td style="text-align:center">Server Error（服务器错误状态码）</td><td style="text-align:center">服务器处理请求出错</td></tr></tbody></table><h3 id="1xx-信息"><a class="markdownIt-Anchor" href="#1xx-信息"></a> 1XX 信息</h3><ul><li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><h3 id="2xx-成功"><a class="markdownIt-Anchor" href="#2xx-成功"></a> 2XX 成功</h3><ul><li><strong>200 OK</strong></li></ul><h3 id="3xx-重定向"><a class="markdownIt-Anchor" href="#3xx-重定向"></a> 3XX 重定向</h3><ul><li><strong>301 Moved Permanently</strong> ：永久性重定向</li><li><strong>302 Found</strong> ：临时性重定向</li></ul><h3 id="4xx-客户端错误"><a class="markdownIt-Anchor" href="#4xx-客户端错误"></a> 4XX 客户端错误</h3><ul><li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li><li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden</strong> ：请求被拒绝。</li><li><strong>404 Not Found</strong></li></ul><h3 id="5xx-服务器错误"><a class="markdownIt-Anchor" href="#5xx-服务器错误"></a> 5XX 服务器错误</h3><ul><li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li></ul><h2 id="连接管理"><a class="markdownIt-Anchor" href="#连接管理"></a> 连接管理</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/HTTP1_x_Connections.png" alt="img" style="zoom:67%;" /><h3 id="短连接与长连接"><a class="markdownIt-Anchor" href="#短连接与长连接"></a> 短连接与长连接</h3><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p><p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p><ul><li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li><li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li></ul><h3 id="流水线"><a class="markdownIt-Anchor" href="#流水线"></a> 流水线</h3><p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p><p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p><h2 id="cookie"><a class="markdownIt-Anchor" href="#cookie"></a> Cookie</h2><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><h3 id="用途"><a class="markdownIt-Anchor" href="#用途"></a> 用途</h3><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h3 id="创建过程"><a class="markdownIt-Anchor" href="#创建过程"></a> 创建过程</h3><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><h2 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h2><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><ul><li>缓解服务器压力；</li><li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li></ul><h3 id="实现方法"><a class="markdownIt-Anchor" href="#实现方法"></a> 实现方法</h3><ul><li>让代理服务器进行缓存；</li><li>让客户端浏览器进行缓存。</li></ul><h3 id="cache-control"><a class="markdownIt-Anchor" href="#cache-control"></a> Cache-Control</h3><p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p><h2 id="通信数据转发"><a class="markdownIt-Anchor" href="#通信数据转发"></a> 通信数据转发</h2><h3 id="代理"><a class="markdownIt-Anchor" href="#代理"></a> 代理</h3><p>代理服务器接受客户端的请求，并且转发给其它服务器。</p><h3 id="网关"><a class="markdownIt-Anchor" href="#网关"></a> 网关</h3><p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。</p><h3 id="隧道"><a class="markdownIt-Anchor" href="#隧道"></a> 隧道</h3><p>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</p><h2 id="http-的安全性问题"><a class="markdownIt-Anchor" href="#http-的安全性问题"></a> HTTP  的安全性问题</h2><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><h1 id="https"><a class="markdownIt-Anchor" href="#https"></a> HTTPS</h1><p>HTTP 有以下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p><p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ssl-offloading.jpg" alt="img" style="zoom:67%;" /><h2 id="加密"><a class="markdownIt-Anchor" href="#加密"></a> 加密</h2><h3 id="对称密钥加密"><a class="markdownIt-Anchor" href="#对称密钥加密"></a> 对称密钥加密</h3><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p><ul><li>优点：运算速度快；</li><li>缺点：无法安全地将密钥传输给通信方。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png" alt="img" style="zoom:67%;" /><h3 id="非对称密钥加密"><a class="markdownIt-Anchor" href="#非对称密钥加密"></a> 非对称密钥加密</h3><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p><p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p><ul><li>优点：可以更安全地将公开密钥传输给通信发送方；</li><li>缺点：运算速度慢。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png" alt="img" style="zoom: 67%;" /><h3 id="https-采用的加密方式"><a class="markdownIt-Anchor" href="#https-采用的加密方式"></a> HTTPS 采用的加密方式</h3><p>上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：</p><ul><li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;</li><li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/How-HTTPS-Works.png" alt="img" style="zoom: 33%;" /><h2 id="https-的缺点"><a class="markdownIt-Anchor" href="#https-的缺点"></a> HTTPS 的缺点</h2><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高额费用。</li></ul><h1 id="从-url-输入到页面展现到底发生什么"><a class="markdownIt-Anchor" href="#从-url-输入到页面展现到底发生什么"></a> 从 URL 输入到页面展现到底发生什么？</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/57895541">经典面试题：从 URL 输入到页面展现到底发生什么？ - 知乎 (zhihu.com)</a></li></ul></blockquote><p>总体来说分为以下几个过程:</p><ol><li><p>DNS 解析:将域名解析成 IP 地址</p></li><li><p>TCP 连接：TCP 三次握手</p></li><li><p>发送 HTTP 请求</p></li><li><p>服务器处理请求并返回 HTTP 报文</p></li><li><p>浏览器解析渲染页面</p></li><li><p>断开连接：TCP 四次挥手</p></li></ol><p><strong><font size="5">DNS解析</font></strong></p><p>在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。</p><p><strong><font size="4">IP地址</font></strong></p><p>IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址是一个 32 位的二进制数，比如 127.0.0.1 为本机 IP。</p><p><strong><font size="4">域名解析</font></strong></p><p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。</p><p><strong><font size="4">浏览器如何通过域名去查询 URL 对应的 IP 呢</font></strong></p><ul><li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li><li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。</li><li>路由缓存：路由器也有 DNS 缓存。</li><li>ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li><li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS <a href="http://xn--44qr6aba96ld4eda63xey2cfa111ap36q.com">服务器先问根域名服务器.com</a> 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）</li></ul><p><strong><font size="4">小结</font></strong></p><p>浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息、关闭 TCP 连接。</p>]]></content>
      
      
      <categories>
          
          <category> 2022校招面试整理 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 美化教程 博客整理</title>
      <link href="/posts/07af833ec811/"/>
      <url>/posts/07af833ec811/</url>
      
        <content type="html"><![CDATA[<blockquote><p><em>本文持续更新中~</em></p></blockquote><h1 id="字体更改"><a class="markdownIt-Anchor" href="#字体更改"></a> 字体更改</h1><ul><li><a href="https://www.yanchengxu.top/hexo-font-modification/">【Hexo-Butterfly】字体修改 | yanchengxu</a></li></ul><h1 id="博客相关插件-网页"><a class="markdownIt-Anchor" href="#博客相关插件-网页"></a> 博客相关插件、网页</h1><blockquote><p>以下表格来源：</p><ul><li><a href="https://imbhj.com/link-favorites/">我早就忘了该如何开心的笑了《黑执事》 | Ordis’Blog (imbhj.com)</a></li></ul></blockquote><h2 id="博客插件"><a class="markdownIt-Anchor" href="#博客插件"></a> 博客插件</h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://github.com/jerryc127/hexo-theme-butterfly">博客主题</a></td><td style="text-align:center">本博客主题，Hexo-Butterfly</td></tr><tr><td style="text-align:center"><a href="https://www.gulpjs.com.cn/">gulp-cli 压缩插件</a></td><td style="text-align:center">Gulp 压缩</td></tr><tr><td style="text-align:center"><a href="https://www.npmjs.com/package/workbox-build">PWA 构建插件 workbox-build</a></td><td style="text-align:center">Workbox Build</td></tr><tr><td style="text-align:center"><a href="https://github.com/HCLonely/hexo-bilibili-bangumi">hexo-bilibili-bangumi: 哔哩哔哩追番页面插件</a></td><td style="text-align:center">在 Hexo 中生成哔哩哔哩追番页面</td></tr><tr><td style="text-align:center"><a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search: 本地搜索插件</a></td><td style="text-align:center">开启本地搜索插件</td></tr><tr><td style="text-align:center"><a href="https://github.com/MoePlayer/hexo-tag-aplayer">hexo-tag-aplayer: 音乐页面插件</a></td><td style="text-align:center">音乐页面的插件</td></tr><tr><td style="text-align:center"><a href="https://github.com/willin/hexo-wordcount">hexo-wordcount: 字数统计插件</a></td><td style="text-align:center">文章字数统计</td></tr><tr><td style="text-align:center"><a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed: RSS 生成插件</a></td><td style="text-align:center">RSS 生成</td></tr><tr><td style="text-align:center"><a href="https://github.com/netcan/hexo-generator-index-pin-top">hexo-generator-index-pin-top: 文章置顶插件</a></td><td style="text-align:center">实现文章置顶</td></tr><tr><td style="text-align:center"><a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git: Git 推送插件</a></td><td style="text-align:center">一键 Gti 推送</td></tr><tr><td style="text-align:center"><a href="https://github.com/coneycode/hexo-generator-baidu-sitemap">hexo-generator-baidu-sitemap: 百度 sitemap 生成插件</a></td><td style="text-align:center">如题，百度 sitemap 生成</td></tr><tr><td style="text-align:center"><a href="https://github.com/Rozbo/hexo-abbrlink">hexo-abbrlink: 永久链接生成插件</a></td><td style="text-align:center">精简文章链接</td></tr><tr><td style="text-align:center"><a href="https://github.com/huiwang/hexo-baidu-url-submit">hexo-baidu-url-submit: 百度主动推送</a></td><td style="text-align:center">百度主动链接提交</td></tr><tr><td style="text-align:center"><a href="https://github.com/hexojs/hexo-generator-sitemap">hexo-generator-sitemap: Sitemap 生成插件</a></td><td style="text-align:center">如题</td></tr></tbody></table><h2 id="无版权图库"><a class="markdownIt-Anchor" href="#无版权图库"></a> 无版权图库</h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">简介</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://www.pexels.com/zh-cn/">Pexels</a></td><td style="text-align:center">每一张都高清大图，无版权可任性下载</td></tr><tr><td style="text-align:center"><a href="https://www.sitebuilderreport.com/stock-up">Stock Up</a></td><td style="text-align:center">一个收集了来自 27 个免版权图库的神奇网站，图片数量之大，超乎你的想象</td></tr><tr><td style="text-align:center"><a href="https://unsplash.com/">Unsplash</a></td><td style="text-align:center">主要是生活中的景象作品</td></tr><tr><td style="text-align:center"><a href="https://pixabay.com/">Pixabay</a></td><td style="text-align:center">支持中文搜索的免费可商用图库</td></tr><tr><td style="text-align:center"><a href="https://stocksnap.io/">StockSnap</a></td><td style="text-align:center">最先进的检索功能，瞬间拥有高质量的免费高清图片</td></tr><tr><td style="text-align:center"><a href="https://magdeleine.co/">Magdeleine</a></td><td style="text-align:center">主要类别有自然、城市建筑、动物、视频风格偏厚重，比较艺术化</td></tr><tr><td style="text-align:center"><a href="https://visualhunt.com/">Visual Hunt</a></td><td style="text-align:center">通过颜色找图片，更精准的满足用户需求</td></tr></tbody></table><h2 id="无版权字体"><a class="markdownIt-Anchor" href="#无版权字体"></a> 无版权字体</h2><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://www.fontspace.com/">Free Fonts 字体</a></td><td style="text-align:center">emm。忘了介绍是啥了，自己打开看看吧</td></tr><tr><td style="text-align:center"><a href="http://www.googlefonts.net/">Google Fonts 谷歌字体中文版</a></td><td style="text-align:center">谷歌字体（暂时无法使用中文字体，请访问旧版）</td></tr><tr><td style="text-align:center"><a href="https://github.com/adobe-fonts">Adobe Fonts</a></td><td style="text-align:center">Adobe 的免费开源字体</td></tr><tr><td style="text-align:center"><a href="https://www.zcool.com.cn/special/zcoolfonts/">站酷字库 - 付费字体 &amp; 免费字体 - 站酷 (ZCOOL)</a></td><td style="text-align:center">站酷字体</td></tr><tr><td style="text-align:center"><a href="http://www.fonts.net.cn/">字体天下 - 提供各类字体的免费下载和在线预览服务</a></td><td style="text-align:center">这个里面的免费字体好像只能用于设计，比如 PS 什么的</td></tr></tbody></table><h2 id="文章封面设计"><a class="markdownIt-Anchor" href="#文章封面设计"></a> 文章封面设计</h2><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://nav.rdonly.com/laboratory/bgimage/backimage.html">文章封面生成工具</a></td><td style="text-align:center"><a href="http://GitHub.io">GitHub.io</a> 的，某些地区可能无法访问</td></tr><tr><td style="text-align:center"><a href="https://stories.freepik.com/">Stories 免费插图设计</a></td><td style="text-align:center">自定义更改插图颜色、插图背景、隐藏元素等，插图动画化，完全免费，但必须注明来源。</td></tr><tr><td style="text-align:center"><a href="https://icons8.com/vector-creator/">Vector Creator 插图设计</a></td><td style="text-align:center">有人物、动物、植物等类别的元素，而且每种类型的插图还有不同的风格，无需注册即可免费设计并下载 PNG 格式的插图，不付费使用时需要遵循免费使用条款</td></tr><tr><td style="text-align:center"><a href="https://undraw.co/">unDraw - 插图设计</a></td><td style="text-align:center">风格单一，但完全免费，不用担心版权，可任意使用不用担心律师函</td></tr><tr><td style="text-align:center"><a href="https://www.manypixels.co/gallery/">ManyPixels 插图设计</a></td><td style="text-align:center">可以说是另一个版本的 <strong>unDraw</strong> 插图库，完全免费，不用担心版权</td></tr></tbody></table><h2 id="acg-无版权图库"><a class="markdownIt-Anchor" href="#acg-无版权图库"></a> ACG 无版权图库</h2><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">简述</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://alphacoders.com/">Alpha Coders ACG 无版权图片</a></td><td style="text-align:center">偏向游戏、人物</td></tr><tr><td style="text-align:center"><a href="https://www.gamewallpapers.com/index.php">GameWallpapers. ACG 无版权图库</a></td><td style="text-align:center">同上</td></tr></tbody></table><h2 id="代码托管"><a class="markdownIt-Anchor" href="#代码托管"></a> 代码托管</h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://git-scm.com/">Git</a></td><td style="text-align:center">分布式版本管理工具，程序员必会技能</td></tr><tr><td style="text-align:center"><a href="https://gitee.com/">码云 Gitee</a></td><td style="text-align:center">国内版的 Github，支持静态站点配置，不过付费才嫩自动部署，自定义域名</td></tr><tr><td style="text-align:center"><a href="https://coding.net/">Coding</a></td><td style="text-align:center">也是国内的，支持静态站点、自定义域名、强制 https、自动部署，非常好用</td></tr><tr><td style="text-align:center"><a href="https://github.com/">GitHub</a></td><td style="text-align:center">国外的，功能非常全，程序员最爱的 “交友” 网站，唯一的缺点是在国外，访问有点慢</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统 - Android校招面试整理2022</title>
      <link href="/posts/f4f7590eb984/"/>
      <url>/posts/f4f7590eb984/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文整理自：</p><ul><li><a href="http://www.cyc2018.xyz/">CS-Notes (cyc2018.xyz)</a></li></ul></blockquote><h1 id="四个基本特征"><a class="markdownIt-Anchor" href="#四个基本特征"></a> 四个基本特征</h1><ol><li><p>并发</p><p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p><p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p></li><li><p>共享</p><p>共享是指系统中的资源可以被多个并发进程共同使用。</p><p>有两种共享方式：互斥共享和同时共享。</p><p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p></li><li><p>虚拟</p><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p><p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p></li><li><p>异步</p><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p></li></ol><h1 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h1><ol><li><p>进程管理</p><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p></li><li><p>内存管理</p><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p></li><li><p>文件管理</p><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p></li><li><p>设备管理</p><p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p><p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p></li></ol><h1 id="系统调用"><a class="markdownIt-Anchor" href="#系统调用"></a> 系统调用</h1><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/tGPV0.png" alt="img" /></p><h1 id="进程和线程"><a class="markdownIt-Anchor" href="#进程和线程"></a> 进程和线程</h1><h2 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h2><p><strong>进程是资源分配的最小单位。</strong></p><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p><p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/a6ac2b08-3861-4e85-baa8-382287bfee9f.png" alt="img" /></p><h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2><p><strong>线程是独立调度的基本单位。</strong></p><p>一个进程中可以有多个线程，它们共享进程资源。</p><h2 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h2><ol><li><p>拥有资源</p><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p></li><li><p>调度</p><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p></li><li><p>系统开销</p><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。</p></li><li><p>通信方面</p><p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p></li></ol><h1 id="进程状态的切换"><a class="markdownIt-Anchor" href="#进程状态的切换"></a> 进程状态的切换</h1><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ProcessState.png" alt="img" /></p><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源</li></ul><p>注意：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是由于缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h1 id="进程调度算法"><a class="markdownIt-Anchor" href="#进程调度算法"></a> 进程调度算法</h1><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h2 id="交互式系统"><a class="markdownIt-Anchor" href="#交互式系统"></a> 交互式系统</h2><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><h3 id="时间片轮转"><a class="markdownIt-Anchor" href="#时间片轮转"></a> 时间片轮转</h3><blockquote><p><strong>先来先服务 first-come first-serverd（FCFS）</strong></p><p>批处理系统中非抢占式的调度算法，按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p></blockquote><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><h3 id="优先级调度"><a class="markdownIt-Anchor" href="#优先级调度"></a> 优先级调度</h3><p>为每个进程分配一个优先级，按优先级进行调度。</p><p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><h3 id="多级反馈队列"><a class="markdownIt-Anchor" href="#多级反馈队列"></a> 多级反馈队列</h3><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,…。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/042cf928-3c8e-4815-ae9c-f2780202c68f.png" alt="img" /></p><h2 id="批处理系统-实时系统"><a class="markdownIt-Anchor" href="#批处理系统-实时系统"></a> 批处理系统、实时系统</h2><p>具体内容查看本文上方的参考文章。</p><h1 id="进程同步"><a class="markdownIt-Anchor" href="#进程同步"></a> 进程同步</h1><h2 id="临界区"><a class="markdownIt-Anchor" href="#临界区"></a> 临界区</h2><p>对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section;</span><br><span class="line">// exit section</span><br></pre></td></tr></table></figure><h2 id="同步与互斥"><a class="markdownIt-Anchor" href="#同步与互斥"></a> 同步与互斥</h2><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><h2 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h2><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P2</span><span class="params">()</span> &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="管程"><a class="markdownIt-Anchor" href="#管程"></a> 管程</h2><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p><p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><h1 id="经典同步问题"><a class="markdownIt-Anchor" href="#经典同步问题"></a> 经典同步问题</h1><h2 id="哲学家进餐问题"><a class="markdownIt-Anchor" href="#哲学家进餐问题"></a> 哲学家进餐问题</h2><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><p>一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p><p>为了防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul><h2 id="读者-写者问题"><a class="markdownIt-Anchor" href="#读者-写者问题"></a> 读者-写者问题</h2><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><h1 id="进程通信"><a class="markdownIt-Anchor" href="#进程通信"></a> 进程通信</h1><p>进程同步与进程通信很容易混淆，它们的区别在于：</p><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><h2 id="共享存储"><a class="markdownIt-Anchor" href="#共享存储"></a> 共享存储</h2><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p><h2 id="信号量-2"><a class="markdownIt-Anchor" href="#信号量-2"></a> 信号量</h2><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p><h1 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h1><h2 id="死锁的必要条件"><a class="markdownIt-Anchor" href="#死锁的必要条件"></a> 死锁的必要条件</h2><ol><li>互斥</li><li>占有且等待</li><li>不可抢占</li><li>循环等待</li></ol><h2 id="已发生死锁后的处理方法"><a class="markdownIt-Anchor" href="#已发生死锁后的处理方法"></a> 已发生死锁后的处理方法</h2><p>主要有以下四种方法：</p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防</li><li>死锁避免</li></ul><h3 id="鸵鸟策略"><a class="markdownIt-Anchor" href="#鸵鸟策略"></a> 鸵鸟策略</h3><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p><h3 id="死锁检测与死锁恢复"><a class="markdownIt-Anchor" href="#死锁检测与死锁恢复"></a> 死锁检测与死锁恢复</h3><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><p><strong>死锁检测：</strong></p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><p><strong>死锁恢复：</strong></p><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><h2 id="死锁预防"><a class="markdownIt-Anchor" href="#死锁预防"></a> 死锁预防</h2><p>我们只要<strong>破坏产生死锁的四个条件中的其中一个就可以了</strong>。</p><ol><li><p><strong>破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p></li><li><p><strong>破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p></li><li><p><strong>破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p></li><li><p><strong>破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p></li></ol><h2 id="死锁避免"><a class="markdownIt-Anchor" href="#死锁避免"></a> 死锁避免</h2><h3 id="安全状态"><a class="markdownIt-Anchor" href="#安全状态"></a> 安全状态</h3><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ed523051-608f-4c3f-b343-383e2d194470.png" alt="img" /></p><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p><h3 id="单个资源的银行家算法"><a class="markdownIt-Anchor" href="#单个资源的银行家算法"></a> 单个资源的银行家算法</h3><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png" alt="img" /></p><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p><h3 id="多个资源的银行家算法"><a class="markdownIt-Anchor" href="#多个资源的银行家算法"></a> 多个资源的银行家算法</h3><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png" alt="img" /></p><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p><p><strong>检查一个状态是否安全的算法如下：</strong></p><ul><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ul><p>如果一个状态不是安全的，需要拒绝进入这个状态。</p><h1 id="虚拟内存"><a class="markdownIt-Anchor" href="#虚拟内存"></a> 虚拟内存</h1><blockquote><p>参考视频：</p><ul><li><a href="https://www.bilibili.com/video/BV18v411a7Vk">【操作系统】内存管理——虚拟内存 _ 哔哩哔哩_bilibili</a></li></ul></blockquote><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/7b281b1e-0595-402b-ae35-8c91084c33c1.png" alt="img" /></p><h1 id="分页系统地址映射"><a class="markdownIt-Anchor" href="#分页系统地址映射"></a> 分页系统地址映射</h1><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p><p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p><p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" alt="img" style="zoom:67%;" /><h1 id="页面置换算法"><a class="markdownIt-Anchor" href="#页面置换算法"></a> 页面置换算法</h1><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h2 id="最佳"><a class="markdownIt-Anchor" href="#最佳"></a> 最佳</h2><blockquote><p>OPT, Optimal replacement algorithm</p></blockquote><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p><p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p><h2 id="最近最久未使用"><a class="markdownIt-Anchor" href="#最近最久未使用"></a> 最近最久未使用</h2><blockquote><p>LRU, Least Recently Used</p></blockquote><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p><p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p><h2 id="先进先出"><a class="markdownIt-Anchor" href="#先进先出"></a> 先进先出</h2><blockquote><p>FIFO, First In First Out</p></blockquote><p>选择换出的页面是最先进入的页面。</p><p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p><h2 id="第二次机会算法"><a class="markdownIt-Anchor" href="#第二次机会算法"></a> 第二次机会算法</h2><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png" alt="img" /></p><h2 id="时钟"><a class="markdownIt-Anchor" href="#时钟"></a> 时钟</h2><blockquote><p>Clock</p></blockquote><p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png" alt="img" /></p><h2 id="最近未使用"><a class="markdownIt-Anchor" href="#最近未使用"></a> 最近未使用</h2><blockquote><p>NRU, Not Recently Used</p></blockquote><p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p><ul><li>R=0，M=0</li><li>R=0，M=1</li><li>R=1，M=0</li><li>R=1，M=1</li></ul><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p><p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p><h1 id="分段"><a class="markdownIt-Anchor" href="#分段"></a> 分段</h1><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p><p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/22de0538-7c6e-4365-bd3b-8ce3c5900216.png" alt="img" /></p><p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><h1 id="段页式"><a class="markdownIt-Anchor" href="#段页式"></a> 段页式</h1><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><h1 id="分页与分段的比较"><a class="markdownIt-Anchor" href="#分页与分段的比较"></a> 分页与分段的比较</h1><ul><li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li><li>地址空间的维度：分页是一维地址空间，分段是二维的。</li><li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li><li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 2022校招面试整理 </category>
          
          <category> 计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 一篇文章添加多个分类</title>
      <link href="/posts/08fcea026748/"/>
      <url>/posts/08fcea026748/</url>
      
        <content type="html"><![CDATA[<h1 id="分类和标签"><a class="markdownIt-Anchor" href="#分类和标签"></a> 分类和标签</h1><p>Hexo 博客中只有文章支持分类和标签，您可以在 Front-matter 中设置。</p><p>在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">Diary</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PS3</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Games</span></span><br></pre></td></tr></table></figure><h1 id="分类方法的分歧"><a class="markdownIt-Anchor" href="#分类方法的分歧"></a> 分类方法的分歧</h1><p>如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Diary</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Life</span></span><br></pre></td></tr></table></figure><p>会使分类 Life 成为 Diary 的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p><p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="string">Diary</span>, <span class="string">PlayStation</span>]</span><br><span class="line">  <span class="bullet">-</span> [<span class="string">Diary</span>, <span class="string">Games</span>]</span><br><span class="line">  <span class="bullet">-</span> [<span class="string">Life</span>]</span><br></pre></td></tr></table></figure><p>此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://hexo.io/zh-cn/docs/front-matter.html">Front-matter | Hexo</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Front-matter 格式</title>
      <link href="/posts/a6d8264a3704/"/>
      <url>/posts/a6d8264a3704/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-front-matter"><a class="markdownIt-Anchor" href="#什么是-front-matter"></a> 什么是 Front-matter</h1><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2013/7/13 20:46:25</span><br><span class="line">---</span><br></pre></td></tr></table></figure><hr /><h1 id="部分参数"><a class="markdownIt-Anchor" href="#部分参数"></a> 部分参数</h1><blockquote><p>以下参数不一定全部适用于所有主题的博客，请自行尝试。</p></blockquote><h2 id="page-front-matter"><a class="markdownIt-Anchor" href="#page-front-matter"></a> Page Front-matter</h2><table><thead><tr><th style="text-align:center">Type</th><th style="text-align:center">Explanation</th><th style="text-align:center">Example</th></tr></thead><tbody><tr><td style="text-align:center">title</td><td style="text-align:center">标题</td><td style="text-align:center">title: hello, world</td></tr><tr><td style="text-align:center">date</td><td style="text-align:center">创建日期，默认系统时间</td><td style="text-align:center">date: 2020-7-19</td></tr><tr><td style="text-align:center">updated</td><td style="text-align:center">更新日期，默认再次创建日期</td><td style="text-align:center">update: 2020-7-20</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">页面类型，tags、link、categories 这三个页面需要配置</td><td style="text-align:center">type: tags</td></tr><tr><td style="text-align:center">comments</td><td style="text-align:center">是否显示评论，默认 true</td><td style="text-align:center">comments: false</td></tr><tr><td style="text-align:center">description</td><td style="text-align:center">描述，没使用过，暂时不太清楚效果</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">top_img</td><td style="text-align:center">顶部图，默认为系统default配置的图</td><td style="text-align:center">top_img: 图片URL或者博客相对路径</td></tr><tr><td style="text-align:center">mathjax</td><td style="text-align:center">数学公式是否显示，默认为 false ，不显示</td><td style="text-align:center">mathjax: true</td></tr><tr><td style="text-align:center">katex</td><td style="text-align:center">数学公式是否显示，默认为 false ，不显示</td><td style="text-align:center">mathjax: true</td></tr><tr><td style="text-align:center">aside</td><td style="text-align:center">true 表示显示右边信息卡片，默认值；false 表示不显示</td><td style="text-align:center">aside: true</td></tr><tr><td style="text-align:center">aplayer</td><td style="text-align:center">在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">highlight_shrink</td><td style="text-align:center">配置代码框是否展开，默认为设置中 highlight_shrink 的配置</td><td style="text-align:center">–</td></tr></tbody></table><h2 id="post-front-matter"><a class="markdownIt-Anchor" href="#post-front-matter"></a> Post Front-matter</h2><table><thead><tr><th style="text-align:center">Type</th><th style="text-align:center">Explanation</th><th style="text-align:center">Example</th></tr></thead><tbody><tr><td style="text-align:center">title</td><td style="text-align:center">标题</td><td style="text-align:center">title: Hello,World！</td></tr><tr><td style="text-align:center">date</td><td style="text-align:center">创建日期，默认系统时间</td><td style="text-align:center">date: 2020-7-19</td></tr><tr><td style="text-align:center">updated</td><td style="text-align:center">更新日期，默认再次创建日期</td><td style="text-align:center">update: 2020-7-20</td></tr><tr><td style="text-align:center">tags</td><td style="text-align:center">标签，用 - 列出标签，一个 - 表示一个标签，注意换行以及 - 后面有个空格</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">categories</td><td style="text-align:center">分类，同样用 - 区别多个分类，注意换行以及 - 后面有个空格</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">keywords</td><td style="text-align:center">关键字</td><td style="text-align:center">keywords: ‘a, b’</td></tr><tr><td style="text-align:center">description</td><td style="text-align:center">描述，没使用过，暂时不太清楚效果</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">top_img</td><td style="text-align:center">顶部图，可选项，不写则按缩略图的图片显示</td><td style="text-align:center">top_img: 图片URL或者博客中图片的相对路径</td></tr><tr><td style="text-align:center">comments</td><td style="text-align:center">是否显示评论，默认 true。</td><td style="text-align:center">comments: false</td></tr><tr><td style="text-align:center">cover</td><td style="text-align:center">缩略图</td><td style="text-align:center">cover: 图片URL或者博客中图片的相对路径</td></tr><tr><td style="text-align:center">toc</td><td style="text-align:center">是否显示 toc ，默认 true 显示</td><td style="text-align:center">toc: false</td></tr><tr><td style="text-align:center">toc_number</td><td style="text-align:center">是否显示 toc 数字，默认 true 显示</td><td style="text-align:center">toc_number: false</td></tr><tr><td style="text-align:center">auto_open</td><td style="text-align:center">是否自动打开 TOC (默认为设置中 toc 的 auto_open 配置)</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">copyright</td><td style="text-align:center">是否显示版权，默认 true 显示</td><td style="text-align:center">copyright: false</td></tr><tr><td style="text-align:center">mathjax</td><td style="text-align:center">数学公式是否显示，默认为 false ，不显示</td><td style="text-align:center">mathjax: true</td></tr><tr><td style="text-align:center">katex</td><td style="text-align:center">数学公式是否显示，默认为 false ，不显示</td><td style="text-align:center">mathjax: true</td></tr><tr><td style="text-align:center">hidden或hide</td><td style="text-align:center">是否隐藏，需安装hide或者indexed插件，true表示隐藏</td><td style="text-align:center">hidden: true</td></tr><tr><td style="text-align:center">sticky</td><td style="text-align:center">文章置顶，数值越大越靠前，需安装indexed插件，默认值为0</td><td style="text-align:center">sticky: 10</td></tr><tr><td style="text-align:center">top</td><td style="text-align:center">文章置顶，需安装index-pin-top 插件，默认值为false，同时为置顶则按时间先后顺序</td><td style="text-align:center">top: true</td></tr><tr><td style="text-align:center">aplayer</td><td style="text-align:center">在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">highlight_shrink</td><td style="text-align:center">配置代码框是否展开，默认为设置中 highlight_shrink 的配置</td><td style="text-align:center">–</td></tr></tbody></table><hr /><h1 id="butterfly-主题-参数"><a class="markdownIt-Anchor" href="#butterfly-主题-参数"></a> Butterfly 主题 参数</h1><h2 id="page-front-matter-2"><a class="markdownIt-Anchor" href="#page-front-matter-2"></a> Page Front-matter</h2><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220710205859893.png" alt="image-20220710205859893" /></p><h2 id="post-front-matter-2"><a class="markdownIt-Anchor" href="#post-front-matter-2"></a> Post Front-matter</h2><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220710205932635.png" alt="image-20220710205932635" /></p><hr /><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><p><a href="https://hexo.io/zh-cn/docs/front-matter.html">Front-matter | Hexo</a></p></li><li><p><a href="https://caczhtus.github.io/posts/64237/">【Hexo】关于 Hexo-ButterFly 主题的使用记录 | Caczhtus</a></p></li><li><p><a href="https://blog.csdn.net/qq_42549254/article/details/102721177">hexo学习——文章 Front-matter_WMXNLFD的博客-CSDN博客</a></p></li><li><p><a href="https://butterfly.js.org/posts/dc584b87/">Butterfly 安裝文檔(二) 主題頁面 | Butterfly</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程-Android校招面试整理2022</title>
      <link href="/posts/6797cb29bf4c/"/>
      <url>/posts/6797cb29bf4c/</url>
      
        <content type="html"><![CDATA[<h1 id="java中创建线程的方式"><a class="markdownIt-Anchor" href="#java中创建线程的方式"></a> <code>Java</code>中创建线程的方式</h1><blockquote><p><code>Future</code>, <code>FutureTask</code>的实现方式暂未学习，待补充。</p></blockquote><ol><li>写一个类继承自<code>Thread</code>类，重写<code>run</code>方法。用<code>start</code>方法启动线程。</li><li>写一个类实现<code>Runnable</code>接口，实现<code>run</code>方法。用<code>new Thread(Runnable target).start</code>方法来启动。</li></ol><h1 id="线程的几种状态"><a class="markdownIt-Anchor" href="#线程的几种状态"></a> 线程的几种状态</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/pange1991/article/details/53860651/">Java线程的6种状态及切换(透彻讲解)_潘建南的博客-CSDN博客_线程状态</a></li></ul></blockquote><p><code>Java</code>中的线程的状态总共有6种。</p><blockquote><ol><li><strong>初始(<code>NEW</code>)：</strong> 新创建了一个线程对象，但还没有调用start()方法。</li><li><strong>运行(<code>RUNNABLE</code>)：</strong> Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br />线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li><li><strong>阻塞(<code>BLOCKED</code>)：</strong> 表示线程阻塞于锁。</li><li><strong>等待(<code>WAITING</code>)：</strong> 进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li><strong>超时等待(<code>TIMED_WAITING</code>)：</strong> 该状态不同于<code>WAITING</code>，它可以在指定的时间后自行返回。</li><li><strong>终止(<code>TERMINATED</code>)：</strong> 表示该线程已经执行完毕。</li></ol></blockquote><p>这6种状态定义在<code>Thread</code>类的<code>State</code>枚举中，可查看源码进行一一对应。</p><p><strong><font size="4">线程状态图</font></strong></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20181120173640764.jpeg" alt="线程状态图" /></p><p><strong><font size="4">状态详细说明</font></strong></p><ol><li><p><strong>初始状态(<code>NEW</code>)</strong><br />实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</p></li><li><p><strong>运行状态(<code>RUNNABLE</code>)</strong></p><ol><li><strong>就绪状态(<code>RUNNABLE</code>之<code>READY</code>)</strong><ul><li>就绪状态只是说你有资格运行，调度程序没有挑选到你，你就永远是就绪状态。</li><li>调用线程的start()方法，此线程进入就绪状态。</li><li>当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。</li><li>当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。</li><li>锁池里的线程拿到对象锁后，进入就绪状态。</li></ul></li><li><strong>运行中状态(<code>RUNNABLE</code>之<code>RUNNING</code>)</strong><br />线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一的一种方式。</li></ol></li><li><p><strong>阻塞状态(<code>BLOCKED</code>)</strong><br />阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。</p></li><li><p><strong>等待(<code>WAITING</code>)</strong><br />处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</p></li><li><p><strong>超时等待(<code>TIMED_WAITING</code>)</strong><br />处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</p></li><li><p><strong>终止状态(<code>TERMINATED</code>)</strong><br />当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。<br />在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p></li></ol><h1 id="threadsleep与objectwait的区别"><a class="markdownIt-Anchor" href="#threadsleep与objectwait的区别"></a> <code>Thread#sleep</code>与<code>Object#wait</code>的区别</h1><p><strong><font size="4"><code>Thread#sleep</code></font></strong></p><p><code>Thread.sleep(long millis)</code>，一定是当前线程调用此方法，当前线程进入<code>TIMED_WAITING</code>状态，但<strong>不释放对象锁</strong>，<code>millis</code>后线程自动苏醒进入就绪状态。</p><p>作用：给其它线程执行机会的最佳方式。</p><p><strong><font size="4"><code>Object#wait</code></font></strong></p><p>当前线程调用对象的<code>wait</code>方法，当前线程<strong>释放对象锁</strong>，进入等待队列。</p><p>依靠<code>notify/notifyAll</code>唤醒或者<code>wait(long timeout)</code>， <code>timeout</code>时间到自动唤醒。</p><p><strong><font size="4">总结</font></strong></p><p>可以发现，两者的区别为当前的线程是否会释放对象锁。</p><h1 id="objectnotify和objectnotifyall的区别"><a class="markdownIt-Anchor" href="#objectnotify和objectnotifyall的区别"></a> <code>Object#notify</code>和<code>Object#notifyAll</code>的区别</h1><p><code>Object#notify</code>唤醒在此对象监视器上等待的<strong>单个线程</strong>，<strong>选择是任意性的</strong>。</p><p><code>Object#notifyAll</code>唤醒在此对象监视器上等待的<strong>所有线程</strong>。</p><h1 id="锁池和等待池"><a class="markdownIt-Anchor" href="#锁池和等待池"></a> 锁池和等待池</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/javaddd/p/13611981.html">多线程的“锁池”和“等待池” - suncl123 - 博客园 (cnblogs.com)</a></li></ul></blockquote><p>每个对象都有自己的“锁池”和“等待池”，用来存放线程。线程进入“锁池”，会处于竞争锁状态，当其他线程释放锁以后，才可能竞争到锁，然后执行同步块代码。线程进入”等待池“，会等待其他线程调用notify或者notifyAll方法，来进入“锁池”状态。</p><p>synchronized修饰的方法，在执行的时候，线程会被排序依次执行。这时，线程会被阻塞在对象的“锁池”中，只有一个线程会被执行。至于哪个线程被执行，需根据不同的虚拟机实现机制不同。</p><p>进入synchronized方法块的线程，会立即持有该对象的锁，并从“锁池”中移除。执行完毕，会释放锁，“锁池”中的线程依据一定规则会有一个线程依次执行该synchronized代码块。</p><p>进入synchronized代码块的线程，如果执行wait方法，就会释放改对象锁，该线程进入“等待池”，直到其他线程调用该对象的notify方法时，才有可能被唤醒继续执行后续代码，线程被唤醒以后，该线程从“等待池”中移除。</p><h1 id="threadrun和threadstart的区别"><a class="markdownIt-Anchor" href="#threadrun和threadstart的区别"></a> <code>Thread#run</code>和<code>Thread#start</code>的区别</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/renhui/p/6066750.html">Java Thread 的 run() 与 start() 的区别 - 灰色飘零 - 博客园 (cnblogs.com)</a></li></ul></blockquote><ol><li><p>调用<code>start</code>方法方可启动线程，而<code>run</code>方法只是<code>Thread</code>的一个普通方法调用，还是在主线程里执行。</p></li><li><p>把需要并行处理的代码放在<code>run</code>方法中，<code>start</code>方法启动线程将自动调用 <code>run</code>方法，这是由<code>JVM</code>的内存机制规定的。并且<code>run</code>方法必须是<code>public</code>访问权限，返回值类型为<code>void</code>。</p></li></ol><hr /><h1 id="线程死锁如何有效的避免线程死锁"><a class="markdownIt-Anchor" href="#线程死锁如何有效的避免线程死锁"></a> 线程死锁，如何有效的避免线程死锁？</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://developer.aliyun.com/article/763004">什么是线程死锁？形成条件是什么？如何避免？-阿里云开发者社区 (aliyun.com)</a></li></ul></blockquote><h2 id="什么是线程死锁"><a class="markdownIt-Anchor" href="#什么是线程死锁"></a> 什么是线程死锁</h2><p>死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/cff16df19c2ffe9621333dd219990df69664a007.png" alt="image" /></p><p>如上图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><h2 id="形成死锁的四个必要条件"><a class="markdownIt-Anchor" href="#形成死锁的四个必要条件"></a> 形成死锁的四个必要条件</h2><ol><li><strong>互斥条件：</strong> 线程(进程)对于所分配到的资源具有排它性，即一个资源只能被一个线程(进程)占用，直到被该线程(进程)释放。</li><li><strong>请求与保持条件：</strong> 一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</li><li><strong>不可剥夺条件：</strong> 线程(进程)已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li><strong>循环等待条件：</strong> 当发生死锁时，所等待的线程(进程)必定会形成一个环路（类似于死循环），造成永久阻塞。</li></ol><h2 id="如何避免线程死锁"><a class="markdownIt-Anchor" href="#如何避免线程死锁"></a> 如何避免线程死锁</h2><p>我们只要<strong>破坏产生死锁的四个条件中的其中一个就可以了</strong>。</p><ol><li><p><strong>破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p></li><li><p><strong>破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p></li><li><p><strong>破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p></li><li><p><strong>破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p></li></ol><hr /><h1 id="如何保证线程安全"><a class="markdownIt-Anchor" href="#如何保证线程安全"></a> 如何保证线程安全</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/qq_26545305/article/details/79516610">【多线程】如何保证线程安全_LemmonTreelss的博客-CSDN博客</a></li></ul></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20180315101631748.png" alt="img" style="zoom: 80%;" /><ol><li><p>互斥同步</p><p>互斥同步是最常见的一种并发正确性保障手段。同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用（同一时刻，只有一个线程在操作共享数据）。</p><p>在java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码质量，这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。</p><p>此外，ReentrantLock 也是通过互斥来实现同步。在基本用法上，ReentrantLock 与 synchronized 很相似，他们都具备一样的线程重入特性。</p><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也成为阻塞同步。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确地同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁。</p></li><li><p>非阻塞同步</p><p>随着硬件指令集的发展，出现了基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施。（最常见的补偿错误就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。</p><p>实现非阻塞同步的方式为CAS。</p></li></ol><h1 id="如何实现多线程中的同步"><a class="markdownIt-Anchor" href="#如何实现多线程中的同步"></a> 如何实现多线程中的同步</h1><blockquote><p><strong>同步(synchronization)<strong>就是</strong>指一个线程访问数据时，其它线程不得对同一个数据进行访问，即同一时刻只能有一个线程访问该数据，当这一线程访问结束时其它线程才能对这它进行访问</strong> 。同步最常见的方式就是使用锁(Lock)，也称为<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E9%94%81&amp;spm=1001.2101.3001.7020">线程锁</a>。锁是一种非强制机制，每一个线程在访问数据或资源之前，首先试图获取(Acquire)锁，并在访问结束之后释放(Release)锁。 <strong>在锁被占用时试图获取锁，线程会进入等待状态，直到锁被释放再次变为可用。</strong></p></blockquote><h2 id="synchronized"><a class="markdownIt-Anchor" href="#synchronized"></a> synchronized</h2><h2 id="lock"><a class="markdownIt-Anchor" href="#lock"></a> Lock</h2><h1 id="volatile"><a class="markdownIt-Anchor" href="#volatile"></a> <code>volatile</code></h1><blockquote><p>答案参考自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/138819184">volatile 关键字，你真的理解吗？ - 知乎 (zhihu.com)</a></li></ul></blockquote><h2 id="volatile-的作用"><a class="markdownIt-Anchor" href="#volatile-的作用"></a> volatile 的作用</h2><ul><li>保证了变量的内存可见性。</li><li>禁止指令的重排序。</li></ul><h2 id="java-内存模型jmm"><a class="markdownIt-Anchor" href="#java-内存模型jmm"></a> Java 内存模型（JMM）</h2><p>JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。</p><p><strong><font size="4">JMM 的规定：</font></strong></p><ul><li><p>所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p></li><li><p>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p></li><li><p>线程对变量的所有的操作（读，取）都必须在工作内存中完成，而不能直接读写主内存中的变量。</p></li><li><p>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</p></li></ul><p><strong><font size="4">JMM 的抽象示意图：</font></strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-3d312429710bd6a11eca171858f67751_720w.jpg" alt="img" style="zoom:80%;" /><h2 id="内存可见性"><a class="markdownIt-Anchor" href="#内存可见性"></a> 内存可见性</h2><p>内存可见性是指当一个线程修改了某个变量的值，其它线程总是能知道这个变量变化。</p><p>也就是说，如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。</p><h2 id="内存可见行的解决方案"><a class="markdownIt-Anchor" href="#内存可见行的解决方案"></a> 内存可见行的解决方案</h2><p>使用 <code>volatile</code> 关键字，或者加锁。</p><p><strong><font size="4">加锁</font></strong></p><blockquote><p><strong>为什么加锁后就保证了变量的内存可见性了？</strong></p></blockquote><p>因为当一个线程进入 <code>synchronized</code> 代码块后，线程获取到锁，会清空本地内存，然后从主内存中拷贝共享变量的最新值到本地内存作为副本，执行代码，又将修改后的副本值刷新到主内存中，最后线程释放锁。</p><p>这里除了 <code>synchronized</code> 外，其它锁也能保证变量的内存可见性。</p><p><strong><font size="4">使用 volatile 关键字</font></strong></p><p>使用 <code>volatile</code> 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，当线程操作变量副本并写回主内存后，会通过 <strong><code>CPU</code> 总线嗅探机制</strong>告知其他线程该变量副本已经失效，需要重新从主内存中读取。</p><p><code>volatile</code> 保证了不同线程对共享变量操作的可见性，也就是说一个线程修改了 <code>volatile</code> 修饰的变量，当修改后的变量写回主内存时，其他线程能立即看到最新值。</p><p><strong><font size="4">总结</font></strong></p><p>使用 <code>volatile</code> 和 <code>synchronized</code> 锁都可以保证共享变量的可见性。相比 <code>synchronized</code> 而言，<code>volatile</code> 可以看作是一个轻量级锁，所以使用 <code>volatile</code> 的成本更低，因为它不会引起线程上下文的切换和调度。</p><p>但 <code>volatile</code> 无法像 <code>synchronized</code> 一样保证操作的原子性。</p><h2 id="volatile-的原子性问题"><a class="markdownIt-Anchor" href="#volatile-的原子性问题"></a> <code>volatile</code> 的原子性问题</h2><blockquote><p>原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。</p></blockquote><p>在多线程环境下，<code>volatile</code> 关键字可以保证共享数据的可见性，但是并不能保证对数据操作的原子性。也就是说，多线程环境下，使用 <code>volatile</code> 修饰的变量是<strong>线程不安全的</strong>。</p><p>要解决这个问题，我们可以使用锁机制，或者使用原子类（如 <code>AtomicInteger</code>）。</p><p>这里特别说一下，对任意单个使用 <code>volatile</code> 修饰的变量的读 / 写是具有原子性，但类似于 <code>flag = !flag</code> 这种复合操作不具有原子性。简单地说就是，<strong>单纯的赋值操作是原子性的</strong>。</p><h2 id="重排序"><a class="markdownIt-Anchor" href="#重排序"></a> 重排序</h2><p>为了提高性能，在遵守 <code>as-if-serial</code> 语义（即不管怎么重排序，单线程下程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守。）的情况下，编译器和处理器常常会对指令做重排序。</p><p>一般重排序可以分为如下三种类型：</p><ul><li>编译器优化重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul> <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-8655d85c8a9df1bc2262485248b07d4d_720w.jpg" alt="img" style="zoom: 80%;" /><h2 id="happen-before-原则"><a class="markdownIt-Anchor" href="#happen-before-原则"></a> happen-before 原则</h2><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p><p><strong><font size="4">单一线程原则</font></strong></p><blockquote><p>Single Thread rule</p></blockquote><p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/874b3ff7-7c5c-4e7a-b8ab-a82a3e038d20.png" alt="img" style="zoom: 67%;" /><p><strong><font size="4">管程锁定规则</font></strong></p><blockquote><p>Monitor Lock Rule</p></blockquote><p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/8996a537-7c4a-4ec8-a3b7-7ef1798eae26.png" alt="img" style="zoom:67%;" /><p><strong><font size="4">volatile 变量规则</font></strong></p><blockquote><p>Volatile Variable Rule</p></blockquote><p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/942f33c9-8ad9-4987-836f-007de4c21de0.png" alt="img" style="zoom:67%;" /><p><strong><font size="4">线程启动规则</font></strong></p><blockquote><p>Thread Start Rule</p></blockquote><p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/6270c216-7ec0-4db7-94de-0003bce37cd2.png" alt="img" style="zoom:67%;" /><p><strong><font size="4">线程加入规则</font></strong></p><blockquote><p>Thread Join Rule</p></blockquote><p>Thread 对象的结束先行发生于 join() 方法返回。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/233f8d89-31d7-413f-9c02-042f19c46ba1.png" alt="img" style="zoom:67%;" /><p><strong><font size="4">线程中断规则</font></strong></p><blockquote><p>Thread Interruption Rule</p></blockquote><p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p><p><strong><font size="4">对象终结规则</font></strong></p><blockquote><p>Finalizer Rule</p></blockquote><p>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p><p><strong><font size="4">传递性</font></strong></p><blockquote><p>Transitivity</p></blockquote><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p><h1 id="synchronized和volatile的区别"><a class="markdownIt-Anchor" href="#synchronized和volatile的区别"></a> synchronized和volatile的区别？</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/suifeng3051/article/details/52611233">volatile和synchronized的区别_Heaven-Wang的博客-CSDN博客_synchronized和volatile区别</a></li></ul></blockquote><ol><li><p>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p></li><li><p>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的</p></li><li><p>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性</p></li><li><p>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</p></li><li><p>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</p></li></ol><h1 id="为何不用volatile替代synchronized"><a class="markdownIt-Anchor" href="#为何不用volatile替代synchronized"></a> 为何不用volatile替代synchronized？</h1><p>因为 volatile 不能保证原子性，当有多个线程修改同一个变量时，例如++操作，无法保证线程同步。</p><hr /><h1 id="synchronized和lock的比较"><a class="markdownIt-Anchor" href="#synchronized和lock的比较"></a> synchronized和Lock的比较</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/b343a9637f95">Synchronized和Lock的区别 - 简书 (jianshu.com)</a></li></ul></blockquote><p><strong>两种锁的底层实现</strong></p><blockquote><p>Synchronized：底层使用指令码方式来控制锁的，映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当线程执行遇到monitorenter指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到monitorexit指令时锁计数器-1，如果计数器为0则释放锁。</p></blockquote><blockquote><p>Lock：底层是CAS乐观锁，依赖AbstractQueuedSynchronizer类，把所有的请求线程构成一个CLH队列。而对该队列的操作均通过Lock-Free（CAS）操作。</p></blockquote><p><strong>两种锁的区别</strong></p><ol><li><p>Synchronized是关键字，内置语言实现，Lock是接口。</p></li><li><p>Synchronized在线程发生异常时会自动释放锁，因此不会发生异常死锁。Lock异常时不会自动释放锁，所以需要在finally中实现释放锁。</p></li><li><p>Lock是可以中断锁，Synchronized是非中断锁，必须等待线程执行完成释放锁。</p></li><li><p>Lock可以使用读锁提高多线程读效率。</p></li></ol><h1 id="锁的分类"><a class="markdownIt-Anchor" href="#锁的分类"></a> 锁的分类</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/qifengshi/p/6831055.html">Java中的锁分类 - byhieg - 博客园 (cnblogs.com)</a></li></ul></blockquote><h2 id="公平锁非公平锁"><a class="markdownIt-Anchor" href="#公平锁非公平锁"></a> 公平锁/非公平锁</h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁。<br />非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。<br />对于Java <code>ReentrantLock</code>而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。<br />对于<code>Synchronized</code>而言，也是一种非公平锁。由于其并不像<code>ReentrantLock</code>是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</p><h2 id="可重入锁"><a class="markdownIt-Anchor" href="#可重入锁"></a> 可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。<br />对于Java <code>ReentrantLock</code>而言, 他的名字就可以看出是一个可重入锁，其名字是<code>Re entrant Lock</code>重新进入锁。<br />对于<code>Synchronized</code>而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">setB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，<code>setB()</code> 可能不会被当前线程执行，可能造成死锁。</p><h2 id="独享锁共享锁"><a class="markdownIt-Anchor" href="#独享锁共享锁"></a> 独享锁/共享锁</h2><p>独享锁是指该锁一次只能被一个线程所持有。</p><p>共享锁是指该锁可被多个线程所持有。</p><p>对于<code>Java</code> 的 <code>ReentrantLock</code>而言，其是独享锁。但是对于Lock的另一个实现类<code>ReadWriteLock</code>，其读锁是共享锁，其写锁是独享锁。</p><p>读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p><p>对于<code>Synchronized</code>而言，当然是独享锁。</p><h2 id="互斥锁读写锁"><a class="markdownIt-Anchor" href="#互斥锁读写锁"></a> 互斥锁/读写锁</h2><p>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。</p><p>互斥锁在Java中的具体实现就是<code>ReentrantLock</code>。</p><p>读写锁在Java中的具体实现就是<code>ReadWriteLock</code>。</p><h2 id="乐观锁悲观锁"><a class="markdownIt-Anchor" href="#乐观锁悲观锁"></a> 乐观锁/悲观锁</h2><p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。</p><p>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。</p><p>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</p><p>从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。</p><p>悲观锁在Java中的使用，就是利用各种锁。</p><p>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</p><h2 id="分段锁"><a class="markdownIt-Anchor" href="#分段锁"></a> 分段锁</h2><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于<code>ConcurrentHashMap</code>而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p><p>我们以<code>ConcurrentHashMap</code>来说一下分段锁的含义以及设计思想，<code>ConcurrentHashMap</code>中的分段锁称为<code>Segment</code>，它即类似于<code>HashMap</code>（JDK7与JDK8中<code>HashMap</code>的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个<code>ReentrantLock</code>（<code>Segment</code>继承了<code>ReentrantLock</code>)。</p><p>当需要<code>put</code>元素的时候，并不是对整个<code>HashMap</code>进行加锁，而是先通过<code>hashcode</code>来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程<code>put</code>的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</p><p>但是，在统计<code>size</code>的时候，可就是获取<code>hashmap</code>全局信息的时候，就需要获取所有的分段锁才能统计。</p><p>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p><h2 id="自旋锁"><a class="markdownIt-Anchor" href="#自旋锁"></a> 自旋锁</h2><p>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p><p>典型的自旋锁实现的例子，可以参考<a href="http://ifeve.com/java_lock_see1/">自旋锁的实现</a>。</p><h2 id="偏向锁轻量级锁重量级锁"><a class="markdownIt-Anchor" href="#偏向锁轻量级锁重量级锁"></a> 偏向锁/轻量级锁/重量级锁</h2><p>这三种锁是指锁的状态，并且是针对<code>Synchronized</code>。在Java 5通过引入锁升级的机制来实现高效<code>Synchronized</code>。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</p><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p><p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p><h1 id="锁的几种状态-jdk-16-对-synchronized-的优化"><a class="markdownIt-Anchor" href="#锁的几种状态-jdk-16-对-synchronized-的优化"></a> 锁的几种状态 / JDK 1.6 对 synchronized 的优化</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/zmh458/article/details/93053867"> java中锁的四种状态_Hi-Sunshine的博客-CSDN博客</a></li></ul></blockquote><p>锁有四种状态：无锁状态、偏向锁、轻量级锁、重量级锁。具体细节可以参考上一个问题。</p><p>随着锁的竞争，锁的状态会从偏向锁到轻量级锁，再到重量级锁。而且锁的状态只有升级，没有降级。也就是只有偏向锁-&gt;轻量级锁-&gt;重量级锁，没有重量级锁-&gt;轻量级锁-&gt;偏向锁。</p><p>锁状态的改变是根据竞争激烈程度进行的，在几乎无竞争的条件下，会使用偏向锁，在轻度竞争的条件下，会由偏向锁升级为轻量级锁， 在重度竞争的情况下，会升级到重量级锁。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190620153844690.png" alt="在这里插入图片描述" style="zoom: 80%;" /><hr /><h1 id="cas原理"><a class="markdownIt-Anchor" href="#cas原理"></a> CAS原理</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://github.com/LRH1993/android_interview/blob/master/java/concurrence/CAS.md">android_interview/CAS.md at master · LRH1993/android_interview (github.com)</a></li></ul></blockquote><p><strong>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。</strong></p><p>举个CAS操作的应用场景的一个例子，当一个线程需要修改共享变量的值。完成这个操作，先取出共享变量的值赋给A，然后基于A的基础进行计算，得到新值B，完了需要更新共享变量的值了，这个时候就可以调用CAS方法更新变量值了。</p><h2 id="cas的问题"><a class="markdownIt-Anchor" href="#cas的问题"></a> CAS的问题</h2><p>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。</p><ol><li><p>ABA问题。</p><p>因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A－2B－3A。从Java1.5开始JDK的atomic包里提供了一个类 <code>AtomicStampedReference</code> 来解决ABA问题。这个类的 <code>compareAndSet</code> 方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p></li><li><p>循环时间长开销大。</p><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p></li><li><p>只能保证一个共享变量的原子操作。</p><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量<code>i＝2, j=a</code>，合并一下<code>i, j=2a</code>，然后用CAS来操作<code>i, j</code>。从Java1.5开始 JDK 提供了 <code>AtomicReference</code> 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。</p></li></ol><hr /><h1 id="java-线程池"><a class="markdownIt-Anchor" href="#java-线程池"></a> Java 线程池</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://github.com/LRH1993/android_interview/blob/master/java/concurrence/thread-pool.md">android_interview/thread-pool.md at master · LRH1993/android_interview (github.com)</a></li></ul></blockquote><h2 id="为什么java用线程池"><a class="markdownIt-Anchor" href="#为什么java用线程池"></a> 为什么Java用线程池</h2><ol><li><p>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</p></li><li><p>提高系统响应速度，当有任务到达时，无需等待新线程的创建便能立即执行；</p></li><li><p>方便线程并发数的管控，线程若是无限制的创建，不仅会额外消耗大量系统资源，更是占用过多资源而阻塞系统或 OOM 等状况，从而降低系统的稳定性。线程池能有效管控线程，统一分配、调优，提供资源使用率；</p></li><li><p>更强大的功能，线程池提供了定时、定期以及可控线程数等功能的线程池，使用方便简单。</p></li></ol><h2 id="线程池参数"><a class="markdownIt-Anchor" href="#线程池参数"></a> 线程池参数</h2><p>我们可以通过 <code>ThreadPoolExecutor</code> 来创建一个线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(....);</span><br></pre></td></tr></table></figure><p>下面我们就来看一下 <code>ThreadPoolExecutor</code> 中的一个构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">   <span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params"><span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params"><span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">TimeUnit unit,</span></span><br><span class="line"><span class="params">BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">RejectedExecutionHandler handler</span></span><br><span class="line"><span class="params">)</span> </span><br></pre></td></tr></table></figure><h3 id="threadpoolexecutor-参数含义"><a class="markdownIt-Anchor" href="#threadpoolexecutor-参数含义"></a> <code>ThreadPoolExecutor</code> 参数含义</h3><p><strong>1. corePoolSize</strong></p><p>线程池中的核心线程数，默认情况下，核心线程一直存活在线程池中，即便他们在线程池中处于闲置状态。除非我们将ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这时候处于闲置的核心线程在等待新任务到来时会有超时策略，这个超时时间由keepAliveTime来指定。一旦超过所设置的超时时间，闲置的核心线程就会被终止。</p><p><strong>2. maximumPoolSize</strong></p><p>线程池中所容纳的最大线程数，如果活动的线程达到这个数值以后，后续的新任务将会被阻塞。包含核心线程数+非核心线程数。</p><p><strong>3. keepAliveTime</strong></p><p>非核心线程闲置时的超时时长，对于非核心线程，闲置时间超过这个时间，非核心线程就会被回收。只有对 ThreadPoolExecutor 的 allowCoreThreadTimeOut 属性设为 true 的时候，这个超时时间才会对核心线程产生效果。</p><p><strong>4. unit</strong></p><p>用于指定 <code>keepAliveTime</code> 参数的时间单位。他是一个枚举，可以使用的单位有七种：</p><table><thead><tr><th style="text-align:center">时间单位</th><th style="text-align:center">变量名</th></tr></thead><tbody><tr><td style="text-align:center">天</td><td style="text-align:center"><code>TimeUnit.DAYS</code></td></tr><tr><td style="text-align:center">小时</td><td style="text-align:center"><code>TimeUnit.HOURS</code></td></tr><tr><td style="text-align:center">分钟</td><td style="text-align:center"><code>TimeUnit.MINUTES</code></td></tr><tr><td style="text-align:center">秒</td><td style="text-align:center"><code>TimeUnit.SECONDS</code></td></tr><tr><td style="text-align:center">毫秒</td><td style="text-align:center"><code>TimeUnit.MILLISECONDS</code></td></tr><tr><td style="text-align:center">微秒(千分之一毫秒)</td><td style="text-align:center"><code>TimeUnit.MICROSECONDS</code></td></tr><tr><td style="text-align:center">毫微秒(千分之一微秒)</td><td style="text-align:center"><code>TimeUnit.NANOSECONDS</code></td></tr></tbody></table><p><strong>5. workQueue</strong></p><p>线程池中保存等待执行的任务的阻塞队列。通过线程池中的execute方法提交的Runable对象都会存储在该队列中。我们可以选择下面几个阻塞队列。</p><table><thead><tr><th>阻塞队列</th><th>说明</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>基于数组实现的有界的阻塞队列,该队列按照FIFO（先进先出）原则对队列中的元素进行排序。</td></tr><tr><td>LinkedBlockingQueue</td><td>基于链表实现的阻塞队列，该队列按照FIFO（先进先出）原则对队列中的元素进行排序。</td></tr><tr><td>SynchronousQueue</td><td>内部没有任何容量的阻塞队列。在它内部没有任何的缓存空间。对于 SynchronousQueue 中的数据元素只有当我们试着取走的时候才可能存在。</td></tr><tr><td>PriorityBlockingQueue</td><td>具有优先级的无限阻塞队列。</td></tr></tbody></table><p>我们还能够通过实现 BlockingQueue 接口来自定义我们所需要的阻塞队列。</p><p><strong>6. threadFactory</strong></p><p>线程工厂，为线程池提供新线程的创建。ThreadFactory是一个接口，里面只有一个newThread方法。 默认为DefaultThreadFactory类。</p><p><strong>7. handler</strong></p><p>是 RejectedExecutionHandler 对象，而 RejectedExecutionHandler 是一个接口，里面只有一个 rejectedExecution 方法。</p><p>当任务队列已满并且线程池中的活动线程已经达到所限定的最大值或者是无法成功执行任务，这时候 ThreadPoolExecutor 会调用 RejectedExecutionHandler 中的  rejectedExecution 方法。在 ThreadPoolExecutor 中有四个内部类实现了 RejectedExecutionHandler 接口。在线程池中它默认是 AbortPolicy ，在无法处理新任务时抛出 RejectedExecutionException 异常。</p><p>下面是在 ThreadPoolExecutor 中提供的四个可选值。</p><table><thead><tr><th>可选值</th><th>说明</th></tr></thead><tbody><tr><td>CallerRunsPolicy</td><td>只用调用者所在线程来运行任务。</td></tr><tr><td>AbortPolicy</td><td>直接抛出RejectedExecutionException异常。</td></tr><tr><td>DiscardPolicy</td><td>丢弃掉该任务，不进行处理。</td></tr><tr><td>DiscardOldestPolicy</td><td>丢弃队列里最近的一个任务，并执行当前任务。</td></tr></tbody></table><p>我们也可以通过实现RejectedExecutionHandler接口来自定义我们自己的handler。如记录日志或持久化不能处理的任务。</p><p><strong>创建用例</strong></p><p><code>OkHttp</code> 中线程池的创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">executorService = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">0</span>, </span><br><span class="line">    Integer.MAX_VALUE, </span><br><span class="line">    <span class="number">60</span>, </span><br><span class="line">    TimeUnit.SECONDS, </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(), </span><br><span class="line">    Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>该线程池的核心线程数为 0，线程池最有能容纳 <code>Integer.MAX_VALUE</code> 个线程，且线程的空闲存活时间为 60s（可以理解为 okhttp 随时可以创建新的线程来满足需要。可以保证网络的 I/O 任务有线程来处理，不被阻塞）。</p><h2 id="线程池的关闭"><a class="markdownIt-Anchor" href="#线程池的关闭"></a> 线程池的关闭</h2><p>调用线程池的 <code>shutdown()</code> 或 <code>shutdownNow()</code> 方法来关闭线程池</p><p><code>shutdown</code>原理：将线程池状态设置成 <code>SHUTDOWN</code> 状态，然后中断所有没有正在执行任务的线程。</p><p><code>shutdownNow</code>原理：将线程池的状态设置成 <code>STOP</code> 状态，然后中断所有任务(包括正在执行的)的线程，并返回等待执行任务的列表。</p><h2 id="有几种线程池"><a class="markdownIt-Anchor" href="#有几种线程池"></a> 有几种线程池</h2><p>Java中四种具有不同功能常见的线程池。他们都是直接或者间接配置 ThreadPoolExecutor 来实现他们各自的功能。这四种线程池分别是</p><ol><li>newFixedThreadPool</li><li>newCachedThreadPool</li><li>newScheduledThreadPool</li><li>newSingleThreadExecutor</li></ol><p>这四个线程池可以通过Executors类获取。</p><hr /><h1 id="android-多线程通信"><a class="markdownIt-Anchor" href="#android-多线程通信"></a> Android 多线程通信</h1><ol><li><code>Handler</code> 机制</li><li><code>AsyncTask</code> 类</li></ol><hr /><h1 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> TODO</h1><ol><li>CLH 与 AQS</li><li>其他并发容器</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 2022校招面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM - Android校招面试整理2022</title>
      <link href="/posts/d479c1bb49e9/"/>
      <url>/posts/d479c1bb49e9/</url>
      
        <content type="html"><![CDATA[<h1 id="jvm-的体系结构"><a class="markdownIt-Anchor" href="#jvm-的体系结构"></a> <code>JVM</code> 的体系结构</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/102702428">十分钟带你了解JVM的结构体系 - 知乎 (zhihu.com)</a></li></ul></blockquote><p><code>JVM</code>的组成：</p><ul><li>类加载子系统 Class loader</li><li>运行时数据区</li><li>执行引擎</li></ul><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-f3141f2dd349b87c98543fbc9fc00495_720w.jpg" alt="img" /></p><h1 id="类加载器"><a class="markdownIt-Anchor" href="#类加载器"></a> 类加载器</h1><ul><li>负责加载 <code>class</code>文件(<code>class</code>文件在文件开头有特定的文件标识)，将 <code>class</code>文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构。</li><li><code>ClassLoader</code>只负责加载 <code>class</code>文件的加载，至于它是否可以运行，则由<code>Execution Engine</code>决定。</li></ul><p>在 Java 9 以前，一共有三种类加载器：</p><ul><li>启动类加载器（<strong><code>BootStrap ClassLoader</code></strong>）</li><li>扩展类加载器（<strong><code>Extension ClassLoader</code></strong>）</li><li>应用类加载器（<strong><code>Application ClassLoader</code></strong>）</li></ul><p>在 Java 9 之后，经过更改后变成了两种：</p><ul><li>启动类加载器</li><li>平台类加载器</li></ul><p>启动类加载器是所有类加载器的祖先，由 C++ 编程，没有对应的 Java 对象，因此在 Java 中用 <code>null</code> 来指代。</p><p>除了启动类加载器，其他的加载器都有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。</p><h1 id="双亲委派机制及其优势"><a class="markdownIt-Anchor" href="#双亲委派机制及其优势"></a> 双亲委派机制及其优势</h1><ul><li><p><strong>全盘负责：</strong></p><p>当前线程的类加载器负责加载某个<code>Class</code>时，该<code>Class</code>所依赖的和引用的其他<code>Class</code>也将由该类加载器负责载入，除非显示使用<code>CLassLoader.loadClass()</code>指定类加载器来载入。</p></li><li><p><strong>父类委托：</strong></p><p>先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。所以我们在开发中尽量不要使用与JDK相同的类（例如自定义一个<code>java.lang.System</code>类），因为父类加载器中已经有一份<code>java.lang.System</code>类了，它会直接将该类给程序使用，而你自定义的类压根就不会被加载。</p></li><li><p><strong>双亲委派模型：</strong></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中。</p><p>只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p></li><li><p><strong>双亲委派模型的工作流程：</strong></p><ol><li><p>当<code>AppClassLoader</code>加载一个<code>class</code>时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</p></li><li><p>当<code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrap ClassLoader</code>去完成。</p></li><li><p>如果<code>BootStrap ClassLoader</code>加载失败（例如在<code>$JAVA_HOME/jre/lib</code>里未查找到该<code>class</code>），会使用<code>ExtClassLoader</code>来尝试加载。</p></li><li><p>若<code>ExtClassLoader</code>也加载失败，则会使用<code>AppClassLoader</code>来加载，如果<code>AppClassLoader</code>也加载失败，则会报出异常<code>ClassNotFoundException</code>。</p></li></ol></li><li><p><strong>双亲委派模型的优势：</strong></p><ol><li>系统类防止内存中出现多份同样的字节码</li><li>保证<code>Java</code>程序安全稳定运行</li></ol></li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/408997874.png" alt="img" style="zoom:67%;" /><h1 id="内存模型"><a class="markdownIt-Anchor" href="#内存模型"></a> 内存模型</h1><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-205a2605346856d95aec826ed9263c03_720w.jpg" alt="img" /></p><h2 id="线程私有内存"><a class="markdownIt-Anchor" href="#线程私有内存"></a> 线程私有内存</h2><p><strong><font size="5">程序计数器(Program Counter Register)</font></strong></p><p>程序计数器可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。</p><p>字节码解释器工作是就是通过改变程序计数器的值来选取下一条需要执行的字节码指令（执行本地方法的时候，程序计数器的值为 <code>null</code>）。</p><p><strong>每条线程都需要有一个独立的程序计数器</strong>，各条的程序计数器互不影响，独立存储。</p><p>此内存区域是唯一一个没有规定任何 <code>OutOfMemoryError</code> 情况的区域。</p><p><strong><font size="5">Java 虚拟机栈(VM Stack)</font></strong></p><p>Java 虚拟机栈为虚拟机执行 Java 方法服务。</p><p><strong>Java 虚拟机栈的生命周期和线程相同。</strong></p><p>虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会在虚拟机栈中同步创建一个 <strong>栈帧</strong> 用于存储局部变量表、操作数栈、方法出口等信息。</p><p>每一个方法被调用直至执行完毕的过程，就对应这一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graphsubgraph 栈帧    局部变量表    操作数栈    动态链接    方法出口    ...end  </pre></div><p><strong><font size="5">本地方法栈(Native Method Stack)</font></strong></p><p>本地方法栈为虚拟机使用本地<code>Native</code>方法服务。</p><h2 id="线程共享内存"><a class="markdownIt-Anchor" href="#线程共享内存"></a> 线程共享内存</h2><p><strong><font size="5">Java 堆(Java Heap)</font></strong></p><p>Java 堆是虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p><p><strong>此内存区域的唯一目的就是存放对象实例</strong>，Java 世界里“几乎”所有的对象实例都在这里分配内存。</p><p>Java 堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”。</p><p>Java 堆可以处于物理上不连续的内存空间中，但在逻辑上都连续存放。</p><p>从分配内存的角度看，所有线程共享的 Java 堆中可以划分出多个线程私有的分配缓冲区，以提升对象分配时的效率。无论如何划分，无论是那个区域，存储的都只能是对象的实例。</p><p><strong>Java 堆既可以实现成固定大小的，也可以是扩展的。</strong> 如果在 Java 堆中没有内存完成对象分配时，并且堆也无法再扩展时，Java 虚拟机将会抛出 <code>OutOfMemoryError</code> 异常。</p><p><strong><font size="5">方法区(Method Area)</font></strong></p><p>方法区与 Java 堆一样，是各个线程共享的内存区域，<strong>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</strong></p><p>如果方法区无法满足新的内存分配需求时，将抛出 <code>OutOfMemoryError</code> 异常。</p><p>在 JDK 1.8 之前，<code>HotSpot</code> 虚拟机把它当作永久代进行垃圾回收。</p><p>在 JDK 1.8 以后，移除永久代，并将永久代拆分至堆和元空间。元空间位于本地内存中，而不是虚拟机内存中，存储类的元数据；堆中则额外存放方法区的静态变量和常量池等。</p><p><strong><font size="4">运行时常量池(Runtime Constant Pool)</font></strong></p><p>运行时常量池是方法区的一部分。</p><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>除了 <strong>保存 Class 文件中描述的符号引用</strong> 外，还会把符号引用翻译出来的直接引用也存储再运行时常量池中。</p><p>运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</p><h1 id="类加载机制的几个阶段"><a class="markdownIt-Anchor" href="#类加载机制的几个阶段"></a> 类加载机制的几个阶段</h1><blockquote><p>Java 语言的类型可以分为两个大类：基本类型和引用类型。</p><p>其中的引用类型，Java 又将其细分为了四种：类、接口、数组类以及泛型参数。</p><p>其中，泛型参数会在编译过程中被擦除，数组类则是由 Java 虚拟机直接在内存中动态构造出来的。所以我们只讨论类和接口的加载过程。</p></blockquote><p><strong>类的加载过程：</strong></p><p><code>JVM</code> 将 <code>javac</code> 编译好的<code>class</code>字节码文件加载到内存中，并对该数据进行验证、解析和初始化、形成<code>JVM</code>可以直接使用的<code>JAVA</code>类，最终回收(卸载)的过程。</p><p><strong>字节码（<code>.class</code>）文件来源：</strong></p><ul><li>从本地系统中直接加载</li><li>通过网络下载<code>.class</code>文件</li><li>从<code>zip</code>, <code>jar</code>等归档文件中加载<code>.class</code>文件</li><li>从专有数据库中提取<code>.class</code>文件</li><li>将<code>Java</code>源文件动态编译为<code>.class</code>文件</li></ul><hr /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/879896-20160414224549770-60006655.png" alt="img" style="zoom:70%;" /><p><strong><font size="5">加载</font></strong></p><p>加载阶段是类加载的第一个部分，在此阶段需要完成三件事情：</p><ol><li>通过类的完全限定名找到该类对应的二进制字节流。</li><li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li><li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li></ol><p>对于非数组类的其他类而言，Java 虚拟机需要通过类加载器来完成查找字节流的过程。</p><p><strong><font size="5">验证</font></strong></p><p>验证阶段是连接阶段的第一步，目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p><strong><font size="5">准备</font></strong></p><p>准备阶段是正式为<strong>类变量(类字段)</strong>（即静态变量，被 <code>static</code> 修饰的变量）分配内存并设置类变量初始值的阶段。</p><p>这些变量所使用的内存都将在方法区中分配，只包括类变量。</p><p>初始值“通常情况”下是数据类型的零值。</p><p>“特殊情况”下，如果类字段的字段属性表中存在 <code>ConstantValue</code> 属性（即被 <code>final</code> 修饰的变量），那么在准备阶段变量的值就会被初始化为 <code>ConstantValue</code> 属性所指定的值。</p><p><strong><font size="5">解析</font></strong></p><p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>这个过程可以在初始化阶段之后进行。</p><p><strong><font size="5">初始化</font></strong></p><p>类加载过程中的最后一步。</p><p>初始化阶段是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。</p><p><code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。</p><p><code>&lt;clinit&gt;()</code> 与类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</p><p>如果一个类没有声明任何的类变量，也没有静态代码块，那么可以没有类<code>&lt;clinit&gt;</code>方法。</p><p><code>JVM</code> 必须确保一个类在初始化的过程中，如果是多线程需要同时初始化它，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程(所以<strong>可以利用静态内部类实现线程安全的单例模式</strong>)。</p><p><strong>简单地说，初始化就是对类变量进行赋值及执行静态代码块。</strong></p><p><strong><font size="5">使用</font></strong></p><p>程序使用 <code>JVM</code> 加载的类。</p><p><strong><font size="5">卸载</font></strong></p><p>触发卸载的五个时机：</p><ul><li>执行了 <code>System.exit()</code> 方法</li><li><code>JVM</code>垃圾回收机制触发回收</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h1 id="何时触发初始化"><a class="markdownIt-Anchor" href="#何时触发初始化"></a> 何时触发初始化</h1><ol><li><p>遇到 <code>new</code>，<code>getstatic</code>，<code>putstatic</code> 或 <code>invokestatic</code> 这4条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。<br />生成这4条指令的最常见的Java代码场景是：</p><ol><li>使用new关键字实例化对象的时候</li><li>读取或设置一个类的静态字段的时候</li><li>调用一个类的静态方法的时候</li></ol></li><li><p>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用的时候。</p></li><li><p>当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先出发父类的初始化。</p></li><li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 <code>main()</code> 方法的那个类），虚拟机会先初始化这个主类。</p></li></ol><h1 id="对象实例化时的顺序"><a class="markdownIt-Anchor" href="#对象实例化时的顺序"></a> 对象实例化时的顺序</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/sc179/article/details/109779168">Java实例化对象时的初始化顺序_hellosc01的博客-CSDN博客</a></li></ul></blockquote><blockquote><p>注：（A，B）表示A和B为同一阶段初始化，执行顺序取决于它们在代码中的顺序。</p></blockquote><p><strong><font size="5">无继承</font></strong></p><p>（静态变量，静态代码块）-&gt; （实例变量，普通代码块） -&gt; 构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="string">&quot;静态变量&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态语句块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> <span class="string">&quot;实例变量&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;普通语句块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InitialOrderTest</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;构造函数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font size="5">有继承</font></strong></p><ol><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ol><h1 id="垃圾回收机制"><a class="markdownIt-Anchor" href="#垃圾回收机制"></a> 垃圾回收机制</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://time.geekbang.org/column/article/13091">11 | 垃圾回收（上） (geekbang.org)</a></li><li><a href="http://www.cyc2018.xyz/Java">Java 虚拟机 | CS-Notes (cyc2018.xyz)</a></li></ul></blockquote><h2 id="判断对象是否存活"><a class="markdownIt-Anchor" href="#判断对象是否存活"></a> 判断对象是否存活</h2><p><strong><font size="5">引用计数法</font></strong></p><p>它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。</p><p>它的具体实现是这样子的：如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。也就是说，我们<strong>需要截获所有的引用更新操作</strong>，并且相应地增减目标对象的引用计数器。</p><p>除了<strong>需要额外的空间来存储计数器</strong>，以及<strong>繁琐的更新操作</strong>，引用计数法还有一个重大的漏洞，那便是<strong>无法处理循环引用对象</strong>。举个例子，假设对象 a 与 b 相互引用，除此之外没有其他引用指向 a 或者 b。在这种情况下，a 和 b 实际上已经死了，但由于它们的引用计数器皆不为 0，在引用计数法的心中，这两个对象还活着。因此，这些循环引用对象所占据的空间将不可回收，从而造成了内存泄露。</p><p><strong><font size="5">可达性分析</font></strong></p><p>Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后<strong>从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中</strong>，这个过程我们也称之为标记（mark）。最终，<strong>未被探索到的对象便是死亡的，是可以回收的。</strong></p><p><strong><font size="4">GC Roots</font></strong></p><p>可以暂时理解为由堆外指向堆内的引用，一般而言，GC Roots 包括（但不限于）如下几种：</p><ul><li>Java 方法栈桢中的局部变量；</li><li>已加载类的静态变量；</li><li>JNI handles；</li><li>已启动且未停止的 Java 线程。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/83d909d2-3858-4fe1-8ff4-16471db0b180.png" alt="img" style="zoom: 67%;" /><p>可达性分析可以解决引用计数法所不能解决的循环引用问题。</p><p>虽然可达性分析的算法本身很简明，但是在实践中还是有不少其他问题需要解决的。</p><p>比如说，在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成<strong>误报</strong>（将引用设置为 null）或者<strong>漏报</strong>（将引用设置为未被访问过的对象）。</p><p>误报并没有什么伤害，Java 虚拟机至多损失了部分垃圾回收的机会。漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 Java 虚拟机崩溃。</p><p>怎么解决这个问题呢？在 Java 虚拟机里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是 <strong>Stop-the-world</strong>，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了<strong>垃圾回收所谓的暂停时间（GC pause）</strong>。</p><h2 id="方法区的回收"><a class="markdownIt-Anchor" href="#方法区的回收"></a> 方法区的回收</h2><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p><p>主要是对常量池的回收和对类的卸载。</p><p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p><p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p><ul><li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>Class</code> 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ul><h2 id="finalize方法"><a class="markdownIt-Anchor" href="#finalize方法"></a> <code>finalize</code>方法</h2><p>类似 C++ 的析构函数，<strong>用于关闭外部资源</strong>。但是 try-finally 等方式可以做得更好，并且该方法<strong>运行代价很高，不确定性大</strong>，无法保证各个对象的调用顺序，因此<strong>最好不要使用</strong>。</p><h2 id="引用类型"><a class="markdownIt-Anchor" href="#引用类型"></a> 引用类型</h2><p>判定对象是否可被回收都与引用有关。</p><ol><li><p>强引用</p><p>被强引用关联的对象不会被回收。</p><p>使用 <code>new</code> 一个新对象的方式来创建强引用。</p></li><li><p>软引用</p><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>使用 <code>SoftReference</code> 类来创建软引用。</p></li><li><p>弱引用</p><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>使用 <code>WeakReference</code> 类来创建弱引用。</p></li><li><p>虚引用</p><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p><p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p><p>使用 <code>PhantomReference</code> 来创建虚引用。</p></li></ol><h2 id="垃圾回收的三种方式"><a class="markdownIt-Anchor" href="#垃圾回收的三种方式"></a> 垃圾回收的三种方式</h2><ol><li><p>标记-清除</p><p>即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。</p><p>缺点：</p><ul><li>会造成内存碎片。由于 Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。</li><li>分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/005b481b-502b-4e3f-985d-d043c2b330aa.png" alt="img" style="zoom: 67%;" /></li><li><p>标记-整理（压缩）</p><p>即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但<strong>代价是压缩算法的性能开销</strong>。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ccd773a5-ad38-4022-895c-7ac318f31437.png" alt="img" style="zoom:67%;" /></li><li><p>标记-复制</p><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p><p><strong>主要不足是只使用了内存的一半。</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png" alt="img" style="zoom:67%;" /><blockquote><p>现在的商业虚拟机都<strong>采用</strong>这种<strong>复制收集算法回收新生代</strong>，但是并不是划分为大小相等的两块，而是一块较大的 <code>Eden</code> 空间和两块较小的 <code>Survivor</code> 空间，每次使用 <code>Eden</code> 和其中一块 <code>Survivor</code>。在回收时，将 <code>Eden</code> 和 <code>Survivor</code> 中还存活着的对象全部复制到另一块 <code>Survivor</code> 上，最后清理 <code>Eden</code> 和使用过的那一块 <code>Survivor</code>。</p><p><code>HotSpot</code> 虚拟机的 <code>Eden</code> 和 <code>Survivor</code> 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 <code>Survivor</code> 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p></blockquote></li><li><p><strong>分代收集</strong></p><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p><p>一般将堆分为新生代和老年代。</p><ul><li>新生代使用：<strong>复制算法</strong></li><li>老年代使用：<strong>标记-清除</strong> 或者 <strong>标记-整理</strong> 算法</li></ul></li></ol><h2 id="垃圾收集器"><a class="markdownIt-Anchor" href="#垃圾收集器"></a> 垃圾收集器</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" alt="img"  /><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。‘</p><p><strong><font size="4">基本概念</font></strong></p><ul><li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li><li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul><p>针对新生代的垃圾回收器共有三个：Serial，Parallel Scavenge 和 Parallel New。这三个采用的都是<strong>标记 - 复制</strong>算法。其中，Serial 是一个单线程的，Parallel New 可以看成 Serial 的多线程版本。Parallel Scavenge 和 Parallel New 类似，但更加注重吞吐率。此外，Parallel Scavenge 不能与 CMS 一起使用。</p><p>针对老年代的垃圾回收器也有三个：刚刚提到的 Serial Old 和 Parallel Old，以及 CMS。Serial Old 和 Parallel Old 都是<strong>标记 - 压缩</strong>算法。同样，前者是单线程的，而后者可以看成前者的多线程版本。</p><p>CMS 采用的是<strong>标记 - 清除</strong>算法，并且是并发的。除了少数几个操作需要 Stop-the-world 之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，Java 虚拟机会使用其他两个压缩型垃圾回收器进行一次垃圾回收。由于 G1 的出现，CMS 在 Java 9 中已被废弃。</p><p>G1（Garbage First）是一个横跨新生代和老年代的垃圾回收器。实际上，它已经打乱了前面所说的堆结构，直接将堆分成极其多个区域。每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。它采用的是<strong>标记 - 压缩</strong>算法，而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃圾回收。</p><p>G1 能够针对每个细分的区域来进行垃圾回收。<strong>在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。</strong> 这也是 G1 名字的由来。</p><h1 id="回收策略和内存分配策略"><a class="markdownIt-Anchor" href="#回收策略和内存分配策略"></a> 回收策略和内存分配策略</h1><p><strong><font size="4">Minor GC &amp; Full GC</font></strong></p><ul><li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li><li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li></ul><p><strong><font size="4">内存分配策略流程</font></strong></p><ol><li>一个人（对象）出来（new 出来）后会在Eden Space（伊甸园）无忧无虑的生活，直到GC到来打破了他们平静的生活。GC会逐一问清楚每个对象的情况，有没有钱（此对象的引用）啊，因为GC想赚钱呀，有钱的才可以敲诈嘛。然后富人就会进入Survivor Space（幸存者区），穷人的就直接kill掉。</li><li>并不是进入Survivor Space（幸存者区）后就保证人身是安全的，但至少可以活段时间。GC会定期（可以自定义）会对这些人进行敲诈，亿万富翁每次都给钱，GC很满意，就让其进入了Genured Gen(养老区)。万元户经不住几次敲诈就没钱了，GC看没有啥价值啦，就直接kill掉了。</li><li>进入到养老区的人基本就可以保证人身安全啦，但是亿万富豪有的也会挥霍成穷光蛋，只要钱没了，GC还是kill掉。</li></ol><p><strong><font size="4">内存分配策略总结</font></strong></p><ol><li><p>对象优先在 Eden 分配</p><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p></li><li><p>大对象直接进入老年代</p><p>大对象是指<strong>需要连续内存空间的对象</strong>，最典型的大对象是那种<strong>很长的字符串以及数组</strong>。</p><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p></li><li><p>长期存活的对象直接进入老年代</p><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p><p>Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15，那么该对象将被晋升（promote）至老年代。</p></li><li><p>动态对象年龄判定</p><p>另外，如果单个 Survivor 区已经被占用了 50%，那么较高复制次数的对象也会被晋升至老年代。</p></li><li><p>空间分配担保</p><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。否则会继续判断其他条件，选择是否进行Full GC。</p></li></ol><p><strong><font size="4">GC 触发条件</font></strong></p><p>对于 Minor GC，其触发条件非常简单，<strong>当 Eden 空间满时，就将触发一次 Minor GC。</strong> 而 Full GC 则相对复杂，有以下条件：</p><ol><li><p>调用 <code>System.gc()</code></p><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p></li><li><p>老年代空间不足</p><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p></li><li><p>空间分配担保失败</p><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。（可参考上文“内存分配策略总结”第5点。）</p></li><li><p>Concurrent Mode Failure</p><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。（可参考上文“垃圾收集器”部分。）</p></li></ol><h1 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> TODO</h1><ol><li>JVM中synchronized的实现</li></ol>]]></content>
      
      
      <categories>
          
          <category> 2022校招面试整理 </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式 - Android校招面试整理2022</title>
      <link href="/posts/bad4a287481b/"/>
      <url>/posts/bad4a287481b/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式 | 菜鸟教程 (runoob.com)</a></li><li><a href="https://blog.csdn.net/hongyinanhai00/article/details/113971787">DCL之单例模式_浦江之猿的博客-CSDN博客_dcl单例模式</a></li><li>《Android源码设计模式解析与实战》</li></ul></blockquote><p><strong>意图：</strong> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>关键代码：</strong> 构造函数是私有的。</p><p><strong>优点：</strong></p><ol><li><p>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</p></li><li><p>避免对资源的多重占用（比如写文件操作）。</p></li></ol><h2 id="实现代码"><a class="markdownIt-Anchor" href="#实现代码"></a> 实现代码</h2><ol><li><p>饿汉式</p><p>优点：没有加锁，执行效率会提高。<br />缺点：类加载时就初始化，浪费内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DCL</p><p>优点：资源利用率高。</p><p>缺点：第一次加载的时候反应稍慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span> &#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>volatile</code>是为了防止指令重排序问题，避免第8行代码被分配了控件但是值为<code>null</code>的情况。</p><p>两次 if 语句的作用：</p><ul><li><p>第一个 if 语句</p><p>防止在变量实例化后仍有线程获取锁，造成性能的开销。</p></li><li><p>第二个 if 语句</p><p>防止变量的重复实例化。</p></li></ul></li><li><p>静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次加载<code>Singleton</code>类的时候并不会初始化<code>instance</code>，只有在第一次调用<code>Singleton.getInstance</code>方法时才会初始化<code>instance</code>。因此第一次调用<code>getInstance</code>方法时也会导致虚拟机加载<code>SingletonHolder</code>类，这种方式不仅确保了线程安全，也能够保证单例模式对象的唯一性，同时也延迟了单例的实例化。</p></li></ol><h2 id="android源码中的单例模式"><a class="markdownIt-Anchor" href="#android源码中的单例模式"></a> Android源码中的单例模式</h2><p><strong><code>LayoutInflater</code>类</strong>。</p><p>在<code>ContextImpl</code>类中，<code>LayoutInflater</code>的获取被写进了该类的<code>static&#123;&#125;</code>，即静态语句块中。表示了只有在该类被加载的时候才会被执行一次且只会执行一次，保证了实例的唯一性。</p><h1 id="建造者模式"><a class="markdownIt-Anchor" href="#建造者模式"></a> 建造者模式</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.runoob.com/design-pattern/builder-pattern.html">建造者模式 | 菜鸟教程 (runoob.com)</a></li><li><a href="https://www.runoob.com/w3cnote/builder-pattern-2.html">设计模式：Builder模式 | 菜鸟教程 (runoob.com)</a></li></ul></blockquote><p><strong>意图：</strong> 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>何时使用：</strong> 一些基本部件不会变，而其组合经常变化的时候。</p><p><strong>优点：</strong></p><ol><li><p>建造者独立，易扩展。</p></li><li><p>便于控制细节风险。</p></li></ol><p><strong>缺点：</strong> 产品必须有共同点，范围有限制。</p><p><strong>注意事项：</strong> 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p><p><strong>用例：</strong></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/1157683-20180626180216963-8235726.png" alt="img" /></p><p>调用者不需要知道<code>Director</code>类中方法的具体实现，而<code>Director</code>类同样也不需要知道<code>Builder</code>类中的具体实现。</p><p>当我们需求发生变动时，只需要单独修改<code>Director</code>或者<code>Builder</code>类的内部细节即可，不会影响到其他类的实现。</p><h2 id="android中的建造者模式"><a class="markdownIt-Anchor" href="#android中的建造者模式"></a> Android中的建造者模式</h2><ol><li><code>Java</code>的<code>StringBuilder</code>。</li><li><code>OkHttp</code>中的<code>OkHttpClient</code>。</li><li><code>Android</code>中的<code>AlterDialog</code>。</li></ol><h1 id="责任链模式"><a class="markdownIt-Anchor" href="#责任链模式"></a> 责任链模式</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html">责任链模式 | 菜鸟教程 (runoob.com)</a></li></ul></blockquote><p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p><p><strong>意图：</strong> 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><p><strong>主要解决：</strong> 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><p><strong>何时使用：</strong> 在处理消息的时候需要过滤很多道。</p><p><strong>优点：</strong></p><ol><li><p>降低耦合度。它将请求的发送者和接收者解耦。</p></li><li><p>简化了对象。使得对象不需要知道链的结构。</p></li><li><p>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。</p></li><li><p>增加新的请求处理类很方便。</p></li></ol><p><strong>缺点：</strong></p><ol><li><p>不能保证请求一定被接收。</p></li><li><p>系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。</p></li><li><p>可能不容易观察运行时的特征，有碍于除错。</p></li></ol><h2 id="android中类似责任链模式的使用"><a class="markdownIt-Anchor" href="#android中类似责任链模式的使用"></a> Android中类似责任链模式的使用</h2><ol><li><code>OkHttp</code>的拦截器。</li><li>View事件分发的<code>dispatchTouchEvent</code>以及<code>dispatchTransformedTouchEvent</code>方法。</li></ol><h1 id="观察者模式"><a class="markdownIt-Anchor" href="#观察者模式"></a> 观察者模式</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/ec399a25e9d4">Android 观察者模式 - 简书 (jianshu.com)</a></li><li><a href="https://blog.csdn.net/niuzhijun66/article/details/80328642">RecyclerView中的观察者模式_niuzhijun66的博客-CSDN博客</a></li></ul></blockquote><p>定义一个被观察者和多个观察者，每当被观察者变化，所有观察者都会得到通知。</p><p><strong>要点：</strong> P用一个list把观察者保存起来，并提供add和remove观察者，在被观察者变化的时候就遍历并调用list里观察者的方法。<strong>核心就是一个list遍历</strong>。</p><p><strong>优点：</strong></p><ol><li><p>观察者和被观察者解耦</p></li><li><p>增强灵活性，解耦</p></li></ol><p><strong>缺点：</strong> 由于java代码的顺序执行，要考虑被察者的执行效率，多个观察者需要及时响应就得考虑异步的问题了。</p><h2 id="android源码中的观察者模式"><a class="markdownIt-Anchor" href="#android源码中的观察者模式"></a> Android源码中的观察者模式</h2><ol><li><p><code>RecyclerView</code>的<code>notifyDataChanged</code>方法。</p><p>当数据集发生变化，调用RecyclerView.Adapter的notifyDataSetChanged()时，发生变化的地方就会刷新，这个过程就涉及到了Java中的观察者模式。</p><p>在RecyclerView的使用中，最重要的两个类应该就是RecyclerView和RecyclerView.Adapter了。</p><p>RecyclerView内部维持了一个Observer(RecyclerViewDataObserver)。</p><p>Adapter内部维持了一个Observable(AdapterDataObservable)。</p><p>我们调用setAdapter(Adapter adapter)时，Adapter内的Observable会持有RecyclerView内部的Observer；当调用notifyDataSetChanged()时，Observable持有的Observer会依次调用onChanged()方法，而RecyclerView持有的Observer的onChanged()方法中实现了UI刷新。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220526214753683.png" alt="image-20220526214753683"  /></li></ol>]]></content>
      
      
      <categories>
          
          <category> 2022校招面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OkHttp - Android校招面试整理2022</title>
      <link href="/posts/fa6189c97401/"/>
      <url>/posts/fa6189c97401/</url>
      
        <content type="html"><![CDATA[<h1 id="okhttp源码流程"><a class="markdownIt-Anchor" href="#okhttp源码流程"></a> <code>OkHttp</code>源码流程</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://luoyu-ying.github.io/posts/85849a386862/">OkHttp 解析 转载 | 洛语 の Blog (luoyu-ying.github.io)</a></li></ul></blockquote><p><strong><font size="5">基本流程</font></strong></p><ol><li>创建 OkHttpClient 对象</li><li>创建 Request 对象</li><li>创建 Call 对象</li><li>同步请求调用 call.execute()；异步请求调用 call.enqueue()</li></ol><h1 id="okhttp线程池"><a class="markdownIt-Anchor" href="#okhttp线程池"></a> <code>OkHttp</code>线程池</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/OneDeveloper/article/details/88381817">okhttp3 读书笔记——默认的线程池，addNetworkInterceptor() 与 addInterceptor() 的区别，复用连接池_OneDeveloper的博客-CSDN博客_okhttp 默认线程数</a></li></ul></blockquote><p><code>OkHttp</code> 的异步请求是基于其内部的默认的线程池实现的。</p><p>而默认的线程池是在 <code>Dispatcher</code> 被实例化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title function_">executorService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="literal">null</span>) &#123;</span><br><span class="line">        executorService = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">0</span>, </span><br><span class="line">            Integer.MAX_VALUE, </span><br><span class="line">            <span class="number">60</span>, </span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(), </span><br><span class="line">            Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该线程池的核心线程数为 0，线程池最有能容纳 Integer.MAX_VALUE 个线程，且线程的空闲存活时间为 60s（可以理解为 okhttp 随时可以创建新的线程来满足需要。可以保证网络的 I/O 任务有线程来处理，不被阻塞）。</p><p>重点是使用的阻塞队列为 SynchronousQueue，参考：<br />[<a href="https://luoming1224.github.io/2018/03/19/%5Bjava1.8%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%5DSynchronousQueue%E8%AF%A6%E8%A7%A3/">java1.8源码笔记]SynchronousQueue详解 | LuoMing’s Blog (luoming1224.github.io)</a></p><h1 id="okhttp拦截器"><a class="markdownIt-Anchor" href="#okhttp拦截器"></a> <code>OkHttp</code>拦截器</h1><p><strong><font size="4">getResponseWithInterceptorChain()</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Response <span class="title function_">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>(client.cookieJar()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>(client.internalCache()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">ConnectInterceptor</span>(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">CallServerInterceptor</span>(forWebSocket));</span><br><span class="line">    Interceptor.<span class="type">Chain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">        interceptors, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，首先，他会将客户端的 interceptors 添加到 List 当中，接着，再添加 okhttp 里面的 interceptor，然后构建了一个 RealInterceptorChain 对象，并将我们的 List<Interceptor> 作为成员变量，最后调用 RealInterceptorChain 的 proceed 方法。</p><p>其中，client.interceptors() 为我们自己添加的请求拦截器，通常是做一些添加统一的token之类操作。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/4122684-67fcdd5d7e5f984e.jpg" alt="其余较重要的拦截器" /></p><p><strong>RetryAndFollowUpInterceptor 拦截器</strong></p><ul><li>RetryAndFollowUpInterceptor 此拦截器顾名思义就是主要负责失败重连工作，但是并不是所有的网络请求都会进行失败重连的,在此拦截器内部会进行网络请求的异常检测和响应码的判断,如果都在限制范围内,那么就可以进行失败重连。</li><li>一个循环来不停的获取response。每循环一次都会获取下一个request，如果没有，则返回response，退出循环。而获取下一个request的逻辑，是根据上一个response返回的状态码，分别作处理。</li></ul><p><strong>桥接拦截器</strong></p><ol><li>请求从应用层数据类型类型转化为网络调用层的数据类型。</li><li>将网络层返回的数据类型 转化为 应用层数据类型。</li></ol><p><strong>CacheInterceptor 拦截器</strong></p><ul><li>作用：将HTPTP和HTTPS的网络返回数据缓存到文件系统中，以便在服务端数据没发生变化的情况下复用，节省时间和带宽；</li></ul><p><strong>连接拦截器 和 最后的请求服务器的拦截器</strong></p><p>这两个连接器基本上完成了最后发起网络请求的工作。</p><h1 id="addinterceptor-和-addnetworkdinterceptor区别"><a class="markdownIt-Anchor" href="#addinterceptor-和-addnetworkdinterceptor区别"></a> <code>addInterceptor</code> 和 <code>addNetworkdInterceptor</code>区别</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/OneDeveloper/article/details/88381817">okhttp3 读书笔记——默认的线程池，addNetworkInterceptor() 与 addInterceptor() 的区别，复用连接池_OneDeveloper的博客-CSDN博客_okhttp 默认线程数</a></li></ul></blockquote><p>从上文构造拦截器链的过程，可以看到，通过 <code>addInterceptor()</code> 方法添加的拦截器是放在最前面的。</p><p>而通过 <code>addNetworkInterceptor()</code> 方法添加的网络拦截器，则是在非 WebSocket 请求时，添加在 ConnectInterceptor 和 CallServerInterceptor 之间的。</p><p><strong><font size="4">addInterceptor（应用拦截器）</font></strong></p><ol><li>不需要担心中间过程的响应,如重定向和重试.</li><li>总是只调用一次,即使HTTP响应是从缓存中获取.</li><li>观察应用程序的初衷. 不关心OkHttp注入的头信息如: If-None-Match.</li><li>允许短路而不调用 Chain.proceed(),即中止调用.</li><li>允许重试,使 Chain.proceed()调用多次.</li></ol><p><strong><font size="4">addNetworkInterceptor（网络拦截器）</font></strong></p><ol><li>能够操作中间过程的响应,如重定向和重试.</li><li>当网络短路而返回缓存响应时不被调用.</li><li>只观察在网络上传输的数据.</li><li>携带请求来访问连接.</li></ol><h1 id="okhttp责任链模式"><a class="markdownIt-Anchor" href="#okhttp责任链模式"></a> <code>OkHttp</code>责任链模式</h1><p><strong><font size="4">proceed()</font></strong></p><blockquote><p><code>proceed</code> <code>v.</code>继续做（或从事、进行）；接着做；继而做；行进</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Response <span class="title function_">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span><br><span class="line"><span class="params">                        Connection connection)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  生成 list 当中下一个 interceptot 的 chain 对象</span></span><br><span class="line">    <span class="type">RealInterceptorChain</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">        interceptors, streamAllocation, httpCodec, connection, index + <span class="number">1</span>, request);</span><br><span class="line">    <span class="comment">// 当前的 interceptor</span></span><br><span class="line">    <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors.get(index);</span><br><span class="line">    <span class="comment">// 当前的 intercept 处理下一个 intercept 包装的 chain 对象</span></span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proceed 方法也很简单，proceed方法每次从拦截器列表中取出拦截器，并调用 interceptor.intercept(next)。</p><p>熟悉 Okhttp 的应该都知道，我们在 addInterceptor 创建 Interceptor 实例，最终都会调用 chain.proceed(Request request),从而形成一种链式调用。这种便是责任链设计模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().addInterceptor(<span class="keyword">new</span> <span class="title class_">Interceptor</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> chain.request();</span><br><span class="line">        Request.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> request.newBuilder().addHeader(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(builder.build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).build();</span><br></pre></td></tr></table></figure><p>而 OkHttp 是怎样结束循环调用的，这是因为最后一个拦截器 CallServerInterceptor 并没有调用 chain.proceed(request)，所以能够结束循环调用。</p><h1 id="okhttp缓存怎么处理"><a class="markdownIt-Anchor" href="#okhttp缓存怎么处理"></a> <code>OkHttp</code>缓存怎么处理</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/00d281c226f6">Okhttp解析（五）缓存的处理 - 简书 (jianshu.com)</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 2022校招面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
            <tag> OkHttp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVC &amp; MVP &amp; MVVM - Android校招面试整理2022</title>
      <link href="/posts/95756e730237/"/>
      <url>/posts/95756e730237/</url>
      
        <content type="html"><![CDATA[<h1 id="mvc及其优缺点"><a class="markdownIt-Anchor" href="#mvc及其优缺点"></a> <code>MVC</code>及其优缺点</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/sunforraining/article/details/79015080">MVC的理解和优缺点的总结_sunforraining的博客-CSDN博客_mvc的缺点</a></li><li><a href="https://zhuanlan.zhihu.com/p/35680070">深入理解MVC - 知乎 (zhihu.com)</a></li></ul></blockquote><p><strong><font size="5">概念</font></strong></p><p>MVC全名是Model-View-Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-30f72a70d6d84065d2147754bf2ad59f_1440w.jpg" alt="深入理解MVC" style="zoom: 50%;" /><p>MVC开始是存在于桌面程序中的，M是指业务模型，V是指用户界面，C则是控制器，使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。C存在的目的则是确保M和V的同步，一旦M改变，V应该同步更新。更好的调节M和V的搭配。</p><p>MVC是一种框架模式，说到底是一种框架，而不是一种设计模式，框架通常是代码重用，而设计模式是设计重用，而架构则介于两者之间，部分代码重用，部分设计重用，有时分析也可重用。</p><p><strong><font size="5">优点</font></strong></p><p>分层，结构清晰，耦合性低，大型项目代码的复用性得到极大的提高，开发人员分工明确，提高了开发的效率，维护方便，降低了维护成本。</p><p><strong><font size="5">缺点</font></strong></p><p>简单的小型项目，使用MVC设计反而会降低开发效率，层和层虽然相互分离，但是之间关联性太强，没有做到独立的重用。</p><h1 id="mvp及其优缺点"><a class="markdownIt-Anchor" href="#mvp及其优缺点"></a> <code>MVP</code>及其优缺点</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://juejin.cn/post/6844903752588066830">MVP 与 MVVM 优缺点总结 - 掘金 (juejin.cn)</a></li></ul></blockquote><p><strong><font size="5">概念</font></strong></p><p>实际上按照代码在 App 中所处位置，描述为 VPM 更合适，即 View -&gt; Presenter -&gt; Model：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/4/16818bbae077f9e3~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" /></p><p>这个架构的核心就是 View 与 Presenter 都被抽象成了接口，是面向接口编程的一个实践。因为面向接口，所以实现了依赖隔离，即无需知道具体的 Class 类型。</p><p><strong><font size="5">优点</font></strong></p><ol><li><strong>模块职责划分明显</strong>,层次清晰,接口功能清晰，遵循了单一职责类的设计原则，提升了代码的可维护性.</li><li><strong>降低耦合度</strong>，Model层和View层分离,解耦.修改View而不影响Model.</li><li><strong>功能复用度高</strong>,方便.一个Presenter可以复用于多个View,而不用更改Presenter的逻辑.</li><li><strong>有利于测试驱动开发</strong>,以前的Android开发是难以进行单元测试.</li><li><strong>代码灵活性</strong>，如果后台接口还未写好,但已知返回数据类型的情况下,完全可以写出此接口完整的功能.</li></ol><p><strong><font size="5">缺点</font></strong></p><ol><li>其实这并不是 MVP 架构的痛点，而是整个 Android App 开发的痛点，那就是对 UI 的操作必须在 Activity 与 Fragment 的生命周期之内，更细致一点，最好在 <code>onStart()</code> 之后 <code>onPause()</code>之前，否则极其容易出现各种异常。而 MVP 架构中，Presenter 对 Activity 与 Fragment 的生命周期是无感知的，所以我们需要手动添加相应的生命周期方法，并进行特殊处理，以避免出现异常或内存泄露。</li><li>MVP中接口过多.</li><li>每一个功能,相比于MVC要多写好几个文件.</li><li>如果某一个界面中需要请求多个服务器接口,这个界面文件中会实现很多的回调接口,导致代码繁杂.</li><li>如果更改了数据源和请求中参数,会导致更多的代码修改.<br />额外的代码复杂度及学习成本.</li><li>由于对视图的渲染放在了Presenter中，所以视图和Presenter的交互会过于频繁。还有一点需要明白，如果Presenter过多地渲染了视图，往往会使得它与特定的视图的联系过于紧密。一旦视图需要变更，那么Presenter也需要变更了。</li></ol><h1 id="mvvm及其优缺点"><a class="markdownIt-Anchor" href="#mvvm及其优缺点"></a> <code>MVVM</code>及其优缺点</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://juejin.cn/post/6844903752588066830">MVP 与 MVVM 优缺点总结 - 掘金 (juejin.cn)</a></li></ul></blockquote><p><strong><font size="5">概念</font></strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/254216d2594c43b3813739c5d0ecf0cd.png" alt="img" style="zoom:67%;" /><p>View可以独立于Model变化和修改，一个ViewModel可以绑定到不同的&quot;View&quot;上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p><p>在MVVM中，数据是核心，由于ViewModel与View之间的双向绑定，操作了ViewModel中的数据，就会同步到DOM，我们透过DOM事件监控用户对DOM的改动，也会同步到ViewModel。</p><p>MVVM 架构相对复杂，核心是 LifecycleOwner、LifecycleObserver、LifecycleRegistry 组件，在此之上，Google 还开发了 DataBinding、ViewModel、LiveData 以实现完整的 MVVM 架构。相关组件已收纳至 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Farch%2F">JetPack Architecture</a> 中。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/16818b1814a8a3f8.png" alt="img" /></p><p>这个架构的核心就是 ViewModel 和 LiveData。ViewModel 的作用是保证当设备因配置改变而重新创建 FragmentActivity(目前 ViewModel 仅支持 FragmentActivity 和 Fragment) 时，数据也不会丢失。LiveData 的作用是保证只在 FragmentActivity 或 Fragment 的生命周期状态为 [onStarted, onResumed] 时，回调 onChanged(T data)，所以我们可以在 onChanged() 中安全的更新 UI。下面简单介绍源码中是如何实现的：</p><p><strong><font size="5">优点</font></strong></p><ul><li><p>ViewModel：因设备配置改变导致 Activity 重建时，无需从 Model 中再次加载数据，减少了 IO 操作</p></li><li><p>LiveData：更新 UI 时，不用再关注生命周期问题</p></li><li><p>Data Binding： 可以有效减少模板代码的编写，而且目前已经支持双向绑定 (注意：不是所有的 UI 都需要使用 Data Binding，虽然通过 @BindingAdapter 我们真的可以“为所欲为”，最好还是只用于需要绑定 Bean 类的布局)</p></li></ul><p><strong><font size="5">缺点</font></strong></p><ul><li>LiveData 本身是没有 public 方法的，所以我们应该使用其子类 MutableLiveData。这样设计，我们就可以在 Model 中使用 MutableLiveData，在 ViewModel 中，只对 View 提供 LiveData，避免 View 去更新 LiveData。</li></ul><h1 id="mvp如何防止内存泄漏"><a class="markdownIt-Anchor" href="#mvp如何防止内存泄漏"></a> <code>MVP</code>如何防止内存泄漏</h1><ul><li><p>在<code>BasePresenter</code>中使用对<code>View</code>的弱引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BasePresenter</span>&lt;M <span class="keyword">extends</span> <span class="title class_">BaseModel</span>, V <span class="keyword">extends</span> <span class="title class_">BaseView</span>, CONTRACT&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> M m;</span><br><span class="line">    <span class="keyword">protected</span> WeakReference&lt;V&gt; weakReference;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BasePresenter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.m = getModel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">bindView</span><span class="params">(V v)</span> &#123;</span><br><span class="line">        weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">unbindView</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (weakReference != <span class="literal">null</span>) &#123;</span><br><span class="line">            weakReference.clear();</span><br><span class="line">            weakReference = <span class="literal">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> V <span class="title function_">getView</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (weakReference != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> weakReference.get();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> CONTRACT <span class="title function_">getContract</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> M <span class="title function_">getModel</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>BaseView</code>中<code>onCreate</code>和<code>onDestory</code>方法中主动绑定和解绑<code>Presenter</code>，防止内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseView</span>&lt;P <span class="keyword">extends</span> <span class="title class_">BasePresenter</span>, CONTRACT&gt; <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> P p;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        p = getPresenter();</span><br><span class="line">        p.bindView(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        p.unbindView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> P <span class="title function_">getPresenter</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> CONTRACT <span class="title function_">getContract</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> TODO</h1><ol><li>MVP如何管理Presenter的生命周期，何时取消网络请求</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 2022校招面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Service - Android校招面试整理2022</title>
      <link href="/posts/94ccd61d6796/"/>
      <url>/posts/94ccd61d6796/</url>
      
        <content type="html"><![CDATA[<h1 id="service-的生命周期两种启动方式的区别"><a class="markdownIt-Anchor" href="#service-的生命周期两种启动方式的区别"></a> <code>Service</code> 的生命周期，两种启动方式的区别</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/jisheng/archive/2011/12/13/2286262.html">Service生命周期 - Hecker385 - 博客园 (cnblogs.com)</a></li><li><a href="https://www.cnblogs.com/Lwenlong/p/15939996.html">Android面试——Service篇 - 向着内核前进！ - 博客园 (cnblogs.com)</a></li><li><a href="https://www.jianshu.com/p/a58780595d2b">Service-服务(一)生命周期及使用方式 - 简书 (jianshu.com)</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/15821503-f7f98e2e43fa178b.png" alt="img" /></p><h2 id="使用contextstartservice-启动service"><a class="markdownIt-Anchor" href="#使用contextstartservice-启动service"></a> <strong>使用<code>context.startService</code> 启动<code>Service</code></strong></h2><p>其生命周期为<em>context.startService()</em> -&gt; <code>onCreate()</code>- &gt; <code>onStartCommand()</code>-&gt; <strong>Service</strong> <strong>running</strong> -&gt; <em>context.stopService()</em> | -&gt; <code>onDestroy()</code> -&gt; <strong>Service</strong> <strong>stop</strong></p><ol><li>如果<code>Service</code>还没有运行，则<code>Android</code>先调用<code>onCreate()</code>然后调用onStart()；</li><li>如果<code>Service</code>已经运行，则只调用<code>onStartCommand()</code>，所以一个<code>Service</code>的<code>onStartCommand</code>方法可能会重复调用多次。</li></ol><p><code>stopService</code>的时候直接<code>onDestroy</code>，如果是调用者自己直接退出而没有调用<code>stopService</code>的话，<code>Service</code>会一直在后台运行。该Service的调用者再启动起来后可以通过<code>stopService</code>关闭<code>Service</code>。</p><p><strong>所以调用<code>startService</code>的生命周期为：<code>onCreate</code> --&gt; <code>onStartCommand</code>(可多次调用) --&gt; <code>onDestroy</code></strong>。</p><h2 id="对于bindservice启动service会经历"><a class="markdownIt-Anchor" href="#对于bindservice启动service会经历"></a> <strong>对于<code>bindService</code>启动<code>Service</code>会经历：</strong></h2><p><em>context.bindService()</em> -&gt; <code>onCreate()</code>-&gt; <code>onBind()</code> -&gt;<strong>Service running</strong> -&gt; <code>onUnbind()</code> -&gt; <code>onDestroy()</code> -&gt; <strong>Service stop</strong></p><p><code>onBind</code>将返回给客户端一个<code>IBind</code>接口实例，<code>IBind</code>允许客户端回调服务的方法，比如得到<code>Service</code>运行的状态或其他操作。</p><p>这个时候把调用者（<code>Context</code>，例如<code>Activity</code>）会和<code>Service</code>绑定在一起，<code>Context</code>退出了，<code>Srevice</code>就会调用<code>onUnbind</code> -&gt; <code>onDestroy</code>相应退出。</p><p><strong>所以调用<code>bindService</code>的生命周期为：<code>onCreate</code> --&gt; <code>onBind</code>(只一次，不可多次绑定) --&gt; <code>onUnbind</code> --&gt; <code>onDestory</code>。</strong></p><p>一但销毁<code>activity</code>它就结束，如果按<code>home</code>把它放到后台，那他就不退出。</p><p><strong><font size="4">补充</font></strong></p><p>在Service每一次的开启关闭过程中，只有<code>onStartCommand</code>可被多次调用(通过多次<code>startService</code>调用)，<br />其他<code>onCreate</code>，<code>onBind</code>，<code>onUnbind</code>，<code>onDestory</code>在一个生命周期中只能被调用一次。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 2022校招面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
            <tag> Service </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ContentProvider - Android校招面试整理2022</title>
      <link href="/posts/bb5f9e1a55ea/"/>
      <url>/posts/bb5f9e1a55ea/</url>
      
        <content type="html"><![CDATA[<blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/Lwenlong/p/15941998.html">Android面试——ContentProvider篇 - 向着内核前进！ - 博客园 (cnblogs.com)</a></li></ul></blockquote><h1 id="什么是contentprovider及其使用"><a class="markdownIt-Anchor" href="#什么是contentprovider及其使用"></a> 什么是<code>ContentProvider</code>及其使用</h1><ol><li><p><code>ContentProvider</code>通过Uri标识其他应用要访问的数据；</p></li><li><p>通过<code>ContentResolver</code>的增删改查方法实现对共享的数据的操作；</p></li><li><p>通过注册<code>ContentObserver</code>来监听数据是否发生了变化来对应的刷新页面</p></li></ol><p><strong><font size="4">作用</font></strong></p><p>为不同应用之间的数据共享提供统一的接口</p><h1 id="contentprovidercontentresolvercontentobserver之间的关系"><a class="markdownIt-Anchor" href="#contentprovidercontentresolvercontentobserver之间的关系"></a> <code>ContentProvider</code>,<code>ContentResolver</code>,<code>ContentObserver</code>之间的关系</h1><ol><li><p><code>ContentProvider</code></p><p>内容提供者：管理数据，提供数据的增删改查操作，数据源可以是数据库，文件，<code>xml</code>，网络等。</p></li><li><p><code>ContentResolver</code></p><p>内容解析者：外部进程通过内容解析者与内容提供者进行交互。</p></li><li><p><code>ContentObserver</code></p><p>内容观察者：观察内容提供者的数据变化，并将变化通知给外界。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 2022校招面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
            <tag> ContentProvider </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BroadcastReceiver - Android校招面试整理2022</title>
      <link href="/posts/90a21a97c0cb/"/>
      <url>/posts/90a21a97c0cb/</url>
      
        <content type="html"><![CDATA[<h1 id="广播的分类和使用场景"><a class="markdownIt-Anchor" href="#广播的分类和使用场景"></a> 广播的分类和使用场景</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/Lwenlong/p/15940123.html">Android面试——BroadcastReceiver篇 - 向着内核前进！ - 博客园 (cnblogs.com)</a></li></ul></blockquote><p><strong><font size="4">分类</font></strong></p><ol><li><p>普通广播：通过Context.sendBroadcast()发送，可并行处理</p></li><li><p>系统广播：系统发送的广播，只需要注册广播接收器，并定义好action等待接收广播</p></li><li><p>有序广播：发出的广播会被接收器按照先后顺序进行接收，发送方式为sendOrderedBroadcast(intent)； 广播接受者接收的顺序规则：按照Priority属性值排序，Priority相同者，动态注册的广播优先；</p></li><li><p>APP应用内广播（Local Broadcast）：由于广播可以跨进程的特性，导致应用可能不断收到来自其他应用的广播，或者别的应用接收到当前应用的私密广播；解决方法为使用应用内广播；也称局部广播，接收者和发送者同属于一个APP，</p></li></ol><p><strong><font size="4">使用方法</font></strong></p><ul><li><p>方法1：注册广播时设置exported属性为false；在广播发送接收时，增加权限，用于权限验证；发送广播时执行广播接收器的包名</p></li><li><p>方法2：使用封装好的LocalBroadcastManager,这种方式的广播只能动态注册，不能静态注册</p></li></ul><p><strong><font size="4">使用场景</font></strong></p><ul><li><p>同一 App 内部的不同组件之间的消息通信（单个进程）；</p></li><li><p>不同 App 之间的组件之间消息通信；</p></li><li><p>Android系统在特定情况下与App之间的消息通信，如：网络变化、电池电量、屏幕开关等；</p></li></ul><h1 id="广播的两种注册方式的区别"><a class="markdownIt-Anchor" href="#广播的两种注册方式的区别"></a> 广播的两种注册方式的区别</h1><ul><li><p>静态注册</p><p>常驻系统，不受组件生命周期影响，即便应用退出，广播还是可以被接收，耗电、占内存。</p></li><li><p>动态注册</p><p>非常驻，跟随组件的生命变化，组件结束，广播结束。在组件结束前，需要先移除广播，否则容易造 成内存泄漏。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 2022校招面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
            <tag> Broadcast </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fragment - Android校招面试整理2022</title>
      <link href="/posts/b9e5d151a0cc/"/>
      <url>/posts/b9e5d151a0cc/</url>
      
        <content type="html"><![CDATA[<h1 id="fragment的生命周期"><a class="markdownIt-Anchor" href="#fragment的生命周期"></a> <code>Fragment</code>的生命周期</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/70d7bfae18f3">Fragment 生命周期和使用 - 简书 (jianshu.com)</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/1688279-0424d62f50035b43.png" alt="img" /></p><p>可以看到 Fragment 的生命周期和 Activity 很相似，只是多了一下几个方法：</p><ol><li><p><strong>onAttach()</strong></p><p>在Fragment 和 Activity 建立关联时调用（Activity 传递到此方法内）。</p></li><li><p><strong>onCreateView()</strong></p><p>当Fragment 创建视图时调用。</p></li><li><p><strong>onActivityCreated()</strong></p><p>在相关联的 Activity 的 onCreate() 方法已返回时调用。</p></li><li><p><strong>onDestroyView()</strong></p><p>当Fragment中的视图被移除时调用。</p></li><li><p><strong>onDetach()</strong></p><p>当Fragment 和 Activity 取消关联时调用。</p></li></ol><p>几种操作情况下Fragment 的生命周期变化</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/1688279-e34d09c9351c7084.png" alt="img" style="zoom:80%;" /><h1 id="结合activity的生命周期"><a class="markdownIt-Anchor" href="#结合activity的生命周期"></a> 结合<code>Activity</code>的生命周期</h1><p>管理 Fragment 生命周期和 Activity 生命周期很相似，同时 Activity 的生命周期对 Fragment 的生命周期也有一定的影响，如下图所示。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/1688279-e513845a80659860.png" alt="img" /></p><p>用下图（<a href="https://www.jianshu.com/p/184f0c8857d6">来源</a>）来表示 Activity 和 Fragment 的生命周期变化的先后过程是:</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/1688279-020ad51ed5443cce.png" alt="img" style="zoom:80%;" /><p>Fragment 生命周期与 Activity 生命周期的一个关键区别就在于，Fragment 的生命周期方法是由托管Activity而不是操作系统调用的。Activity 中生命周期方法都是 protected，而 Fragment 都是 public，也能印证了这一点，因为 Activity 需要调用 Fragment 那些方法并管理它。</p><h1 id="activity和fragment的通信方式"><a class="markdownIt-Anchor" href="#activity和fragment的通信方式"></a> <code>Activity</code>和<code>Fragment</code>的通信方式</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://developer.aliyun.com/article/637559">Fragment与Activity之间的通信-阿里云开发者社区 (aliyun.com)</a></li></ul></blockquote><p><strong>将Fragment添加到Activity之后，Fragment必须与Activity交互信息，这就需要Fragment能获取它所在的Activity，Activity也能获取它所包含的任意的Fragment。</strong></p><ul><li><p><strong><font size="4">Fragment获取它所在的Activtiy</font></strong></p><p>调用Fragment的getActivity()方法即可返回它所在的Activity。</p></li><li><p><strong><font size="4">Activity获取它包含的Fragment</font></strong></p><p>调用Activity关联的FragmentManager的findFragmentById(int id)或findFragmentByTag(String tag)方法即可获取指定的Fragment。</p></li></ul><p><strong>除此之外，Fragment与Activity可能还需要相互传递数据，可按如下方式进行。</strong></p><ul><li><p><strong><font size="4">Activity向Fragment传递数据</font></strong></p><p>在Activity中创建Bundle数据包，并调用Fragment的<strong>setArguments</strong>(Bundle bundle)方法即可将Bundle数据包传给Fragment。</p></li><li><p><strong><font size="4">Fragment向Activity传递数据或Activity需要在Fragment运行中进行实时通信</font></strong></p><p>在Fragment中定义一个<strong>内部回调接口</strong>，再让包含该Fragment的Activity实现该回调接口，这样Fragment即可调用该回调方法将数据传给Activity。</p></li></ul><p><strong>使用 FragmentManager 还可以执行的操作包括：</strong></p><ul><li>通过 findFragmentById 或 findFragmentByTag 获取 activity 中存在的 fragment 的实例</li><li>通过 popBackStack （<em>模拟用户点击返回按钮操作</em>）将 fragment 从返回栈中弹出</li><li>通过 addOnBackStackChangedListener() 注册一个监听返回栈改变的监听器</li><li>像上边生成 fragmentTransaction 的方法，可以使用 fragmentManager 生成一个 fragmentTransaction 来执行某些事务，比如添加、替换、移除、addToBackStack()等。</li></ul><h1 id="fragment之间如何进行通信"><a class="markdownIt-Anchor" href="#fragment之间如何进行通信"></a> <code>Fragment</code>之间如何进行通信</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh-cn#sharing">ViewModel 概览  | Android 开发者  | Android Developers (google.cn)</a></li></ul></blockquote><p>Activity 中的两个或更多 Fragment 需要相互通信是一种很常见的现象。想象一下拆分视图 (<code>list-detail</code>) Fragment 的常见情况，假设您有一个 Fragment，在该 Fragment 中，用户从列表中选择一项，还有另一个 Fragment，用于显示选定项的内容。这种情况不太容易处理，因为这两个 Fragment 都需要定义某种接口描述，并且所有者 Activity 必须将两者绑定在一起。此外，这两个 Fragment 都必须处理另一个 Fragment 尚未创建或不可见的情况。</p><p>可以使用 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel?hl=zh-cn"><code>ViewModel</code></a> 对象解决这一常见的难点。这两个 fragment 可以使用其 activity 范围共享 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel?hl=zh-cn"><code>ViewModel</code></a> 来处理此类通信，如以下示例代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharedViewModel</span> <span class="keyword">extends</span> <span class="title class_">ViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;Item&gt; selected = <span class="keyword">new</span> <span class="title class_">MutableLiveData</span>&lt;Item&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        selected.setValue(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LiveData&lt;Item&gt; <span class="title function_">getSelected</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> selected;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SharedViewModel model;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewCreated</span><span class="params">(<span class="meta">@NonNull</span> View view, Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">        model = <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>(requireActivity()).get(SharedViewModel.class);</span><br><span class="line">        itemSelector.setOnClickListener(item -&gt; &#123;</span><br><span class="line">            model.select(item);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DetailFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewCreated</span><span class="params">(<span class="meta">@NonNull</span> View view, Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">        <span class="type">SharedViewModel</span> <span class="variable">model</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>(requireActivity()).get(SharedViewModel.class);</span><br><span class="line">        model.getSelected().observe(getViewLifecycleOwner(), item -&gt; &#123;</span><br><span class="line">           <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，这两个 Fragment 都会检索包含它们的 Activity。这样，当这两个 Fragment 各自获取 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModelProvider?hl=zh-cn"><code>ViewModelProvider</code></a> 时，它们会收到相同的 <code>SharedViewModel</code> 实例（其范围限定为该 Activity）。</p><p>此方法具有以下优势：</p><ul><li>Activity 不需要执行任何操作，也不需要对此通信有任何了解。</li><li>除了 <code>SharedViewModel</code> 约定之外，Fragment 不需要相互了解。如果其中一个 Fragment 消失，另一个 Fragment 将继续照常工作。</li><li>每个 Fragment 都有自己的生命周期，而不受另一个 Fragment 的生命周期的影响。如果一个 Fragment 替换另一个 Fragment，界面将继续工作而没有任何问题。</li></ul><h1 id="为什么使用fragmentsetargumentsbundle传递参数"><a class="markdownIt-Anchor" href="#为什么使用fragmentsetargumentsbundle传递参数"></a> 为什么使用<code>Fragment.setArguments(Bundle)</code>传递参数</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/tu_bingbing/article/details/24143249">Android解惑 - 为什么要用Fragment.setArguments(Bundle bundle)来传递参数_pobi的博客-CSDN博客_fragment setarguments</a></li><li><a href="https://www.jianshu.com/p/c06efe090589">为什么要通过Fragment.setArguments(Bundle)传递参数 - 简书 (jianshu.com)</a></li></ul></blockquote><p>当我们实例化自定义Fragment时，为什么官方推荐Fragment.setArguments(Bundle bundle)这种方式来传递参数，而不推荐通过构造方法直接来传递参数呢？</p><p><strong>方式一：通过构造方法传递参数</strong></p><p>在创建Fragment的时候，使用 MyFragment fragment = new MyFragment(parameter) 来传递参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyFragment</span><span class="params">(Parameter p)</span>&#123;</span><br><span class="line">        <span class="comment">//将参数保存起来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式二：通过Fragment.setArguments(Bundle)传递参数</strong></p><p>在创建Fragment的时候，使用MyFragment fragment = MyFragment.newInstance(paramter) 来传递参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyFragment <span class="title function_">newInstance</span><span class="params">(Parameter p)</span> &#123;</span><br><span class="line">        <span class="type">MyFragment</span> <span class="variable">myFragment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyFragment</span>();</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">args</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">        args.putInt(<span class="string">&quot;someParameter&quot;</span>, p);</span><br><span class="line">        myFragment.setArguments(args);</span><br><span class="line">        <span class="keyword">return</span> myFragment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论</strong></p><p>我们可以知道Activity重新创建时，会重新构建它所管理的Fragment，原先的Fragment的字段值将会全部丢失，但是通过 Fragment.setArguments(Bundle bundle)方法设置的bundle会保留下来。所以尽量使用Fragment.setArguments(Bundle bundle)方式来传递参数。</p><h1 id="fragment嵌套问题"><a class="markdownIt-Anchor" href="#fragment嵌套问题"></a> <code>Fragment</code>嵌套问题</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/yzwfeng/article/details/123535473">Android开发-Fragment嵌套Fragment的使用及常见错误_有点料的博客-CSDN博客_fragment 嵌套</a></li></ul></blockquote><p>嵌套Fragments (Nested Fragments), 是在Fragment内部又添加Fragment。</p><p><strong>使用时, 主要要依靠宿主Fragment的 getChildFragmentManager() 来获取FragmentManger。</strong> 虽然看起来和在activity中添加fragment差不多, 但因为fragment生命周期及管理恢复模式不同, 其中有一些需要特别注意的地方。</p><p>本文内容还包括了从Fragment迁移到v4.Fragment代码中需要改动的一些地方.</p><p><strong><font size="4">嵌套Fragments</font></strong></p><p>嵌套Fragments 是Android 4.2 API 17 引入的.</p><p>目的: 进一步增强动态复用。</p><p><strong><font size="4">嵌套Fragment的动态添加</font></strong></p><p>在宿主fragment里调用getChildFragmentManager()</p><p>即可用它来向这个fragment内部添加fragments。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Fragment</span> <span class="variable">videoFragment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VideoPlayerFragment</span>();</span><br><span class="line"><span class="type">FragmentTransaction</span> <span class="variable">transaction</span> <span class="operator">=</span> getChildFragmentManager().beginTransaction();</span><br><span class="line">transaction.add(R.id.video_fragment, videoFragment).commit();</span><br></pre></td></tr></table></figure><p><strong>同样, 对于内部的fragment来说, getParentFragment() 方法可以获取到fragment的宿主fragment.</strong></p><p><strong><font size="4">getChildFragmentManager() 和 getFragmentManager()</font></strong></p><p>getChildFragmentManager()是fragment中的方法, 返回的是管理当前fragment内部子fragments的manager.</p><p><strong>getFragmentManager()在activity和fragment中都有。</strong></p><p>在activity中, 如果用的是v4 support库, 方法应该用getSupportFragmentManager(), 返回的是管理activity中fragments的manager.</p><p><strong>在fragment中, 调用getFragmentManager(), 返回的是把自己加进来的那个manager.</strong></p><p>也即, 如果fragment在activity中, fragment.getFragmentManager()得到的是activity中管理fragments的那个manager.<br />如果fragment是嵌套在另一个fragment中, fragment.getFragmentManager()得到的是它的parent的getChildFragmentManager()。</p><p><strong>总结就是: getFragmentManager()是本级别管理者, getChildFragmentManager()是下一级别管理者。这实际上是一个树形管理结构。</strong></p><h1 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> TODO</h1><ol><li><code>FragmentPageAdapter</code>和<code>FragmentStatePageAdapter</code>区别及使用场景</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 2022校招面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
            <tag> Fragment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过注册表在微软输入法中加载小鹤双拼</title>
      <link href="/posts/66c4123f82e6/"/>
      <url>/posts/66c4123f82e6/</url>
      
        <content type="html"><![CDATA[<h1 id="效果"><a class="markdownIt-Anchor" href="#效果"></a> 效果</h1><p>在微软拼音输入法中快速使用小鹤双拼。</p><h1 id="操作步骤"><a class="markdownIt-Anchor" href="#操作步骤"></a> 操作步骤</h1><ol><li><p>通过<code>Win + R</code>，输入<code>regedit</code>打开注册表编辑器。</p></li><li><p>通过左侧的各级文件夹，到达<code>HKEY_CURRENT_USER\SOFTWARE\Microsoft\InputMethod\Settings\CHS</code>路径。</p></li><li><p>通过修改右侧的值项，来加载小鹤双拼输入法。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220107194851414.png" alt="image-20220107194851414" /></p></li></ol><p><strong>各项值：</strong></p><table><thead><tr><th>名称</th><th>类型</th><th>数据</th></tr></thead><tbody><tr><td><code>DoublePinyinScheme</code></td><td><code>DWORD</code></td><td><code>0x0000000a</code></td></tr><tr><td><code>Enable Double Pinyin</code></td><td><code>DWORD</code></td><td><code>0x00000001</code></td></tr><tr><td><code>EnableExtraDomainType</code></td><td><code>DWORD</code></td><td><code>0x00000001</code></td></tr><tr><td><code>UserDefinedDoublePinyinScheme0</code></td><td><code>SZ</code></td><td><code>小鹤双拼*2*^*iuvdjhcwfgrxmlnpbksqszxkrltvyovt</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Windows OS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>通过 AutoHotKey 简化 Hexo 操作</title>
      <link href="/posts/050a11a7817a/"/>
      <url>/posts/050a11a7817a/</url>
      
        <content type="html"><![CDATA[<blockquote><p>功能持续更新中！</p></blockquote><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>通过 <code>AutoHotKey</code> 编写可视化界面以解决每一次部署博客都需要输入命令的情况。</p><p>使用的  <code>AutoHotKey</code> 版本：1.33</p><h1 id="效果"><a class="markdownIt-Anchor" href="#效果"></a> 效果</h1><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220522225631.png?x-oss-process=style/watermark" style="zoom: 50%;" /><p><strong>功能介绍：</strong></p><ol><li><p><strong>Open Blog</strong></p><p>打开自己的博客。</p></li><li><p><strong>New Post</strong></p><p>新建博文，点击后会弹出如下窗口：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220522225716.png?x-oss-process=style/watermark" style="zoom: 50%;" /><p>在输入窗口中可以输入文章的标题，确认后会创建<code>.md</code>文件并打开。</p></li><li><p><strong>Open Root Folder</strong></p><p>打开根目录文件夹。</p></li><li><p><strong>Open Post Folder</strong></p><p>打开已发布文章的文件夹。</p></li><li><p><strong>Open Draft Folder</strong></p><p>打开草稿文章文件夹。</p></li><li><p><strong>Clean &amp; Generate &amp; Server</strong></p><p>部署到本地。</p></li><li><p><strong>Clean &amp; Generate &amp; Deploy</strong></p><p>部署到服务器（适用于对文章做出结构性更改）。</p></li><li><p><strong>Generate &amp; Deploy</strong></p><p>部署到服务器（适用于仅对文章内容做出更改）。</p></li><li><p><strong>Deploy</strong></p><p>部署到服务器（适用于部署失败时重新部署）。</p></li></ol><h1 id="实现步骤"><a class="markdownIt-Anchor" href="#实现步骤"></a> 实现步骤</h1><h2 id="下载-autohotkey"><a class="markdownIt-Anchor" href="#下载-autohotkey"></a> 下载 <code>AutoHotKey</code></h2><p>到 <a href="https://www.autohotkey.com/"><code>AutoHotKey</code> 官网</a>自行下载。</p><h2 id="新建-ahk-文件并复制以下代码"><a class="markdownIt-Anchor" href="#新建-ahk-文件并复制以下代码"></a> 新建 <code>.ahk</code> 文件并复制以下代码</h2><ol><li><p>桌面空白处鼠标右键 &gt;&gt; 新建 &gt;&gt; <code>AutoHotKey Script</code>。</p></li><li><p>对新建的<code>ahk</code>文件右键 &gt;&gt; <code>Edit Script</code>。</p></li><li><p>进入编辑界面后复制以下代码：</p></li></ol><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#SingleInstance, Force</span></span><br><span class="line"></span><br><span class="line">blogSite := <span class="string">&quot;https://XXX.github.io/&quot;</span> <span class="comment">; 更改为自己的博客网址</span></span><br><span class="line">rootFolderPath := <span class="string">&quot;E:\XXX\HexoBlog&quot;</span> <span class="comment">; 更改为自己的博客根目录地址</span></span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">SetWorkingDir,</span> <span class="variable">%rootFolderPath%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 控件添加</span></span><br><span class="line"><span class="built_in">Gui,</span> Add, Text , w200 h27 center section , `nHexo Blog Updater </span><br><span class="line"><span class="built_in">Gui,</span> Add, Text , w200 <span class="number">0</span>x10 <span class="comment">; 横向分割线</span></span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , <span class="keyword">New</span> Post</span><br><span class="line"><span class="built_in">Gui,</span> Add, Text , w200 <span class="number">0</span>x10 </span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Open Root Folder</span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Open Post Folder</span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Open Draft Folder</span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 ys , Open Blog</span><br><span class="line"><span class="built_in">Gui,</span> Add, Text , w200 <span class="number">0</span>x10</span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Clean &amp;&amp; Generate &amp;&amp; Server</span><br><span class="line"><span class="built_in">Gui,</span> Add, Text , w200 <span class="number">0</span>x10 </span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Clean &amp;&amp; Generate &amp;&amp; Deploy</span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Generate &amp;&amp; Deploy</span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Deploy</span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">Gui,</span> Show, Center , Hexo Blog Updater</span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 按钮事件监听</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 打开博客</span></span><br><span class="line"><span class="title">ButtonOpenBlog:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%blogSite%</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 清理、生成和本地部署</span></span><br><span class="line"><span class="title">ButtonCleanGenerateServer:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%comSpec%</span> /c hexo clean &amp;&amp; hexo g &amp;&amp; hexo s &amp;&amp; <span class="keyword">pause</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 清理、生成和服务器部署</span></span><br><span class="line"><span class="title">ButtonCleanGenerateDeploy:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%comSpec%</span> /c hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; <span class="keyword">pause</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 生成和服务器部署</span></span><br><span class="line"><span class="title">ButtonGenerateDeploy:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%comSpec%</span> /c hexo g &amp;&amp; hexo d &amp;&amp; <span class="keyword">pause</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 服务器部署</span></span><br><span class="line"><span class="title">ButtonDeploy:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%comSpec%</span> /c hexo d &amp;&amp; <span class="keyword">pause</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 打开根目录文件夹</span></span><br><span class="line"><span class="title">ButtonOpenRootFolder:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%rootFolderPath%</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 打开已发布文章文件夹</span></span><br><span class="line"><span class="title">ButtonOpenPostFolder:</span></span><br><span class="line"><span class="built_in">    Run,</span> source\_posts</span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 打开草稿文章文件夹</span></span><br><span class="line"><span class="title">ButtonOpenDraftFolder:</span></span><br><span class="line"><span class="built_in">    Run,</span> source\_drafts</span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 添加新文章</span></span><br><span class="line"><span class="title">ButtonNewPost:</span></span><br><span class="line"><span class="built_in">    InputBox,</span> FileName, NewPostTitle, Please enter the title of <span class="keyword">new</span> post., , , <span class="number">130</span></span><br><span class="line">    if <span class="built_in">ErrorLevel</span></span><br><span class="line">        <span class="keyword">Return</span></span><br><span class="line"><span class="built_in">    Gui,</span> Msg:+Disabled -SysMenu +Owner</span><br><span class="line"><span class="built_in">    Gui,</span> Msg:Add, Text, w200 center, File creating...`nPlease wait...</span><br><span class="line"><span class="built_in">    Gui,</span> Msg:Show, NoActivate <span class="comment">; NoActivate 让当前活动窗口继续保持活动状态.</span></span><br><span class="line"><span class="built_in">    RunWait,</span> <span class="variable">%comSpec%</span> /c hexo <span class="keyword">new</span> post <span class="string">&quot;%FileName%&quot;</span>, , Hide</span><br><span class="line"><span class="built_in">    Gui,</span> Msg:Destroy</span><br><span class="line">    newFileName := StrReplace(FileName, <span class="built_in">A_Space</span>, <span class="string">&quot;-&quot;</span>) <span class="string">&quot;.md&quot;</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%newFileName%</span>, source\_posts, Hide</span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 退出程序</span></span><br><span class="line"><span class="title">GuiEscape:</span></span><br><span class="line"><span class="title">GuiClose:</span></span><br><span class="line"><span class="keyword">ExitApp</span></span><br></pre></td></tr></table></figure><h2 id="修改上述部分代码"><a class="markdownIt-Anchor" href="#修改上述部分代码"></a> 修改上述部分代码</h2><ol><li>代码<strong>第3行</strong>处更换为自己的<strong>博客网址</strong>。</li><li>代码<strong>第4行</strong>处更换为自己的<strong>博客根目录地址</strong>。</li></ol><p>修改完成后，保存以上代码。</p><h1 id="使用方式"><a class="markdownIt-Anchor" href="#使用方式"></a> 使用方式</h1><ol><li><p>双击该文件即可使用。</p></li><li><p>也可以对该文件右键并选择 <code>Compile Script</code>，生成<code>exe</code>文件使用。</p></li></ol><h1 id="autohotkey-学习资料"><a class="markdownIt-Anchor" href="#autohotkey-学习资料"></a> <code>AutoHotKey</code> 学习资料</h1><ul><li><p><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/AutoHotkey.htm">快速参考 | AutoHotkey (autoahk.com)</a></p></li><li><p><a href="https://wyagd001.github.io/zh-cn/docs/AutoHotkey.htm">快速参考 | AutoHotkey (wyagd001.github.io)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
          <category> AutoHotKey </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> AutoHotKey </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Activity - Android校招面试整理2022</title>
      <link href="/posts/4aa0626e110f/"/>
      <url>/posts/4aa0626e110f/</url>
      
        <content type="html"><![CDATA[<h1 id="activity的启动流程"><a class="markdownIt-Anchor" href="#activity的启动流程"></a> <code>Activity</code>的启动流程</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/cpcpcp123/article/details/122055099">面试：Activity的启动流程简述_沙漠一只雕得儿得儿的博客-CSDN博客_activity启动流程面试</a></li><li><a href="https://www.jianshu.com/p/6c55c169ba54">Android 系统启动 - SystemServer 进程 - 简书 (jianshu.com)</a></li></ul></blockquote><p>大致为以下过程：</p><ol><li><code>Launcher</code> 通过 <code>startActivity</code> 方法调用 <code>AMS</code>。</li><li><code>AMS</code> 向 <code>Zygote</code> 进程发送创建应用进程的请求。</li><li><code>Zygote</code> 进程接受请求并在 <code>main</code> 方法中孵化应用进程。</li><li>应用进程通过<code>SystemServer#main</code>启动<code>ActivityThread</code>。</li><li><code>Activity</code>的入口是<code>ActivityThread</code>的<code>main</code>函数，在<code>main</code>函数中创建一个新的<code>ActivityThread</code>对象，开启消息循环(UI线程)后创建新的<code>Activity</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SystemServer#main</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemServer</span>().run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// Ensure binder calls into the system always run at foreground priority.</span></span><br><span class="line">    <span class="comment">// 确保当前进程的 binder 调用总是运行在前台优先级</span></span><br><span class="line">    BinderInternal.disableBackgroundScheduling(<span class="literal">true</span>);</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// 创建主线程 Looper</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize native services.</span></span><br><span class="line">    <span class="comment">// 加载android_servers.so库，该库包含的源码在frameworks/base/services/目录下</span></span><br><span class="line">    System.loadLibrary(<span class="string">&quot;android_servers&quot;</span>);</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// Initialize the system context.</span></span><br><span class="line">    <span class="comment">// 初始化系统上下文</span></span><br><span class="line">    createSystemContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the system service manager.</span></span><br><span class="line">    <span class="comment">//创建系统服务管理</span></span><br><span class="line">    mSystemServiceManager = <span class="keyword">new</span> <span class="title class_">SystemServiceManager</span>(mSystemContext);</span><br><span class="line">    <span class="comment">// 将mSystemServiceManager添加到本地服务的成员sLocalServiceObjects</span></span><br><span class="line">    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start services.</span></span><br><span class="line">    <span class="comment">//  启动各种系统服务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startBootstrapServices(); <span class="comment">// 启动引导服务</span></span><br><span class="line">        startCoreServices();      <span class="comment">// 启动核心服务</span></span><br><span class="line">        startOtherServices();     <span class="comment">// 启动其他服务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// Loop forever.</span></span><br><span class="line">    <span class="comment">// 启动 Looper 循环</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="onsaveinstancestate和onrestoreinstancestate的调用时机"><a class="markdownIt-Anchor" href="#onsaveinstancestate和onrestoreinstancestate的调用时机"></a> <code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>的调用时机</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/cpcpcp123/article/details/113396301">Android onSaveInstanceState和onRestoreInstanceState调用时机、及大小限制_沙漠一只雕得儿得儿的博客-CSDN博客_onsaveinstancestate</a></li></ul></blockquote><p><strong><font size = "5">onSaveInstanceState(Bundle outState)</font></strong></p><p>当 Activity 在不正常销毁的情况下，就会调用 onSaveInstanceState 方法，并将 Activity 中需要保存的数据（比如 View 状态 或者我们自己的数据）保存到这个方法的参数 Bundle 中。</p><p><strong>onSaveInstanceState(Bundle outState)会在以下情况被调用</strong>：</p><ol><li>当用户按下HOME键时。</li><li>从最近应用中选择运行其他的程序时。</li><li>按下电源按键（关闭屏幕显示）时。</li><li>从当前activity启动一个新的activity时。</li><li>屏幕方向切换时(无论竖屏切横屏还是横屏切竖屏都会调用)。</li></ol><p><strong>Activity的onSaveInstanceState回调时机，取决于app的targetSdkVersion</strong>：</p><ul><li><p>targetSdkVersion低于11的app，onSaveInstanceState方法会在Activity.onPause之前回调；</p></li><li><p>targetSdkVersion低于28的app，则会在onStop之前回调；</p></li><li><p><strong>28之后，onSaveInstanceState在onStop回调之后才回调。</strong></p></li></ul><p><strong><font size = "5">onRestoreInstanceState(Bundle savedInstanceState)</font></strong></p><p>onRestoreInstanceState(Bundle savedInstanceState)只有在activity确实是被系统回收，重新创建activity的情况下才会被调用。</p><p><strong>onRestoreInstanceState(Bundle outState)会在以下情况被调用</strong>：</p><ol><li>屏幕方向切换时（无论竖屏切横屏还是横屏切竖屏都会调用）</li><li>由于内存紧张导致后台运行的程序被kill掉时（这种不太好模拟）</li></ol><p><strong>onRestoreInstanceState(Bundle outState)</strong> 的回调时机：</p><p>回调发生在<code>onStart</code>回调之后。</p><h1 id="oncreate和onrestoreinstance方法中恢复数据时的区别"><a class="markdownIt-Anchor" href="#oncreate和onrestoreinstance方法中恢复数据时的区别"></a> <code>onCreate</code>和<code>onRestoreInstance</code>方法中恢复数据时的区别</h1><p>因为<code>onSaveInstanceState</code> 不一定会被调用，所以<code>onCreate</code>里的<code>Bundle</code>参数可能为空，如果使用<code>onCreate</code>来恢复数据，一定要做非空判断。</p><p>而<code>onRestoreInstanceState</code>的<code>Bundle</code>参数一定不会是空值，因为它只有在上次<code>activity</code>被回收了才会调用。</p><h1 id="activity的数据是怎么保存的进程被kill后保存的数据怎么恢复的"><a class="markdownIt-Anchor" href="#activity的数据是怎么保存的进程被kill后保存的数据怎么恢复的"></a> <code>Activity</code>的数据是怎么保存的,进程被<code>Kill</code>后,保存的数据怎么恢复的？</h1><blockquote><p>答案参考自：</p><ul><li>《Android 开发艺术探索》</li></ul></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220521185305.png" style="zoom:67%;" /><p>通过<code>onSaveInstanceState</code>方法和<code>onRestoreInstanceState</code>方法进行数据的保存和恢复。</p><p>在 <code>onSaveInstanceState</code>和 <code>onRestoreInstanceState</code>方法中，系统自动为我们做了一定的恢复工作。当 <code>Activity</code> 在异常情况下需要重新创建时，系统会默认为我们保存当前<code>Activity</code> 的视图结构，并且在<code>Activity</code>重启后为我们恢复这些数据，比如文本框中用户输入的数据、<code>ListView</code>滚动的位置等。</p><h1 id="activity的启动模式和使用场景"><a class="markdownIt-Anchor" href="#activity的启动模式和使用场景"></a> <code>Activity</code>的启动模式和使用场景</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/sinat_14849739/article/details/78072401">Android中Activity的启动模式（LaunchMode）和使用场景_Shawpoo的博客-CSDN博客_launchmode</a></li></ul></blockquote><p>Activity的启动模式有四种：<strong><code>standard</code>、<code>singleTop</code>、<code>singleTask</code>和<code>singleInstance</code></strong>。</p><p><strong><font size="5">standard：标准模式</font></strong></p><p>这种启动模式为标准模式，也是默认模式。每当我们启动一个Activity，系统就会相应的创建一个实例，不管这个实例是否已经存在。这种模式，一个栈中可以有多个实例，每个实例也都有自己的任务栈。而且是谁启动了此Activity，那么这个Activity就运行在启动它的Activity所在的栈中。</p><p><strong>分析总结</strong></p><p><strong>标准模式下，只要启动一次Activity，系统就会在当前任务栈新建一个实例。</strong></p><p><strong>使用场景</strong></p><p>正常的去打开一个新的页面，这种启动模式使用最多，最普通 。</p><p><strong><font size="5">singleTop：栈顶复用模式</font></strong></p><p>这种启动模式下，如果要启动的Activity已经处于栈的顶部，那么此时系统不会创建新的实例，而是直接打开此页面，同时它的onNewIntent()方法会被执行，我们可以通过Intent进行传值，而且它的onCreate()，onStart()方法不会被调用，因为它并没有发生任何变化。</p><p><strong>分析总结</strong></p><ol><li>当前栈中已有该Activity的实例并且该实例位于栈顶时，不会创建实例，而是复用栈顶的实例，并且会将Intent对象传入，回调onNewIntent()方法；</li><li>当前栈中已有该Activity的实例但是该实例不在栈顶时，其行为和standard启动模式一样，依然会创建一个新的实例；</li><li>当前栈中不存在该Activity的实例时，其行为同standard启动模式。</li></ol><p><strong>使用场景</strong></p><p>这种模式应用场景的话，假如一个新闻客户端，在通知栏收到了3条推送，点击每一条推送会打开新闻的详情页，如果为默认的启动模式的话，点击一次打开一个页面，会打开三个详情页，这肯定是不合理的。如果启动模式设置为singleTop，当点击第一条推送后，新闻详情页已经处于栈顶，当我们第二条和第三条推送的时候，只需要通过Intent传入相应的内容即可，并不会重新打开新的页面，这样就可以避免重复打开页面了。</p><p><strong><font size="5">singleTask：栈内复用模式</font></strong></p><p>在这个模式下，如果栈中存在这个Activity的实例就会复用这个Activity，不管它是否位于栈顶，复用时，会将它上面的Activity全部出栈，因为singleTask本身自带clearTop这种功能。并且会回调该实例的onNewIntent()方法。其实这个过程还存在一个任务栈的匹配，因为这个模式启动时，会在自己需要的任务栈中寻找实例，这个任务栈就是通过taskAffinity属性指定。如果这个任务栈不存在，则会创建这个任务栈。不设置taskAffinity属性的话，默认为应用的包名。</p><p><strong>分析总结</strong></p><p>在复用的时候，首先会根据taskAffinity去找对应的任务栈：</p><ol><li>如果不存在指定的任务栈，系统会新建对应的任务栈，并新建Activity实例压入栈中。</li><li>如果存在指定的任务栈，则会查找该任务栈中是否存在该Activity实例<ol><li>如果不存在该实例，则会在该任务栈中新建Activity实例。</li><li>如果存在该实例，则会直接引用，并且回调该实例的onNewIntent()方法。并且任务栈中该实例之上的Activity会被全部销毁。</li></ol></li></ol><p><strong>使用场景</strong></p><p>SingleTask这种启动模式最常使用的就是一个APP的首页，因为一般为一个APP的第一个页面，且长时间保留在栈中，所以最适合设置singleTask启动模式来复用。</p><p><strong><font size="5">singleInstance：单实例模式</font></strong></p><p>单实例模式，顾名思义，只有一个实例。该模式具备singleTask模式的所有特性外，与它的区别就是，这种模式下的<strong>Activity会单独占用一个Task栈，具有全局唯一性</strong>，即整个系统中就这么一个实例，由于栈内复用的特性，后续的请求均不会创建新的Activity实例，除非这个特殊的任务栈被销毁了。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。</p><p><strong>分析总结</strong></p><p>启动该模式Activity的时候，会查找系统中是否存在：</p><ol><li>不存在，首先会新建一个任务栈，其次创建该Activity实例。</li><li>存在，则会直接引用该实例，并且回调onNewIntent()方法。</li><li>特殊情况：该任务栈或该实例被销毁，系统会重新创建。</li></ol><p><strong>使用场景</strong></p><p>很常见的是，电话拨号盘页面，通过自己的应用或者其他应用打开拨打电话页面 ，只要系统的栈中存在该实例，那么就会直接调用。</p><p><strong><font size="5">总结</font></strong></p><p>在使用APP过程中，不可避免页面之间的跳转，那么就会涉及到启动模式。其实在对界面进行跳转时，Android系统既能在同一个任务中对Activity进行调度，也能以Task（任务栈）为单位进行整体调度。在启动模式为standard或singleTop时，一般是在同一个任务中对Activity进行调度，而在启动模式为singleTask或singleInstance是，一般会对Task进行整体调度。</p><h1 id="activity的onnewintent方法什么时候会执行"><a class="markdownIt-Anchor" href="#activity的onnewintent方法什么时候会执行"></a> <code>Activity</code>的<code>onNewIntent</code>方法什么时候会执行</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/8897068505d8">Android中的onNewIntent()函数 - 简书 (jianshu.com)</a></li></ul></blockquote><p><strong>使用<code>SingleTask</code>以及<code>SingleInstance</code>启动模式的时候，会调用<code>onNewInstance</code>方法。</strong></p><p><code>Activity</code>第一次启动的时候执行<code>onCreate</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>等后续生命周期函数，也就时说第一次启动Activity并不会执行到<code>onNewIntent</code>。</p><p>而后面如果再有想启动<code>Activity</code>的时候，那就是执行 <strong><code>onNewIntent</code> -&gt; <code>onResart</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code></strong>。</p><p>如果Android系统由于内存不足把已存在<code>Activity</code>释放掉了，那么再次调用的时候会重新启动<code>Activity</code>即执行<code>onCreate</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>等。</p><p>当调用到<code>onNewIntent(intent)</code>的时候，需要在<code>onNewIntent</code>中使用<code>setIntent(intent)</code>赋值给<code>Activity</code>的<code>Intent</code>。否则，后续的<code>getIntent</code>都是得到旧的<code>Intent</code>。</p><h1 id="activity-生命周期"><a class="markdownIt-Anchor" href="#activity-生命周期"></a> <code>Activity</code> 生命周期</h1><blockquote><p>答案参考自：</p><ul><li><p>《Android 开发艺术探索》</p></li><li><p><a href="https://blog.csdn.net/xiajun2356033/article/details/78741121">activity生命周期（这篇足够了）_android_Mr_夏的博客-CSDN博客</a></p></li></ul></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220521182943.png" alt="Activity的生命周期" style="zoom:67%;" /><ol><li><p><code>onCreate</code></p><p>表示 Activity 正在被创建，这是生命周期的第一个方法。在这个方法中,我们可以做一些<strong>初始化工作</strong>,比如调用<strong>setContentView</strong>去加载界面布局资源,初始化Activity所需数据等。</p></li><li><p><code>onStart</code></p><p>表示Activity正在被启动，即将开始，这时 Activity已经<strong>可见</strong>了，但是还<strong>没有出现在前台</strong>，还<strong>无法和用户交互</strong>。这个时候其实可以理解为Activity已经显示出来了，但是我们还<strong>看不到</strong>。</p></li><li><p><code>onResume</code></p><p>表示 Activity<strong>已经可见</strong>了，并且<strong>出现在前台并开始活动</strong>。</p><p>要注意这个和 onStart的对比, onStart和onResume都表示Activity已经可见,但是onStart的时候Activity还在后台，onResume的时候Activity才显示到前台。</p></li><li><p><code>onPause</code></p><p>表示Activity正在停止，正常情况下，紧接着onStop就会被调用。</p><p>在特殊情况下，如果这个时候快速地再回到当前Activity，那么onResume会被调用。笔者的理解是，这种情况属于极端情况，用户操作很难重现这一场景。</p><p><strong>当前Activity是可见的，但不能与用户交互状态（即不在前台）。</strong></p><p>此时可以做一些<strong>存储数据、停止动画</strong>等工作，但是注意<strong>不能太耗时</strong>，因为这会影响到新Activity的显示，<strong>onPause必须先执行完，新Activity 的onResume才会执行。</strong></p></li><li><p><code>onStop</code></p><p>表示Activity即将停止，此时Activity对用户是<strong>不可见</strong>的，可以做一些稍微重量级的回收工作，同样<strong>不能太耗时</strong>。</p><p>在系统内存紧张的情况下，有可能会被系统进行回收，所以一般在当前方法可做资源回收。</p></li><li><p><code>onDestroy</code></p><p>表示Activity即将被销毁，这是Activity生命周期中的最后一个回调,在这里我们可以做一些<strong>回收工作和最终的资源释放</strong>。</p></li><li><p><code>onRestart</code></p><p>表示Activity正在重新启动。一般情况下，当当前Activity 从<strong>不可见重新变为可见状态</strong>时，onRestart就会被调用。</p><p>这种情形一般是用户行为所导致的，比如用户按Home键切换到桌面或者用户打开了一个新的Activity，这时当前的Activity就会暂停，也就是onPause和 onStop被执行了，接着用户又回到了这个Activity，就会出现这种情况。</p></li></ol><p><strong>具体情况分析</strong>：</p><ol><li><p>针对一个特定的Activity,<strong>第一次启动</strong>,回调如下：<code>onCreate</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>。</p></li><li><p>当用户<strong>打开新的Activity</strong>或者<strong>切换到桌面</strong>的时候，回调如下： <code>onPause</code> -&gt; <code>onStop</code>。</p><p>这里有一种特殊情况,如果新Activity 采用了透明主题,那么当前Activity不会回调<code>onStop</code>。</p></li><li><p>当用户<strong>再次回到原Activity</strong> 时，回调如下： <code>onRestart</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>。</p></li><li><p>当用户<strong>按back键回退</strong>时，回调如下: <code>onPause</code> -&gt; <code>onStop</code> -&gt; <code>onDestroy</code>。</p></li><li><p>当<strong>Activity被系统回收后再次打开</strong>，生命周期方法回调过程和（1）一样，注意只是生命周期方法一样，不代表所有过程都一样，比如<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>的调用。</p></li><li><p>从<strong>Activity_A跳转到Activity_B</strong>，会先执行A活动的<code>onPause</code>，再执行B活动的<code>onResume</code>。</p></li><li><p>从<strong>整个生命周期</strong>来说，<code>onCreate</code>和 <code>onDestroy</code>是配对的，分别标识着Activity 的创建和销毁，并且只可能有一次调用。</p></li><li><p>从<strong>Activity是否可见</strong>来说，<code>onStart</code>和 <code>onStop</code>是配对的，随着用户的操作或者设备屏幕的点亮和熄灭，这两个方法可能被调用多次。</p></li><li><p>从 <strong>Activity是否在前台</strong>来说，<code>onResume</code>和 <code>onPause</code>是配对的,随着用户操作或者设备屏幕的点亮和熄灭，这两个方法可能被调用多次。</p></li></ol><table><thead><tr><th>生命周期</th><th>是否可见</th><th>是否在前台</th></tr></thead><tbody><tr><td><code>onStart</code></td><td>是</td><td>否</td></tr><tr><td><code>onResume</code></td><td>是</td><td>是</td></tr><tr><td><code>onPause</code></td><td>是</td><td>否</td></tr><tr><td><code>onStop</code></td><td>否</td><td>否</td></tr></tbody></table><h1 id="onstart-和-onresume-onpause-和-onstop-的区别"><a class="markdownIt-Anchor" href="#onstart-和-onresume-onpause-和-onstop-的区别"></a> <code>onStart</code> 和 <code>onResume</code>、<code>onPause</code> 和 <code>onStop</code> 的区别</h1><blockquote><p>答案参考自：</p><ul><li>《Android 开发艺术探索》</li></ul></blockquote><p>从实际使用过程来说，<code>onStart</code>和 <code>onResume</code>、<code>onPause</code>和 <code>onStop</code>看起来的确差不多，甚至我们可以只保留其中一对，比如只保留<code>onStart</code>和 <code>onStop</code>。既然如此,那为什么Android系统还要提供看起来重复的接口呢？</p><p>根据上面的分析，我们知道，这两个配对的回调分别表示不同的意义，<code>onStart</code>和 <code>onStop</code>是从<strong>Activity是否可见</strong>这个角度来回调的，而 <code>onResume</code>和 <code>onPause</code>是从<strong>Activity是否位于前台</strong>这个角度来回调的，除了这种区别，在实际使用中没有其他明显区别。</p><h1 id="activity的显式启动和隐式启动"><a class="markdownIt-Anchor" href="#activity的显式启动和隐式启动"></a> <code>Activity</code>的显式启动和隐式启动</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/lrq851215/article/details/62881056">显示和隐式启动Activity的方式_卩s秋灬的博客-CSDN博客</a></li></ul></blockquote><p>启动Activity主要是通过Intent（意图）来实现。主要分为显示的和隐式的两种。</p><p><strong><font size="4">隐式启动 <code>Activity</code></font></strong></p><p>优点：</p><ol><li>只要知道被启动<code>Activity</code>的<code>Action</code>和<code>Category</code>即可，不用知道对应的类名或者是包名。</li><li>只要<code>Activity</code>有对应的<code>Action</code>和<code>Category</code>都会被启动起来。然后提供给用户选择要启动哪一个。</li></ol><p>需要被启动的<code>Activity</code>，需要在自己的<code>AndroidManifest.xml</code>定义对应的<code>action</code> 和 <code>category</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;com.android.activity.demo.SecondActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;@string/second_activity_name&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.SECONDACTIVITY_START&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动<code>Activity</code>的地方，把对应的<code>Action</code>填入即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startSecondActivityByAction</span><span class="params">()</span> &#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;startSecondActivityByAction()&quot;</span>);</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">    intent.setAction(<span class="string">&quot;android.intent.action.SECONDACTIVITY_START&quot;</span>);</span><br><span class="line">    intent.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;start activity error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font size="4">显示启动 <code>Activity</code></font></strong></p><p>不足：</p><ol><li>被启动的应用的包名或者类名发生变化后，就会无法启动。</li></ol><p>通过类名类启动Activity， 一般是同一个APK里面使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startSecondActivityByClass</span><span class="params">()</span> &#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;startSecondActivityByClass()&quot;</span>);</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(FirstActivity.<span class="built_in">this</span>, SecondActivity.class);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;start activity error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="activity间传递数据的方式"><a class="markdownIt-Anchor" href="#activity间传递数据的方式"></a> <code>Activity</code>间传递数据的方式</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/u010112268/article/details/83832021">关于Android Activity之间传递数据的6种方式_淼淼1111的博客-CSDN博客_activity传递数据</a></li></ul></blockquote><p>共六种传递数据的方式。</p><ol><li><p><strong>使用Intent的putExtra传递</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建意图对象</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>,TwoActivity.class);</span><br><span class="line"><span class="comment">//设置传递键值对</span></span><br><span class="line">intent.putExtra(<span class="string">&quot;data&quot;</span>,str);</span><br><span class="line"><span class="comment">//激活意图</span></span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>第二个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取意图对象</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line"><span class="comment">//获取传递的值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;data&quot;</span>);</span><br><span class="line"><span class="comment">//设置值</span></span><br><span class="line">tv.setText(str);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用Intention的Bundle传递</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建意图对象</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>,TwoActivity.class);</span><br><span class="line"><span class="comment">//用数据捆传递数据</span></span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">bundle.putString(<span class="string">&quot;data&quot;</span>, str);</span><br><span class="line"><span class="comment">//把数据捆设置改意图</span></span><br><span class="line">intent.putExtra(<span class="string">&quot;bun&quot;</span>, bundle);</span><br><span class="line"><span class="comment">//激活意图</span></span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>第二个Activity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Bundle</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> intent.getBundleExtra(<span class="string">&quot;bun&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">tv.setText(str);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用Activity销毁时传递数据(startActivityForResult)</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>,TwoActivity.class);</span><br><span class="line"><span class="comment">//用一种特殊方式开启Activity</span></span><br><span class="line">startActivityForResult(intent, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置数据</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, Intent data)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> data.getStringExtra(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">    tvOne.setText(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置返回的数据</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.putExtra(<span class="string">&quot;data&quot;</span>, edtOne.getText().toString().trim());</span><br><span class="line">setResult(<span class="number">3</span>, intent);</span><br><span class="line"><span class="comment">//关闭当前activity</span></span><br><span class="line">finish();</span><br></pre></td></tr></table></figure></li><li><p><strong>SharedPreferences传递数据</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SharedPreferences</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="built_in">this</span>.getSharedPreferences(<span class="string">&quot;info&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//获取sp编辑器</span></span><br><span class="line"><span class="type">Editor</span> <span class="variable">edit</span> <span class="operator">=</span> sp.edit();</span><br><span class="line">edit.putString(<span class="string">&quot;data&quot;</span>, str);</span><br><span class="line">edit.commit();</span><br><span class="line"><span class="comment">//创建意图对象</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>,TwoActivity.class);</span><br><span class="line"><span class="comment">//激活意图</span></span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>第二个activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SharedPreferences</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="built_in">this</span>.getSharedPreferences(<span class="string">&quot;info&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//设置数据</span></span><br><span class="line">tv.setText(sp.getString(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>使用序列化对象Seriazable</strong></p><p>工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataBean</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建意图</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>,TwoActivity.class);</span><br><span class="line"><span class="type">DataBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataBean</span>();</span><br><span class="line"><span class="comment">//通过set方法把数据保存到DataBean对象中</span></span><br><span class="line">bean.setName(<span class="string">&quot;啦啦&quot;</span>);</span><br><span class="line">bean.setSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;key&quot;</span>, bean);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>第二个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line"><span class="comment">//反序列化数据对象</span></span><br><span class="line"><span class="type">Serializable</span> <span class="variable">se</span> <span class="operator">=</span> intent.getSerializableExtra(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(se <span class="keyword">instanceof</span> DataBean)&#123;</span><br><span class="line">    <span class="comment">//获取到携带数据的DataBean对象db</span></span><br><span class="line">    <span class="type">DataBean</span> <span class="variable">db</span> <span class="operator">=</span> (DataBean) se;</span><br><span class="line">    tv.setText(db.getName() + <span class="string">&quot;===&quot;</span> + db.getSex());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用静态变量传递数据</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>,TwoActivity.class);</span><br><span class="line">TwoActivity.name = <span class="string">&quot;NAME&quot;</span>;</span><br><span class="line">TwoActivity.str = <span class="string">&quot;STR&quot;</span>;</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>第二个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态变量</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> String name;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> String str;</span><br><span class="line">tv.setText(str + name);</span><br></pre></td></tr></table></figure></li></ol><h1 id="有哪些activity常用的标记位flags"><a class="markdownIt-Anchor" href="#有哪些activity常用的标记位flags"></a> 有哪些<code>Activity</code>常用的标记位<code>Flags</code></h1><ol><li><p><code>FLAG_ACTIVITY_NEW_TASK</code></p><p>指定启动模式为SingleTask</p></li><li><p><code>FLAG_ACTIVITY_SINGLE_TOP</code></p><p>指定启动模式为SingleTop</p></li><li><p><code>FLAG_ACTIVITY_CLEAR_TOP</code></p><p>一般与SingleTask启动模式一起出现，启动时位于它上方的Activity出栈，如果被启动的Activity实例已存在，系统则会调用它的onNewIntent</p></li></ol><h1 id="activity任务栈是什么"><a class="markdownIt-Anchor" href="#activity任务栈是什么"></a> <code>Activity</code>任务栈是什么</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/Lwenlong/p/15939583.html">Android面试——Activity篇 - 向着内核前进！ - 博客园 (cnblogs.com)</a></li></ul></blockquote><p>即Task，栈结构，存放Activity；退出应用程序时只有将所有任务栈找那个的所有Activity出栈，任务栈才能销毁。</p><p>任务栈可以移动到后台，在其中保留每一个Activity的状态。</p><p>对应的类：ActivityRecord、TaskRecord、ActivityStack。</p><h1 id="跨app启动activity的方式注意事项"><a class="markdownIt-Anchor" href="#跨app启动activity的方式注意事项"></a> 跨<code>App</code>启动<code>Activity</code>的方式,注意事项</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/Lwenlong/p/15939583.html">Android面试——Activity篇 - 向着内核前进！ - 博客园 (cnblogs.com)</a></li><li>《Android 开发艺术探索》</li></ul></blockquote><ol><li><p>指定打开的应用</p><p>通过Intent 隐式启动时，如果有多个action值相同的Activity，系统会让你选择启动哪个，解决办法时通过指定Intent-filter的 <code>data</code>属性，Intent 则要加上一个URI，该URI的scheme必须与data的scheme相同。</p><blockquote><p>data由两部分组成，mimeType和 URI。mimeType指媒体类型，比如 image/ijpeg.audio/mpeg4-generic和 video/*等，可以表示图片、文本、视频等不同的媒体格式，而URI中包含的数据就比较多了，下面是URI的结构：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]</span><br></pre></td></tr></table></figure><p>Scheme：URI的模式，比如 http、file、content等，如果URI中没有指定scheme，那么整个URI的其他参数无效，这也意味着URI是无效的。</p></blockquote></li><li><p>如何防止自己的Activity被外部非正常启动</p><p>给自己的Activity 添加<code>android:permission=”xxx.xxx.xx”</code>，那么想要访问你的Activity就必须声明<code>uses-permission xxx.xxx.xx</code></p></li></ol><h1 id="anr-的四种场景"><a class="markdownIt-Anchor" href="#anr-的四种场景"></a> <code>ANR</code> 的四种场景</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/xingyu19911016/article/details/122080235">ANR 的四种场景_橙子19911016的博客-CSDN博客_anr的四种场景</a></li></ul></blockquote><ol><li><p><code>Service TimeOut</code></p><p><code>Service</code>未在规定时间执行完成，前台服务20s，后台200s。</p></li><li><p><code>BroadCastQueue TimeOut</code></p><p>未在规定时间内未处理完广播，前台广播10s内，后台60s内。</p></li><li><p><code>ContentProvider TimeOut</code></p><p><code>publish</code>在10s内没有完成。</p></li><li><p><code>Input Dispatching timeout</code></p><p>5s内未响应键盘输入、触摸屏幕等事件。</p></li></ol><p>Activity的生命周期回调的阻塞并不在触发ANR的场景里面，所以并不会直接触发ANR。 只不过死循环阻塞了主线程，如果系统再有上述的四种事件发生，就无法在相应的时间内处理从而触发ANR。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 2022校招面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Activity </tag>
            
            <tag> 2022校招面试整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 提交出现 FATAL err Error Spawn failed</title>
      <link href="/posts/b6ee2f2e134b/"/>
      <url>/posts/b6ee2f2e134b/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h1><p>当我们使用 <code>Hexo</code> 博客，在提交的时候可能会出现以下的错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FATAL &#123;</span><br><span class="line">    err: Error: Spawn failed</span><br><span class="line">        at ChildProcess.&lt;anonymous&gt; (node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">        at ChildProcess.emit (node:events:390:28)</span><br><span class="line">        at ChildProcess.cp.emit (node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">        at Process.ChildProcess._handle.onexit (node:internal/child_process:290:12) &#123;</span><br><span class="line">         code: 128</span><br><span class="line">     &#125;</span><br><span class="line">&#125; Something&#x27;s wrong. Maybe you can find the solution here: ...</span><br></pre></td></tr></table></figure><h1 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h1><p>打开博客根目录下的  <strong><code>_config.yml</code></strong> 文件，并找到以下段落：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/...</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>将原来 <code>repo</code> 处 <code>HTTPS</code> 格式的仓库地址（<code>https://github.com/...</code>）换成 <code>SSH</code> 格式的仓库地址（<code>git@github.com:...</code>）后，重新推送即可解决。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在博客根目录下，通过 cmd 或 git 输入该命令重新推送。 </span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化 - Android校招面试整理2022</title>
      <link href="/posts/1718d96306cd/"/>
      <url>/posts/1718d96306cd/</url>
      
        <content type="html"><![CDATA[<blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/douzi520/p/9497889.html">Java中序列化的好处及意义 - 久孤丶 - 博客园 (cnblogs.com)</a></li><li><a href="https://www.jianshu.com/p/2ed41bb7aa3a">Serializable和Parcelable区别 - 简书 (jianshu.com)</a></li></ul></blockquote><h1 id="什么是序列化"><a class="markdownIt-Anchor" href="#什么是序列化"></a> 什么是序列化？</h1><p><strong>序列化：</strong> 把对象转化为可传输的字节序列过程称为序列化。</p><p><strong>反序列化：</strong> 把字节序列还原为对象的过程称为反序列化。</p><h1 id="为什么需要使用序列化和反序列化"><a class="markdownIt-Anchor" href="#为什么需要使用序列化和反序列化"></a> 为什么需要使用序列化和反序列化？</h1><p>目的是为了对象可以<strong>跨平台存储，和进行网络传输</strong>。</p><h1 id="序列化的有哪些好处"><a class="markdownIt-Anchor" href="#序列化的有哪些好处"></a> 序列化的有哪些好处</h1><p>对对象进行序列化操作，可以极大程度的方便传输。</p><h1 id="什么情况下需要序列化"><a class="markdownIt-Anchor" href="#什么情况下需要序列化"></a> 什么情况下需要序列化</h1><ol><li>当你想把的内存中的对象保存到一个文件中或者数据库中时候。</li><li>当你想用序列化在网络上传送对象的时候。</li></ol><h1 id="什么是serialversionuid"><a class="markdownIt-Anchor" href="#什么是serialversionuid"></a> 什么是<code>serialVersionUID</code></h1><p><code>serialVersionUID</code>是用来辅助序列化和反序列化的过程。原则上序列化后的数据中的<code>serialVersionUID</code>只有和当前类的<code>serialVersionUID</code>一致才能成功的反序列化。</p><h1 id="为什么还要显示指定serialversionuid的值"><a class="markdownIt-Anchor" href="#为什么还要显示指定serialversionuid的值"></a> 为什么还要显示指定<code>serialVersionUID</code>的值?</h1><p><code>serialVersionUID</code>的详细工作机制是这样的：</p><p>序列化的时候系统会把当前类的<code>serialVersionUID</code>写入序列化的文件中(也可能是其他中介)。当反序列化的时候系统会去检测文件中的<code>serialVersionUID</code>，看它是否和当前类的<code>serialVersionUID</code>一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则就说明当前类和序列化的类相比发生了某些变换，比如成员变量的数量、类型可能会发生变化，这时候就无法正常的反序列化。</p><p>以一般来说，我们应该手动去指定<code>serialVersionUID</code>的值，比如&quot;1L&quot;,也可以让IDE根据当前类的结构去生成对应的<code>hash</code>值，这样序列化和反序列化时两者的<code>serialVersionUID</code>是相同的，因此可以正常的进行反序列化。如果不不设置<code>serialVersionUID</code>，系统在序列化的时候默认会根据类的结构在生成对应的<code>serialVersionUID</code>，在反序列化的时候，如果当类有变化，比如增加或者减少字段，这时候当前的类的<code>serialVersionUID</code>和序列化的时候的<code>serialVersionUID</code>就不一样了，就会出现反序列化失败，如果没有捕获异常会导致<code>crash</code>。</p><p><strong>所以当我们手动指定了它之后，就可以很大程度上避免了反序列化过程的失败。</strong></p><p>比如当版本升级以后，我们可能删除了某个成员变量也可能增加一些新的成员变量，这个时候我们的反序列化过程仍然可以成功，程序仍然能够最大限度地恢复数据。相反 如果我们没有指定<code>serialVersionUID</code>的话，程序就会挂掉。</p><p>当然我们也要考虑到另外一种情况，如果类结构发生了非常规性的改变，比如修改了类名，修改了成员变量的类型，这个时候尽管<code>serialVersionUID</code>验证通过了，但是反序列化过程还是会失败，因为类的而结构有了重大改变，根本无法从老版本的数据还原出一个新的类结构对象。</p><p><strong>注意</strong></p><ol><li><p>静态成员变量属于类，不属于对象，所以不会参与序列化的过程</p></li><li><p>用transient关键字编辑的成员变量不参与序列化的过程。</p></li><li><p>可以通过重写<code>writeObject</code>和<code>readObject</code>两个方法来重写系统默认的序列化和反序列化的过程。不过并不推荐。</p></li></ol><h1 id="serializable-和-parcelable-的区别"><a class="markdownIt-Anchor" href="#serializable-和-parcelable-的区别"></a> <code>Serializable</code> 和 <code>Parcelable</code> 的区别</h1><p><strong>1、平台区别</strong></p><ul><li><code>Serializable</code>是属于 <code>Java</code> 自带的，表示一个对象可以转换成可存储或者可传输的状态，序列化后的对象可以在网络上进行传输，也可以存储到本地。</li><li><code>Parcelable</code> 是属于 <code>Android</code> 专用。不过不同于<code>Serializable</code>，<code>Parcelable</code>实现的原理是将一个完整的对象进行分解。而分解后的每一部分都是Intent所支持的数据类型。</li></ul><p><strong>2、编写上的区别</strong></p><ul><li><code>Serializable</code>代码量少，写起来方便</li><li><code>Parcelable</code>代码多一些，略复杂</li></ul><p><strong>3、选择的原则</strong></p><ul><li>如果是仅仅在内存中使用，比如<code>activity</code>、<code>service</code>之间进行对象的传递，强烈推荐使用<code>Parcelable</code>，因为<code>Parcelable</code>比<code>Serializable</code>性能高很多。因为<code>Serializable</code>在序列化的时候会产生大量的临时变量， 从而引起频繁的<code>GC</code>。</li><li>如果是持久化操作，推荐<code>Serializable</code>，虽然<code>Serializable</code>效率比较低，但是还是要选择它，因为在外界有变化的情况下，<code>Parcelable</code>不能很好的保存数据的持续性。</li></ul><p><strong>4、本质的区别</strong></p><ul><li><code>Serializable</code>的本质是使用了反射，序列化的过程比较慢，这种机制在序列化的时候会创建很多临时的对象，比引起频繁的GC、</li><li><code>Parcelable</code>方式的本质是将一个完整的对象进行分解，而分解后的每一部分都是<code>Intent</code>所支持的类型，这样就实现了传递对象的功能了。</li></ul><h1 id="java-transient-解析"><a class="markdownIt-Anchor" href="#java-transient-解析"></a> Java <code>transient</code> 解析</h1><ol><li><code>transient</code> 关键字<strong>只能修饰变量，而不能修饰方法和类</strong>。注意，本地变量是不能被 <code>transient</code> 关键字修饰的。变量如果是用户自定义的类变量，则该类是要实现 <code>Serializable</code> 接口。</li><li>一旦变量被 <code>transient</code> 修饰，变量将不是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li><li>静态变量不管是否被 <code>transient</code> 修饰，都无法被序列化。</li></ol><p><strong>注意： 被 <code>transient</code> 修饰的变量也是可以被序列化的。</strong></p><p>Java 中，对象的序列化可以通过实现两个接口实现：</p><ul><li>若实现的是 <code>Serializable</code> 接口，则所有的序列化都将会自动进行，被 <code>transient</code> 修饰的变量将不会被序列化。</li><li>若实现的是 <code>Externalizable</code> 接口，则任何东西都需要自己在 <code>writeExternal</code> 方法中自己手动指定需要序列化的变量。任何变量都可以序列化，与变量是否被 <code>transient</code> 修饰无关。</li></ul><h1 id="其他注意事项"><a class="markdownIt-Anchor" href="#其他注意事项"></a> 其他注意事项</h1><ol><li>当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</li><li>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</li><li>并非所有的对象都可以序列化，,至于为什么不可以，有很多原因了。比如：<ol><li>安全方面的原因，比如一个对象拥有<code>private</code>，<code>public</code>等<code>field</code>，对于一个要传输的对象，比如写到文件，或者进行<code>RMI</code>传输 等等，在序列化进行传输的过程中，这个对象的<code>private</code>等域是不受保护的。</li><li>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 2022校招面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
            <tag> 序列化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList - Android校招面试整理2022</title>
      <link href="/posts/ca56681199c8/"/>
      <url>/posts/ca56681199c8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://blog.csdn.net/qq_51596354/article/details/122398978">Java ArrayList底层原理详情笔记和相关面试题_抹泪的知更鸟的博客-CSDN博客</a></li></ul></blockquote><h1 id="arraylist是如何扩容的"><a class="markdownIt-Anchor" href="#arraylist是如何扩容的"></a> <code>ArrayList</code>是如何扩容的？</h1><p>初始容量为10，第一扩容就为10。</p><p>以后每次的扩容都是原容量的1.5倍。</p><h1 id="arraylist继承关系"><a class="markdownIt-Anchor" href="#arraylist继承关系"></a> <code>ArrayList</code>继承关系</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><h2 id="实现serializable标记型接口"><a class="markdownIt-Anchor" href="#实现serializable标记型接口"></a> 实现<code>Serializable</code>标记型接口</h2><p>序列化：将对象转化为字节数组的过程</p><p>反序列化：将字节数组转化为对象的过程</p><h2 id="实现cloneable标记型接口"><a class="markdownIt-Anchor" href="#实现cloneable标记型接口"></a> 实现<code>Cloneable</code>标记型接口</h2><p>克隆：将<code>ArrayList</code>集合的数组clone到另一个集合</p><p>实际底层调用的是Object中的<code>clone</code>方法，而<code>clone</code>是一个<code>native</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.clone();</span><br><span class="line">System.out.println(o == list);<span class="comment">//地址不一样，深度克隆</span></span><br></pre></td></tr></table></figure><p>使用了<code>Arrays#copyOf</code>方法进行复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">v.elementData = Arrays.copyOf(elementData, size);</span><br></pre></td></tr></table></figure><p>浅拷贝：基本数据类型可以达到完全复制，引用数据类型拷贝的是栈上的地址值，所以修改引用类型的数据，会改变原来的数据。</p><p>深拷贝：基本数据类型和引用类型都可以完全复制，引用对象在堆中创建新的对象，对原数据没有任何影响。</p><p><strong>深拷贝的实现方式：</strong></p><p>实现<code>Cloneable</code>接口并重写<code>clone</code>方法。</p><p>让其<code>clone</code>方法通过序列化和反序列化的方式来生成一个原对象的深拷贝副本</p><h2 id="实现randomaccess标记型接口"><a class="markdownIt-Anchor" href="#实现randomaccess标记型接口"></a> 实现<code>RandomAccess</code>标记型接口</h2><p><strong><code>ArrayList</code>支持随机访问。</strong></p><blockquote><p>随机访问：直接 <code>first+N</code>，便可以得到第<code>N</code>个元素的地址，因为这些相邻元素是按顺序连续存储的。<br />比如普通数组就是可随机访问的。</p><p>文件随机访问是指<strong>在某个文件内直接读写任何给定位置数据的能力</strong>。</p></blockquote><p>通过<code>get(i)</code>即可获得相应内存中存放的值。原因是因为<code>ArrayList</code>存放的内容在内存中是连续的，数组直接用<code>[]</code>访问，相当于直接操作内存地址，所以随机访问的效率较高。</p><p>普通的for循环是随机访问的，所以遍历<code>ArrayList</code>使用普通<code>for</code>循环比增强<code>for</code>循环和迭代器的效率高。</p><p>而<code>LinkedList</code>是一个双向链表，链表只能顺序访问，不支持随机访问，<code>LinkedList</code>中的<code>get</code>方法是按照顺序从列表的一端开始检查，直到找到要找的地址。所以遍历<code>LinkedList</code>使用增强<code>for</code>循环和迭代器的效率高，使用普通<code>for</code>循环会每次都从头开始遍历，效率较差。</p><h2 id="abstractlist抽象类"><a class="markdownIt-Anchor" href="#abstractlist抽象类"></a> <code>AbstractList</code>抽象类</h2><p><code>AbstractList</code> 虽然是抽象类，但其内部只有一个抽象方法 <code>get</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure><p>从字面上看这是获取的方法，子类必须实现它，一般是作为获取元素的用途，除此之外，如果子类要操作元素，还需要重写 <code>add</code>、<code>set</code>、 <code>remove</code>方法，因为 <code>AbstractList</code> 虽然定义了这几个方法，但默认是不支持的。</p><h1 id="arraylist频繁扩容导致添加性能急剧下降如何处理"><a class="markdownIt-Anchor" href="#arraylist频繁扩容导致添加性能急剧下降如何处理"></a> <code>ArrayList</code>频繁扩容导致添加性能急剧下降，如何处理？</h1><p>每次扩容都会创建一个数据，将数据复制到新数组，所以在<code>ArrayList</code>中有一个构造方法，参数是自定义长度，指定初始容量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123; <span class="comment">//手动初始化</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果长度为0，使用final修饰的空数组</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="arraylist插入或删除元素一定比linkedlist慢吗"><a class="markdownIt-Anchor" href="#arraylist插入或删除元素一定比linkedlist慢吗"></a> <code>ArrayList</code>插入或删除元素一定比<code>LinkedList</code>慢吗？</h1><p>不一定，<code>LinkedList</code> 其底层调用了 Node的方法,该方法循环也是比较复杂的 , 如果这个<code>LinkedList</code>上的数据很多,虽说进行了折半的 但是效率也是比较低的。</p><p>而<code>ArrayList</code>底层数组需要移动位置，复制数组。</p><h1 id="arraylist是线程安全的吗"><a class="markdownIt-Anchor" href="#arraylist是线程安全的吗"></a> <code>ArrayList</code>是线程安全的吗？</h1><p><code>ArrayList</code>不是线程安全的，效率高。</p><h1 id="如何解决arraylist线程安全问题"><a class="markdownIt-Anchor" href="#如何解决arraylist线程安全问题"></a> 如何解决<code>ArrayList</code>线程安全问题？</h1><p>可以使用安全集合<code>Vector</code>。</p><p>可以使用<code>Collections</code>工具类中的<code>SyschronizedList</code>方法解决<code>ArrayList</code>的线程安全问题</p><p>定义为全局变量，被多个线程所共享，就要考虑线程问题</p><p>定义为局部变量时，调用方法会在虚拟机栈处创建一个栈帧，虚拟机栈线程私有的，每一次只有一个线程执行，所以局部变量的数据是独立的，不需要考虑安全问题</p><h1 id="如何复制一个arraylist集合到另一个arraylist集合中"><a class="markdownIt-Anchor" href="#如何复制一个arraylist集合到另一个arraylist集合中"></a> 如何复制一个<code>ArrayList</code>集合到另一个<code>ArrayList</code>集合中？</h1><p>可以使用clone()方法</p><p>使用其中的构造器</p><p>使用addAll()方法</p><p>for循环遍历复制</p><h1 id="已知成员变量集合存储n多用户名称在多线程的环境下使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合"><a class="markdownIt-Anchor" href="#已知成员变量集合存储n多用户名称在多线程的环境下使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合"></a> 已知成员变量集合存储N多用户名称，在多线程的环境下，使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合？</h1><p>在多线程读写操作，<code>ArrayList</code>会抛出并发异常，所以在进行读写数据时，使用读写的操作时，使用<code>CopyOnWriteArrayList</code>这个读写分离的集合。</p><h1 id="arraylist和linkedlist区别"><a class="markdownIt-Anchor" href="#arraylist和linkedlist区别"></a> <code>ArrayList</code>和<code>LinkedList</code>区别？</h1><p><strong><code>ArrayList</code></strong></p><ul><li><p>基于动态数组的数据结构</p></li><li><p><code>ArrayList</code>支持随机访问</p></li><li><p>查询快，增删慢，但并不一定比<code>LinkedList</code>慢</p></li></ul><p><strong><code>LinkedList</code></strong></p><ul><li><p>基于链表的数据结构</p></li><li><p>对于顺序操作，<code>LinkedList</code>不一定比<code>ArrayList</code>慢</p></li><li><p>查询慢，增删快</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 2022校招面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
            <tag> ArrayList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap - Android校招面试整理2022</title>
      <link href="/posts/217436a720e7/"/>
      <url>/posts/217436a720e7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/weixin_44015043/article/details/105346187">看完还不懂HashMap算我输（附职场面试常见问题）_黛色翩翩的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/weixin_39603469/article/details/110639674">hashmap为什么用红黑树_HashMap面试必问的6个点，你知道几个？_weixin_39603469的博客-CSDN博客</a></li></ul></blockquote><h1 id="jdk-18-中-hashmap-更改了什么内容"><a class="markdownIt-Anchor" href="#jdk-18-中-hashmap-更改了什么内容"></a> <code>JDK 1.8</code> 中 <code>HashMap</code> 更改了什么内容？</h1><ol><li>将存储方式更改为了 数组 + 链表/<strong>红黑树</strong>。</li><li>优化了高位运算的<code>hash</code>算法：<code>h &amp; (h &gt;&gt;&gt; 16)</code>。</li><li>扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。</li></ol><h1 id="hashmap-原理"><a class="markdownIt-Anchor" href="#hashmap-原理"></a> <code>HashMap</code> 原理</h1><p><strong>几个重要的变量</strong></p><ul><li><p><code>DEFAULT_INITIAL_CAPACITY</code></p><p>Table数组的初始化长度： <code>1 &lt;&lt; 4</code> 。</p></li><li><p><code>MAXIMUM_CAPACITY</code></p><p>Table数组的最大长度： <code>1 &lt;&lt; 30</code>。</p></li><li><p><code>DEFAULT_LOAD_FACTOR</code></p><p>负载因子：默认值为<code>0.75</code>。</p><p>当<code>元素的总个数 &gt; (当前数组的长度 * 负载因子)</code>，数组会进行扩容，<strong>扩容为原来的两倍</strong>。</p></li><li><p><code>TREEIFY_THRESHOLD</code></p><p>链表树化阙值： 默认值为 <code>8</code> 。</p><p>表示在一个node（Table）节点下的值的个数大于8时候，会将链表转换成为红黑树。</p></li><li><p><code>UNTREEIFY_THRESHOLD</code></p><p>红黑树链化阙值： 默认值为 <code>6</code> 。</p><p>表示在进行扩容期间，单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。</p></li><li><p><code>MIN_TREEIFY_CAPACITY = 64</code></p><p>最小树化阈值，值为 64。</p><p>当Table所有元素超过改值，才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突）。</p></li></ul><p><strong>实现原理</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220522214849.png" style="zoom:67%;" /><p><code>HashMap</code>采⽤<code>Entry</code>数组来存储<code>key-value</code>对，每⼀个键值对组成了⼀个<code>Entry</code>实体，<code>Entry</code>类实际上是⼀个单向的链表结构，它具有<code>Next</code>指针，可以连接下⼀个<code>Entry</code>实体。 只是在<code>JDK1.8</code>中，链表⻓度⼤于<code>8</code>的时候，链表会转成<strong>红黑树</strong>。</p><h1 id="为什么使用-链表-数组-的存储方式"><a class="markdownIt-Anchor" href="#为什么使用-链表-数组-的存储方式"></a> 为什么使用 <code>链表</code> + <code>数组</code> 的存储方式？</h1><p>由于我们的数组的值是限制死的，我们在对<code>key</code>值进行散列取到下标以后，放入到数组中时，难免出现两个<code>key</code>值不同，但是却放入到下标相同的<strong>格子</strong>中，此时我们就可以使用链表来对其进行链式的存放。</p><h1 id="用linkedlist代替数组结构可以吗"><a class="markdownIt-Anchor" href="#用linkedlist代替数组结构可以吗"></a> 用<code>LinkedList</code>代替<code>数组</code>结构可以吗？</h1><p>可以的。</p><h1 id="既然可以使用进行替换处理为什么偏偏使用到数组呢"><a class="markdownIt-Anchor" href="#既然可以使用进行替换处理为什么偏偏使用到数组呢"></a> 既然可以使用进行替换处理，为什么偏偏使用到<code>数组</code>呢？</h1><p>因为使用数组效率最高。</p><p>在<code>HashMap</code>中，定位节点的位置是通过 <code>i = (n - 1) &amp; hash</code> 得到。此时，我们已得到节点的位置。显然数组的查找效率比<code>LinkedList</code>更优（底层是链表结构）。</p><p>那<code>ArrayList</code>，底层也是数组，查找也快啊，为啥不⽤<code>ArrayList</code>?</p><p>因为采用基本数组结构，扩容机制可以自己定义，<code>HashMap</code>中数组扩容刚好是<strong>2的次幂</strong>，方便原数组中的元素的位置变动， 而<code>ArrayList</code>的扩容机制是1.5倍扩容。</p><h1 id="hashmap中如何计算出存放位置的hash函数怎么实现的"><a class="markdownIt-Anchor" href="#hashmap中如何计算出存放位置的hash函数怎么实现的"></a> <code>HashMap</code>中如何计算出存放位置的？<code>hash</code>函数怎么实现的?</h1><p><strong>该问题解析同下问。</strong></p><h1 id="为什么不直接将hashcode作为哈希值去做取模而是要先高16位异或低16位"><a class="markdownIt-Anchor" href="#为什么不直接将hashcode作为哈希值去做取模而是要先高16位异或低16位"></a> 为什么不直接将<code>hashcode</code>作为哈希值去做取模,而是要先高16位异或低16位</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap#putVal 计算位置并存放</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><strong>通过图做进一步的了解 <code>i = (n - 1) &amp; hash</code>：</strong></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220522214907.png" alt="img" /></p><p>这里我们也就得知为什么<code>Table</code>数组的长度要一直都为<code>2的n次方</code>，只有这样，减一进行<strong>与操作</strong>时候，才能够达到最大的<code>n-1</code>值。</p><p><strong>通过反例验证一下：</strong></p><p>我们现 数组的长度为 15 ，减一为 14 ，二进制表示 <code>0000 1110</code> 。进行<strong>与操作</strong>时候，最后一位永远是0，这样就可能导致不能够完完全全的进行Table数组的使用。违背了我们最开始的想要对Table数组进行<strong>最大限度的无序使用</strong>的原则，因为HashMap为了能够存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表⻓度⼤致相同。</p><p><strong>此时还有一点需要注意的是： 我们对key值进行hashcode以后，进行相与时候都是只用到了后四位，前面的很多位都没有能够得到使用,这样也可能会导致我们所生成的下标值不能够完全散列。</strong></p><p><strong>解决方案：</strong></p><p>将生成的<code>hashcode</code>值的高16位于低16位进行异或运算，这样得到的值再进行<strong>与操作</strong>，得散列的下标值，异或的1或0的结果都是1/2，使得散列更均匀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="还有哪些hash函数的实现方式"><a class="markdownIt-Anchor" href="#还有哪些hash函数的实现方式"></a> 还有哪些<code>hash</code>函数的实现方式？</h1><p>先说⼀下<code>hash</code>算法⼲嘛的，<code>hash</code>函数是指把⼀个⼤范围映射到⼀个⼩范围。把⼤范围映射到⼀个⼩范围的⽬的往往是为了 节省空间，使得数据容易保存。</p><p>⽐较出名的有<code>MurmurHash</code>、<code>MD4</code>、<code>MD5</code>等等。</p><p><strong><code>String</code>中<code>hashcode</code>的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="hash冲突有哪些解决办法"><a class="markdownIt-Anchor" href="#hash冲突有哪些解决办法"></a> hash冲突有哪些解决办法</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/qq_48241564/article/details/118613312">解决哈希冲突（四种方法）_君诀的博客-CSDN博客_解决哈希冲突的方法</a></li></ul></blockquote><p>有三个方法：</p><ol><li>开放定址法</li><li>再哈希法</li><li>链地址法</li></ol><h1 id="解决hash冲突的时候为什么用红黑树"><a class="markdownIt-Anchor" href="#解决hash冲突的时候为什么用红黑树"></a> 解决<code>hash</code>冲突的时候，为什么用红黑树？</h1><p>当链表过长的时候，如果仍旧使用链表进行搜索和删改，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，所消耗的时间叫较大。</p><p>如果采用了红黑树的设计，则可以使得在数据量较大的情况下，以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的时间复杂度进行搜索和删改，大幅减少使用的时间。</p><h1 id="红黑树的效率高为什么一开始不用红黑树存储"><a class="markdownIt-Anchor" href="#红黑树的效率高为什么一开始不用红黑树存储"></a> 红黑树的效率高，为什么一开始不用红黑树存储？</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/baidu_37147070/article/details/98785367">JDK1.8以后的hashmap为什么在链表长度为8的时候变为红黑树_向日葵班学霸的博客-CSDN博客</a></li></ul></blockquote><p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。</p><p>源码中的注释写的很清楚，因为树节点所占空间是普通节点的两倍，所以只有当节点足够多的时候，才会使用树节点。也就是说，节点少的时候，尽管时间复杂度上，红黑树比链表好一点，但是红黑树所占空间比较大，综合考虑，认为只能在节点太多的时候，红黑树占空间大这一劣势不太明显的时候，才会舍弃链表，使用红黑树。</p><h1 id="不用红黑树用二叉查找树可以不"><a class="markdownIt-Anchor" href="#不用红黑树用二叉查找树可以不"></a> 不用<a href="https://luoyu-ying.github.io/posts/59c5aea57d8c/">红黑树</a>，用二叉查找树可以不？</h1><p>可以。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。</p><h1 id="为什么阈值是8才转为红黑树"><a class="markdownIt-Anchor" href="#为什么阈值是8才转为红黑树"></a> 为什么阈值是8才转为红黑树</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/baidu_37147070/article/details/98785367">JDK1.8以后的hashmap为什么在链表长度为8的时候变为红黑树_向日葵班学霸的博客-CSDN博客</a></li></ul></blockquote><p>源码上说，为了配合使用分布良好的hashCode，树节点很少使用。并且在理想状态下，受随机分布的hashCode影响，链表中的节点<strong>遵循泊松分布</strong>，而且根据统计，<strong>链表中节点数</strong>是8的概率已经接近千分之一，而且此时链表的性能已经很差了。</p><p>所以在这种比较罕见和极端的情况下，才会把链表转变为红黑树。因为链表转换为红黑树也是需要消耗性能的，特殊情况特殊处理，为了挽回性能，权衡之下，才使用红黑树，提高性能。</p><p>也就是大部分情况下，hashmap还是使用的链表，如果是理想的均匀分布，节点数不到8，hashmap就自动扩容了。为什么这么说呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在链表转变为红黑树方法中，有这样一个判断，数组长度小于<code>MIN_TREEIFY_CAPACITY = 64</code>，就会扩容，而不是直接转变为红黑树，可不是什么链表长度为8就变为红黑树，要仔细看代码，还有别的条件。</p><p>现在回头想想，为啥用8？</p><p><strong>因为通常情况下，链表长度很难达到8，但是特殊情况下链表长度为8，哈希表容量又很大，造成链表性能很差的时候，只能采用红黑树提高性能，这是一种应对策略。</strong></p><h1 id="为什么退化为链表的阈值是6"><a class="markdownIt-Anchor" href="#为什么退化为链表的阈值是6"></a> 为什么退化为<a href="https://luoyu-ying.github.io/posts/59c5aea57d8c/">链表</a>的阈值是6</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/a7a76c5b8435">HashMap系列：树化阀值8，退化阀值6 - 简书 (jianshu.com)</a></li></ul></blockquote><p>如果不设退化阀值，只以8来树化与退化：<br />那么8将成为一个临界值，时而树化，时而退化，此时会非常影响性能，因此，我们需要一个比8小的退化阀值；</p><p>UNTREEIFY_THRESHOLD = 7<br />同样，与上面的情况没有好多少，仅相差1个元素，仍旧会在链表与树之间反复转化；</p><p>那为什么是6呢？<br />源码中也说了，考虑到内存（树节点比普通节点内存大2倍，以及避免反复转化），所以，退化阀值最多为6。</p><h1 id="hashmap中put如何实现的"><a class="markdownIt-Anchor" href="#hashmap中put如何实现的"></a> <code>HashMap</code>中<code>put</code>如何实现的</h1><p><code>put</code> 方法中会实现以下的过程：</p><ol><li>如果 <code>table</code> 没有初始化，就先进行初始化（<code>resize</code>）操作。</li><li>对 <code>key</code> 进行 <code>hash</code>，并计算出存放位置 <code>index</code> (<code>i = (n - 1) &amp; hash</code>)。</li><li>如果没碰撞直接放到<code>bucket</code>中。</li><li>如果发生碰撞了，就遍历链表：<ol><li>如果出现了key相同，value不同的节点，就替换该value(保证key的唯⼀性)。</li><li>否则直接加入到链表的结尾（<strong>尾插法</strong>）。</li></ol></li><li>如果链表过长(大于等于<code>TREEIFY_THRESHOLD</code>)，就把链表转换成红黑树(<code>JDK1.8</code>中的改动)。</li><li>如果<code>bucket</code>满了(超过<code>DEFAULT_LOAD_FACTOR</code> * <code>CAPACITY</code>)，就要<code>resize</code>。</li></ol><h1 id="hashmap中get如何实现的"><a class="markdownIt-Anchor" href="#hashmap中get如何实现的"></a> <code>HashMap</code>中<code>get</code>如何实现的</h1><p><code>get</code> 方法中会实现以下的过程：</p><ol><li>判断<code>table</code>是否为<code>null</code>，若为<code>null</code>，则直接返回<code>null</code>。</li><li>计算<code>key</code>的<code>hash</code>，并计算存放位置。</li><li>直接判断第一个元素是否为自己所需要的元素。如果是，则直接返回该节点。</li><li>如果有冲突，则通过<code>key.equals(k)</code>去查找对应的<code>Entry</code>。<ol><li>若为树，则<strong>在树中</strong>通过<code>key.equals(k)</code>查找，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</li><li>若为链表，则<strong>在链表中</strong>通过<code>key.equals(k)</code>查找，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 判断 表是否为空，表重读是否大于零，并且根据此 key 对应的表内是否存在 Node节点。    </span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 检查第一个Node 节点，若是命中则不需要进行do... whirle 循环。</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//树形结构，采用 对应的检索方法，进行检索。</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//链表方法 做while循环，直到命中结束或者遍历结束。</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表的查找的时间复杂度是多少"><a class="markdownIt-Anchor" href="#链表的查找的时间复杂度是多少"></a> 链表的查找的时间复杂度是多少</h1><p>时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><h1 id="hashmap在什么条件下扩容"><a class="markdownIt-Anchor" href="#hashmap在什么条件下扩容"></a> <code>HashMap</code>在什么条件下扩容</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/yanzige/p/8392142.html">深入理解HashMap的扩容机制 - 颜子歌 - 博客园 (cnblogs.com)</a></li></ul></blockquote><p>Java8不再像Java7中那样需要满足两个条件，Java8中扩容只需要满足一个条件：</p><p><em><em>当前存放新值</em>（注意不是替换已有元素位置时）<em>的时候已有元素的个数大于等于阈值（已有元素等于阈值，下一个存放后必然触发扩容机制）</em></em></p><p>注：</p><ol><li>扩容一定是放入新值的时候，该新值不是替换以前位置的情况下（说明：put（“name”,“zhangsan”），而map里面原有数据&lt;“name”,“lisi”&gt;，则该存放过程就是替换一个原有值，而不是新增值，则不会扩容）。</li><li>扩容发生在存放后，即是数据存放后（先存放后扩容），判断当前存入对象的个数，如果大于阈值则进行扩容。</li></ol><h1 id="为什么扩容是2的次幂"><a class="markdownIt-Anchor" href="#为什么扩容是2的次幂"></a> 为什么扩容是<strong>2的次幂</strong></h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/weixin_44273302/article/details/113733422">HashMap初始容量为什么是2的n次幂及扩容为什么是2倍的形式？_喜欢敲代码的Apollo的博客-CSDN博客</a></li></ul></blockquote><ol><li><p>得到的新的数组索引和老数组索引只有最高位区别，更快地得到新索引。</p></li><li><p>rehash时的取余操作，hash % length == hash &amp; (length - 1)这个关系只有在length等于二的幂次方时成立，位运算能比%高效得多。</p></li></ol><p><strong>HashMap#resize 源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap#resize</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    HashMapEntry[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMapEntry[] newTable = <span class="keyword">new</span> <span class="title class_">HashMapEntry</span>[newCapacity];<span class="comment">//新建一个数组</span></span><br><span class="line">    transfer(newTable);<span class="comment">//完成新旧数组拷贝</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(HashMapEntry[] newTable)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (HashMapEntry&lt;K,V&gt; e : table) &#123;<span class="comment">//遍历整个数组</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;<span class="comment">//将同一个位置的元素按链表顺序取出</span></span><br><span class="line">            HashMapEntry&lt;K,V&gt; next = e.next;<span class="comment">//先将当前元素指向的下一个元素存起来，一个一个存放到新表的位置中，记住不一定是同一位置，因为长度变了</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);<span class="comment">//根据新数组长度，重新生成数组索引</span></span><br><span class="line">            e.next = newTable[i];<span class="comment">//将当前位置的元素链表头指向即将新加入的元素，</span></span><br><span class="line">            newTable[i] = e;<span class="comment">//然后放入数组中，完成同一位置元素链表的拼接，最先添加的元素总在链表末尾</span></span><br><span class="line">            e = next;<span class="comment">//然后继续循环，拿出下一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="为什么hashmap线程不安全"><a class="markdownIt-Anchor" href="#为什么hashmap线程不安全"></a> 为什么<code>HashMap</code>线程不安全</h1><p>HashMap 没有通过锁的方式使得同一时间只有一个线程可以访问，如果多个线程同一时间对同一个元素进行修改，便会出现结果错误的情况。</p><h1 id="处理hashmap线程不安全"><a class="markdownIt-Anchor" href="#处理hashmap线程不安全"></a> 处理<code>HashMap</code>线程不安全</h1><ol><li>在之前使用<code>HashTable</code>。 在每一个函数前面都加上了synchronized 但是 效率太低 我们现在不常用了。</li><li>使用 <code>ConcurrentHashmap</code>。用于提高效率。</li></ol><h1 id="concurrenthashmap"><a class="markdownIt-Anchor" href="#concurrenthashmap"></a> <code>ConcurrentHashMap</code></h1><blockquote><p>答案参考自：</p><ul><li><a href="https://cloud.tencent.com/developer/article/1873182">ConcurrentHashMap（JDK8） - 云+社区 - 腾讯云 (tencent.com)</a></li></ul></blockquote><p><font size="5"><strong>对比</strong></font></p><p><font size="4"><strong>与HashMap的区别是什么？</strong></font></p><p>ConcurrentHashMap是HashMap的升级版，HashMap是线程不安全的，而ConcurrentHashMap是线程安全。而其他功能和实现原理和HashMap类似。</p><p><font size="4"><strong>与Hashtable的区别是什么？</strong></font></p><p>Hashtable也是线程安全的，但每次要锁住整个结构，并发性低。相比之下，ConcurrentHashMap获取size时才锁整个对象。</p><p>Hashtable对get/put/remove都使用了同步操作。ConcurrentHashMap只对put/remove同步。</p><p>Hashtable是快速失败的，遍历时改变结构会报错ConcurrentModificationException。ConcurrentHashMap是安全失败，允许并发检索和更新。</p><p><font size="4"><strong>JDK8的ConcurrentHashMap和JDK7的ConcurrentHashMap有什么区别？</strong></font></p><ol><li>JDK8中新增了红黑树</li><li>JDK7中使用的是头插法，JDK8中使用的是尾插法</li><li>JDK7中使用了分段锁，而JDK8中没有使用分段锁了</li><li>JDK7中使用了ReentrantLock，JDK8中没有使用ReentrantLock了，而使用了Synchronized</li><li>JDK7中的扩容是每个Segment内部进行扩容，不会影响其他Segment，而JDK8中的扩容和HashMap的扩容类似，只不过支持了多线程扩容，并且保证了线程安全</li></ol><p><font size="5"><strong>特性</strong></font></p><p><font size="4"><strong>ConcurrentHashMap是如何保证并发安全的？</strong></font></p><p>JDK7中ConcurrentHashMap是通过ReentrantLock+CAS+分段思想来保证的并发安全的，ConcurrentHashMap的put方法会通过CAS的方式，把一个Segment对象存到Segment数组中，一个Segment内部存在一个HashEntry数组，相当于分段的HashMap，Segment继承了ReentrantLock，每段put开始会加锁。</p><p>在JDK7的ConcurrentHashMap中，首先有一个Segment数组，存的是Segment对象，Segment相当于一个小HashMap，Segment内部有一个HashEntry的数组，也有扩容的阈值，同时Segment继承了ReentrantLock类，同时在Segment中还提供了put，get等方法，比如Segment的put方法在一开始就会去加锁，加到锁之后才会把key,value存到Segment中去，然后释放锁。同时在ConcurrentHashMap的put方法中，会通过CAS的方式把一个Segment对象存到Segment数组的某个位置中。同时因为一个Segment内部存在一个HashEntry数组，所以和HashMap对比来看，相当于分段了，每段里面是一个小的HashMap，每段公用一把锁，同时在ConcurrentHashMap的构造方法中是可以设置分段的数量的，叫做并发级别concurrencyLevel.</p><p>JDK8中ConcurrentHashMap是通过synchronized+cas来实现了。在JDK8中只有一个数组，就是Node数组，Node就是key，value，hashcode封装出来的对象，和HashMap中的Entry一样，在JDK8中通过对Node数组的某个index位置的元素进行同步，达到该index位置的并发安全。同时内部也利用了CAS对数组的某个位置进行并发安全的赋值。</p><p><font size="4"><strong>JDK8中的ConcurrentHashMap为什么使用synchronized来进行加锁？</strong></font></p><p>JDK8中使用synchronized加锁时，是对链表头结点和红黑树根结点来加锁的，而ConcurrentHashMap会保证，数组中某个位置的元素一定是链表的头结点或红黑树的根结点，所以JDK8中的ConcurrentHashMap在对某个桶进行并发安全控制时，只需要使用synchronized对当前那个位置的数组上的元素进行加锁即可，对于每个桶，只有获取到了第一个元素上的锁，才能操作这个桶，不管这个桶是一个链表还是红黑树。</p><p>想比于JDK7中使用ReentrantLock来加锁，因为JDK7中使用了分段锁，所以对于一个ConcurrentHashMap对象而言，分了几段就得有几个ReentrantLock对象，表示得有对应的几把锁。</p><p>而JDK8中使用synchronized关键字来加锁就会更节省内存，并且jdk也已经对synchronized的底层工作机制进行了优化，效率更好。</p><p><font size="4"><strong>JDK7中的ConcurrentHashMap是如何扩容的？</strong></font></p><p>JDK7中的ConcurrentHashMap和JDK7的HashMap的扩容是不太一样的，首先JDK7中也是支持多线程扩容的，原因是，JDK7中的ConcurrentHashMap分段了，每一段叫做Segment对象，每个Segment对象相当于一个HashMap，分段之后，对于ConcurrentHashMap而言，能同时支持多个线程进行操作，前提是这些操作的是不同的Segment，而ConcurrentHashMap中的扩容是仅限于本Segment，也就是对应的小型HashMap进行扩容，所以是可以多线程扩容的。</p><p>每个Segment内部的扩容逻辑和HashMap中一样。</p><p><font size="4"><strong>JDK8中的ConcurrentHashMap是如何扩容的？</strong></font></p><p>首先，JDK8中是支持多线程扩容的，JDK8中的ConcurrentHashMap不再是分段，或者可以理解为每个桶为一段，在需要扩容时，首先会生成一个双倍大小的数组，生成完数组后，线程就会开始转移元素，在扩容的过程中，如果有其他线程在put，那么这个put线程会帮助去进行元素的转移，虽然叫转移，但是其实是基于原数组上的Node信息去生成一个新的Node的，也就是原数组上的Node不会消失，因为在扩容的过程中，如果有其他线程在get也是可以的。</p><p><font size="4"><strong>JDK8中的ConcurrentHashMap有一个CounterCell，你是如何理解的？</strong></font></p><p>CounterCell是JDK8中用来统计ConcurrentHashMap中所有元素个数的，在统计ConcurentHashMap时，不能直接对ConcurrentHashMap对象进行加锁然后再去统计，因为这样会影响ConcurrentHashMap的put等操作的效率，在JDK8的实现中使用了CounterCell+baseCount来辅助进行统计，baseCount是ConcurrentHashMap中的一个属性，某个线程在调用ConcurrentHashMap对象的put操作时，会先通过CAS去修改baseCount的值，如果CAS修改成功，就计数成功，如果CAS修改失败，则会从CounterCell数组中随机选出一个CounterCell对象，然后利用CAS去修改CounterCell对象中的值，因为存在CounterCell数组，所以，当某个线程想要计数时，先尝试通过CAS去修改baseCount的值，如果没有修改成功，则从CounterCell数组中随机取出来一个CounterCell对象进行CAS计数，这样在计数时提高了效率。</p><p>所以ConcurrentHashMap在统计元素个数时，就是baseCount加上所有CountCeller中的value值，所得的和就是所有的元素个数。</p><h1 id="key可以是null吗value可以是null吗"><a class="markdownIt-Anchor" href="#key可以是null吗value可以是null吗"></a> key可以是<code>null</code>吗，<code>value</code>可以是<code>null</code>吗</h1><p>当然都是可以的，但是对于 <code>key</code>来说只能运行出现一个<code>key</code>值为<code>null</code>，但是可以出现多个<code>value</code>值为<code>null</code>。</p><h1 id="一般用什么值作为key值"><a class="markdownIt-Anchor" href="#一般用什么值作为key值"></a> 一般用什么值作为<code>key</code>值？</h1><p>一般用Integer、String这种不可变类当HashMap当key，⽽且String最为常⽤。</p><ol><li>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。 这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。 这就是HashMap中的键往往都使⽤字符串</li><li>因为获取对象的时候要⽤到equals()和hashCode()⽅法，那么键对象正确的重写这两个⽅法是⾮常重要的,这些类已 经很规范的覆写了hashCode()以及equals()⽅法。</li></ol><h1 id="用可变类当hashmap的key会有什么问题"><a class="markdownIt-Anchor" href="#用可变类当hashmap的key会有什么问题"></a> 用可变类当<code>Hashmap</code>的<code>key</code>会有什么问题</h1><p><code>hashcode</code>可能会发生变化，导致<code>put</code>进行的值，无法<code>get</code>出来。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 2022校招面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Handler - Android校招面试整理2022</title>
      <link href="/posts/a2ee5464a9b5/"/>
      <url>/posts/a2ee5464a9b5/</url>
      
        <content type="html"><![CDATA[<h1 id="handler的实现原理"><a class="markdownIt-Anchor" href="#handler的实现原理"></a> <code>Handler</code>的实现原理</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://luoyu-ying.github.io/posts/9435d0391c8a/">Handler 机制解析 | 洛语 の Blog (luoyu-ying.github.io)</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/Handler%E6%9C%BA%E5%88%B6ver2.png" alt="Handler 机制" /></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/a3f0101bb9aef02691d45337a906325f.png" alt="img" /></p><h1 id="子线程中能不能直接new一个handler为什么主线程可以主线程的looper第一次调用loop方法什么时候哪个类"><a class="markdownIt-Anchor" href="#子线程中能不能直接new一个handler为什么主线程可以主线程的looper第一次调用loop方法什么时候哪个类"></a> 子线程中能不能直接<code>new</code>一个<code>Handler</code>,为什么主线程可以？主线程的<code>Looper</code>第一次调用<code>loop</code>方法,什么时候,哪个类？</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/886b11e233b3">可以在子线程直接new一个Handler吗？怎么做？ - 简书 (jianshu.com)</a></li></ul></blockquote><p><strong>可以在子线程直接<code>new</code>一个<code>Handler</code>，不过需要在子线程里先调用<code>Looper#prepare</code>。<code>new</code>一个<code>Handler</code>后，还需要调用<code>Looper#loop</code>方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>有人会问，在主线程中为什么没看到<code>Looper.prepare()</code>？其实系统已经给我们调用了，不过调用的是<code>Looper.prepareMainLooper()</code>，如下源码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SystemServer 类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The main entry point from zygote.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SystemServer</span>().run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code>方法是整个<code>android</code>应用的入口，在子线程中调用<code>Looper.prepare()</code>是为了创建一个<code>Looper</code>对象，并将该对象存储在当前线程的<code>ThreadLocal</code>中。</p><p>每个线程都会有一个<code>ThreadLocal</code>，它为每个线程提供了一个本地的副本变量机制，实现了和其它线程隔离，并且这种变量只在本线程的生命周期内起作用，可以减少同一个线程内多个方法之间的公共变量传递的复杂度。<code>Looper.loop()</code>方法是为了取出消息队列中的消息并将消息发送给指定的<code>handler</code>,通过<code>msg.target.dispatchMassage()</code>方法。</p><h1 id="handler导致的内存泄露原因及其解决方案"><a class="markdownIt-Anchor" href="#handler导致的内存泄露原因及其解决方案"></a> <code>Handler</code>导致的内存泄露原因及其解决方案</h1><blockquote><p>当不再需要某个实例后，这个对象却仍然被引用，阻止被垃圾回收(Prevent from being bargage collected)，这个情况就叫做内存泄露(Memory Leak)。</p></blockquote><p>考虑以下的代码；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Handler</span> <span class="variable">mLeakyHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然不明显，但是这段代码可能导致内存泄露。Android Lint会提示以下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In Android, Handler classes should be static or leaks might occur.</span><br></pre></td></tr></table></figure><p><strong>它到底是如何泄露的呢？</strong></p><ol><li><p>当一个<code>Android</code>应用程序启动的时候，<code>Android</code>框架为这个程序的主线程即UI线程创建了一个<code>Looper</code>对象，用于处理<code>Handler</code>中的<code>Message</code>。<br /><code>Looper</code>实现了一个简单的消息队列<code>MessageQueue</code>，不断循环的处理其中的<code>message</code>。<br />所有的应用程序框架的事件（比如<code>Activity</code>生命周期的调用，按钮的点击等）都被封装在这个<code>Message</code>对象里，然后被加入到<code>Looper</code>的<code>MessageQueue</code>，最后一个一个的处理这些<code>Message</code>。<br />注意，<code>Looper</code>在整个应用程序的生命周期中一直存在。</p></li><li><p>在主线程中实例化一个<code>Handler</code>对象的时候，就和它关联了主线程<code>Looper</code>的消息队列<code>MessageQueue</code>。<br />被发送到这个消息队列的<code>Message</code>将保持对这个Handler对象的引用，这样框架就可以在处理这个<code>Message</code>的时候调用<code>Handler.handleMessage(Message)</code>来处理消息了。<br />(也就是说，只要没有处理到这个<code>Message</code>，<code>Handler</code>就一直在队列中被引用)。</p></li><li><p>在<code>Java</code>中，非静态内部类和匿名内部类都隐式的保持了一个对外部类<code>outerclass</code>的引用。<strong>但是静态内部类不会有这个引用。</strong></p></li></ol><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/5238c9d2921c4ba6b78be289b24a7d27.jpg" style="zoom:67%;" /><p><strong>正确的解决方法：</strong></p><ol><li><code>Handler</code>静态内部类 + <code>WeakReference&lt;Activity&gt;</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态内部类不会持有外部类的信用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;MainActivity&gt; mActivity;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyHandler</span><span class="params">(MainActivity activity)</span> &#123;</span><br><span class="line">            mActivity = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;MainActivity&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="type">MainActivity</span> <span class="variable">activity</span> <span class="operator">=</span> mActivity.get();</span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">MyHandler</span> <span class="variable">mHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHandler</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><ol start="2"><li>静态<code>Runnable</code>，避免对外部类的引用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名类用static修饰后，不会再持有外部类的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">sRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState); </span><br><span class="line">        mHandler.postDelayed(sRunnable, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// Go back to the previous Activity.</span></span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类和非静态内部类的区别很微小，但是开发人员必须了解。</p><p>那么底线是什么？</p><p>当内部类可以独立于<code>Activity</code>的生命周期而存在的时候，应该避免使用非静态内部类，应该用静态内部类并且使用<code>WeakReference</code>保持对<code>Activity</code>的引用。</p><p><strong>深入理解</strong></p><p>像下面这样使用handler的时候，其实是将handler定义为了匿名内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mLeakyHandler=<span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123; </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<strong>匿名内部类会默认持有外部类（<code>MainActivity</code>）的引用</strong>。</p><p>学过<code>handler</code>的都知道，<code>handler</code>发送消息后，消息会进行入队操作，在<code>enqueueMessage</code>方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg.targer = <span class="built_in">this</span>;</span><br></pre></td></tr></table></figure><p><code>this</code>指的就是handler，所以<code>handler</code>被<code>message</code>持有了，而<code>message</code>放入消息队列后，<code>message</code>又被<code>MessageQueue</code>持有了，而<code>MessageQueue</code>是在创建Looper的时候生成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以<code>MessageQueue</code>又被<code>looper</code>所持有。如果这个<code>handler</code>是主线程的<code>handler</code>，那么此时的<code>looper</code>就是指的主线程的<code>Looper</code>，它的声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;</span><br></pre></td></tr></table></figure><p>可以看到主线程的<code>looper</code>是<code>static</code>静态变量，而<code>static</code>静态变量在垃圾回收的时候是会被当做<code>GC Root</code>的，静态变量的生命周期与<code>APP</code>的生命周期、与虚拟机的生命周期是一样的，所以正是因为这个持有链的存在，导致了内存泄露。</p><p>引用链大致如下：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRstaticLooper[&quot;(static) Looper&quot;]staticLooper --&gt;|持有| MessageQueue --&gt;|持有| Message --&gt;|持有| Handler --&gt;|持有| MainActivity  </pre></div><p>所以解决 <code>handler</code> 内存泄露的办法就是要破坏这个持有链，比如只要 <code>handler</code> 不被 <code>activity</code> 持有就可以，所以可以把 <code>handler</code> 定义为<code>static</code>，因为 <code>static</code> 不会持有外部类，这样 <code>handler</code> 就不会持有 <code>activity</code> 了。</p><p><strong>怎样判断一个内部类有没有被持有外部类？</strong></p><p>比如上面的<code>handler</code>定义，没有加static的时候，在<code>handleMessage</code>方法里面可以正常使用<code>MainActivity.this</code>，这说明它持有了外部类。而一旦<code>Handler</code>加上static关键字，在<code>handleMessage</code>方法内部就不能再使用<code>MainActivity.this</code>，说明它没有持有外部类。</p><p>（为什么<code>static</code>变量，不会造成内存泄露？<code>static</code> 不会去持有外部类）</p><h1 id="messagequeue是什么数据结构"><a class="markdownIt-Anchor" href="#messagequeue是什么数据结构"></a> <code>MessageQueue</code>是什么数据结构</h1><p><code>MessageQueue</code> 是一个基于时间排序的<strong>优先队列</strong>。</p><h1 id="message对象创建的方式有哪些-区别"><a class="markdownIt-Anchor" href="#message对象创建的方式有哪些-区别"></a> <code>Message</code>对象创建的方式有哪些 &amp; 区别？</h1><p>创建Message对象的时候，<strong>有三种方式</strong>，分别为：</p><ol><li><code>Message msg = new Message();</code></li><li><code>Message msg = Message.obtain();</code></li><li><code>Message msg = handler.obtainMessage();</code></li></ol><p><strong>分析</strong></p><ol><li><p><code>Message msg = new Message();</code></p><p>这种就是直接初始化一个Message对象，没有什么特别的。</p></li><li><p><code>Message msg = Message.obtain();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment">* avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line"><span class="keyword">if</span> (sPool != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="literal">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从注释可以得知，从整个<code>Message</code>池中返回一个新的<code>Message</code>实例，通过<code>obtainMessage</code>能避免重复<code>Message</code>创建对象。</p></li><li><p><code>Message msg = handler1.obtainMessage();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title function_">obtainMessage</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Message.obtain(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">(Handler h)</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> obtain();</span><br><span class="line">    m.target = h;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="literal">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，第二种跟第三种其实是一样的，都可以避免重复创建Message对象，所以建议用第二种或者第三种任何一个创建Message对象。</p></li></ol><h1 id="messageobtain怎么维护消息池的"><a class="markdownIt-Anchor" href="#messageobtain怎么维护消息池的"></a> <code>Message.obtain()</code>怎么维护消息池的？</h1><p>使用了<strong>享元设计模式</strong>，当前message执行完后，把message置为空，然后重新给message进行赋值。 通<strong>过链表的形式</strong>，进行了复用和回收</p><h1 id="handler-有哪些发送消息的方法"><a class="markdownIt-Anchor" href="#handler-有哪些发送消息的方法"></a> <code>Handler</code> 有哪些发送消息的方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//版本1</span><br><span class="line">Message message = new Message();</span><br><span class="line">message.what = 0;</span><br><span class="line">message.obj = &quot;hello&quot;;</span><br><span class="line">mHandler.sendMessage(message); </span><br><span class="line"></span><br><span class="line">//版本2</span><br><span class="line">Message message = mHandler.obtainMessage();</span><br><span class="line">message.what = 0;</span><br><span class="line">message.obj = &quot;hello&quot;;</span><br><span class="line">mHandler.sendMessage(message);</span><br><span class="line"></span><br><span class="line">//版本3</span><br><span class="line">mHandler.obtainMessage(0,&quot;hello&quot;).sendToTarget();</span><br></pre></td></tr></table></figure><p>其中，版本3 使用到的 <code>sendToTarget</code> 方法只适用于有<code>target</code>值的<code>Message</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Sends this Message to the Handler specified by &#123;<span class="doctag">@link</span> #getTarget&#125;.</span></span><br><span class="line"><span class="comment">* Throws a null pointer exception if this field has not been set.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendToTarget</span><span class="params">()</span> &#123;</span><br><span class="line">target.sendMessage(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="handler的post与sendmessage的区别和应用场景"><a class="markdownIt-Anchor" href="#handler的post与sendmessage的区别和应用场景"></a> <code>Handler</code>的<code>post</code>与<code>sendMessage</code>的区别和应用场景</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/jingerlovexiaojie/article/details/107973310">Handler发送消息的方式_程序员老林的博客-CSDN博客_handler发送消息</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220517154734.png" alt="img" /></p><h1 id="子线程能不能更新ui"><a class="markdownIt-Anchor" href="#子线程能不能更新ui"></a> 子线程能不能更新UI</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/xyh269/article/details/52728861">Android中子线程真的不能更新UI吗？_yinhuanxu的博客-CSDN博客_android非主线程更新ui</a></li></ul></blockquote><p>极端情况下是可以的。</p><ol><li><p>更新UI后会立即通过 <code>ViewRootImpl</code> 类执行里面的 <code>performTraversal</code> 方法。</p></li><li><p>在 <code>performTraversal</code> 方法前，还会先执行一个 <code>checkThread</code> 方法。如果监测到当前的线程不是主线程，就会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">checkThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CalledFromWrongThreadException</span>(</span><br><span class="line">                <span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过源码可以发现， <code>ViewRootImpl</code> 类的创建是在回调了 <code>onResume</code> 方法之后。所以我们在 <code>onCreate</code> 方法中通过子线程立即更新UI时，由于该类并没有创建，所以无法检测当前线程是否为主线程，所以程序没有崩溃一样能跑起来，如果修改了程序，让线程休眠了200毫秒后，程序就崩了。很明显200毫秒后<code>ViewRootImpl</code>已经创建了，可以执行<code>checkThread</code>方法检查当前线程。</p></li></ol><h1 id="为什么android系统不建议子线程访问ui"><a class="markdownIt-Anchor" href="#为什么android系统不建议子线程访问ui"></a> 为什么Android系统不建议子线程访问UI</h1><p>Android的UI访问是没有加锁的，这样在多个线程访问UI是不安全的。所以Android中规定只能在UI线程中访问UI。</p><h1 id="postdelay后消息队列有什么变化假设先-postdelay-10s-再postdelay-1s-怎么处理这2条消息"><a class="markdownIt-Anchor" href="#postdelay后消息队列有什么变化假设先-postdelay-10s-再postdelay-1s-怎么处理这2条消息"></a> <code>postDelay</code>后消息队列有什么变化，假设先 <code>postDelay</code> 10s, 再<code>postDelay</code> 1s, 怎么处理这2条消息</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://juejin.cn/post/7030413030940737549">android 面试题handle系列 - 掘金 (juejin.cn)</a></li></ul></blockquote><p>如果队列中只有这个消息，那么消息不会被发送，而是计算到时唤醒的时间，先将Looper阻塞，到时间就唤醒它。</p><p>但如果此时要加入新消息，该消息队列的对头跟delay时间相比更长，则插入到头部，<strong>按照触发时间进行排序</strong>，队头的时间最小、队尾的时间最大。<strong>（消息队列为优先队列）</strong></p><h1 id="messagequeue的enqueuemessage方法如何进行线程同步的"><a class="markdownIt-Anchor" href="#messagequeue的enqueuemessage方法如何进行线程同步的"></a> <code>MessageQueue</code>的<code>enqueueMessage</code>()方法如何进行线程同步的</h1><p>通过源码可以发现，<code>enqueueMessage</code> 方法中，通过了 <code>synchronized</code> 关键字对 <code>MessageQueue</code> 进行了上锁的处理。保证了线程的同步。</p><h1 id="threadlocal在handler机制中的作用"><a class="markdownIt-Anchor" href="#threadlocal在handler机制中的作用"></a> <code>ThreadLocal</code>在<code>Handler</code>机制中的作用</h1><blockquote><p>ThreadLocal 更多细节：</p><ul><li>[ThreadLocal 解析 <a href="https://luoyu-ying.github.io/posts/03160a3be19b/">转载] | 洛语 の Blog (luoyu-ying.github.io)</a></li></ul></blockquote><p><code>Threadlocal</code>内部是一个<code>Map</code>实现，以当前线程<code>Threadlocal</code>为键，以<code>Looper</code>为值进行绑定，<strong>保证一个线程对应一个<code>Looper</code></strong>。</p><h1 id="当activity有多个handler的时候怎么样区分当前消息由哪个handler处理"><a class="markdownIt-Anchor" href="#当activity有多个handler的时候怎么样区分当前消息由哪个handler处理"></a> 当<code>Activity</code>有多个<code>Handler</code>的时候，怎么样区分当前消息由哪个<code>Handler</code>处理</h1><p>在<code>Looper#loop</code>中，<code>Looper</code>把<code>message</code>直接交给了<code>target</code>即发送这个消息的<code>handler</code>处理。</p><h1 id="handler-如何与-looper-关联的"><a class="markdownIt-Anchor" href="#handler-如何与-looper-关联的"></a> <code>Handler</code> 如何与 <code>Looper</code> 关联的</h1><p>通过 ThreadLocal 进行关联。</p><h1 id="looper-如何与-thread-关联的"><a class="markdownIt-Anchor" href="#looper-如何与-thread-关联的"></a> <code>Looper</code> 如何与 <code>Thread</code> 关联的</h1><p>通过 ThreadLocal 进行关联。</p><h1 id="通过handler如何实现线程的切换"><a class="markdownIt-Anchor" href="#通过handler如何实现线程的切换"></a> 通过<code>Handler</code>如何实现线程的切换</h1><p>实际线程间切换，就是通过<strong>线程间共享变量</strong>实现的。</p><p>在A线程new handler()，在b线程调用这个handler发送消息，这个message发送到了，A线程中的 messageQueue里面，又回到了a线程中执行。</p><h1 id="android中为什么主线程不会因为looperloop里的死循环卡死"><a class="markdownIt-Anchor" href="#android中为什么主线程不会因为looperloop里的死循环卡死"></a> <code>Android</code>中为什么主线程不会因为<code>Looper#loop</code>里的死循环卡死？</h1><p>主线程确实是阻塞的,不阻塞那<code>APP</code>怎么能一直运行？</p><p>所以说主线程阻塞是一个伪命题,只不过是没有弄明白既然阻塞了,为什么还能调用各种声明周期而已。</p><p>调用生命周期是因为有<code>Looper</code>,有<code>MessageQueue</code>,还有沟通的桥梁<code>Handler</code>,通过<code>IPC</code>机制调用<code>Handler</code>发送各种消息,保存到<code>MessageQueue</code>中,然后在主线程中的<code>Looper</code>提取了消息,并在主线程中调用<code>Handler</code>的方法去处理消息.最终完成各种声明周期。</p><h1 id="messagequeuenext-在没有消息的时候会阻塞如何恢复"><a class="markdownIt-Anchor" href="#messagequeuenext-在没有消息的时候会阻塞如何恢复"></a> <code>MessageQueue#next</code> 在没有消息的时候会阻塞，如何恢复？</h1><p>用 <code>MessageQueue#enqueueMessage</code> 时会唤醒 <code>MessageQueue</code>，这个方法会被 <code>Handler#sendMessage</code>、<code>Handler#post</code> 等一系列发送消息的方法调用。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 2022校招面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
            <tag> Handler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View事件分发 - Android校招面试整理2022</title>
      <link href="/posts/0557737935e1/"/>
      <url>/posts/0557737935e1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/qq_40959750/article/details/119218780">View事件分发相关面试题_打架不行的二哈的博客-CSDN博客_事件分发机制面试题</a></li></ul></blockquote><h1 id="view事件分发机制"><a class="markdownIt-Anchor" href="#view事件分发机制"></a> <code>View</code>事件分发机制</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://luoyu-ying.github.io/posts/38fdb1d1c50f/">View 的事件体系 | 洛语 の Blog (luoyu-ying.github.io)</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/22046c435b7d49f29b7ad04214c4c2fb.png" alt="" /></p><h1 id="事件是先到-decorview-还是先到-window"><a class="markdownIt-Anchor" href="#事件是先到-decorview-还是先到-window"></a> 事件是先到 <code>DecorView</code> 还是先到 <code>Window</code></h1><p>由上述流程图中可以得知，事件的分发顺序为</p><p><code>Activity -&gt; Window -&gt; DecorView -&gt; ViewGroup -&gt; View</code></p><h1 id="view的ontouchevent-onclicklisterner和ontouchlistener的ontouch方法的三者优先级"><a class="markdownIt-Anchor" href="#view的ontouchevent-onclicklisterner和ontouchlistener的ontouch方法的三者优先级"></a> <code>View</code>的<code>onTouchEvent</code>、<code>OnClickListerner</code>和<code>OnTouchListener</code>的<code>onTouch</code>方法的三者优先级</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://cloud.tencent.com/developer/article/1333422">Android View的Touch事件分发</a></li></ul></blockquote><p>点击事件的执行顺序为</p><p><code>OnTouchListener.DOWN -&gt; OnTouchEvent.DOWN -&gt; OnTouchListener.MOVE -&gt; OnTouchEvent.MOVE -&gt; OnTouchListener.UP -&gt; OnTouchEvent.UP -&gt; OnClickListener</code></p><p>所以三者的优先级为</p><p><code>OnTouchListener &gt; onTouchEvent &gt; onClick</code></p><h1 id="ontouch-和-ontouchevent-的区别"><a class="markdownIt-Anchor" href="#ontouch-和-ontouchevent-的区别"></a> <code>onTouch</code> 和 <code>onTouchEvent</code> 的区别</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/huiguixian/article/details/22193977">Android View的onTouchEvent和OnTouch区别_小小攻城师的博客-CSDN博客_ontouch和ontouchevent区别</a></li></ul></blockquote><ol><li><p><code>onTouchListener</code>的<code>onTouch</code>方法优先级比<code>onTouchEvent</code>高，会先触发。</p></li><li><p>假如<code>onTouch</code>方法返回false会接着触发<code>onTouchEvent</code>，反之<code>onTouchEvent</code>方法不会被调用。</p></li><li><p>内置诸如<code>click</code>事件的实现等等都基于<code>onTouchEvent</code>，假如<code>onTouch</code>返回<code>true</code>，这些事件将不会被触发。</p></li></ol><h1 id="activity-viewgroup和view都不消费action_down那么action_up事件是怎么传递的"><a class="markdownIt-Anchor" href="#activity-viewgroup和view都不消费action_down那么action_up事件是怎么传递的"></a> <code>Activity</code> 、<code>ViewGroup</code>和<code>View</code>都不消费<code>ACTION_DOWN</code>,那么<code>ACTION_UP</code>事件是怎么传递的</h1><p>首先，如果大家都不消费 ACTION_DOWN，那么 ACTION_DOWN 的事件传递流程是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Activity.dispatchTouchEvent() </span><br><span class="line">-&gt; ViewGroup1.dispatchTouchEvent() </span><br><span class="line">-&gt; ViewGroup1.onInterceptTouchEvent()</span><br><span class="line">-&gt; view1.dispatchTouchEvent() </span><br><span class="line">-&gt; view1.onTouchEvent() </span><br><span class="line">-&gt; ViewGroup1.onTouchEvent() </span><br><span class="line">-&gt; Activity.onTouchEvent();</span><br></pre></td></tr></table></figure><p>接着，由于大家都不消费 ACTION_DOWN，对于 ACTION_MOVE 和 ACTION_UP 的事件传递是这样的</p><p>接着，由于大家都不消费 ACTION_DOWN，对于 ACTION_MOVE 和 ACTION_UP 的事件传递是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Activity.dispatchTouchEvent()</span><br><span class="line">-&gt; Activity.onTouchEvent();</span><br><span class="line">-&gt; 消费</span><br></pre></td></tr></table></figure><h1 id="点击事件被拦截但是想传到下面的view如何操作"><a class="markdownIt-Anchor" href="#点击事件被拦截但是想传到下面的view如何操作"></a> 点击事件被拦截，但是想传到下面的<code>View</code>，如何操作</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>可将点击事件传到下面的<code>View</code>, 剥夺了父<code>View</code> 对除了<code>ACTION_DOWN</code>以外的事件的处理权。</p><h1 id="如何解决view的事件冲突"><a class="markdownIt-Anchor" href="#如何解决view的事件冲突"></a> 如何解决<code>View</code>的事件冲突</h1><h2 id="三种出现滑动冲突的情况"><a class="markdownIt-Anchor" href="#三种出现滑动冲突的情况"></a> 三种出现滑动冲突的情况</h2><ol><li><code>内部View</code>与<code>外部View</code>的滑动方向相反。</li><li><code>内部View</code>与<code>外部View</code>的滑动方向相同。</li><li>前两种情况的嵌套。</li></ol><p>三种情况的处理思路：</p><ol><li>通过手势滑动的角度判断滑动的方向。</li><li>通过当前处于的不同的页面状态来判断应该滑动的<code>View</code>。</li><li>通过前两种的综合使用。</li></ol><h2 id="滑动冲突的解决方式"><a class="markdownIt-Anchor" href="#滑动冲突的解决方式"></a> 滑动冲突的解决方式</h2><h3 id="外部拦截法"><a class="markdownIt-Anchor" href="#外部拦截法"></a> 外部拦截法</h3><p>通过重写<strong>父容器的</strong><code>onInterceptTouchEvent</code>方法，所有的事件都先经过父容器的筛选，对其中父容器需要的事件进行拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">intercepted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) event.getX();</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) event.getY();</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN : &#123;</span><br><span class="line">            intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE : &#123;</span><br><span class="line">            <span class="keyword">if</span> (父容器需要当前的点击事件)</span><br><span class="line">                intercepted = <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">                intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP : &#123;</span><br><span class="line">            intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastXIntercept = x;</span><br><span class="line">    mLastYIntercept = y;</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部拦截法"><a class="markdownIt-Anchor" href="#内部拦截法"></a> 内部拦截法</h3><p>父元素拦截除<code>ACTION_DOWN</code>以外的其他事件，当事件到达子元素后，由子元素判断是否需要这些事件，不需要的事件将重新交由父容器来处理。这种方法和Android的事件分发机制不一致，需要配合<code>requestDisallowInterceptTouchEvent</code>方法才能正常的工作。</p><p>相关阅读链接：<a href="https://www.jianshu.com/p/fe3d109eb27e">Android TouchEvent之requestDisallowInterceptTouchEvent - 简书 (jianshu.com)</a></p><p><strong>子元素的<code>dispatchTouchEvent</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) event.getX();</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) event.getY();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN : &#123;</span><br><span class="line">            parent.requestDisallowInterceptTouchEvent(<span class="literal">true</span>); <span class="comment">// 此子View的所有父ViewGroup会跳过onInterceptTouchEvent回调</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE : &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">deltaX</span> <span class="operator">=</span> x - mLastX;</span><br><span class="line">            <span class="type">int</span> <span class="variable">deltaY</span> <span class="operator">=</span> y - mLastY;</span><br><span class="line">            <span class="keyword">if</span> (父容器需要当前的点击事件) &#123;</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP : &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> : </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastX = x;</span><br><span class="line">    mLastY = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>父容器的<code>onInterceptTouchEvent</code>方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="requestdisallowintercepttouchevent的调用时机"><a class="markdownIt-Anchor" href="#requestdisallowintercepttouchevent的调用时机"></a> <code>requestDisallowInterceptTouchEvent</code>的调用时机</h1><p><strong><code>parent.requestDisallowInterceptTouchEvent</code>的调用需要写在<code>onTouchEvent</code>方法中</strong></p><p>我们一个手势的操作，会经历<code>ACTION_DOWN</code>、<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等操作。</p><p>子<code>view</code>调用<code>requestDisallowInterceptTouchEvent(true)</code>的时间，是必须在能拿到点击事件的时候。</p><p>比如我们在<code>ACTION_DOWN</code>的时候调用了方法，接下来的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>都会直接传递到子<code>view</code>上了；如果是在子<code>view</code>的<code>ACTION_MOVE</code>方法中调用的话，那么要确认父<code>view</code>在<code>ACTION_MOVE</code>的过程中，能否将事件传递给子<code>view</code>就好了。</p><h1 id="同时对父-view-和子-view-设置点击方法优先响应哪个"><a class="markdownIt-Anchor" href="#同时对父-view-和子-view-设置点击方法优先响应哪个"></a> 同时对父 <code>View</code> 和子 <code>View</code> 设置点击方法，优先响应哪个</h1><p>优先响应子 view。</p><p>如果先响应父 view，那么子 view 将永远无法响应。父 view 要优先响应事件，必须先调用 onInterceptTouchEvent 对事件进行拦截，那么事件不会再往下传递，直接交给父 view 的 onTouchEvent 处理。</p><p>Android系统中ViewGroup的拦截事件默认不拦截。</p><h1 id="action_cancel什么时候触发"><a class="markdownIt-Anchor" href="#action_cancel什么时候触发"></a> <code>ACTION_CANCEL</code>什么时候触发</h1><ol><li><p>如果在父<code>View</code>中拦截<code>ACTION_UP</code>或<code>ACTION_MOVE</code>，在第一次父视图拦截消息的瞬间，父视图指定子视图不接受后续消息了，同时子视图会收到<code>ACTION_CANCEL</code>事件。一般是系统自己处理</p></li><li><p>如果触摸某个控件，但是又不是在这个控件的区域上抬起（移动到别的地方了），就会出现<code>ACTION_CANCEL</code>。</p></li></ol><h1 id="为什么子-view-不消费-action_down之后的所有事件都不会向下传递了"><a class="markdownIt-Anchor" href="#为什么子-view-不消费-action_down之后的所有事件都不会向下传递了"></a> 为什么子 <code>View</code> 不消费 <code>ACTION_DOWN</code>,之后的所有事件都不会向下传递了</h1><p>答案是：<code>mFirstTouchTarget</code>。</p><p>当子 view 对事件进行处理的时，那么 <code>mFirstTouchTarget</code> 就会被赋值，若是子 <code>view</code> 不对事件进行处理，那么 <code>mFirstTouchTarget</code> 就为 <code>null</code>，之后 <code>VIewGroup</code> 就会默认拦截所有的事件。</p><p>我们可以从 <code>dispatchTouchEvent</code> 中找到如下代码，可以看出来，若是子 <code>View</code> 不处理 <code>ACTION_DOWN</code>,那么之后的事件也不会给到它了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否拦截</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 省略和问题无关代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 默认拦截</span></span><br><span class="line">    intercepted = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在-viewgroup-中的-ontouchevent-中消费-action_down-事件onintercepttouch-默认设置那么-action_move-和-action_up-事件是怎么传递的"><a class="markdownIt-Anchor" href="#在-viewgroup-中的-ontouchevent-中消费-action_down-事件onintercepttouch-默认设置那么-action_move-和-action_up-事件是怎么传递的"></a> 在 <code>ViewGroup</code> 中的 <code>onTouchEvent</code> 中消费 <code>ACTION_DOWN</code> 事件（<code>onInterceptTouch</code> 默认设置），那么 <code>ACTION_MOVE</code> 和 <code>ACTION_UP</code> 事件是怎么传递的？</h1><p>首先，我们先分析一下 ACTION_DOWN 的事件走向，由于 ViewGroup 中的 onInterceptTouch 是默认设置的，那么 ACTION_DOWN 的事件最终在 ViewGroup 中的 onTouchEvent 方法中停止了，事件走向是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Activity.dispatchTouchEvent() </span><br><span class="line">-&gt; ViewGroup1.dispatchTouchEvent() </span><br><span class="line">-&gt; ViewGroup1.onInterceptTouchEvent()</span><br><span class="line">-&gt; view1.dispatchTouchEvent() </span><br><span class="line">-&gt; view1.onTouchEvent() </span><br><span class="line">-&gt; ViewGroup1.onTouchEvent() </span><br></pre></td></tr></table></figure><p>接着 ACTION_MOVE 和 ACTION_UP 的事件分发流程，之后 onInterceptTouch 和 View 中的方法都不会被调用了，事件分发如下：</p><p>接着 ACTION_MOVE 和 ACTION_UP 的事件分发流程，之后 onInterceptTouch 和 View 中的方法都不会被调用了，事件分发如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Activity.dispatchTouchEvent() </span><br><span class="line">-&gt; ViewGroup1.dispatchTouchEvent() </span><br><span class="line">-&gt; ViewGroup1.onTouchEvent() </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 2022校招面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Animation - Android校招面试整理2022</title>
      <link href="/posts/004ee5be31d6/"/>
      <url>/posts/004ee5be31d6/</url>
      
        <content type="html"><![CDATA[<h1 id="动画的类型"><a class="markdownIt-Anchor" href="#动画的类型"></a> 动画的类型</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/luzaiyy611/article/details/82083213">Android 属性动画和补间动画的区别和特性_luzaiyy611的博客-CSDN博客_属性动画和补间动画的区别</a></li></ul></blockquote><ol><li><p>View 动画（补间动画）</p><p>只产生了一个动画效果，其真实的坐标并没有发生改变（只是改变了View的显示效果而已，并不会真正的改变View的属性）。View做在做动画的时候，它并没有真正的移动它的位置，而是根据动画时间的插值，计算出一个Matrix，然后不停的invalidate，在onDraw中的Canvas上使用这个计算出来的Matrix去draw这个View的内容，并有onLayout中还是原来的位置，所以点击事件只能点击到原来的位置才能触发</p></li><li><p>帧动画</p></li><li><p>属性动画</p><p>属性动画可以对任何对象的属性做动画而不仅仅是View，甚至可以没有对象。除了作用对象进行扩展外，属性动画的效果也加强了，不仅能实现View动画的四种效果，还能实现其它多种效果，这些效果都是通过<code>ValuAnimator</code>或<code>ObjectAnimator</code>、<code>AnimatorSet</code>等来实现的。我们只需要告诉系统动画的运行时长，需要执行哪种类型的动画，以及动画的初始值和结束值，剩下的工作就可以全部交给系统去完成了。</p></li></ol><h1 id="补间动画和属性动画的区别"><a class="markdownIt-Anchor" href="#补间动画和属性动画的区别"></a> 补间动画和属性动画的区别</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/lgdcoder/p/10684996.html">Android补间动画和属性动画的区别及属性动画使用详解</a></li></ul></blockquote><ol start="2"><li>作用对象不同，补间动画只能作用在view上，属性动画可以作用在所有对象上。</li><li>属性变化不同，补间动画只是改变显示效果，不会改变view的属性，比如位置、宽高等，而属性动画实际改变对象的属性。</li><li>动画效果不同，补间动画只能实现位移、缩放、旋转和透明度四种动画操作，而属性动画还能实现补间动画所有效果及其他更多动画效果。</li></ol><h1 id="objectanimatorvalueanimator及其区别"><a class="markdownIt-Anchor" href="#objectanimatorvalueanimator及其区别"></a> <code>ObjectAnimator</code>，<code>ValueAnimator</code>及其区别</h1><p><strong>ValueAnimator</strong></p><p>ValueAnimator是整个属性动画机制当中最核心的一个类，前面我们已经提到了，属性动画的运行机制是通过不断地<strong>对值进行操作</strong>来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等，确实是一个非常重要的类。</p><p><strong>ObjectAnimator</strong></p><p>相比于ValueAnimator，ObjectAnimator可能才是我们最常接触到的类，因为ValueAnimator只不过是对值进行了一个平滑的动画过渡，但我们实际使用到这种功能的场景好像并不多。而ObjectAnimator则就不同了，它是可以直接<strong>对任意对象的任意属性进行动画操作</strong>的，比如说View的alpha属性。</p><p>不过虽说ObjectAnimator会更加常用一些，但是它其实是继承自ValueAnimator的，底层的动画实现机制也是基于ValueAnimator来完成的，因此ValueAnimator仍然是整个属性动画当中最核心的一个类。</p><p><strong>总结</strong></p><p><code>ValueAnimator</code> 是<strong>对 数值 进行平滑操作</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ValueAnimator</span> <span class="variable">anim</span> <span class="operator">=</span> ValueAnimator.ofFloat(<span class="number">0f</span>, <span class="number">1f</span>);  </span><br></pre></td></tr></table></figure><p><code>ObjectAnimator</code> 功能更加强大，是<strong>对 任意对象 的 任意属性值 进行平滑操作</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">animator</span> <span class="operator">=</span> ObjectAnimator.ofFloat(textview, <span class="string">&quot;alpha&quot;</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>);</span><br></pre></td></tr></table></figure><h1 id="timeinterpolator插值器typeevaluator估值器"><a class="markdownIt-Anchor" href="#timeinterpolator插值器typeevaluator估值器"></a> TimeInterpolator插值器，TypeEvaluator估值器</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://luoyu-ying.github.io/posts/89ece43bd0a9/">Android 动画深入分析 | 洛语 の Blog (luoyu-ying.github.io)</a></li></ul></blockquote><p>插值器和估值器是实现非匀速动画的重要手段。</p><h3 id="timeinterpolator"><a class="markdownIt-Anchor" href="#timeinterpolator"></a> <code>TimeInterpolator</code></h3><p>时间插值器。作用为<strong>根据时间的流逝的百分比计算当前属性值改变的百分比</strong>。</p><p>预设的有多种插值器，常见的三种如下：</p><ol><li><code>LinearInterpolator</code>——线性插值器：匀速动画</li><li><code>AccelerateDecelerateInterpolator</code>——加速减速插值器：动画两头慢中间快</li><li><code>DecelerateInterpolator</code>——减速插值器：动画越来越慢</li></ol><p>三个类都实现了<code>Interpolartor</code>接口，接口内部只有一个用来计算属性值的改变的百分比的<code>getInterpolation</code>方法需要实现。</p><h3 id="typeevaluator"><a class="markdownIt-Anchor" href="#typeevaluator"></a> <code>TypeEvaluator</code></h3><p>类型估值算法，也叫估值器。作用是<strong>根据属性值改变的百分比来计算改变后的属性值</strong>。</p><p>系统预置的有3种：</p><ol><li><code>IntEvaluator</code>：针对整形属性</li><li><code>FloatEvaluator</code>：针对浮点型属性</li><li><code>ArgbEvaluator</code>：针对Color属性</li></ol><p>三个类都实现了<code>TypeEvalator</code>接口，接口内部只有一个用来计算改变后的属性值的<code>evaluate</code>方法需要实现。</p><h3 id="计算顺序"><a class="markdownIt-Anchor" href="#计算顺序"></a> 计算顺序</h3><p>系统会根据当前的帧所在时刻与动画播放的总时间求出时间的流逝的百分比，再通过插值器计算出当前属性值改变的百分比，后用此值通过估值器计算出当前的属性改变后的确定的值是多少并通过<code>set</code>方法对属性赋值。</p><p>故属性动画要求对象的该属性有<code>set</code>方法（必须有）和<code>get</code>方法（可选）。</p><h1 id="自定义插值器和估值器"><a class="markdownIt-Anchor" href="#自定义插值器和估值器"></a> 自定义插值器和估值器</h1><p>我们可以自定义插值器和估值器，来实现自己想要的动画效果。实现方式也很简单。</p><p>因为插值器和估值器都是一个接口，且内部都只有一个方法，所以我们只需要派生一个类并实现接口就可以了，然后就可以做出千奇百怪的动画效果了。即：</p><ul><li>自定义插值器需要实现<code>Interpolator</code>或者<code>TimeInterpolator</code>接口</li><li>自定义估值器需要实现<code>TypeEvaluator</code>接口。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 2022校招面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
            <tag> Animation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora 流程图中文字显示不全 [转载]</title>
      <link href="/posts/b97556f04186/"/>
      <url>/posts/b97556f04186/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自：</p><ul><li><a href="https://blog.csdn.net/qq_28225871/article/details/119521382">Typora流程图中文字显示不全解决_日之朝矣的博客-CSDN博客_typora流程图不显示</a></li></ul></blockquote><p>最近使用 Typora 的流程图，发现流程图里的字总是显示不全，让我感觉十分难受，百度去搜解决方案，却没有人回答，因此写下此文。</p><p>这个是主题的问题，更改为 Github 主题，发现仍然显示不全，但是更改为 PixyII 主题却能正常使用了，推测从官方那里下载来的部分主题是基于 Github 主题进行修改。</p><p>我喜欢我现在的主题，不想换，下面是我的解决方法。</p><p><strong>文件 &gt;&gt; 偏好设置 &gt;&gt; 外观 &gt;&gt; 打开主题文件夹</strong></p><p>找到当前主题对应的 CSS 文件，比如 <code>Github.css</code> ，用记事本或者 VSCode 打开，翻到最下面，另起一行，添加如下代码，保存后，关闭所有 Typora 窗口，重新启动便可解决问题。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.md-require-zoom-fix</span> foreignObject &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: unset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局限性就是需要把自己喜欢的主题一个一个文件进行添加，但本人日常只用那一个主题。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View绘制 - Android校招面试整理2022</title>
      <link href="/posts/76aedbc4e682/"/>
      <url>/posts/76aedbc4e682/</url>
      
        <content type="html"><![CDATA[<h1 id="view-的绘制流程"><a class="markdownIt-Anchor" href="#view-的绘制流程"></a> View 的绘制流程</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://luoyu-ying.github.io/posts/19429a22b2b2/">View 的绘制原理 | 洛语 の Blog (luoyu-ying.github.io)</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-3d1255a5093de81fd5bdc27a300d2f0d_720w.jpg" alt="" /></p><h1 id="measurespec-是什么"><a class="markdownIt-Anchor" href="#measurespec-是什么"></a> <code>MeasureSpec</code> 是什么</h1><blockquote><p><code>spec</code> <strong><code>英[spek]</code></strong><code>n.</code>规格 <code>vt.</code>按特定标准设计并制造</p></blockquote><p><code>MeasureSpec</code>参与了<code>View</code>的<code>measure</code>过程。在测量过程中，系统将<code>View</code>的<code>LayoutParams</code>根据父容器所施加的规则转换成对应的<code>MeasureSpec</code>，然后再根据这个<code>MeasureSpec</code>来测量出<code>View</code>的测量宽/高。</p><p><code>MeasureSpec</code>代表一个32位的<code>int</code>值，高两位代表 测量模式<code>SpecMode</code>，低30位代表 该测量模式下的规格大小<code>SpecSize</code>。</p><p><code>MeasureSpec</code>与<code>SpecMode</code>、<code>SpecSize</code>之间可以通过位运算互相求出。</p><p>每个<code>View</code>的<code>measure</code>过程之前都会先计算其<code>MeasureSpec</code>的值，然后再对其进行<code>measure</code>。</p><p><strong>注意</strong>：<code>View</code>的宽和高各有一个<code>MeasureSpec</code>值，分别为<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>。</p><p><strong><code>SpecMode</code>的三种状态</strong></p><ol><li><p><code>UNSPECIFIED</code></p><p>父容器不对<code>View</code>做任何的限制，要多大给多大。<strong>这种情况一般用于系统的内部</strong>，表示一种测量方式的状态。</p></li><li><p><code>EXACTLY</code></p><p>父容器已经测出了<code>View</code>所需要的精确大小，此时的大小就是<code>View</code>的最终大小。</p><p>它对应于<code>LayoutParams</code>的<code>match_parent</code>和具体的数值这两种模式。</p></li><li><p><code>AT_MOST</code></p><p>父容器指定了一个可用的大小，<code>View</code>的大小不能大于这个值。</p><p>它对应于<code>LayoutParams</code>中的<code>wrap_content</code>。</p></li></ol><h1 id="子view创建measurespec创建规则是什么"><a class="markdownIt-Anchor" href="#子view创建measurespec创建规则是什么"></a> 子View创建<code>MeasureSpec</code>创建规则是什么</h1><p><strong><code>MeasureSpec</code>和<code>LayoutParams</code>的对应关系</strong></p><p>对于<code>DecorView</code>和普通<code>View</code>来说，<code>MeasureSpec</code>的转化过程略有不同。</p><p><strong>对于<code>DecorView</code>：</strong></p><p><strong><code>DecorView</code>的<code>MeasureSpec</code>由窗口的大小和<code>DecorView</code>自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在<code>ViewRootImpl</code>中的<code>measureHierarchy</code>方法中，调用<code>getRootMeasureSpec</code>方法，获得<code>DecorView</code>的<code>MeasureSpec</code>。</p><p>其中<code>getRootMeasureSpec</code>方法中，根据自身<code>LayoutParams</code>的不同大小，共有三种情况：</p><ol><li><code>LayoutParams.MATCH_PARENT</code>：精确模式，大小就是窗口的大小。</li><li><code>LayoutParams.WRAP_CONTENT</code>：最大模式，大小不定，但是不能超过窗口的大小。</li><li>固定大小(比如100dp)：精确模式，大小为<code>LayoutParams</code>中指定的大小。</li></ol><p><strong>对于普通<code>View</code>：</strong></p><p><strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在父容器的<code>measureChildWithMargins</code>中的<code>getChildMeasureSpec</code>方法获得<code>View</code>的<code>MeasureSpec</code>。</p><p>其中<code>getChildMeasureSpec</code>方法的参数中使用到了父容器的<code>MeasureSpec</code>。在这个方法中通过<code>switch</code>和<code>if</code>语句，对<code>View</code>的<code>MeasureSpec</code>进行了决定。结果如下：</p><table><thead><tr><th><code>↓childLayoutParams</code> \ <code>parentMeasureSpec→</code></th><th><code>EXACTLY</code></th><th><code>AT_MOST</code></th><th><code>UNSPECIFIED</code></th></tr></thead><tbody><tr><td><code>dp</code>/<code>px</code></td><td><code>EXACTLY</code><br>childSize</td><td><code>EXACTLY</code><br/>childSize</td><td><code>EXACTLY</code><br/>childSize</td></tr><tr><td><code>match_parent</code></td><td><code>EXACTLY</code><br/>parentSize</td><td><code>AT_MOST</code><br>parentSize</td><td><code>UNSPECIFIED</code><br>0</td></tr><tr><td><code>wrap_content</code></td><td><code>AT_MOST</code><br>parentSize</td><td><code>AT_MOST</code><br/>parentSize</td><td><code>UNSPECIFIED</code><br/>0</td></tr></tbody></table><p>上图可以简单记为：除了<code>dp</code>/<code>px</code>的精确模式情况外，三种<code>MeasureSpec</code>的级别为：<code>EXACTLY</code> &lt; <code>AT_MOST</code> &lt; <code>UNSPECIFIED</code> 且<code>childMeasureSpec</code> = max(<code>childLayoutParams</code> , <code>parentMeasureSpec</code>)。（<strong>实际上并无级别之分</strong>）</p><p>通过上面的表格，可以更加直观的看出：<strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><h1 id="自定义view-wrap_content不起作用的原因"><a class="markdownIt-Anchor" href="#自定义view-wrap_content不起作用的原因"></a> 自定义View <code>wrap_content</code>不起作用的原因</h1><p>对于直接继承<code>View</code>的自定义<code>View</code>来说，<strong>需要重写<code>onMeasure</code>方法并设置在<code>wrap_content</code>情况时的自身大小</strong>，否则在布局中使用<code>wrap_content</code>就相当于使用<code>match_parent</code>。</p><p>因为当自定义<code>View</code>处于<code>wrap_content</code>时，它的<code>SpecMode</code>为<code>AT_MOST</code>模式，由前文可知，当父容器无论为<code>AT_MOST</code>还是<code>ECACTLY</code>模式时，自定义<code>View</code>都为<code>AT_MOST</code>模式且尺寸大小为<code>parentSize</code>，也就是父容器的剩余空间，即自定义<code>View</code>的大小变得与父容器的剩余空间大小一致，显然不是我们需要的。</p><p><strong>解决方法：</strong></p><p>解决方法也是非常简单的。我们只需要在<code>onMeasure</code>方法中对</p><ol><li>仅<code>width</code>方向为<code>AT_MOST</code>模式</li><li>仅<code>height</code>方向为<code>AT_MOST</code>模式</li><li><code>width</code>方向以及<code>height</code>方向都为<code>AT_MOST</code>模式</li><li>其他的情况</li></ol><p>这四个状态单独判断，分别使用<code>setMeasuredDimension</code>方法直接为自定义<code>View</code>设置我们需要的值即可。</p><p>源码中对于<code>TextView</code>、<code>ImageView</code>等控件的<code>wrap_content</code>也做了特殊的处理。</p><h1 id="在activity中获取某个view的宽高有几种方法"><a class="markdownIt-Anchor" href="#在activity中获取某个view的宽高有几种方法"></a> 在Activity中获取某个View的宽高有几种方法</h1><p>由于<code>Activity</code>的启动和<code>View</code>的测量过程并不是同步进行的，因此无法保证在<code>Activity</code>启动时某个<code>View</code>已经测量完毕了。所以我们在<code>Activity</code>启动的时候，如果直接通过<code>getMeasuredWidth</code>/<code>getMeasuredHeight</code>方法获得的值可能为0。</p><p>以下有四种方法可以解决这个问题（详细代码见《Android开发艺术探索》190页）。</p><ol><li><p><code>Activity/View#onWindowFocusChanged</code></p><p>在<code>Activity</code>的<code>onResume</code>和<code>onPause</code>方法启动时，<code>onWindowFocusChanged</code>方法也会同时被调用，可以重写里面的内容，使之计算<code>View</code>的宽高。</p><p><strong>注意</strong>：<code>onWindowFocusChanged</code>方法会在<code>View</code>已经初始化完毕后才开始调用。</p></li><li><p><code>view.post(runnable)</code></p><p>通过<code>post</code>可以将一个<code>runnable</code>投递都消息队列的尾部，然后等待<code>Looper</code>调用此<code>runnable</code>的时候，<code>View</code>也已经初始化好了。</p></li><li><p><code>ViewTreeObserver</code></p><p><code>ViewTreeObserver</code>中的众多回调可以完成这个功能。</p><p>比如<code>OnGlobalLayoutListener</code>接口，当<code>View</code>树的状态发生改变或者<code>View</code>树内部的<code>View</code>的可见性发生改变的时候，<code>onGlobalLayout</code>方法将被回调，此时就可以获取<code>View</code>的宽高了。</p></li><li><p><code>view.measure(int widthMeasureSpec, int heightMeasureSpec)</code></p><p>可以主动调用该方法开始计算<code>view</code>的宽高。</p><ol><li><p><strong><code>match_parent</code></strong></p><p>由于正常的<code>measure</code>过程中，我们需要父容器的<code>MeasureSpec</code>的值，而此时父容器并没开始计算，我们无从得知这两个值的大小。故我们无法对<code>match_parent</code>的<code>view</code>计算其宽高。</p></li><li><p><strong><code>dp</code>/<code>px</code></strong></p><p>因为有精确的数值了，所以我们可以直接使用这个精确的数值通过<code>MeasureSpec.makeMeasureSpec</code>方法构建<code>view</code>的<code>MeasureSpec</code>。</p></li><li><p><strong><code>wrap_content</code></strong></p><p>直接将<code>MeasureSpec.makeMeasureSpec</code>方法中参数的值设置为<code>(1&lt;&lt;30)-1</code>即可，这是<code>View</code>理论上可以支持的最大值，所以这样构建<code>MeasureSpec</code>是合理的。</p></li></ol></li></ol><h1 id="oncreate-onresume中可以获取view的宽高吗怎么做brviewpost-为什么可以获取"><a class="markdownIt-Anchor" href="#oncreate-onresume中可以获取view的宽高吗怎么做brviewpost-为什么可以获取"></a> <code>onCreate</code>、<code>onResume</code>中可以获取View的宽高吗？怎么做？<br><code>View#post</code> 为什么可以获取？</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/qq_40714317/article/details/117666277">onCreate()、onResume() 中可以获取View的宽高吗？怎么做？ View.post{} 为什么可以获取？_qq_40714317的博客</a></li><li><a href="https://github.com/Moosphan/Android-Daily-Interview/issues/126">2019-08-21：View.post()为什么可以获取到宽高信息？ · Issue #126 · Moosphan/Android-Daily-Interview </a></li></ul></blockquote><p><strong><code>onCreate</code>、<code>onResume</code>中可以获取View的宽高吗？怎么做？</strong></p><p>View 的测绘绘制流程就是从 ViewRootImpl#performTraversals() 开始的，而这个方法的调用是在 onResume() 方法之后，所以在 onCreate() 和 onResume() 方法中拿不到 View 的测量值。</p><p>View的宽高是在onLayout阶段才能最终确定的，而在Activity#onCreate中并不能保证View已经执行到了onLayout方法，也就是说Activity的声明周期与View的绘制流程并不是一一绑定。所以onCreate() 和 onResume() 中获取不到View的宽高值。以Handler为基础，View.post() 将传入任务的执行时机调整到View 绘制完成之后。</p><p><strong><code>View#post</code> 为什么可以获取？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">view.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> view.getWidth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> view.getHeight();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样写一般是在 Activity 的 onResume 方法中，因为 onResume 执行在 View 初始化之前，如果在 onResume 中直接获取 View 宽高是获取不到的。</p><p>使用 view.post 就能获取到，因为 view.post 是向 主 Handler 的 MessageQueue 中插入一条待执行消息，但是因为系统在 ViewRoot 中初始化 View 时也是利用 Handler 机制，平且为了优先执行 View 的初始化设置了同步屏障，导致 view.post 插入的消息会在 View 初始化之后执行，那么肯定就能获取到 View 的宽高啦！</p><p><strong><code>Runnable</code>的执行时机具体是什么</strong></p><p>在 <strong>Android 7.0</strong> 之后，view.post()中的runnbale 能确定被执执行。具体来说：</p><p>Android 7.0之后，除了<code>performTraversal</code>中会调用外，在View的<code>dispatchAttachedToWindow</code>中也会调用，但Android 7.0之后不管在主线程还是在子线程都可以成功执行<code>view.post</code>内部逻辑，并不是因为增加了调用时机，而是取消了<code>ThreadLocal</code>机制，使得 <strong>不管在主线程还是子线程调用view.post方法，都会将runnable对象丢到主线程的任务队列中，更新UI或者获取view的信息</strong>。</p><h1 id="viewpost与handlerpost的区别"><a class="markdownIt-Anchor" href="#viewpost与handlerpost的区别"></a> <code>View#post</code>与<code>Handler#post</code>的区别</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/7280b2d3b4d1">Handler.post和View.post的区别 - 简书 (jianshu.com)</a></li></ul></blockquote><ol><li><p><code>Handler.post</code>，它的执行时间基本是等同于<code>onCreate</code>里那行代码触达的时间；</p></li><li><p>View.post，则不同，它说白了执行时间一定是在<code>Activity#onResume</code>发生后才开始算的；或者换句话说它的效果相当于你上面的<code>View.post</code>方法是写在<code>Activity#onResume</code>里面的（但只执行一次，因为<code>onCreate</code>不像onResume会被多次触发）；</p></li><li><p>当然，虽然这里说的是<code>post</code>方法，但对应的<code>postDelayed</code>方法区别也是类似的。</p></li></ol><h1 id="getwidth方法和getmeasurewidth方法的区别"><a class="markdownIt-Anchor" href="#getwidth方法和getmeasurewidth方法的区别"></a> <code>getWidth()</code>方法和<code>getMeasureWidth()</code>方法的区别</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/7d8a54dd692f">getMeasureWidth和getWidth的区别 - 简书 (jianshu.com)</a></li><li><a href="https://www.cnblogs.com/yongdaimi/p/13612622.html">android: View的getWidth() 和 getMeasureWidth()方法的区别 - 夜行过客 - 博客园 (cnblogs.com)</a></li></ul></blockquote><ol><li><p><code>getMeasureWidth()</code>方法在<code>measure()</code>过程结束后就可以获取到了，而<code>getWidth()</code>方法要在<code>layout()</code>过程结束后才能获取到。<code>getMeasuredWidth()</code>获取的是<code>View</code>原始的大小，也就是这个<code>View</code>在<code>XML</code>文件中配置或者是代码中设置的大小。<code>getWidth()</code>获取的是这个<code>View</code>最终显示的大小，这个大小有可能等于原始的大小，也有可能不相等。只要在代码里重新修改了子控件的摆放位置，<code>getWidth()</code>和<code>getMeasureWidth()</code>的值就会不同。</p></li><li><p><code>getMeasureWidth()</code>方法中的值是通过<code>setMeasuredDimension()</code>方法来进行设置的，而<code>getWidth()</code>方法中的值则是通过视图右边的坐标减去左边的坐标计算出来的。</p></li></ol><h1 id="view加载流程setcontentview"><a class="markdownIt-Anchor" href="#view加载流程setcontentview"></a> View加载流程（setContentView）</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/pgg_cold/article/details/79481301"> Android面试题（28）-android的view加载和绘制流程_胖哥哥飘过的博客-CSDN博客_android view加载流程</a></li></ul></blockquote><ol><li><p>通过Activity的setContentView方法间接调用PhoneWindow的setContentView()，在PhoneWindow中通过getLayoutInflate()得到LayoutInflate对象。</p></li><li><p>通过LayoutInflate对象去加载View，主要步骤是：</p><ol><li>通过xml的Pull方式去解析xml布局文件，获取xml信息，并保存缓存信息，因为这些数据是静态不变的。</li><li>根据xml的tag标签通过反射创建View逐层构建View。</li><li>递归构建其中的子View，并将子View添加到父ViewGroup中。</li></ol></li></ol><p>其中，有四种加载XML文件的常用方法：</p><ol><li><p>使用view的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> View.inflate(context, R.layout.child, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过系统获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LayoutInflater</span> <span class="variable">inflater</span> <span class="operator">=</span> (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> inflater.inflate(R.layout.child, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过LayoutInflater</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LayoutInflater</span> <span class="variable">inflater</span> <span class="operator">=</span> LayoutInflater.from(context);</span><br><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> inflater.inflate(R.layout.child, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过getLayoutInflater</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> getLayoutInflater().inflate(R.layout.child, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li></ol><p>View 加载过程结束后，便会开始 View 的绘制流程了。</p><h1 id="invalidate-和-postinvalidate-的区别"><a class="markdownIt-Anchor" href="#invalidate-和-postinvalidate-的区别"></a> <code>invalidate()</code> 和 <code>postInvalidate()</code> 的区别</h1><p>这两个方法都是在<strong>重绘当前控件</strong>的时候调用的。</p><p><strong>invalidate在UI线程中调用，postInvalidate在非UI线程中调用。</strong> 因为android的UI线程是非线程安全的，所以在非UI线程中，需要使用postInvalidate来使View重绘。</p><p>view调用invalidate将导致当前view的重绘（draw调用），view的父类将不会执行draw方法；viewGroup调用invalidate会使viewGroup的子view调用draw，也就是viewGroup内部的子view进行重绘。</p><h1 id="requestlayout-和-onlayout-的区别"><a class="markdownIt-Anchor" href="#requestlayout-和-onlayout-的区别"></a> <code>requestLayout()</code> 和 <code>onLayout()</code> 的区别</h1><p><strong>requestLayout()</strong></p><p><code>requestLayout</code>方法只会<strong>导致当前<code>view</code>的<code>measure</code>和<code>layout</code></strong>，而<code>draw</code>不一定被执行，只有当<code>view</code>的位置发生改变才会执行<code>draw</code>方法，因此如果要使当前<code>view</code>重绘需要调用<code>invalidate</code>。</p><p><strong>onLayout()</strong></p><p>在很多情况下requestLayout是不需要被调用的。</p><p>例如，我们把一个AbsoluteLayout里面的childView挪动一下位置。我们仅仅需要调用的可能就是重新布局当前AbsoluteLayout，然后调用invalidate方法进行重绘。而不是从当前View向上的整个View树形结构都要重新layout，onLayout，measure，onMeasure一次。在这种情况下可以直接调用onLayout。然后调用invalidate进行重绘。很明显可以提升绘制效率。</p><p>由于父View的layout实现了会通知布局的listener。但是由于无法得到listener，因此调用onlayout的时候无法对其进行通知，这也是这种实现的缺陷。</p><h1 id="自定义-view-的流程和注意事项"><a class="markdownIt-Anchor" href="#自定义-view-的流程和注意事项"></a> 自定义 View 的流程和注意事项</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/b0f0d5462d16">自定义View学习–定义View流程和注意事项 - 简书 (jianshu.com)</a></li><li><a href="https://blog.csdn.net/lmj623565791/article/details/38339817"> Android 手把手教您自定义ViewGroup（一）_鸿洋_的博客-CSDN博客_自定义viewgroup</a></li></ul></blockquote><hr /><h1 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> TODO</h1><ol><li>invalidate怎么局部刷新</li><li>Android绘制和屏幕刷新机制原理`</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 2022校招面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RecyclerView - Android校招面试整理2022</title>
      <link href="/posts/743419965876/"/>
      <url>/posts/743419965876/</url>
      
        <content type="html"><![CDATA[<h1 id="recyclerview-为什么要预布局"><a class="markdownIt-Anchor" href="#recyclerview-为什么要预布局"></a> RecyclerView 为什么要预布局</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://juejin.cn/post/6908256535005102094">RecyclerView：预布局和 ItemAnimator 解析</a></li></ul></blockquote><p><strong>什么是预布局</strong></p><p>预布局是指在正式布局 <code>RecyclerView</code> 中的 <code>ItemView</code> 前执行的一次布局过程。</p><p><strong>预布局的作用</strong></p><p>预布局的作用是为了使 <code>ItemAnimator</code> 执行时能给用户更好的视觉体验。</p><p><strong>预布局和正式布局的区别</strong></p><p>预布局过程和正式布局过程执行的都是一样的代码，不同的是预布局过程得到的是 <code>ItemAnimator</code> 执行前的布局，而正式布局得到的是 <code>ItemAnimator</code> 执行后的布局也就是最终用户看到的布局。</p><p><strong>什么情况下会执行预布局</strong></p><p>当布局结束后若有新的 <code>ItemView</code> 在布局结尾显示则需要执行预布局，也就是当 <code>RecycleView</code> 中有 <code>ItemView</code> 被删除或更新时需要执行预布局。看下图更清晰。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/recyclerview-interviewList-1.awebp" alt="img" /></p><p>从上图中可以看到当不执行预布局时如果布局结尾有新的 <code>ItemView</code> 出现会执行 <code>DefaultItemAnimator</code> 的添加动画（淡入），这种看起来好像卡顿一样的显示给用户的感觉并不好。当然如果根本没有动画那预布局也就没有了意义。</p><h1 id="recyclerview的多级缓存机制每一级缓存具体作用是什么分别在什么场景下会用到哪些缓存"><a class="markdownIt-Anchor" href="#recyclerview的多级缓存机制每一级缓存具体作用是什么分别在什么场景下会用到哪些缓存"></a> RecyclerView的多级缓存机制,每一级缓存具体作用是什么,分别在什么场景下会用到哪些缓存</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://juejin.cn/post/6935605122567241742">详细讲解RecyclerView缓存机制</a></li><li><a href="https://blog.csdn.net/jb_home/article/details/111647931">Android深入理解RecyclerView的缓存机制</a></li></ul></blockquote><p>RecyclerView 是先复用，后回收。</p><p>共四级缓存，分别为：</p><ol><li><code>ArrayList&lt;ViewHolder&gt; mAttachedScrap</code> &amp; <code>ArrayList&lt;ViewHolder&gt; mChangedSracp</code> (屏幕内)</li><li><code>ArrayList&lt;ViewHolder&gt; mCachedViews</code> (屏幕外)</li><li><code>ViewCacheExtension mViewCacheExtension</code> (自定义缓存)</li><li><code>RecycledViewPool mRecyclerPool</code> (缓存池)</li></ol><p>每一级缓存的具体作用是什么？</p><ol><li>mAttachedScrap(屏幕内)<ol><li>用于屏幕内itemview快速重用，不需要重新createView和bindView。</li><li>缓存大小没有限制，大小等于RecyclerView子View的数量。</li><li>该缓存中的ViewHolder无需重新绑定，只要ViewHolder的position和数据源中的position对应上。</li></ol></li><li>mCacheViews(屏幕外)<ol><li>保存最近移出屏幕的ViewHolder，包含数据和position信息，复用时必须是相同位置的ViewHolder才能复用。</li><li>应用场景在那些需要来回滑动的列表中，当往回滑动时，能直接复用ViewHolder数据，不需要重新bindView。</li><li>缓存大小有限制，默认缓存大小为2，可以修改默认缓存大小。</li><li>该缓存的特性是FIFO。</li><li>该缓存中的ViewHolder无需重新绑定，只要ViewHolder的position和数据源中的position和itemType对应上。</li></ol></li><li>mViewCacheExtension(自定义缓存)。<ol><li>不直接使用，需要用户自定义实现，默认不实现。</li><li>该接口只提供了get方法，没提供put方法。</li></ol></li><li>mRecyclerPool(缓存池)<ol><li>当cacheView满了后或者adapter被更换，将cacheView中移出的ViewHolder放到Pool中，放之前会把ViewHolder数据清除掉，所以复用时需要重新bindView。需要重新执行onBindView的只有一种缓存区，就是缓存池mRecyclerPool。</li><li>每个itemType对应的ScrapData的缓存大小默认值是5，可以修改缓存大小。</li><li>该缓存中的ViewHolder需要重新绑定数据。</li><li>可以提供给多个RecyclerView共享。</li></ol></li></ol><h1 id="recyclerview的回收复用机制"><a class="markdownIt-Anchor" href="#recyclerview的回收复用机制"></a> RecyclerView的回收复用机制</h1><p><code>RecyclerView</code>滑动时会触发<code>onTouchEvent#onMove</code>，回收及复用<code>ViewHolder</code>在这里就会开始。</p><p><strong>保存缓存流程：</strong></p><ol><li><p>插入或是删除itemView时，先把屏幕内的ViewHolder保存至AttachedScrap中。</p></li><li><p>滑动屏幕的时候，先消失的itemview会保存到CacheView，CacheView大小默认是2，超过数量的话按照先入先出原则，移出头部的itemview保存到RecyclerPool缓存池（如果有自定义缓存就会保存到自定义缓存里），RecyclerPool缓存池会按照itemview的itemtype进行保存，每个itemType缓存个数为5个，超过就会被回收。</p></li></ol><p><strong>获取缓存流程：</strong></p><ol><li><p>AttachedScrap中获取，通过pos匹配holder——&gt;获取失败，从CacheView中获取，也是通过pos获取holder缓存 ——&gt;获取失败，从自定义缓存中获取缓存——&gt;获取失败，从mRecyclerPool中获取 ——&gt;获取失败，重新创建viewholder——createViewHolder并bindview。</p></li><li><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/d7f4bedb15c617e67c094b234c8b0958.webp" alt="" /></p></li><li><p>总结一下上述流程：</p><ol><li>通过mAttachedScrap、mCachedViews及mViewCacheExtension获取的ViewHolder不需要重新创建布局及绑定数据；</li><li>通过缓存池mRecyclerPool获取的ViewHolder不需要重新创建布局，但是需要重新绑定数据；</li><li>如果上述缓存中都没有获取到目标ViewHolder，那么就会回调Adapter#onCreateViewHolder创建布局，以及回调Adapter#onBindViewHolder来绑定数据。</li></ol></li></ol><h1 id="listview-和-recyclerview-的区别"><a class="markdownIt-Anchor" href="#listview-和-recyclerview-的区别"></a> ListView 和 RecyclerView 的区别</h1><p>缓存机制</p><ol><li>ListView 是二级缓存，缓存的对象为 View</li><li>RecyclerView 是四级缓存，缓存的对象为 RecyclerView.ViewHolder</li></ol><p>使用方式</p><ol><li>ListView<ol><li>需要继承 BaseAdapter 类</li><li>需要自定义 ViewHolder 实现 Item 的复用</li></ol></li><li>RecyclerView<ol><li>需要继承 RecyclerView.Adapter 以及 RecyclerView.ViewHolder</li></ol></li></ol><p>布局效果</p><ol><li>ListView 只有一种纵向布局</li><li>RecyclerView 默认有三种布局效果，可以自己继承 LayoutManager 实现自己想要的效果</li></ol><p>空数据处理</p><ol><li>ListView 有 <code>setEmptyView</code> 方法处理 Adapter 数据为空的情况</li><li>RecyclerView 必须自己处理数据为空的情况</li></ol><p>Header View 与 Footer View</p><ol><li>ListView 提供了添加 Header View 与 Footer View 的方法</li><li>RecyclerView 必须自己实现添加的方法</li></ol><p>动画效果</p><ol><li>ListView 中没有默认实现的动画效果，但是我们可以在 Adapter 中自行实现。</li><li>RecyclerView 中已经实现了部分默认的动画效果，例如 <code>notifyItemChanged()</code>、<code>notifyDataInserted()</code>等方法。如果需要自定义动画，我们可以继承 RecyclerView.ItemAnimator类实现自己的动画效果。</li></ol><p>点击事件</p><ol><li>ListView 实现了 <code>onItemClickListener</code> 接口。</li><li>RecyclerView 中并没有实现默认的点击事件的监听方法，我们需要自行实现。</li></ol><p>嵌套滚动机制</p><ol><li>ListView没有实现嵌套滚动机制。</li><li>在事件分发机制中，Touch事件在进行分发的时候，由父View向子View传递，一旦子View消费这个事件的话，那么接下来的事件分发的时候，父View将不接受，由子View进行处理；但是与Android的事件分发机制不同，嵌套滚动机制（<code>Nested Scrolling</code>）可以弥补这个不足，<strong>能让子View与父View同时处理这个Touch事件</strong>，主要实现在于NestedScrollingChild与NestedScrollingParent这两个接口；而在RecyclerView中，实现的是NestedScrollingChild，所以能实现嵌套滚动机制。</li></ol><h1 id="recyclerview性能优化"><a class="markdownIt-Anchor" href="#recyclerview性能优化"></a> RecyclerView性能优化</h1><blockquote><p>答案参考自：</p><ul><li>[RecyclerView性能优化](<a href="https://www.jianshu.com/p/1853ff1e8de6">RecyclerView性能优化 - 简书 (jianshu.com)</a>)</li><li>[RecyclerView性能优化及高级使用](<a href="https://www.jianshu.com/p/b79ee254f848">RecyclerView性能优化及高级使用 - 简书 (jianshu.com)</a>)</li></ul></blockquote><ol><li><p><strong>减少 xml 文件 inflate 时间</strong></p><p>xml文件包括：layout、drawable的xml，xml文件inflate出ItemView是通过耗时的IO操作。可以使用代码去生成布局，即new View()的方式。这种方式是比较麻烦，但是在布局太过复杂，或对性能要求比较高的时候可以使用。</p></li><li><p><strong>设置高度固定</strong></p><p>如果item高度是固定的话，可以使用RecyclerView.setHasFixedSize(true);来避免requestLayout浪费资源。</p></li><li><p><strong>共用RecycledViewPool</strong></p><p>在嵌套RecyclerView中，如果子RecyclerView具有相同的adapter，那么可以设置RecyclerView.setRecycledViewPool(pool)来共用一个RecycledViewPool。</p><p><strong>Note</strong>: 如果LayoutManager是LinearLayoutManager或其子类，需要手动开启这个特性：layout.setRecycleChildrenOnDetach(true)。</p></li><li><p><strong>加大RecyclerView的缓存</strong></p><p>用空间换时间，来提高滚动的流畅性。</p><p>recyclerView.setItemViewCacheSize(20);</p><p>recyclerView.setDrawingCacheEnabled(true);</p><p>recyclerView.setDrawingCacheQuality(View.DRAWING_CACHE_QUALITY_HIGH);</p></li><li><p><strong>增加RecyclerView预留的额外空间</strong></p><p>额外空间：显示范围之外，应该额外缓存的空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">newLinearLayoutManager( <span class="built_in">this</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getExtraLayoutSpace</span><span class="params">(RecyclerView.Statestate)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>减少ItemView监听器的创建</strong></p><p>对ItemView设置监听器，不要对每个item都创建一个监听器，而应该共用一个XxListener，然后根据ID来进行不同的操作，优化了对象的频繁创建带来的资源消耗。</p></li><li><p><strong>回收资源</strong></p><p>通过重写RecyclerView.onViewRecycled(holder)来回收资源。</p></li></ol><hr /><h1 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> TODO</h1><ol><li>RecyclerView的刷新回收复用机制</li><li>RecyclerView的滑动回收复用机制</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> 2022校招面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
            <tag> RecyclerView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原问题列表 - Android校招面试整理2022</title>
      <link href="/posts/59c5aea57d8c/"/>
      <url>/posts/59c5aea57d8c/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://www.nowcoder.com/discuss/692490?type=post&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack">已经过了字节试用期，才敢回来还愿，Android社招面经分享_笔经面经_牛客网 (nowcoder.com)</a></li></ul></blockquote><h1 id="android"><a class="markdownIt-Anchor" href="#android"></a> Android</h1><h2 id="activity"><a class="markdownIt-Anchor" href="#activity"></a> Activity</h2><ol><li>Activity的启动流程</li><li>onSaveInstanceState(),onRestoreInstanceState的掉用时机</li><li>activity的启动模式和使用场景</li><li>Activity A跳转Activity B，再按返回键，生命周期执行的顺序</li><li>横竖屏切换,按home键,按返回键,锁屏与解锁屏幕,跳转透明Activity界面,启动一个 Theme 为 Dialog 的 Activity，弹出Dialog时Activity的生命周期</li><li>onStart 和 onResume、onPause 和 onStop 的区别</li><li>Activity之间传递数据的方式Intent是否有大小限制，如果传递的数据量偏大，有哪些方案</li><li>Activity的onNewIntent()方法什么时候会执行</li><li>显示启动和隐式启动</li><li>scheme使用场景,协议格式,如何使用</li><li>ANR 的四种场景</li><li>onCreate和onRestoreInstance方法中恢复数据时的区别</li><li>activty间传递数据的方式</li><li>跨App启动Activity的方式,注意事项</li><li>Activity任务栈是什么</li><li>有哪些Activity常用的标记位Flags</li><li>Activity的数据是怎么保存的,进程被Kill后,保存的数据怎么恢复的</li></ol><h2 id="service"><a class="markdownIt-Anchor" href="#service"></a> Service</h2><ol><li>service 的生命周期，两种启动方式的区别</li><li>Service启动流程</li><li>Service与Activity怎么实现通信</li><li>IntentService是什么,IntentService原理，应用场景及其与Service的区别</li><li>Service 的 onStartCommand 方法有几种返回值?各代表什么意思?</li><li>bindService和startService混合使用的生命周期以及怎么关闭</li></ol><h2 id="broadcastreceiver"><a class="markdownIt-Anchor" href="#broadcastreceiver"></a> BroadcastReceiver</h2><ol><li>广播的分类和使用场景</li><li>广播的两种注册方式的区别</li><li>广播发送和接收的原理</li><li>本地广播和全局广播的区别</li></ol><h2 id="contentprovider"><a class="markdownIt-Anchor" href="#contentprovider"></a> ContentProvider</h2><ol><li>什么是ContentProvider及其使用</li><li>ContentProvider,ContentResolver,ContentObserver之间的关系</li><li>ContentProvider的实现原理</li><li>ContentProvider的优点</li><li>Uri 是什么</li></ol><h2 id="handler"><a class="markdownIt-Anchor" href="#handler"></a> Handler</h2><ol><li>Handler的实现原理</li><li>子线程中能不能直接new一个Handler,为什么主线程可以？主线程的Looper第一次调用loop方法,什么时候,哪个类</li><li>Handler导致的内存泄露原因及其解决方案</li><li>一个线程可以有几个Handler,几个Looper,几个MessageQueue对象</li><li>Message对象创建的方式有哪些 &amp; 区别？Message.obtain()怎么维护消息池的</li><li>Handler 有哪些发送消息的方法</li><li>Handler的post与sendMessage的区别和应用场景</li><li>handler postDelay后消息队列有什么变化，假设先 postDelay 10s, 再postDelay 1s, 怎么处理这2条消息</li><li>MessageQueue是什么数据结构</li><li>Handler怎么做到的一个线程对应一个Looper，如何保证只有一个MessageQueue？ThreadLocal在Handler机制中的作用</li><li>HandlerThread是什么 &amp; 好处 &amp;原理 &amp; 使用场景</li><li>IdleHandler及其使用场景</li><li>消息屏障,同步屏障机制</li><li>子线程能不能更新UI</li><li>为什么Android系统不建议子线程访问UI</li><li>Android中为什么主线程不会因为Looper.loop()里的死循环卡死？MessageQueue#next 在没有消息的时候会阻塞，如何恢复？</li><li>Handler消息机制中，一个looper是如何区分多个Handler的？当Activity有多个Handler的时候，怎么样区分当前消息由哪个Handler处理？处理message的时候怎么知道是去哪个callback处理的</li><li>Looper.quit/quitSafely的区别</li><li>通过Handler如何实现线程的切换</li><li>Handler 如何与 Looper 关联的</li><li>Looper 如何与 Thread 关联的</li><li>Looper.loop()源码</li><li>MessageQueue的enqueueMessage()方法如何进行线程同步的</li><li>MessageQueue的next()方法内部原理</li><li>子线程中是否可以用MainLooper去创建Handler，Looper和Handler是否一定处于一个线程</li><li>ANR和Handler的联系</li></ol><h2 id="view绘制"><a class="markdownIt-Anchor" href="#view绘制"></a> View绘制</h2><ol><li>View绘制流程</li><li>MeasureSpec是什么</li><li>子View创建MeasureSpec创建规则是什么</li><li>自定义Viewwrap_content不起作用的原因</li><li>在Activity中获取某个View的宽高有几种方法</li><li>为什么onCreate获取不到View的宽高</li><li>View#post与Handler#post的区别</li><li>Android绘制和屏幕刷新机制原理</li><li>Choreography原理</li><li>什么是双缓冲</li><li>为什么使用SurfaceView</li><li>什么是SurfaceView</li><li>View和SurfaceView的区别</li><li>SurfaceView为什么可以直接子线程绘制</li><li>SurfaceView、TextureView、SurfaceTexture、GLSurfaceView</li><li>getWidth()方法和getMeasureWidth()区别</li><li>invalidate() 和 postInvalidate() 的区别</li><li>Requestlayout，onlayout，onDraw，DrawChild区别与联系</li><li>LinearLayout、FrameLayout 和 RelativeLayout 哪个效率高</li><li>LinearLayout的绘制流程</li><li>自定义 View 的流程和注意事项</li><li>自定义View如何考虑机型适配</li><li>自定义控件优化方案</li><li>invalidate怎么局部刷新</li><li>View加载流程（setContentView）</li></ol><h2 id="view事件分发"><a class="markdownIt-Anchor" href="#view事件分发"></a> View事件分发</h2><ol><li>View事件分发机制</li><li>view的onTouchEvent，OnClickListerner和OnTouchListener的onTouch方法 三者优先级</li><li>onTouch 和onTouchEvent 的区别</li><li>ACTION_CANCEL什么时候触发</li><li>事件是先到DecorView还是先到Window</li><li>点击事件被拦截，但是想传到下面的View，如何操作</li><li>如何解决View的事件冲突</li><li>在 ViewGroup 中的 onTouchEvent 中消费 ACTION_DOWN 事件，ACTION_UP事件是怎么传递</li><li>Activity ViewGroup和View都不消费ACTION_DOWN,那么ACTION_UP事件是怎么传递的</li><li>同时对父 View 和子 View 设置点击方法，优先响应哪个</li><li>requestDisallowInterceptTouchEvent的调用时机</li></ol><h2 id="recycleview"><a class="markdownIt-Anchor" href="#recycleview"></a> RecycleView</h2><ol><li>RecyclerView的多级缓存机制,每一级缓存具体作用是什么,分别在什么场景下会用到哪些缓存</li><li>RecyclerView的滑动回收复用机制</li><li>RecyclerView的刷新回收复用机制</li><li>RecyclerView 为什么要预布局</li><li>ListView 与 RecyclerView区别</li><li>RecyclerView性能优化</li></ol><h2 id="viewpager-fragment"><a class="markdownIt-Anchor" href="#viewpager-fragment"></a> ViewPager &amp; Fragment</h2><ol><li>Fragment的生命周期 &amp; 结合Activity的生命周期</li><li>Activity和Fragment的通信方式， Fragment之间如何进行通信</li><li>为什么使用Fragment.setArguments(Bundle)传递参数</li><li>FragmentPageAdapter和FragmentStatePageAdapter区别及使用场景</li><li>Fragment懒加载</li><li>ViewPager2与ViewPager区别</li><li>Fragment嵌套问题</li></ol><h2 id="webview"><a class="markdownIt-Anchor" href="#webview"></a> WebView</h2><ol><li>如何提高WebView加载速度</li><li>WebView与 js的交互</li><li>WebView的漏洞</li><li>JsBridge原理</li></ol><h2 id="动画"><a class="markdownIt-Anchor" href="#动画"></a> 动画</h2><ol><li>动画的类型</li><li>补间动画和属性动画的区别</li><li>ObjectAnimator，ValueAnimator及其区别</li><li>TimeInterpolator插值器，自定义插值器</li><li>TypeEvaluator估值器</li></ol><h2 id="bitmap"><a class="markdownIt-Anchor" href="#bitmap"></a> Bitmap</h2><ol><li>Bitmap 内存占用的计算</li><li>getByteCount() &amp; getAllocationByteCount()的区别</li><li>Bitmap的压缩方式</li><li>LruCache &amp; DiskLruCache原理</li><li>如何设计一个图片加载库</li><li>有一张非常大的图片,如何去加载这张大图片</li><li>如果把drawable-xxhdpi下的图片移动到drawable-xhdpi下，图片内存是如何变的。</li><li>如果在hdpi、xxhdpi下放置了图片，加载的优先级。如果是400800，10801920，加载的优先级。</li></ol><h2 id="mvc-mvp-mvvm"><a class="markdownIt-Anchor" href="#mvc-mvp-mvvm"></a> MVC &amp; MVP &amp; MVVM</h2><ol><li>MVC及其优缺点</li><li>MVP及其优缺点</li><li>MVVM及其优缺点</li><li>MVP如何管理Presenter的生命周期，何时取消网络请求</li></ol><h2 id="binder"><a class="markdownIt-Anchor" href="#binder"></a> Binder</h2><ol><li>Android中进程和线程的关系,区别</li><li>为何需要进行IPC,多进程通信可能会出现什么问题</li><li>Android中IPC方式有几种、各种方式优缺点</li><li>为何新增Binder来作为主要的IPC方式</li><li>什么是Binder</li><li>Binder的原理</li><li>Binder Driver 如何在内核空间中做到一次拷贝的？</li><li>使用Binder进行数据传输的具体过程</li><li>Binder框架中ServiceManager的作用</li><li>什么是AIDL</li><li>AIDL使用的步骤</li><li>AIDL支持哪些数据类型</li><li>AIDL的关键类，方法和工作流程</li><li>如何优化多模块都使用AIDL的情况</li><li>使用 Binder 传输数据的最大限制是多少，被占满后会导致什么问题</li><li>Binder 驱动加载过程中有哪些重要的步骤</li><li>系统服务与bindService启动的服务的区别</li><li>Activity的bindService流程</li><li>不通过AIDL，手动编码来实现Binder的通信</li></ol><h2 id="内存泄漏内存溢出"><a class="markdownIt-Anchor" href="#内存泄漏内存溢出"></a> 内存泄漏&amp;内存溢出</h2><ol><li>什么是OOM &amp; 什么是内存泄漏以及原因</li><li>Thread是如何造成内存泄露的，如何解决？</li><li>Handler导致的内存泄露的原因以及如何解决</li><li>如何加载Bitmap防止内存溢出</li><li>MVP中如何处理Presenter层以防止内存泄漏的</li></ol><h2 id="性能优化"><a class="markdownIt-Anchor" href="#性能优化"></a> 性能优化</h2><ol><li>内存优化</li><li>启动优化</li><li>布局加载和绘制优化</li><li>卡顿优化</li><li>网络优化</li></ol><h2 id="windowwindowmanager"><a class="markdownIt-Anchor" href="#windowwindowmanager"></a> Window&amp;WindowManager</h2><ol><li>什么是Window</li><li>什么是WindowManager</li><li>什么是ViewRootImpl</li><li>什么是DecorView</li><li>Activity，View，Window三者之间的关系</li><li>DecorView什么时候被WindowManager添加到Window中</li></ol><h2 id="wms"><a class="markdownIt-Anchor" href="#wms"></a> WMS</h2><ol><li>什么是WMS</li><li>WMS是如何管理Window的</li><li>IWindowSession是什么，WindowSession的创建过程是怎样的</li><li>WindowToken是什么</li><li>WindowState是什么</li><li>Android窗口大概分为几种？分组原理是什么</li><li>Dialog的Context只能是Activity的Context，不能是Application的Context？</li><li>App应用程序如何与SurfaceFlinger通信的？View 的绘制是如何把数据传递给 SurfaceFlinger 的</li><li>共享内存的具体实现是什么</li><li>relayout是如何向SurfaceFlinger申请Surface</li><li>什么是Surface</li></ol><h2 id="ams"><a class="markdownIt-Anchor" href="#ams"></a> AMS</h2><ol><li>ActivityManagerService是什么？什么时候初始化的？有什么作用？</li><li>ActivityThread是什么?ApplicationThread是什么?他们的区别</li><li>Instrumentation是什么？和ActivityThread是什么关系？</li><li>ActivityManagerService和zygote进程通信是如何实现的</li><li>ActivityRecord、TaskRecord、ActivityStack，ActivityStackSupervisor，ProcessRecord</li><li>ActivityManager、ActivityManagerService、ActivityManagerNative、ActivityManagerProxy的关系</li><li>手写实现简化版AMS</li></ol><h2 id="系统启动"><a class="markdownIt-Anchor" href="#系统启动"></a> 系统启动</h2><ol><li>android系统启动流程</li><li>SystemServer，ServiceManager，SystemServiceManager的关系</li><li>孵化应用进程这种事为什么不交给SystemServer来做，而专门设计一个Zygote</li><li>Zygote的IPC通信机制为什么使用socket而不采用binder</li></ol><h2 id="app启动打包安装"><a class="markdownIt-Anchor" href="#app启动打包安装"></a> App启动&amp;打包&amp;安装</h2><ol><li>应用启动流程</li><li>apk组成和Android的打包流程</li><li>Android的签名机制，签名如何实现的,v2相比于v1签名机制的改变</li><li>APK的安装流程</li></ol><h2 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h2><ol><li>什么是序列化</li><li>为什么需要使用序列化和反序列化</li><li>序列化的有哪些好处</li><li>Serializable 和 Parcelable 的区别</li><li>什么是serialVersionUID</li><li>为什么还要显示指定serialVersionUID的值?</li></ol><h2 id="art-dalvik-及其区别"><a class="markdownIt-Anchor" href="#art-dalvik-及其区别"></a> Art &amp; Dalvik 及其区别</h2><ol><li>Art &amp; Dalvik 及其区别</li></ol><h2 id="模块化组件化"><a class="markdownIt-Anchor" href="#模块化组件化"></a> 模块化&amp;组件化</h2><ol><li>什么是模块化</li><li>什么是组件化</li><li>组件化优点和方案</li><li>组件独立调试</li><li>组件间通信</li><li>Aplication动态加载</li><li>ARouter原理</li></ol><h2 id="热修复插件化"><a class="markdownIt-Anchor" href="#热修复插件化"></a> 热修复&amp;插件化</h2><ol><li>插件化的定义</li><li>插件化的优势</li><li>插件化框架对比</li><li>插件化流程</li><li>插件化类加载原理</li><li>插件化资源加载原理</li><li>插件化Activity加载原理</li><li>热修复和插件化区别</li><li>热修复原理</li></ol><h2 id="aop"><a class="markdownIt-Anchor" href="#aop"></a> AOP</h2><ol><li>AOP是什么</li><li>AOP的优点</li><li>AOP的实现方式,APT,AspectJ,ASM,epic,hook</li></ol><h2 id="jetpack"><a class="markdownIt-Anchor" href="#jetpack"></a> Jetpack</h2><ol><li>Navigation</li><li>DataBinding</li><li>Viewmodel</li><li>livedata</li><li>liferecycle</li></ol><h2 id="开源框架"><a class="markdownIt-Anchor" href="#开源框架"></a> 开源框架</h2><ol><li>Okhttp源码流程,线程池</li><li>Okhttp拦截器,addInterceptor 和 addNetworkdInterceptor区别</li><li>Okhttp责任链模式</li><li>Okhttp缓存怎么处理</li><li>Okhttp连接池和socket复用</li><li>Glide怎么绑定生命周期</li><li>Glide缓存机制,内存缓存，磁盘缓存</li><li>Glide与Picasso的区别</li><li>LruCache原理</li><li>Retrofit源码流程,动态代理</li><li>LeakCanary弱引用,源码流程</li><li>Eventbus</li><li>Rxjava</li></ol><h1 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h1><h2 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h2><ol><li>HashMap原理</li><li>HashMap中put()如何实现的</li><li>HashMap中get()如何实现的</li><li>为什么HashMap线程不安全</li><li>HashMap1.7和1.8有哪些区别</li><li>解决hash冲突的时候，为什么用<a href="">红黑树</a></li><li><a href="">红黑树</a>的效率高，为什么一开始不用<a href="">红黑树</a>存储</li><li>不用<a href="">红黑树</a>，用二叉查找树可以不</li><li>为什么阀值是8才转为<a href="">红黑树</a></li><li>为什么退化为<a href="">链表</a>的阈值是6</li><li>hash冲突有哪些解决办法</li><li>HashMap在什么条件下扩容</li><li>HashMap中hash函数怎么实现的，还有哪些hash函数的实现方式</li><li>为什么不直接将hashcode作为哈希值去做取模,而是要先高16位异或低16位</li><li>为什么扩容是2的次幂</li><li><a href="">链表</a>的查找的时间复杂度是多少</li><li><a href="">红黑树</a></li></ol><h2 id="arraylist"><a class="markdownIt-Anchor" href="#arraylist"></a> ArrayList</h2><h2 id="jvm"><a class="markdownIt-Anchor" href="#jvm"></a> Jvm</h2><ol><li>Jvm的内存模型,每个里面都保存的什么</li><li>类加载机制的几个阶段加载、验证、准备、解析、初始化、使用、卸载</li><li>对象实例化时的顺序</li><li>类加载器,双亲委派及其优势</li><li>垃圾回收机制</li></ol><h2 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> 多线程</h2><ol><li>Java中创建线程的方式,Callable,Runnable,Future,FutureTask</li><li>线程的几种状态</li><li>谈谈线程死锁，如何有效的避免线程死锁？</li><li>如何实现多线程中的同步</li><li>synchronized和Lock的使用、区别,原理；</li><li>volatile，synchronized和volatile的区别？为何不用volatile替代synchronized？</li><li>锁的分类，锁的几种状态，CAS原理</li><li>为什么会有线程安全？如何保证线程安全</li><li>sleep()与wait()区别,run和start的区别,notify和notifyall区别,锁池,等待池</li><li>Java多线程通信</li><li>为什么Java用线程池</li><li>Java中的线程池参数,共有几种</li></ol><h2 id="注解"><a class="markdownIt-Anchor" href="#注解"></a> 注解</h2><ol><li>注解的分类和底层实现原理</li><li>自定义注解</li></ol><h2 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h2><ol><li>什么是反射</li><li>反射机制的相关类</li><li>反射中如何获取Class类的实例</li><li>如何获取一个类的属性对象 &amp; 构造器对象 &amp; 方法对象</li><li>Class.getField和getDeclaredField的区别，getDeclaredMethod和getMethod的区别</li><li>反射机制的优缺点</li></ol><h2 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h2><h2 id="设计模式"><a class="markdownIt-Anchor" href="#设计模式"></a> 设计模式</h2>]]></content>
      
      
      <categories>
          
          <category> 2022校招面试整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022校招面试整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OkHttp 解析 [转载]</title>
      <link href="/posts/85849a386862/"/>
      <url>/posts/85849a386862/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自：</p><ul><li><a href="https://blog.csdn.net/gdutxiaoxu/article/details/100545600">一步步带你读懂 Okhttp 源码</a></li><li><a href="https://www.jianshu.com/p/8522bc275390">okhttp拦截器Interceptor详解</a></li></ul></blockquote><hr /><h1 id="使用-okhttp-的基本流程"><a class="markdownIt-Anchor" href="#使用-okhttp-的基本流程"></a> 使用 OkHttp 的基本流程</h1><ol><li>创建 OkHttpClient 对象</li><li>创建 Request 对象</li><li>创建 Call 对象</li><li>同步请求调用 call.execute()；异步请求调用 call.enqueue()</li></ol><h2 id="同步执行"><a class="markdownIt-Anchor" href="#同步执行"></a> 同步执行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建OkHttpClient对象</span></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"></span><br><span class="line">String <span class="title function_">run</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="comment">//创建Request请求对象</span></span><br><span class="line">  <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建Call对象，并执行同步获取网络数据</span></span><br><span class="line">  <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">return</span> response.body().string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步执行"><a class="markdownIt-Anchor" href="#异步执行"></a> 异步执行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">runAsync</span><span class="params">(String url, Callback callback)</span> &#123;</span><br><span class="line">    <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().addInterceptor(<span class="keyword">new</span> <span class="title class_">Interceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> chain.request();</span><br><span class="line">            Request.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> request.newBuilder().addHeader(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> chain.proceed(builder.build());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).build();</span><br><span class="line">    <span class="comment">//创建Request请求对象</span></span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">        .url(url)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    client.newCall(request).enqueue(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="创建-okhttpclient-对象"><a class="markdownIt-Anchor" href="#创建-okhttpclient-对象"></a> 创建 OkHttpClient 对象</h1><p>创建 OkHttpClient 一般有两种方法，一种是直接 new OkHttpClient(),另外一种是通过 OkHttpClient.Builder()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkhttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span></span><br><span class="line">    .Builder()</span><br><span class="line">    .connectTimeout(<span class="number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">    .writeTimeout(<span class="number">10</span>,TimeUnit.SECONDS)</span><br><span class="line">    .readTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>第二种创建方式主要是通过建造者模式，来配置一些参数，比如连接超时时间，读写超时时间，超时重试次数等。这样有一个好处，可以对外屏蔽掉构建 client 的细节。</p><p>OkhttpClient 对象主要处理一些基础的配置，比如连接超时，读写超时，添加拦截器。</p><hr /><h1 id="创建-request-对象"><a class="markdownIt-Anchor" href="#创建-request-对象"></a> 创建 Request 对象</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Request</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> HttpUrl url;</span><br><span class="line">    <span class="keyword">final</span> String method;</span><br><span class="line">    <span class="keyword">final</span> Headers headers;</span><br><span class="line">    <span class="keyword">final</span> RequestBody body;</span><br><span class="line">    <span class="keyword">final</span> Object tag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> CacheControl cacheControl; <span class="comment">// Lazily initialized.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Request 对象主要封装的是一些网络请求的信息，比如请求 url，请求方法，请求头，请求 body 等，也比较简单，这里不再展开阐述。</p><hr /><h1 id="创建-call-对象"><a class="markdownIt-Anchor" href="#创建-call-对象"></a> 创建 Call 对象</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> Call <span class="title function_">newCall</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RealCall</span>(<span class="built_in">this</span>, request, <span class="literal">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 call 对象实际是 RealCall 的实例化对象。</p><hr /><h1 id="同步请求"><a class="markdownIt-Anchor" href="#同步请求"></a> 同步请求</h1><h2 id="realcallexecute"><a class="markdownIt-Anchor" href="#realcallexecute"></a> RealCall#execute()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">        executed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行 client.dispatcher() 的 executed 方法</span></span><br><span class="line">        client.dispatcher().executed(<span class="built_in">this</span>);</span><br><span class="line">        <span class="type">Response</span> <span class="variable">result</span> <span class="operator">=</span> getResponseWithInterceptorChain();</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 最后再执行 dispatcher 的 finish 方法</span></span><br><span class="line">        client.dispatcher().finished(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 execute 方法中：</p><ol><li>首先会调用 client.dispatcher().executed(this) 加入到 runningAsyncCalls 队列当中</li><li>接着执行 getResponseWithInterceptorChain() 获取请求结果</li><li>最终再执行 client.dispatcher().finished(this) 将 realCall 从 runningAsyncCalls 队列中移除</li></ol><hr /><h1 id="拦截器-interceptor"><a class="markdownIt-Anchor" href="#拦截器-interceptor"></a> 拦截器 Interceptor</h1><h2 id="getresponsewithinterceptorchain"><a class="markdownIt-Anchor" href="#getresponsewithinterceptorchain"></a> getResponseWithInterceptorChain()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Response <span class="title function_">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors());</span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>(client.cookieJar()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>(client.internalCache()));</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">ConnectInterceptor</span>(client));</span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        interceptors.addAll(client.networkInterceptors());</span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> <span class="title class_">CallServerInterceptor</span>(forWebSocket));</span><br><span class="line">    Interceptor.<span class="type">Chain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">        interceptors, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，首先，他会将客户端的 interceptors 添加到 List 当中，接着，再添加 okhttp 里面的 interceptor，然后构建了一个 RealInterceptorChain 对象，并将我们的 List<Interceptor> 作为成员变量，最后调用 RealInterceptorChain 的 proceed 方法。</p><p>其中，client.interceptors() 为我们自己添加的请求拦截器，通常是做一些添加统一的token之类操作。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/4122684-67fcdd5d7e5f984e.jpg" alt="其余较重要的拦截器" /></p><p><strong>RetryAndFollowUpInterceptor 拦截器</strong></p><ul><li>RetryAndFollowUpInterceptor 此拦截器顾名思义就是主要负责失败重连工作，但是并不是所有的网络请求都会进行失败重连的,在此拦截器内部会进行网络请求的异常检测和响应码的判断,如果都在限制范围内,那么就可以进行失败重连。</li></ul><p><strong>CacheInterceptor 拦截器</strong></p><ul><li><p>如果当前未使用网络，并且缓存不可以使用，通过构建者模式创建一个 Response 响应,抛出504错误。</p></li><li><p>如果有缓存 但是不能使用网络 ，直接返回缓存结果。这是在进行网络请求之前所做的事情，当网络请求完成，得到下一个拦截器返回的 response 之后，判断 response 的响应码是否是 HTTP_NOT_MODIFIED = 304（未改变），是则从缓存中读取数据。</p></li></ul><h2 id="proceed"><a class="markdownIt-Anchor" href="#proceed"></a> proceed()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Response <span class="title function_">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span><br><span class="line"><span class="params">                        Connection connection)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  生成 list 当中下一个 interceptot 的 chain 对象</span></span><br><span class="line">    <span class="type">RealInterceptorChain</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">        interceptors, streamAllocation, httpCodec, connection, index + <span class="number">1</span>, request);</span><br><span class="line">    <span class="comment">// 当前的 interceptor</span></span><br><span class="line">    <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors.get(index);</span><br><span class="line">    <span class="comment">// 当前的 intercept 处理下一个 intercept 包装的 chain 对象</span></span><br><span class="line">    <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proceed 方法也很简单，proceed方法每次从拦截器列表中取出拦截器，并调用 interceptor.intercept(next)。</p><p>熟悉 Okhttp 的应该都知道，我们在 addInterceptor 创建 Interceptor 实例，最终都会调用 chain.proceed(Request request),从而形成一种链式调用。这种便是责任链设计模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().addInterceptor(<span class="keyword">new</span> <span class="title class_">Interceptor</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> chain.request();</span><br><span class="line">        Request.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> request.newBuilder().addHeader(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(builder.build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).build();</span><br></pre></td></tr></table></figure><p>而 OkHttp 是怎样结束循环调用的，这是因为最后一个拦截器 CallServerInterceptor 并没有调用 chain.proceed(request)，所以能够结束循环调用。</p><hr /><h1 id="异步请求"><a class="markdownIt-Anchor" href="#异步请求"></a> 异步请求</h1><h2 id="dispatcher-分发器"><a class="markdownIt-Anchor" href="#dispatcher-分发器"></a> dispatcher 分发器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Dispatcher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRequests</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRequestsPerHost</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> Runnable idleCallback;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Executes calls. Created lazily. */</span></span><br><span class="line">    <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步的请求等待队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步的正在请求的队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步的正在请求的队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分发器 Dispatcher，里面有三个请求队列，一个是正在请求的队列，一个是等待队列，另外一个是同步的正在请求的队列，当我们执行 enqueue 方法的时候，他会判断正在请求队列数量是否超过允许的最大并发数量（默认是 64）（线程池的原理），如果超过了，会添加到等待队列里面。</p><p><strong>maxRequests</strong>：可以同时运行的最大请求数，也就是说 一个okhttp的client 可以同时发64个请求。</p><p><strong>maxRequestsPerHost</strong>：对 每个域名 我们最多同时只能有5个请求。</p><p><strong>这个参数的实际意义是 针对每个域名，okhttp最多可以发起5条tcp连接。</strong></p><p>execute 方法是同步执行的，每次执行会添加到同步请求队列当中，执行完毕之后会移除。</p><h2 id="realcallenqueuecallback-responsecallback"><a class="markdownIt-Anchor" href="#realcallenqueuecallback-responsecallback"></a> RealCall#enqueue(Callback responseCallback)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Callback responseCallback)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">        executed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> <span class="title class_">AsyncCall</span>(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，AsyncCall 是 Runnable 的子类，实现了 run 方法。</p><h2 id="dispatcherenqueueasynccall-call"><a class="markdownIt-Anchor" href="#dispatcherenqueueasynccall-call"></a> dispatcher().enqueue(AsyncCall call)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(AsyncCall call)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        executorService().execute(call);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 executorService().execute(call) 的时候，会调用 run 方法， run 方法又会调用到 execute 方法进行网络请求，请求完成之后，会调用 client.dispatcher().finished(this) 从队列里面移除。</p><hr /><p>到此， Okhttp 的主要流程已经讲完。</p><hr /><h1 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h1><ol><li><p>有一个分发器 Dispatcher，里面有三个请求队列，一个是正在请求的队列，一个是等待队列，另外一个是同步的正在请求的队列，当我们执行 enqueue 方法的时候，他会判断正在请求队列数量是否超过允许的最大并发数量（默认是 64）（线程池的原理），如果超过了，会添加到等待队列里面。<br />excute 方法是同步执行的，每次执行会添加到同步请求队列当中，执行完毕之后会移除。</p></li><li><p>设计的核心思想责任链模式，当我们需要拦截的时候，可以实现 Interceptor 接口，会按照添加的顺序执行 Chain.proceed 方法。</p></li><li><p>职责分明，OkhttpClient 对象主要处理一些基础的配置，比如连接超时，读写超时，添加拦截器。Request 主要配置请求方法，请求头等。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OkHttp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clang 不同类型 格式控制符</title>
      <link href="/posts/645f57a51719/"/>
      <url>/posts/645f57a51719/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>type</th><th>scanf</th><th>printf</th></tr></thead><tbody><tr><td><code>int</code></td><td>%d</td><td>%d</td></tr><tr><td><code>unsigned</code></td><td>%u</td><td>%u</td></tr><tr><td><code>long long</code></td><td>%lld</td><td>%lld</td></tr><tr><td><code>unsigned long long</code></td><td>%llu</td><td>%llu</td></tr><tr><td><code>float</code></td><td>%f</td><td>%f</td></tr><tr><td><code>double</code></td><td>%lf</td><td>%f</td></tr><tr><td><code>long double</code></td><td>%lf</td><td>%lf</td></tr><tr><td><code>char</code></td><td>%c</td><td>%c</td></tr><tr><td><code>char[]</code></td><td>%s</td><td>%s</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> XCPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCPC K短路模板</title>
      <link href="/posts/ac36d4ee2e65/"/>
      <url>/posts/ac36d4ee2e65/</url>
      
        <content type="html"><![CDATA[<h1 id="k-短路"><a class="markdownIt-Anchor" href="#k-短路"></a> K 短路</h1><h2 id="input"><a class="markdownIt-Anchor" href="#input"></a> Input</h2><p>第一行输入五个数字，依次表示为图的点数 N、边数 M、所求的第 K 段路、开始的点号 S、结尾的点号 T。<br />后面的 M 行，每行三个数字，代表一条单向边，分别为 From, To, Distance。</p><h2 id="output"><a class="markdownIt-Anchor" href="#output"></a> Output</h2><p>一个数字，表示第 K 短路的值。</p><h2 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Kth_Path &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        N nodes, M edges, find the K-th path from S to T.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> N, M, S, T, K;</span><br><span class="line">    <span class="type">int</span> dist[MAXN], cnt, fa[MAXN];</span><br><span class="line">    <span class="type">bool</span> tf[MAXN], vis[MAXN], onTree[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Path</span> &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>, head[MAXN];</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">            <span class="type">int</span> next, to, dis;</span><br><span class="line">        &#125; G[MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> dis)</span> </span>&#123;</span><br><span class="line">            G[++num] = &#123;head[from], to, dis&#125;;</span><br><span class="line">            head[from] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; E1, E2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> x, val;</span><br><span class="line"></span><br><span class="line">        Node *<span class="keyword">operator</span>=(Node a) &#123;</span><br><span class="line">            x = a.x;</span><br><span class="line">            val = a.val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Node a) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> val &gt; a.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; A;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;Node&gt; Q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">        vis[s] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = E2.head[s]; i; i = E2.G[i].next) &#123;</span><br><span class="line">            <span class="type">int</span> to = E2.G[i].to;</span><br><span class="line">            <span class="keyword">if</span> (vis[to])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (dist[to] == dist[s] + E2.G[i].dis) &#123;</span><br><span class="line">                fa[to] = s;</span><br><span class="line">                onTree[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LeftistTree</span> &#123;</span><br><span class="line">        <span class="type">int</span> num, rt[MAXN], lc[MAXN * <span class="number">20</span>], rc[MAXN * <span class="number">20</span>], dist[MAXN * <span class="number">20</span>];</span><br><span class="line">        Node v[MAXN &lt;&lt; <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">LeftistTree</span>() &#123;</span><br><span class="line">            dist[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">newNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">            v[++num] = node;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!x || !y)</span><br><span class="line">                <span class="keyword">return</span> x + y;</span><br><span class="line">            <span class="keyword">if</span> (v[x] &lt; v[y])</span><br><span class="line">                <span class="built_in">swap</span>(x, y);</span><br><span class="line">            <span class="type">int</span> p = ++num;</span><br><span class="line">            lc[p] = lc[x];</span><br><span class="line">            v[p] = v[x];</span><br><span class="line">            rc[p] = <span class="built_in">merge</span>(rc[x], y);</span><br><span class="line">            <span class="keyword">if</span> (dist[lc[p]] &lt; dist[rc[p]])</span><br><span class="line">                <span class="built_in">swap</span>(lc[p], rc[p]);</span><br><span class="line">            dist[p] = dist[rc[p]] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ST;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">        vis[s] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (fa[s])</span><br><span class="line">            ST.rt[s] = ST.<span class="built_in">merge</span>(ST.rt[s], ST.rt[fa[s]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = E2.head[s]; i; i = E2.G[i].next) &#123;</span><br><span class="line">            <span class="type">int</span> to = E2.G[i].to;</span><br><span class="line">            <span class="keyword">if</span> (fa[to] == s &amp;&amp; !vis[to])</span><br><span class="line">                <span class="built_in">dfs</span>(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; M &gt;&gt; K &gt;&gt; S &gt;&gt; T;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> x, y, z;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            E1.<span class="built_in">addEdge</span>(x, y, z);</span><br><span class="line">            E2.<span class="built_in">addEdge</span>(y, x, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  Solve the K-th path problem.</span></span><br><span class="line"><span class="comment">        if answer is -1, there is no k-th path in this graph.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Q.<span class="built_in">push</span>(&#123;T, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (Q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            A = Q.<span class="built_in">top</span>();</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (tf[A.x])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            tf[A.x] = <span class="literal">true</span>;</span><br><span class="line">            dist[A.x] = A.val;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = E2.head[A.x]; i; i = E2.G[i].next) &#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(&#123;E2.G[i].to, A.val + E2.G[i].dis&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tf[S])</span><br><span class="line">                <span class="keyword">return</span> dist[S];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(T);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tf[i])</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = E1.head[i]; j; j = E1.G[j].next)</span><br><span class="line">                    <span class="keyword">if</span> (!onTree[j])</span><br><span class="line">                        <span class="keyword">if</span> (tf[E1.G[j].to])</span><br><span class="line">                            ST.rt[i] = ST.<span class="built_in">merge</span>(</span><br><span class="line">                                ST.rt[i],</span><br><span class="line">                                ST.<span class="built_in">newNode</span>(&#123;</span><br><span class="line">                                    E1.G[j].to,</span><br><span class="line">                                    dist[E1.G[j].to] + E1.G[j].dis - dist[i]</span><br><span class="line">                                &#125;)</span><br><span class="line">                            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs2</span>(T);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ST.rt[S])</span><br><span class="line">            Q.<span class="built_in">push</span>(&#123;</span><br><span class="line">                ST.rt[S],</span><br><span class="line">                dist[S] + ST.v[ST.rt[S]].val</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            A = Q.<span class="built_in">top</span>();</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt == K - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> A.val;</span><br><span class="line">            <span class="keyword">if</span> (ST.lc[A.x])</span><br><span class="line">                Q.<span class="built_in">push</span>(&#123;</span><br><span class="line">                    ST.lc[A.x],</span><br><span class="line">                    A.val - ST.v[A.x].val + ST.v[ST.lc[A.x]].val</span><br><span class="line">                &#125;);</span><br><span class="line">            <span class="keyword">if</span> (ST.rc[A.x])</span><br><span class="line">                Q.<span class="built_in">push</span>(&#123;</span><br><span class="line">                    ST.rc[A.x],</span><br><span class="line">                    A.val - ST.v[A.x].val + ST.v[ST.rc[A.x]].val</span><br><span class="line">                &#125;);</span><br><span class="line">            <span class="type">int</span> X = ST.rt[ST.v[A.x].x];</span><br><span class="line">            <span class="keyword">if</span> (X)</span><br><span class="line">                Q.<span class="built_in">push</span>(&#123;X, A.val + ST.v[X].val&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Kth_Path::<span class="built_in">input</span>();</span><br><span class="line">    cout &lt;&lt; Kth_Path::<span class="built_in">solve</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> XCPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> XCPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCPC 字符串哈希</title>
      <link href="/posts/bb54934ff9ed/"/>
      <url>/posts/bb54934ff9ed/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="http://www.yhzq-blog.cc/%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E6%80%BB%E7%BB%93/">字符串Hash总结 | 远航休息栈</a></li></ul></blockquote><hr /><h1 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> StringHash &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> BASE = <span class="number">131</span>;</span><br><span class="line">    <span class="type">char</span> s[MAXN]; <span class="comment">// cin &gt;&gt; (s + 1);</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> hash[MAXN], power[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">preHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        power[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) </span><br><span class="line">            power[i] = power[i - <span class="number">1</span>] * BASE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calcHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            hash[i] = hash[i - <span class="number">1</span>] * BASE + s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">getHash</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)hash[r] - hash[l - <span class="number">1</span>] * power[r - l + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cin &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">        len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringHash::<span class="built_in">input</span>();</span><br><span class="line">    StringHash::<span class="built_in">preHash</span>();</span><br><span class="line">    StringHash::<span class="built_in">calcHash</span>();</span><br><span class="line">    cout &lt;&lt; StringHash::<span class="built_in">getHash</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="使用字符串哈希完成其他算法"><a class="markdownIt-Anchor" href="#使用字符串哈希完成其他算法"></a> 使用字符串哈希完成其他算法</h1><h2 id="kmp"><a class="markdownIt-Anchor" href="#kmp"></a> KMP</h2><blockquote><p>给两个字符串 S1、S2，求 S2 是否是 S1 的字串，并求出 S2 在 S1 中出现的次数。</p></blockquote><p>将 S2 哈希后，在 S1 中查询所有长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mn>2</mn><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|S2|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">2</span><span class="mord">∣</span></span></span></span> 的字串，并进行哈希比较。</p><blockquote><p>复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mn>1</mn><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|S1|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。</p></blockquote><h2 id="ac-自动机"><a class="markdownIt-Anchor" href="#ac-自动机"></a> AC 自动机</h2><blockquote><p>给出 N 个单词串，和一个文章串，求每个单词串是否是文章串的子串，并求每个单词在文章中出现的次数。</p></blockquote><p>先把每一个单词串哈希，再把文章的每一个子串也进行整数，接下来只需要进行整数上的查找即可。</p><blockquote><p>复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>A</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|A|^2+|S|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|S|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span></span></span></span> 是单词串总长，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>A</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|A|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mord">∣</span></span></span></span> 是文章串长度。</p></blockquote><h2 id="后缀数组"><a class="markdownIt-Anchor" href="#后缀数组"></a> 后缀数组</h2><blockquote><p>给出两个字符串 S1、S2，求它们的最长公共子串的长度。</p></blockquote><p>将 S1 的每一个子串都哈希成一个整数，再对 S2 的每一个字串进行哈希，并判断是否与 S1 的某一个字串相同，不断维护相同的字串的长度最大值即可。</p><blockquote><p>复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mn>1</mn><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mn>2</mn><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|S1|^2+|S2|^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">2</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p></blockquote><h2 id="马拉车"><a class="markdownIt-Anchor" href="#马拉车"></a> 马拉车</h2><blockquote><p>给一个字符串 S，求 S 的最长回文子串。</p></blockquote><p>将 S 从前后两个方向分别进行字符车哈希。<br />先求子串长度位奇数的，再求偶数的。<br />枚举回文子串的中心位置，然后二分子串的长度，直到找到一个该位置的最长回文子串，不断维护长度最大值即可。</p><blockquote><p>复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|S|log|S|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。</p></blockquote><h2 id="扩展-kmp"><a class="markdownIt-Anchor" href="#扩展-kmp"></a> 扩展 KMP</h2><blockquote><p>给一个字符串 S，求 S 的每个后缀与S的最长公共前缀。</p></blockquote><p>枚举每一个后缀的起始位置，二分长度，求出每个后缀与S的最长公共前缀。</p><blockquote><p>复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|S|log|S|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> XCPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View 的事件体系</title>
      <link href="/posts/38fdb1d1c50f/"/>
      <url>/posts/38fdb1d1c50f/</url>
      
        <content type="html"><![CDATA[<h1 id="view基础知识"><a class="markdownIt-Anchor" href="#view基础知识"></a> View基础知识</h1><h2 id="一-view的相关坐标和位置"><a class="markdownIt-Anchor" href="#一-view的相关坐标和位置"></a> 一、<code>View</code>的相关坐标和位置</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20180802114150486.jpg" style="zoom:80%;" /><p><strong>先来了解一个概念：</strong></p><p><code>view动画</code>不改变<code>view</code>的真实位置，就是肉眼看上去，<code>view</code>位置发生了变化，但是它的点击区域还是在原来的位置。</p><p>为了方便描述，下文中的的 <code>真实View</code>，表示真实位置的<code>View</code>，<code>看到的View</code>，表示肉眼看到的<code>View</code>。</p><p>属性动画和 <code>setTranslationX</code> / <code>setTranslationY</code> ，会改变显示位置和真实位置。</p><p>上图中<code>view1</code>是初始位置，通过执行<code>setTranslation</code>函数，得到的<code>view2</code>位置，其中<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>这几个值不会改变。</p><h3 id="lefttoprightbottom"><a class="markdownIt-Anchor" href="#lefttoprightbottom"></a> <code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code></h3><p><code>View</code>的位置主要由它的四个顶点的位置来决定，分别对应 View 的四个属性：<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>。对应的函数是<code>getLeft</code>，<code>getTop</code>，<code>getRight</code>，<code>getBottom</code>。</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>left</code></td><td><code>View</code> 左上顶点相对于父容器的横坐标</td></tr><tr><td><code>top</code></td><td><code>View</code> 左上顶点相对于父容器的纵坐标</td></tr><tr><td><code>right</code></td><td><code>View</code> 右下顶点相对于父容器的横坐标</td></tr><tr><td><code>bottom</code></td><td><code>View</code> 右下顶点相对于父容器的纵坐标</td></tr></tbody></table><p>这几个值表示的是View的真身位置，它表示哪里，点击区域就在哪里。和肉眼在屏幕上看到的位置可能不一样。</p><h3 id="xy"><a class="markdownIt-Anchor" href="#xy"></a> <code>X</code>，<code>Y</code></h3><p>上面说到view动画不改变<code>view</code>的真实位置（也就是不改变<code>view</code>的<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>）。</p><p>看到的view相对于真实<code>view</code>，位置发生了变化，但是它的点击区域还是在真实view的位置。</p><p>从 Android 3.0 开始，<code>View</code> 增加了 x，y，<code>translationX</code> 和 <code>translationY</code>。</p><p>x，y 是看到的<code>view</code>的左上角相对父容器的坐标，但不同于 left 和 top ，这两个坐标点的值并一定都是相等的。</p><p>真实<code>view</code> 和 看到<code>view</code>的偏差用 <code>translationX</code> 和 <code>translationY</code> <code>来表示</code>。</p><h3 id="translationxtranslationy"><a class="markdownIt-Anchor" href="#translationxtranslationy"></a> <code>translationX</code>，<code>translationY</code></h3><p>**android开发艺术探索中，关于<code>translationX</code>的讲解是错误的。**真实情况是，<code>translationX</code>是<code>真实view</code> 相对于<code>看到view</code>的 x 方向偏移量。</p><p>从上图可以得知：<code>x</code> = <code>left</code> + <code>translationX</code>。</p><h2 id="二-点击事件的xy坐标"><a class="markdownIt-Anchor" href="#二-点击事件的xy坐标"></a> 二、点击事件的<code>XY</code>坐标</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20180802143219331.jpg" style="zoom:50%;" /><h2 id="三-motionevent"><a class="markdownIt-Anchor" href="#三-motionevent"></a> 三、<code>MotionEvent</code></h2><p>常见的触摸动作一共有三个：</p><ol><li><code>ACTION_DOWN</code>手指按下动作</li><li><code>ACTION_MOVE</code>手指滑动动作</li><li><code>ACTION_UP</code>    手指抬起动作</li></ol><h2 id="四-gesturedetector"><a class="markdownIt-Anchor" href="#四-gesturedetector"></a> 四、<code>GestureDetector</code></h2><p>手势检测，检测用户的单击、双击、长按等操作。</p><p>通过创建<code>GestureDetector</code>对象并实现<code>OnGestureListener</code>接口（检测单击相关手势）或者<code>OnDoubleTapListener</code>接口（检测双击相关动作）。</p><h2 id="五-touchslop"><a class="markdownIt-Anchor" href="#五-touchslop"></a> 五、<code>TouchSlop</code></h2><p>不同安卓设备认为的最小的滑动距离，低于此距离，将不认为用户在滑动，开发者可自行更改，默认为<code>8dp</code>。</p><h2 id="六-velocitytracker"><a class="markdownIt-Anchor" href="#六-velocitytracker"></a> 六、<code>VelocityTracker</code></h2><p>速度检测，可以计算出用户的手势的滑动速度。</p><p>注意，在<code>VelocityTracker#computeCurrentVelocity(int time)</code>中的<code>time</code>参数是我们计算速度的单位时间，相同的速度用不同的单位时间会有不同的表示方法。</p><h2 id="七-scroller"><a class="markdownIt-Anchor" href="#七-scroller"></a> 七、<code>Scroller</code></h2><p>弹性滑动对象，由于View中的<code>scrollTo/scrollBy</code>都是瞬间完成位移的。对用户的使用体验不太友好，所以引入弹性滑动对象，使得<code>View</code>的滑动变得可视化。</p><h1 id="view的滑动"><a class="markdownIt-Anchor" href="#view的滑动"></a> View的滑动</h1><h2 id="一-scrolltoscrollby"><a class="markdownIt-Anchor" href="#一-scrolltoscrollby"></a> 一、<code>scrollTo</code>/<code>scrollBy</code></h2><p>View有专门的方法实现滑动，即<code>scrollTo()</code>, <code>scrollBy()</code>;</p><p>这两个函数只能将<code>View</code>中间的内容进行位移，但是不能改变<code>View</code>本身的位置。</p><p>可以方便的实现滑动效果并且不影响内部元素的点击事件。</p><p><code>scrollTo(int destX, int destY)</code>直接让View出现在目标位置，无中间动画。</p><p>参数变量的单位都是像素级。</p><h2 id="二-使用动画"><a class="markdownIt-Anchor" href="#二-使用动画"></a> 二、使用动画</h2><p>有两种动画的使用方法。</p><ol><li><p><code>View</code>动画</p><p>在<code>XML</code>文件里面通过改变<code>translationX</code>/<code>translationY</code>的方式来实现View的移动效果。</p></li><li><p>属性动画</p><p>在<code>Android3.0</code>版本以上，可以使用<code>ObjectAnimator</code>类来实现属性动画的效果。</p><p>在<code>Android3.0</code>以下的版本中，我们需要自己加载开源动画库<code>NineOldAndroids</code>。</p></li></ol><p>在<code>XML</code>文件中，有一个<code>andoird:fillAfter=&quot;true|false&quot;</code>的选项。</p><p>当为<code>true</code>的时候，View在动画结束后，图像将停留在目标位置上。</p><p>当为<code>false</code>的时候，View会在动画结束后，从末位置消失，重新在初位置出现。</p><p>不论是<code>true</code>还是<code>false</code>，View的点击事件的坐标还是在原先的初始位置上，并不会随着<code>View</code>的移动而移动。</p><p>在<code>Android3.0</code>以上使用属性动画可以解决这样的问题。</p><h2 id="三-改变布局参数"><a class="markdownIt-Anchor" href="#三-改变布局参数"></a> 三、改变布局参数</h2><p>通过修改<code>View</code>的<code>marginLeft</code>等等布局参数，以此来达到<code>View</code>滑动的效果。</p><h1 id="弹性滑动"><a class="markdownIt-Anchor" href="#弹性滑动"></a> 弹性滑动</h1><h2 id="一-scroller"><a class="markdownIt-Anchor" href="#一-scroller"></a> 一、<code>Scroller</code></h2><p><code>Scroller#smoothScrollTo(int destX, int destY)</code>将<strong>目标位置与初始位置的偏移值delta</strong>计算后调用<code>startScroller()</code>方法存储相关参数，并开始使用<code>invalidate()</code>方法重绘<code>View</code>。重绘<code>View</code>时的<code>draw()</code>方法会调用<code>computeScroll()</code>方法，其中又会调用<code>invalidate</code>方法重绘<code>View</code>，不断的循环。由于<code>scrollTo(int destX, int destY)</code>直接让View出现在目标位置，所以我们在<code>computeScroll()</code>方法中采取微分法的做法，即将一段长距离拆分成许多微小的距离。不断通过<code>scrollTo()</code>的直接滑动以及<code>computeScrollOffset()</code>的重新计算下一个短距离的相关参数以及<code>postInvalidate()</code>的重绘View，最终达到弹性滑动的效果。</p><p><code>computeScrollOffset()</code>方法通过计算目前已经位移的百分比来计算下一次的位移目标以及是否已经完成的滑动，不通过计时器等工具。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart TDA[startScroll]B[invalidate]C[computeScroll]D[computeScrollOffset : boolean]E[invalidate]A --&gt; B --&gt;|draw| C --&gt; D --&gt;|not finish| E --&gt;|draw| CD --&gt;|finish| F[finish]  </pre></div><h2 id="二-通过动画"><a class="markdownIt-Anchor" href="#二-通过动画"></a> 二、通过动画</h2><p>通过<code>ObjectAnimator类</code>我们可以直接的通过动画完成<code>View</code>的弹性滑动。</p><p>我们也可以通过<code>onAnimatorUpdate</code>方法还自定义自己想要的动画效果。</p><h2 id="三-使用延时策略"><a class="markdownIt-Anchor" href="#三-使用延时策略"></a> 三、使用延时策略</h2><p>可以通过<code>Thread#sleep</code>或者<code>Handler#postDelayed</code>方法来达到间隔一定的时间就改变一次微小位置变化的操作。</p><p>在此次的<code>scrollTo</code>方法执行结束后，通过<code>sleep|postDelayed</code>方法暂停一定的时间，然后重复执行<code>scrollTo</code>的方法，以此来达到弹性滑动的效果。</p><p>**注意：**无法在精准的时间内移动固定的位移，因为系统的消息调度（<code>sleep|postDelayed</code>）也是需要时间的。</p><h1 id="view的事件分发机制"><a class="markdownIt-Anchor" href="#view的事件分发机制"></a> <code>View</code>的事件分发机制</h1><h2 id="一-点击事件的传递规则"><a class="markdownIt-Anchor" href="#一-点击事件的传递规则"></a> 一、点击事件的传递规则</h2><p>点击事件分发过程，即将一系列的<code>MotionEvent</code>事件序列（由<code>ACTION_DOWN</code>开始到<code>ACTION_UP</code>结束的一连串操作）交给一个<code>View</code>执行的过程。</p><p>点击事件的分发主要由三个重要方法构成：<code>dispatchTouchEvent</code>, <code>onInterceptTouchEvent</code>,<code>onTouchEvent</code>。</p><p>三个方法的执行顺序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123; <span class="comment">// 对当前的View进行事件的分发</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">consume</span> <span class="operator">=</span> <span class="literal">false</span>;                        <span class="comment">// 判断是否可以消耗这个事件序列</span></span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123;                <span class="comment">// 如果准备拦截此次事件序列</span></span><br><span class="line">        consume = onTouchEvent(ev);                 <span class="comment">// 事件由该View执行，并返回结果</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        consume = child.dispatchTouchEvent(ev);     <span class="comment">// 若不准备拦截，则交给子View进行判断</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consume;                                 <span class="comment">// 向父级返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中执行事件序列的不同方法中同样由优先顺序：<code>onTouchListener &gt; onTouchEvent &gt; onClickListener</code></p><p>当点击事件发生后，它的传递过程会遵循以下的顺序：<code>Activity　-&gt; Window -&gt; DecorView -&gt; View -&gt; ...</code>、</p><p>同时，如果子级发现无法执行这个事件的时候，那么它的父容器的<code>onTouchEvent</code>就会重新调用，直到<code>Activity</code>。</p><p>其中，<code>ViewGroup</code>默认不拦截任何事件，<code>View</code>没有<code>onInterceptTouchEvent</code>方法。</p><h2 id="二-事件分发解析"><a class="markdownIt-Anchor" href="#二-事件分发解析"></a> 二、事件分发解析</h2><h3 id="activity对点击事件的分发"><a class="markdownIt-Anchor" href="#activity对点击事件的分发"></a> <code>Activity</code>对点击事件的分发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) <span class="comment">// 如果Window可以处理点击事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev); <span class="comment">// 返回Activity自己处理点击事件的结果(true|false)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="window对点击事件的分发"><a class="markdownIt-Anchor" href="#window对点击事件的分发"></a> <code>Window</code>对点击事件的分发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> PhoneWindow#superDispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">  <span class="keyword">return</span> mDecor.superDispatchTouchEvent(ev); <span class="comment">// 返回DecorView的处理结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顶级view对点击事件的分发"><a class="markdownIt-Anchor" href="#顶级view对点击事件的分发"></a> <code>顶级View</code>对点击事件的分发</h3><p>由此开始，将执行（一）所讲述的事件传递规则。其主要的部分是<code>ViewGroup</code>的事件传递。<code>顶级View</code>一般来说都是<code>ViewGroup</code>。</p><h4 id="判断当前viewgroup是否拦截点击事件"><a class="markdownIt-Anchor" href="#判断当前viewgroup是否拦截点击事件"></a> 判断当前<code>ViewGroup</code>是否拦截点击事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION.DOWN || mFirstTouchTarget != NULL) &#123; <span class="comment">// 意思见下方文字</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>; <span class="comment">// 判断是否允许屏蔽自身的onInterceptTouchEvent方法</span></span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123; <span class="comment">// 如果允许拦截</span></span><br><span class="line">        intercepted = onInterceptTouchEvent(ev); <span class="comment">// 询问能否拦截并赋值</span></span><br><span class="line">        ev.setAction(action); <span class="comment">// 防止事件被修改，存储事件的动作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="literal">false</span>; <span class="comment">// 由于不允许拦截，则直接赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    intercepted = <span class="literal">true</span>; <span class="comment">// 由于直接拦截，则不用询问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的几个变量的作用：</p><ol><li><p>当事件由<code>ViewGroup</code>的子元素处理成功时，<code>mFirstTouchTarget</code>就会被赋值并指向子元素，此时的<code>mFirstTouchTarget != NULL</code>。</p></li><li><p><code>FLAG_DISALLOW_INTERCEPT</code>一旦被设置后，那么当前的<code>ViewGroup</code>就无法拦截<code>ACTION_MOVE</code>以及<code>ACTION_UP</code>。</p><p>由于事件为<code>ACTION_DOWN</code>的时候，<code>ViewGroup</code>会重置<code>FLAG_DISALLOW_INTERCEPT</code>，所以每次事件为<code>ACTION_DOWN</code>的时候，都会执行一次<code>onInterceptTouchEvent</code>方法。</p></li></ol><p>第3行的判断语句的意思为：</p><ol><li>如果当前的事件为<code>ACTION_DOWN</code>时，作为一个点击事件的开始，需要向子元素传递，返回<code>true</code>。允许向子元素传递。</li><li>如果当前的事件为<code>ACTION_MOVE</code>或者<code>ACTION_UP</code>的时候，如果<code>ACTION_DOWN</code>已经被子元素处理了（<code>mFirstTouchTarget != NULL</code>），那么由于一系列的点击事件都要有同一个<code>View</code>处理，则不能在此拦截，故返回<code>true</code>。反之，如果<code>mFirstTouchTarget == NULL</code>，则代表<code>ACTION_DOWN</code>是由<code>ViewGroup</code>自身处理的，则不能向下传递，返回<code>false</code>。</li></ol><h4 id="viewgroup在action_down到来时的重置操作"><a class="markdownIt-Anchor" href="#viewgroup在action_down到来时的重置操作"></a> <code>ViewGroup</code>在<code>ACTION_DOWN</code>到来时的重置操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle an initial down.</span></span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">cancelAndClearTouchTargets(ev);</span><br><span class="line">resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>resetTouchState</code>方法中会对<code>FLAG_DISALLOW_INTERCEPT</code>进行重置。</p><p>因此<code>子View</code>的<code>requestDisallowInterceptTouchEvent</code>方法并不能影响<code>ViewGroup</code>对<code>ACTION_DOWN</code>事件的处理。</p><h4 id="viewgroup不拦截事件时对点击事件的分发"><a class="markdownIt-Anchor" href="#viewgroup不拦截事件时对点击事件的分发"></a> <code>ViewGroup</code>不拦截事件时，对点击事件的分发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> View[] = mChildren;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 获取每一个子View的位置以及其他信息</span></span><br><span class="line">    <span class="keyword">if</span> (子元素正在播放动画 || 点击事件的坐标落在当前子元素的区域外) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    newTouchTarget = getTouchTarget(child); </span><br><span class="line">    <span class="keyword">if</span> (newTouchTarget != NULL) &#123; <span class="comment">// 如果不是NULL的话(该child之前初始化过)，就直接向其中添加元素就行了</span></span><br><span class="line">        newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果 newTouchTarget == NULL, 那么就初始化 + 添加第一个可用子元素</span></span><br><span class="line">    resetCancelNextUpFlag(child);</span><br><span class="line">    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="literal">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">        alreadyDispatchedToNewTouchTarget = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不断的遍历当前<code>ViewGroup</code>的所有子元素，如果<strong>子元素不在播放动画</strong>以及<strong>点击事件的坐标落在当前子元素的区域内</strong>，那么这个子元素就是一个可以传递的。</p><blockquote><p>由<code>TouchTarget</code>源码可知：</p><p><code>TouchTarget</code>保存了响应触摸事件的子<code>view</code>和该子view上的触摸点ID集合，表示一个触摸事件派发目标。通过<code>next</code>成员可以看出，它支持作为一个链表节点储存。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TouchTarget</span> &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The touched child view.</span></span><br><span class="line">    <span class="comment">// 被触摸的子元素</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> View child;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The combined bit mask of pointer ids for all pointers captured by the target.</span></span><br><span class="line">    <span class="comment">// 指针 id 的位的掩码组合，用于目标捕获的所有指针</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> pointerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The next target in the target list.</span></span><br><span class="line">    <span class="comment">// 目标列表中的下一个目标</span></span><br><span class="line">    <span class="keyword">public</span> TouchTarget next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「分则能成」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/dehang0/article/details/104317611</span></span><br></pre></td></tr></table></figure></blockquote><p>如果是第一个可传递元素，那么就会进入初始化部分，其中的<code>dispatchTransformedTouchEvent</code>方法实际上就是调用的子元素的<code>dispatchTouchEvent</code>方法。在该方法中有如下的一段内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == NULL) &#123;</span><br><span class="line">    handled = <span class="built_in">super</span>.dispatchTouchTarget(event);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handled = child.dispatchTouchTarget(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于前面的代码中<code>dispatchTransformedTouchEvent</code>方法的第三个参数为<code>child</code>，所以会执行子元素的<code>dispatchTouchEvent</code>方法，点击事件交由子元素处理，从而完成了一轮事件的分发。</p><p>当子元素的<code>dispatchTouchEvent</code>方法返回<code>true</code>时，<code>dispatchTransformedTouchEvent</code>方法同样也会返回<code>true</code>，接着便执行<code>if语句</code>的代码块部分了。如果<code>dispatchTouchEvent</code>方法返回<code>false</code>的话，<code>ViewGroup</code>就会把事件向后遍历，寻找新的可传递的子元素。在<code>if语句</code>的代码块中，<code>mFirstTouchTarget</code>会被赋值同时跳出<code>for循环</code>。</p><p>其中<code>mFirstTouchTarget</code>的赋值由<code>addTouchTarget</code>方法完成，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TouchTarget <span class="title function_">addTouchTarget</span><span class="params">(View child, <span class="type">int</span> pointerIdBits)</span> &#123;</span><br><span class="line">    <span class="type">TouchTarget</span> <span class="variable">target</span> <span class="operator">=</span> TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">   target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很容易的看出，<code>mFirstTouchTarget</code>其实是一个<strong>单链表结构</strong>，<code>mFirstTouchTarget</code>是否被赋值，将直接影响<code>ViewGroup</code>对事件的拦截策略。</p><h4 id="viewgroup中没有合适的子元素"><a class="markdownIt-Anchor" href="#viewgroup中没有合适的子元素"></a> <code>ViewGroup</code>中没有合适的子元素</h4><p>有两种情况，<code>ViewGroup</code>中会没有合适的子元素可以传递：</p><ol><li><code>ViewGroup</code>没有子元素</li><li>子元素处理了点击事件，但是<code>dispatchTouchEvent</code>方法返回了<code>false</code>，这一般是因为子元素在<code>onTouchEvent</code>中返回了<code>false</code>。</li></ol><p>在这两种情况中，<code>ViewGroup</code>都会自己处理点击事件。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == NULL) &#123;</span><br><span class="line"><span class="comment">// 没有可分发子元素，就当其是一个普通的View</span></span><br><span class="line">handled = dispatchTransformedTouchEvent(ev, canceled, <span class="literal">null</span>, TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，代码中的<code>dispatchTransformedTouchEvent</code>方法的第三个参数将其设置为<code>null</code>，此时它就会调用<code>super.dispatchTouchTarget</code>方法了。</p><h3 id="view对点击事件的处理过程"><a class="markdownIt-Anchor" href="#view对点击事件的处理过程"></a> <code>View</code>对点击事件的处理过程</h3><p>这里的<code>View</code>不包含<code>ViewGroup</code>，因为没有子元素，所以不用向下分发事件，只能自己处理事件。</p><p>先看它的<code>dispatchTouchEvent</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="type">ListenerInfo</span> <span class="variable">li</span> <span class="operator">=</span> mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="literal">null</span> &amp;&amp; li.mOnTouchListener.onTouch(<span class="built_in">this</span>, event) &amp;&amp; ...) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可以看出，<code>View</code>对点击事件的处理流程中，首先会判断有没有设置<code>onTouchListener</code>，如果有且其中的<code>onTouch</code>方法返回<code>true</code>，则<code>onTouchEvent</code>方法就不会被调用。</p><p>从其他的代码中也可以得出的一些结论：</p><ol><li>如果<code>View</code>的<code>CLICKABLE</code>以及<code>LONG_CLICKABLE</code>中有一个为<code>true</code>，不论<code>View</code>是否为<code>DISABLE</code>，都会消耗事件（也就是即使<code>View</code>看起来没有任何的反应，但是也消耗了点击事件）。</li><li><code>View</code>的<code>LONG_CLICKABLE</code>默认为<code>false</code>，而<code>CLICKABLE</code>是否为<code>false</code>与其<code>View</code>有关，如<code>button</code>的默认为<code>true</code>、<code>textview</code>的默认为<code>false</code>。</li><li>当<code>ACTION_UP</code>事件发生时，会触发<code>performClick</code>方法，如果<code>View</code>设置了<code>OnClickListener</code>，那么<code>performClick</code>方法就会调用它的<code>onClick</code>方法。（即<code>onClick</code>的触发前提时<code>View</code>是可点击的，且收到了<code>DOWN</code>和<code>UP</code>的点击事件。）</li><li><code>setOnClickListener</code>方法会自动将<code>CLICKABLE</code>设置为<code>true</code>，<code>setOnLongClickListener</code>方法会自动将<code>LONG_CLICKABLE</code>设置为<code>true</code>。</li></ol><h1 id="view的滑动冲突"><a class="markdownIt-Anchor" href="#view的滑动冲突"></a> <code>View</code>的滑动冲突</h1><p>总共会出现三种滑动冲突的情况：</p><ol><li><code>内部View</code>与<code>外部View</code>的滑动方向相反。</li><li><code>内部View</code>与<code>外部View</code>的滑动方向相同。</li><li>前两种情况的嵌套。</li></ol><p>三种情况的处理思路：</p><ol><li>通过手势滑动的角度判断滑动的方向。</li><li>通过当前处于的不同的页面状态来判断应该滑动的<code>View</code>。</li><li>通过前两种的综合使用。</li></ol><h2 id="滑动冲突的解决方式"><a class="markdownIt-Anchor" href="#滑动冲突的解决方式"></a> 滑动冲突的解决方式</h2><h3 id="外部拦截法"><a class="markdownIt-Anchor" href="#外部拦截法"></a> 外部拦截法</h3><p>通过重写<strong>父容器的</strong><code>onInterceptTouchEvent</code>方法，所有的事件都先经过父容器的筛选，对其中父容器需要的事件进行拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">intercepted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) event.getX();</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) event.getY();</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN : &#123;</span><br><span class="line">            intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE : &#123;</span><br><span class="line">            <span class="keyword">if</span> (父容器需要当前的点击事件)</span><br><span class="line">                intercepted = <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">                intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP : &#123;</span><br><span class="line">            intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastXIntercept = x;</span><br><span class="line">    mLastYIntercept = y;</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部拦截法"><a class="markdownIt-Anchor" href="#内部拦截法"></a> 内部拦截法</h3><p>父元素拦截除<code>ACTION_DOWN</code>以外的其他事件，当事件到达子元素后，由子元素判断是否需要这些事件，不需要的事件将重新交由父容器来处理。这种方法和Android的事件分发机制不一致，需要配合<code>requestDisallowInterceptTouchEvent</code>方法才能正常的工作。</p><p>相关阅读链接：<a href="https://www.jianshu.com/p/fe3d109eb27e">Android TouchEvent之requestDisallowInterceptTouchEvent - 简书 (jianshu.com)</a></p><h4 id="子元素的dispatchtouchevent方法"><a class="markdownIt-Anchor" href="#子元素的dispatchtouchevent方法"></a> 子元素的<code>dispatchTouchEvent</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) event.getX();</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) event.getY();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN : &#123;</span><br><span class="line">            parent.requestDisallowInterceptTouchEvent(<span class="literal">true</span>); <span class="comment">// 此子View的所有父ViewGroup会跳过onInterceptTouchEvent回调</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE : &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">deltaX</span> <span class="operator">=</span> x - mLastX;</span><br><span class="line">            <span class="type">int</span> <span class="variable">deltaY</span> <span class="operator">=</span> y - mLastY;</span><br><span class="line">            <span class="keyword">if</span> (父容器需要当前的点击事件) &#123;</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP : &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> : </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastX = x;</span><br><span class="line">    mLastY = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="父容器的onintercepttouchevent方法"><a class="markdownIt-Anchor" href="#父容器的onintercepttouchevent方法"></a> 父容器的<code>onInterceptTouchEvent</code>方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCPC 读入操作模板</title>
      <link href="/posts/cec9f65c0174/"/>
      <url>/posts/cec9f65c0174/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考：</p><ul><li><a href="https://www.cnblogs.com/AlvinZH/p/6798023.html">C/C++如何整行读入字符串？</a></li></ul></blockquote><hr /><h1 id="快速读入-int"><a class="markdownIt-Anchor" href="#快速读入-int"></a> 快速读入 <code>int</code></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        f = (ch == <span class="number">45</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> f ? (~x + <span class="number">1</span>) : x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="字符串整行读入"><a class="markdownIt-Anchor" href="#字符串整行读入"></a> 字符串整行读入</h1><h2 id="char-整行读入"><a class="markdownIt-Anchor" href="#char-整行读入"></a> char[] 整行读入</h2><h3 id="使用-gets-推荐"><a class="markdownIt-Anchor" href="#使用-gets-推荐"></a> 使用 <code>gets()</code> [推荐]</h3><p>读入不需要考虑换行符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[LEN];</span><br><span class="line"><span class="built_in">gets</span>(s);</span><br></pre></td></tr></table></figure><h3 id="使用-scanf"><a class="markdownIt-Anchor" href="#使用-scanf"></a> 使用 <code>scanf()</code></h3><p>无法读入末尾的换行符，需使用 <code>getchar()</code> 额外读取以便下一行的正常读入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[LEN];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%[^\m]&quot;</span>, s);</span><br><span class="line"><span class="built_in">getchar</span>(); <span class="comment">// 读取末尾换行符</span></span><br></pre></td></tr></table></figure><h3 id="使用-getchar"><a class="markdownIt-Anchor" href="#使用-getchar"></a> 使用 <code>getchar()</code></h3><p>无法读入末尾的换行符，需使用 <code>getchar()</code> 额外读取以便下一行的正常读入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[LEN];</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((s[len] = <span class="built_in">getchar</span>()) != <span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line">  len++;</span><br><span class="line"><span class="built_in">getchar</span>(); <span class="comment">// 读取末尾换行符</span></span><br></pre></td></tr></table></figure><h3 id="使用-getline"><a class="markdownIt-Anchor" href="#使用-getline"></a> 使用 <code>getline()</code></h3><p>读入不需要考虑换行符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[LEN];</span><br><span class="line">cin.<span class="built_in">getline</span>(s, LEN);</span><br></pre></td></tr></table></figure><h2 id="string-整行读入"><a class="markdownIt-Anchor" href="#string-整行读入"></a> string 整行读入</h2><h3 id="使用-getline-2"><a class="markdownIt-Anchor" href="#使用-getline-2"></a> 使用 <code>getline()</code></h3><p>读入不需要考虑换行符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin, s);</span><br></pre></td></tr></table></figure><hr />]]></content>
      
      
      <categories>
          
          <category> XCPC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 面试问题整理</title>
      <link href="/posts/d278b3f4f3e3/"/>
      <url>/posts/d278b3f4f3e3/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>本文持续更新中~</strong></p></blockquote><hr /><h2 id="java-并发包提供了哪些并发工具"><a class="markdownIt-Anchor" href="#java-并发包提供了哪些并发工具"></a> Java 并发包提供了哪些并发工具？</h2><blockquote><p>解答</p></blockquote><p>同步结构</p><ul><li><p>Semaphore 信号量</p><ul><li>通过一个<strong>计数器</strong>来实现并发。</li><li>其基本逻辑 基于 <strong>acquire/release</strong> ,并没有什么太复杂的同步逻辑。</li></ul></li><li><p>CatchDownLatch</p><ul><li>可以做到等待不同的线程处理完各自的数据。</li></ul></li></ul><p>线程安全的容器</p><ul><li>ConcurrentHashMap</li><li>ConcurrentSkipListMap</li></ul><p><em>TODO : 参考极客时间 整理相关内容</em><br />…</p><h2 id="接口和抽象类的区别"><a class="markdownIt-Anchor" href="#接口和抽象类的区别"></a> 接口和抽象类的区别</h2><blockquote><p>解答</p></blockquote><p>接口和抽象类是 Java 面向对象设计的两个基础机制。</p><p>接口是对行为的抽象：</p><ol><li>是抽象方法的集合。</li><li>不能实例化。</li><li>不能包含任何非常量成员，任何变量都是 <code>public static final</code> 。</li><li>没有非静态方法的实现，要么是抽象方法，要么是静态方法。但是在 Java 8 以后，接口也是可以进行方法实现的。</li><li>使用 implements 来实现接口。</li></ol><p>抽象类是不能实例化的类：</p><ol><li>用 abstract 关键字写实 class ，其目的是代码重用。</li><li>除了不能实例化，形式上和一般的 Java 类并没有太大的区别。</li><li>使用 extends 继承抽象类。</li></ol><h2 id="string-stringbuffer-stringbuilder-有什么区别"><a class="markdownIt-Anchor" href="#string-stringbuffer-stringbuilder-有什么区别"></a> String, StringBuffer, StringBuilder 有什么区别</h2><blockquote><p>解答</p></blockquote><p>String：</p><ol><li>是 Java 非常基础和重要的类。</li><li>是典型的 Immutable 类，被声明为 final class，所有的属性也都是 final。</li><li>由于不可变性，所有对字符串的操作，都会产生新的 String 对象。</li></ol><p>StringBuffer：</p><ol><li>是一个 <strong>线程安全</strong> 的可修改字符序列，保证了线程的安全，但是同时带来了额外的性能开销。</li><li>提供了 append 以及 add 等方法，可以将一个字符串添加到已有序列的末尾。</li><li><strong>线程安全</strong> 本质上是对各种能够修改数据的方法都添加了 synchronized 关键字。</li></ol><p>StringBuilder：</p><ol><li>在 StringBuffer 的基础上，去除了线程安全的部分，减少了性能的开销。</li></ol><p>StringBuffer 和 StringBuilder 的底层在 JDK 9 以前使用了 char 数组，在 JDK 9 以后使用了 byte 数组，二者都继承了 AbstractStringBuilder。<br />二者初始化的时候，默认的长度都是16，可以自行更改。扩容会进行额外的开销，因为需要抛弃原有数组、建立新的数组，然后再进行数组的复制。</p><h2 id="对比-vector-arraylist-linkedlist"><a class="markdownIt-Anchor" href="#对比-vector-arraylist-linkedlist"></a> 对比 Vector, ArrayList, LinkedList</h2><blockquote><p>解答</p></blockquote><p>三者都是实现了 List 接口的类，即都是有序集合。</p><ul><li><p>Vector 是 Java 早期提供的 线程安全的动态数组，扩容时会提高当前的1倍容量。</p></li><li><p>ArrayList 并不是线程安全的，所以它有更好的性能。</p><ul><li>第一次插入元素时创建的大小为10。</li><li>与 Vector 不同，ArrayList 的扩容量为之前的50%，如果扩充了50%的容量后仍达不到需求值，则直接扩充为需求值。扩容函数为 <code>ensureCapacityInternal</code>。</li></ul></li><li><p>LinkedList 为双向链表，也不是线程安全的。</p><ul><li>如果访问的位置在链表的后半部分，则直接从末尾开始遍历访问。将时间复杂度变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>。</li></ul></li></ul><h2 id="set-的实现"><a class="markdownIt-Anchor" href="#set-的实现"></a> Set 的实现</h2><blockquote><p>解答</p></blockquote><p>在源码中，Set 的实现是通过对应的 Map 实现的。<br />如 HashSet 的内部是一个 HashMap，TreeSet 的内部是一个 TreeMap。</p><h2 id="java-中的不同的-sort-的实现原理"><a class="markdownIt-Anchor" href="#java-中的不同的-sort-的实现原理"></a> Java 中的不同的 sort() 的实现原理</h2><blockquote><p>解答</p></blockquote><p>Java 中的不同 sort() 的原理是不一样的。</p><ul><li>对于原始数据类型，目前使用的是所谓的双轴快速排序，早期使用的是传统的快速排序。</li><li>对视对象数据类型，目前使用的是 TimSort，思想上是一种归并和二分插入排序结合的优化排序算法。</li></ul><h2 id="一个线程调用了两次-start-会发生什么"><a class="markdownIt-Anchor" href="#一个线程调用了两次-start-会发生什么"></a> 一个线程调用了两次 start() 会发生什么</h2><blockquote><p>解答</p></blockquote><p>Java 线程不允许启动两次，第二次启动的时候必定会抛出 <code>IllegalThreadStateException</code>。</p><h2 id="线程生命周期的不同状态"><a class="markdownIt-Anchor" href="#线程生命周期的不同状态"></a> 线程生命周期的不同状态</h2><blockquote><p>解答</p></blockquote><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{init : {&#39;theme&#39; : &#39;default&#39;, &quot;flowchart&quot; : {&#39;curve&#39; : &#39;&#39;}}}%%graph TBRunnable --&gt; Waiting --&gt; RunnableNew --&gt; Runnable --&gt; TerminatedRunnable --&gt; Blocked --&gt; Runnable  </pre></div><h2 id="jvm-的类加载机制"><a class="markdownIt-Anchor" href="#jvm-的类加载机制"></a> JVM 的类加载机制</h2><blockquote><p>解答</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">subgraph 链接</span><br><span class="line">    验证 ==&gt; 准备 ==&gt; 解析</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">加载 ==&gt; 验证</span><br><span class="line">解析 ==&gt; 初始化</span><br></pre></td></tr></table></figure><h2 id="jvm-的类加载器"><a class="markdownIt-Anchor" href="#jvm-的类加载器"></a> JVM 的类加载器</h2><blockquote><p>解答</p></blockquote><p><strong>Java 8 及以前</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">应用类加载器 --&gt;|父-类加载器| 扩展类加载器 --&gt;|父-类加载器| 启动类加载器</span><br></pre></td></tr></table></figure><p><strong>Java 9 以后</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">平台类加载器 --&gt;|父-类加载器|启动类加载器 </span><br></pre></td></tr></table></figure><h2 id="如何保证集合的线程安全"><a class="markdownIt-Anchor" href="#如何保证集合的线程安全"></a> 如何保证集合的线程安全？</h2><blockquote><p>解答</p></blockquote><ul><li>HashTable：在 HashMap 的 put、get 方法前面加上 synchronized 来保证线程的安全。性能大大的降低。</li><li>ConcurrentHashMap：依赖于 Java 内存模型，提升了性能，经过多次的优化。</li></ul><h2 id="concurrenthashmap-解析"><a class="markdownIt-Anchor" href="#concurrenthashmap-解析"></a> ConcurrentHashMap 解析</h2><blockquote><p>解答</p></blockquote><p>Java 9 以前使用：分段锁 + HashEntry + 红黑树</p><p>Java 9 以后使用：CAS + HashEntry + 红黑树</p><h2 id="treemap-解析"><a class="markdownIt-Anchor" href="#treemap-解析"></a> TreeMap 解析</h2><blockquote><p>解答</p></blockquote><p>TreeMap 可以在保证 Key 的大小有序的情况下，存储键值对。<br />TreeMap 通过使用<strong>红黑树</strong>来进行存储和取出，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log \space n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。<br />TreeMap 通过<strong>中序遍历</strong>的方式来有序的输出键值对（以 Key 的大小排序）。</p><h2 id="hashmap-解析"><a class="markdownIt-Anchor" href="#hashmap-解析"></a> HashMap 解析</h2><blockquote><p>解答</p></blockquote><p><em>TODO ：完成相关内容</em></p><h2 id="泛型-解析"><a class="markdownIt-Anchor" href="#泛型-解析"></a> 泛型 解析</h2><blockquote><p>解答</p></blockquote><ol><li><p>泛型的好处</p><ul><li>类型安全，类型的错误在编译器就可以被捕获到了，提高了程序的可靠性。</li><li>消除了代码的许多的强制类型转换，增强了代码的可读性。</li><li>为较大的优化带来了可能性。</li></ul></li><li><p>在静态方法、静态初始化块或者静态变量的生命和初始化中不允许使用类型形参。由于系统中并不会真正生成泛型类，所以 instanceof 运算符后不能使用泛型类。</p></li></ol><h2 id="java-反射"><a class="markdownIt-Anchor" href="#java-反射"></a> Java 反射</h2><blockquote><p>解答</p></blockquote><p><strong>Java 反射机制的应用场景</strong></p><ol><li>与注解相结合的框架，如 Retrofit</li><li>单纯的反射机制应用框架，如 EventBus</li><li>动态生成类框架，如 Gson</li><li>逆向代码，例如反编译</li></ol><h2 id="java-注释annotation"><a class="markdownIt-Anchor" href="#java-注释annotation"></a> Java 注释（Annotation）</h2><blockquote><p>解答</p></blockquote><p>理解注释的作用，就要先理解 Java 中元数据的概念。</p><ol><li><p>元数据概念<br />元数据是关于数据的数据。在编程语言的上下文中，元数据是添加到程序元素如方法、字段、类和包上的额为撒信息。对数据进行说明描述的数据。</p></li><li><p>元数据的作用（注释的作用）</p></li><li><p>编写代码</p></li><li><p>代码分析</p></li><li><p>编译检查</p></li></ol><p><strong>注意：<strong>注释 Annotation 就是 Java 平台的元数据，该机制允许在 Java 代码中添加自定义注释，并允许通过</strong>反射（Reflection）</strong>，以编程的方式访问元数据注释。如果想以编程的方法获得注释，可以通过反射的 <code>getAnnotation</code> 方法获得。</p><ol start="3"><li>内建注解<br />Java 内部提供了多种内建的注解，常用的四个注解如下：</li><li>@Override</li><li>@Deprecated</li><li>@SuppressWarnings</li><li>@FunctinoalInterface</li></ol><h2 id="java-nio"><a class="markdownIt-Anchor" href="#java-nio"></a> Java NIO</h2><blockquote><p>解答</p></blockquote><p>Java NIO(New IO) 是一个新式的 IO 标准，与之前的普通 IO 的工作方式不同：</p><ul><li>标准的 IO 基于字节流和字符流进行操作的。</li><li>NIO 是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入通道也类似。</li></ul><p>Java NIO 由以下几个核心部分组成：</p><ul><li>Buffer</li><li>Channel</li><li>Selector</li></ul><h2 id="java-异常解析"><a class="markdownIt-Anchor" href="#java-异常解析"></a> Java 异常解析</h2><blockquote><p>解答</p></blockquote><ol><li>异常的种类</li></ol><p><em>TODO：补充类图</em></p><ol start="2"><li>finally 和 return 的执行顺序<ol><li>finally 语句在 return 语句执行之后，return 返回之前执行。</li><li>finally 里的修改语句可能会影响 try 和 catch 中 return 已经确定的返回值。</li><li>如果 finally 里面也有 return 语句，则会覆盖 try 和 catch 中的 return 语句直接返回。</li></ol></li></ol><h2 id="java-transient-解析"><a class="markdownIt-Anchor" href="#java-transient-解析"></a> Java transient 解析</h2><blockquote><p>解答</p></blockquote><ol><li>transient 关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被 transient 关键字修饰的。变量如果是用户自定义的类变量，则该类是要实现 Serializable 接口。</li><li>一旦变量被 transient 修饰，变量将不是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li><li>静态变量不管是否被 transient 修饰，都无法被序列化。</li></ol><p>**注意：**被 transient 修饰的变量也是可以被序列化的。</p><p>Java 中，对象的序列化可以通过实现两个接口实现：</p><ul><li>若实现的是 Serializable 接口，则所有的序列化都将会自动进行，被 transient 修饰的变量将不会被序列化。</li><li>若实现的是 Externalizable 接口，则任何东西都需要自己在 writeExternal 方法中自己手动指定需要序列化的变量。任何变量都可以序列化，与变量是否被 transient 修饰无关。</li></ul><h2 id="java-aqs-解析"><a class="markdownIt-Anchor" href="#java-aqs-解析"></a> Java AQS 解析</h2><blockquote><p>解答</p></blockquote><p>参考 <a href="https://blog.csdn.net/mulinsen77/article/details/84583716">AQS详解（面试）</a></p><h2 id="java-中-和-equals-的区别"><a class="markdownIt-Anchor" href="#java-中-和-equals-的区别"></a> Java 中 == 和 equals() 的区别</h2><blockquote><p>解答</p></blockquote><ol><li><code>equals()</code> 是方法，而 <code>==</code> 是操作符。</li><li>对于基本类型，只能使用 <code>==</code>。因为基本类型没有 equals 方法。</li><li><code>==</code> 比较的是两者的值。</li><li>equals 方法是 Object 类中的方法。除了子类重写 equals 方法，完成特定的比较内容，如 String 类中 equals 方法是比较两个字符串的值，默认的 equals 方法是比较两者在内存中的存放地址。</li></ol><h2 id="生产者-消费者模式"><a class="markdownIt-Anchor" href="#生产者-消费者模式"></a> 生产者-消费者模式</h2><blockquote><p>解答</p></blockquote><p>生产者-消费者模式的核心是一个<strong>任务队列</strong>，生产者线程生产任务，并将任务添加到任务队列中。而消费者线程中任务队列中获取任务并执行。</p><p><strong>优点：</strong></p><ul><li>生产者和消费者没有任何的依赖关系，他们彼此之间的通信只能通过任务队列，所以 <strong>生产者-消费者模式是一个不错的解耦方案</strong>。</li><li>生产者-消费者模式支持异步，并且能够通过任务队列平衡生产者和消费者的速度差异。</li></ul><h2 id="java-死锁"><a class="markdownIt-Anchor" href="#java-死锁"></a> Java 死锁</h2><blockquote><p>解答</p></blockquote><ol><li><p>死锁的定义：<br />一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。</p></li><li><p>出现死锁的四个条件：</p><ol><li>占有且等待</li><li>不可抢占</li><li>循环等待</li><li>互斥</li></ol></li><li><p>对应的解决方法：</p><ol><li>通过一个管理对象统一申请所有资源。</li><li>通过并发包的 Lock。</li><li>对资源进行有序获取。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改 mermaid 流程图的样式以及连线的曲直</title>
      <link href="/posts/b16a9e46aacf/"/>
      <url>/posts/b16a9e46aacf/</url>
      
        <content type="html"><![CDATA[<h1 id="修改前的效果"><a class="markdownIt-Anchor" href="#修改前的效果"></a> 修改前的效果</h1><p>若直接使用 mermaid 完成一个流程图的画，我们可能会在默认样式的图中得到众多曲线。</p><p>比如通过下方的代码便可以得到对应的流程图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A --&gt; B --&gt; C &amp; D &amp; E &amp; F</span><br><span class="line">C --&gt; A</span><br><span class="line">D --&gt; C</span><br></pre></td></tr></table></figure><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph TBA --&gt; B --&gt; C &amp; D &amp; E &amp; FC --&gt; AD --&gt; C  </pre></div><hr /><h1 id="修改方法及解析"><a class="markdownIt-Anchor" href="#修改方法及解析"></a> 修改方法及解析</h1><p>在 <code>graph</code> 所在行的前面加上如下设定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%%&#123;init : &#123;&#x27;theme&#x27; : &#x27;default&#x27;, &quot;flowchart&quot; : &#123;&#x27;curve&#x27; : &#x27;linear&#x27;&#125; &#125; &#125;%%</span><br></pre></td></tr></table></figure><h2 id="样式部分"><a class="markdownIt-Anchor" href="#样式部分"></a> 样式部分</h2><p><code>init</code> 代码块中的前半部分 <code>'theme' : 'default'</code> 是流程图的样式，官方提供四种样式：</p><ul><li><code>default</code></li><li><code>forest</code></li><li><code>neutral</code></li><li><code>dark</code></li></ul><p>我们可以只为流程图设置样式，那么只需要在 <code>graph</code> 前面添加如下部分即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%%&#123;init: &#123;&#x27;theme&#x27;: &#x27;neutral&#x27; &#125; &#125;%%</span><br></pre></td></tr></table></figure><h2 id="连线曲直部分解析"><a class="markdownIt-Anchor" href="#连线曲直部分解析"></a> 连线曲直部分解析</h2><p>后半部分 <code>&quot;flowchart&quot; : &#123;'curve' : 'linear'&#125;</code> 则是选择连线的曲直，内部的 <code>curve</code> 也有两个取值：</p><ul><li><code>basis</code></li><li><code>linear</code></li></ul><p>两个选项分别对应着曲线和直线。</p><p>同样，如果我们只希望修改连线的曲直，那么我们就可以添加如下部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%%&#123;init : &#123;&quot;flowchart&quot; : &#123;&#x27;curve&#x27; : &#x27;linear&#x27;&#125; &#125; &#125;%%</span><br></pre></td></tr></table></figure><hr /><h1 id="修改后的效果"><a class="markdownIt-Anchor" href="#修改后的效果"></a> 修改后的效果</h1><p>我们对上方的 <code>mermaid</code> 代码进行修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%%&#123;init : &#123;&#x27;theme&#x27; : &#x27;forest&#x27;, &quot;flowchart&quot; : &#123;&#x27;curve&#x27; : &#x27;linear&#x27;&#125; &#125; &#125;%%</span><br><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A --&gt; B --&gt; C &amp; D &amp; E &amp; F</span><br><span class="line">C --&gt; A</span><br><span class="line">D --&gt; C</span><br></pre></td></tr></table></figure><p>就可以得到 <code>forest</code> 样式的直线连线图了：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{init : {&#39;theme&#39; : &#39;forest&#39;, &quot;flowchart&quot; : {&#39;curve&#39; : &#39;linear&#39;} } }%%graph TBA --&gt; B --&gt; C &amp; D &amp; E &amp; FC --&gt; AD --&gt; C  </pre></div>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> mermaid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ikbc 键盘 Win 键无法响应</title>
      <link href="/posts/65315041b85b/"/>
      <url>/posts/65315041b85b/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用 ikbc 键盘时，<code>Win</code> 键无法响应？</p></blockquote><p>可能是通过 <code>Fn</code> + <code>左Win</code> 进行了加锁操作，导致无法正常使用 <code>Win</code> 键。</p><p>可以通过 <code>Fn</code> + <code>右Win</code> 进行解锁操作，这样就可以正常使用 <code>Win</code> 键了。</p>]]></content>
      
      
      <categories>
          
          <category> ikbc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ikbc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View 的绘制原理</title>
      <link href="/posts/19429a22b2b2/"/>
      <url>/posts/19429a22b2b2/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><h2 id="viewroot"><a class="markdownIt-Anchor" href="#viewroot"></a> <code>ViewRoot</code></h2><p><code>ViewRoot</code>对应于<code>ViewRootImpl</code>类，它是连接<code>WindowManager</code>和<code>DecorView</code>的纽带。<code>View</code>的三大流程都是通过<code>ViewRoot</code>来完成的。</p><p>在<code>ActivityThread</code>中，当<code>Activity</code>对象被创建完毕后，会将<code>DecorView</code>添加到<code>Window</code>中，同时也会创建<code>ViewRootImpl</code>对象，并将<code>ViewRootImpl</code>对象与<code>DecorView</code>建立关联。</p><h2 id="view的三大绘制流程"><a class="markdownIt-Anchor" href="#view的三大绘制流程"></a> <code>View</code>的三大绘制流程</h2><p><code>View</code>的绘制流程主要有<code>measure</code>、<code>layout</code>和<code>draw</code>过程。</p><ol><li><code>measure</code>：用来确定<code>View</code>的测量宽高。</li><li><code>layout</code>：用来确定<code>View</code>的最终宽高以及四个顶点的位置。</li><li><code>draw</code>：将<code>View</code>绘制在屏幕上。</li></ol><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-d165daed428c4a5312c1ce1af6a9693a_720w.jpg" alt="" /></p><p><code>View</code>的绘制流程由<code>ViewRoot</code>的<code>performTraversals</code>方法开始。</p><p><code>performTraversals</code>方法会依次调用<code>performMeasure</code>、<code>performLayout</code>、<code>performDraw</code>方法。<strong>这三个方法会分别完成<code>顶层View</code>的<code>measure</code>、<code>layout</code>、<code>draw</code>过程。</strong></p><p>其中、<code>performMeasure</code>方法会调用其中的<code>measure</code>方法，在<code>measure</code>方法中又会调用<code>onMeasure</code>方法，在<code>onMeasure</code>方法中会对所有的子元素进行<code>measure</code>过程，这个时候<code>measure</code>的流程就从父容器传递到了子元素中，这样就完成了一轮<code>measure</code>过程。不断的对子元素进行<code>measure</code>过程。如此反复便完成了对<code>View</code>树的遍历。</p><p>其中，<code>performMeasure</code>方法位于<code>ViewRootImpl</code>中的<code>measureHierarchy</code>方法中(<code>hierarchy</code>：<code>n.</code>层次结构)。</p><p><code>performLayout</code>方法、<code>performDraw</code>方法的流程与之同理，需要注意一点的是，<code>draw</code>流程的传递是通过<code>draw</code>方法中的<code>dispatchDraw</code>实现的，不过并无本质的区别。</p><h2 id="decorview"><a class="markdownIt-Anchor" href="#decorview"></a> <code>DecorView</code></h2><p><code>DecorView</code>作为<code>顶层View</code>，继承自<code>FrameLayout</code>。一般情况下它的内部都会包含一个<code>LinearLayout</code>。而<code>LinearLayout</code>中有上下两个部分，分别为标题栏和内容栏。我们平时设置指定布局文件的方法<code>setContentView</code>，就是指的是内容栏中的布局。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-8f887429daf00df80319901f69cd1d35_720w.jpg" alt="img" style="zoom:67%;" /><p>通过源码，我们可以得知，<strong><code>DecorView</code>其实是一个<code>LinearLayout</code></strong>，<code>View</code>层的事件都先通过<code>DecorView</code>，然后才传递给我们的<code>View</code>。</p><h2 id="measurespec"><a class="markdownIt-Anchor" href="#measurespec"></a> <code>MeasureSpec</code></h2><blockquote><p><code>spec</code> <strong><code>英[spek]</code></strong><code>n.</code>规格 <code>vt.</code>按特定标准设计并制造</p></blockquote><p><code>MeasureSpec</code>参与了<code>View</code>的<code>measure</code>过程。在测量过程中，系统将<code>View</code>的<code>LayoutParams</code>根据父容器所施加的规则转换成对应的<code>MeasureSpec</code>，然后再根据这个<code>MeasureSpec</code>来测量出<code>View</code>的测量宽/高。</p><p><code>MeasureSpec</code>代表一个32位的<code>int</code>值，高两位代表 测量模式<code>SpecMode</code>，低30位代表 该测量模式下的规格大小<code>SpecSize</code>。</p><p><code>MeasureSpec</code>与<code>SpecMode</code>、<code>SpecSize</code>之间可以通过位运算互相求出。</p><p>每个<code>View</code>的<code>measure</code>过程之前都会先计算其<code>MeasureSpec</code>的值，然后再对其进行<code>measure</code>。</p><p><strong>注意</strong>：<code>View</code>的宽和高各有一个<code>MeasureSpec</code>值，分别为<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>。</p><h3 id="specmode的三种状态"><a class="markdownIt-Anchor" href="#specmode的三种状态"></a> <code>SpecMode</code>的三种状态</h3><ol><li><p><code>UNSPECIFIED</code></p><p>父容器不对<code>View</code>做任何的限制，要多大给多大。<strong>这种情况一般用于系统的内部</strong>，表示一种测量方式的状态。</p></li><li><p><code>EXACTLY</code></p><p>父容器已经测出了<code>View</code>所需要的精确大小，此时的大小就是<code>View</code>的最终大小。</p><p>它对应于<code>LayoutParams</code>的<code>match_parent</code>和具体的数值这两种模式。</p></li><li><p><code>AT_MOST</code></p><p>父容器指定了一个可用的大小，<code>View</code>的大小不能大于这个值。</p><p>它对应于<code>LayoutParams</code>中的<code>wrap_content</code>。</p></li></ol><h3 id="measurespec和layoutparams的对应关系"><a class="markdownIt-Anchor" href="#measurespec和layoutparams的对应关系"></a> <code>MeasureSpec</code>和<code>LayoutParams</code>的对应关系</h3><p>对于<code>DecorView</code>和普通<code>View</code>来说，<code>MeasureSpec</code>的转化过程略有不同。</p><p><strong>对于<code>DecorView</code>：</strong></p><p><strong><code>DecorView</code>的<code>MeasureSpec</code>由窗口的大小和<code>DecorView</code>自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在<code>ViewRootImpl</code>中的<code>measureHierarchy</code>方法中，调用<code>getRootMeasureSpec</code>方法，获得<code>DecorView</code>的<code>MeasureSpec</code>。</p><p>其中<code>getRootMeasureSpec</code>方法中，根据自身<code>LayoutParams</code>的不同大小，共有三种情况：</p><ol><li><code>LayoutParams.MATCH_PARENT</code>：精确模式，大小就是窗口的大小。</li><li><code>LayoutParams.WRAP_CONTENT</code>：最大模式，大小不定，但是不能超过窗口的大小。</li><li>固定大小(比如100dp)：精确模式，大小为<code>LayoutParams</code>中指定的大小。</li></ol><p><strong>对于普通<code>View</code>：</strong></p><p><strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在父容器的<code>measureChildWithMargins</code>中的<code>getChildMeasureSpec</code>方法获得<code>View</code>的<code>MeasureSpec</code>。</p><p>其中<code>getChildMeasureSpec</code>方法的参数中使用到了父容器的<code>MeasureSpec</code>。在这个方法中通过<code>switch</code>和<code>if</code>语句，对<code>View</code>的<code>MeasureSpec</code>进行了决定。结果如下：</p><table><thead><tr><th><code>childLayoutParams</code> \ <code>parentMeasureSpec</code></th><th><code>EXACTLY</code></th><th><code>AT_MOST</code></th><th><code>UNSPECIFIED</code></th></tr></thead><tbody><tr><td><code>dp</code>/<code>px</code></td><td><code>EXACTLY</code><br>childSize</td><td><code>EXACTLY</code><br/>childSize</td><td><code>EXACTLY</code><br/>childSize</td></tr><tr><td><code>match_parent</code></td><td><code>EXACTLY</code><br/>parentSize</td><td><code>AT_MOST</code><br>parentSize</td><td><code>UNSPECIFIED</code><br>0</td></tr><tr><td><code>wrap_content</code></td><td><code>AT_MOST</code><br>parentSize</td><td><code>AT_MOST</code><br/>parentSize</td><td><code>UNSPECIFIED</code><br/>0</td></tr></tbody></table><p>上图可以简单记为：除了<code>dp</code>/<code>px</code>的精确模式情况外，三种<code>MeasureSpec</code>的级别为：<code>EXACTLY</code> &lt; <code>AT_MOST</code> &lt; <code>UNSPECIFIED</code> 且<code>childMeasureSpec</code> = max(<code>childLayoutParams</code> , <code>parentMeasureSpec</code>)。（<strong>实际上并无级别之分</strong>）</p><p>通过上面的表格，可以更加直观的看出：<strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><h1 id="view的工作流程"><a class="markdownIt-Anchor" href="#view的工作流程"></a> <code>View</code>的工作流程</h1><h2 id="measure过程"><a class="markdownIt-Anchor" href="#measure过程"></a> <code>measure</code>过程</h2><p><code>measure</code>过程分为两种情况：</p><ol><li><code>View</code>的<code>measure</code>过程：只需要测量自身即可。</li><li><code>ViewGroup</code>的<code>measure</code>过程：则除了完成自己的测量外，还需要遍历去调用所有子元素的<code>measure</code>过程。</li></ol><p>以下对这两种情况分别讨论。</p><h3 id="view的measure过程"><a class="markdownIt-Anchor" href="#view的measure过程"></a> <code>View</code>的<code>measure</code>过程</h3><p><code>View</code>的<code>measure</code>方法是<code>final</code>类型的方法，不可以重写，<code>measure</code>方法里面调用了<code>onMeasure</code>方法。</p><p>在<code>onMeasure</code>方法里面也只调用了一个<code>setMeasuredDimension</code>方法来设置<code>View</code>的宽/高的测量值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMininumWidth(), </span><br><span class="line">                                        widthMeasureSpec), </span><br><span class="line">                         getDefaultSize(getSuggestedMininumHeight(), </span><br><span class="line">                                        heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在<code>setMeasureDimension</code>方法的参数中，则使用了<code>getDefaultSize</code>的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDefaultSize</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> measureSpec)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> Measurespec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            result = size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            result = specsize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对于at_most和exactly的情况"><a class="markdownIt-Anchor" href="#对于at_most和exactly的情况"></a> 对于<code>AT_MOST</code>和<code>EXACTLY</code>的情况</h4><p>通过代码可以看出，最终返回的值就是传入的<code>MeasureSpec</code>的中<code>View</code><strong>测量后</strong>的大小（<code>View</code>的<strong>最终的</strong>大小是在<code>layout</code>阶段确定的，但是几乎所有情况下，<code>View</code>的测量大小和最终大小都是相同的）。</p><h4 id="对于unspecified的情况"><a class="markdownIt-Anchor" href="#对于unspecified的情况"></a> 对于<code>UNSPECIFIED</code>的情况</h4><p><code>getDefaultSize</code>方法返回的值是<code>getsuggestedMininumWidth</code>方法和<code>getsuggestedMininumHeight</code>方法决定的。</p><p>这里只讨论<code>getsuggestedMininumWidth</code>方法的逻辑，另一个方法同理：</p><ol><li>如果<code>View</code>没有设置背景，那么此方法的返回值就是<code>android:minWidth</code>这个属性所指定的值，这个值默认为0。</li><li>如果<code>View</code>设置了背景，则返回<code>android:minWidth</code>和背景的最小宽度这两者中的最大值。</li></ol><h4 id="对于自定义view的情况"><a class="markdownIt-Anchor" href="#对于自定义view的情况"></a> 对于自定义<code>View</code>的情况</h4><p>对于直接继承<code>View</code>的自定义<code>View</code>来说，<strong>需要重写<code>onMeasure</code>方法并设置在<code>wrap_content</code>情况时的自身大小</strong>，否则在布局中使用<code>wrap_content</code>就相当于使用<code>match_parent</code>。</p><p>因为当自定义<code>View</code>处于<code>wrap_content</code>时，它的<code>SpecMode</code>为<code>AT_MOST</code>模式，由前文可知，当父容器无论为<code>AT_MOST</code>还是<code>ECACTLY</code>模式时，自定义<code>View</code>都为<code>AT_MOST</code>模式且尺寸大小为<code>parentSize</code>，也就是父容器的剩余空间，即自定义<code>View</code>的大小变得与父容器的剩余空间大小一致，显然不是我们需要的。</p><p><strong>解决方法：</strong></p><p>解决方法也是非常简单的。我们只需要在<code>onMeasure</code>方法中对</p><ol><li>仅<code>width</code>方向为<code>AT_MOST</code>模式</li><li>仅<code>height</code>方向为<code>AT_MOST</code>模式</li><li><code>width</code>方向以及<code>height</code>方向都为<code>AT_MOST</code>模式</li><li>其他的情况</li></ol><p>这四个状态单独判断，分别使用<code>setMeasuredDimension</code>方法直接为自定义<code>View</code>设置我们需要的值即可。</p><p>源码中对于<code>TextView</code>、<code>ImageView</code>等控件的<code>wrap_content</code>也做了特殊的处理。</p><h3 id="viewgroup的measure过程"><a class="markdownIt-Anchor" href="#viewgroup的measure过程"></a> <code>ViewGroup</code>的<code>measure</code>过程</h3><p>对于<code>ViewGroup</code>来说，处理要完成它自己的<code>measure</code>过程，还需要遍历去调用所有子元素的<code>measure</code>方法，对子元素也进行<code>measure</code>过程。</p><p>由于<code>ViewGroup</code>是一个抽象类，不能重写<code>View</code>的<code>onMeasure</code>方法，但是他提供了一个<code>measureChildren</code>的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">measureChildren</span><span class="params">(<span class="type">int</span> widthMeasureSepc, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> children[i];</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中，可以清晰的看出，<code>measureChildren</code>方法遍历了所有的子元素，并对他们使用了<code>measureChild</code>方法。</p><p>在<code>measureChild</code>方法中，通过</p><ol><li>参数<code>child</code>获得了<code>child.LayoutParams</code>；</li><li><code>measureChild</code>方法中的<code>getChildMeasureSpec</code>方法配合参数中父容器的两个<code>MeasureSpec</code>值，得到子元素的两个<code>MeasureSpec</code>值。</li></ol><p>接着将子元素的两个<code>MeasureSpec</code>值传递给<code>child.measure</code>方法来进行测量，到此便结束了一轮的<code>measure</code>过程。</p><p><strong>注意</strong>：不同的<code>ViewGroup</code>有着不同的布局特性，不易写出通用的供<code>ViewGroup</code>使用的<code>onMeasure</code>方法。故设置成抽象类，需要测量过程中的各个子类（如<code>LinearLayout</code>、<code>RelativeLayout</code>等）自己去具体实现<code>onMeasure</code>方法。</p><h3 id="在activity启动时获得一个view的宽高信息的方法"><a class="markdownIt-Anchor" href="#在activity启动时获得一个view的宽高信息的方法"></a> 在<code>Activity</code>启动时获得一个<code>View</code>的宽/高信息的方法</h3><p>由于<code>Activity</code>的启动和<code>View</code>的测量过程并不是同步进行的，因此无法保证在<code>Activity</code>启动时某个<code>View</code>已经测量完毕了。所以我们在<code>Activity</code>启动的时候，如果直接通过<code>getMeasuredWidth</code>/<code>getMeasuredHeight</code>方法获得的值可能为0。</p><p>以下有四种方法可以解决这个问题（详细代码见《Android开发艺术探索》190页）。</p><ol><li><p><code>Activity/View#onWindowFocusChanged</code></p><p>在<code>Activity</code>的<code>onResume</code>和<code>onPause</code>方法启动时，<code>onWindowFocusChanged</code>方法也会同时被调用，可以重写里面的内容，使之计算<code>View</code>的宽高。</p><p><strong>注意</strong>：<code>onWindowFocusChanged</code>方法会在<code>View</code>已经初始化完毕后才开始调用。</p></li><li><p><code>view.post(runnable)</code></p><p>通过<code>post</code>可以将一个<code>runnable</code>投递都消息队列的尾部，然后等待<code>Looper</code>调用此<code>runnable</code>的时候，<code>View</code>也已经初始化好了。</p></li><li><p><code>ViewTreeObserver</code></p><p><code>ViewTreeObserver</code>中的众多回调可以完成这个功能。</p><p>比如<code>OnGlobalLayoutListener</code>接口，当<code>View</code>树的状态发生改变或者<code>View</code>树内部的<code>View</code>的可见性发生改变的时候，<code>onGlobalLayout</code>方法将被回调，此时就可以获取<code>View</code>的宽高了。</p></li><li><p><code>view.measure(int widthMeasureSpec, int heightMeasureSpec)</code></p><p>可以主动调用该方法开始计算<code>view</code>的宽高。</p><ol><li><p><strong><code>match_parent</code></strong></p><p>由于正常的<code>measure</code>过程中，我们需要父容器的<code>MeasureSpec</code>的值，而此时父容器并没开始计算，我们无从得知这两个值的大小。故我们无法对<code>match_parent</code>的<code>view</code>计算其宽高。</p></li><li><p><strong><code>dp</code>/<code>px</code></strong></p><p>因为有精确的数值了，所以我们可以直接使用这个精确的数值通过<code>MeasureSpec.makeMeasureSpec</code>方法构建<code>view</code>的<code>MeasureSpec</code>。</p></li><li><p><strong><code>wrap_content</code></strong></p><p>直接将<code>MeasureSpec.makeMeasureSpec</code>方法中参数的值设置为<code>(1&lt;&lt;30)-1</code>即可，这是<code>View</code>理论上可以支持的最大值，所以这样构建<code>MeasureSpec</code>是合理的。</p></li></ol></li></ol><h2 id="layout过程"><a class="markdownIt-Anchor" href="#layout过程"></a> <code>layout</code>过程</h2><p><code>layout</code>的作用是<code>ViewGroup</code>用来确定子元素的位置。当调用一个<code>View</code>的<code>layout</code>方法时，它会在<code>layout</code>方法中通过<code>setFrame</code>方法确定自身的位置，然后调用<code>onLayout</code>方法确定子元素的位置。</p><p>在<code>onLayout</code>方法中，会遍历所有子元素，对它们计算各自的位置后，调用子元素的<code>layout</code>方法，完成一轮<code>layout</code>过程。</p><p><code>View</code>中实现了<code>layout</code>方法，但是由于<code>onLayout</code>的实现与不同<code>View</code>各自的布局有关，所以源码中仅给出了一个空<code>onLayout</code>方法。需要每个<code>View</code>和<code>ViewGroup</code>自己去重写。</p><p><strong>注意</strong>：单一<code>View</code>一般不需要重写<code>onLayout</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Assign a size and position to a view and all of its</span></span><br><span class="line"><span class="comment"> * descendants</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is the second phase of the layout mechanism.</span></span><br><span class="line"><span class="comment"> * (The first is measuring). In this phase, each parent calls</span></span><br><span class="line"><span class="comment"> * layout on all of its children to position them.</span></span><br><span class="line"><span class="comment"> * This is typically done using the child measurements</span></span><br><span class="line"><span class="comment"> * that were stored in the measure pass().&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Derived classes should not override this method.</span></span><br><span class="line"><span class="comment"> * Derived classes with children should override</span></span><br><span class="line"><span class="comment"> * onLayout. In that method, they should</span></span><br><span class="line"><span class="comment"> * call layout on each of their children.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * 为视图及其所有子体指定大小和位置</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这是布局机制的第二阶段。</span></span><br><span class="line"><span class="comment"> * （第一个是测量）。在此阶段中，每个父级调用其所有子级上的layout来定位它们。</span></span><br><span class="line"><span class="comment"> * 这通常使用存储在方法pass()中的子测量值来完成。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 派生类不应重写此方法。</span></span><br><span class="line"><span class="comment"> * 具有子级的派生类应重写onLayout。在该方法中，他们应该对每个子对象调用布局。  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLayout</span><span class="params">(<span class="type">boolean</span> changed, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="draw过程"><a class="markdownIt-Anchor" href="#draw过程"></a> <code>draw</code>过程</h2><p><code>draw</code>过程就比较简单，它的作用是将<code>View</code>绘制到屏幕上面。</p><p><code>View</code>的绘制过程遵循以下的4步：</p><ol><li>绘制背景：<code>background.draw(canvas)</code></li><li>绘制自己：<code>onDraw</code>方法</li><li>绘制children：<code>dispatchDraw</code>方法</li><li>绘制装饰：<code>onDrawScrollBars</code>方法</li></ol><p>所有的绘制过程都在<code>draw</code>方法中进行。</p><p>其中，<code>View</code>绘制过程的传递是通过<code>dispatchDraw</code>方法实现的，<code>dispatchDraw</code>方法会遍历所有的子元素并调用他们的<code>draw</code>方法，完成一轮的<code>draw</code>过程。</p><p><strong>注意</strong>：</p><ol><li>单一<code>View</code>需要重写<code>onDraw</code>方法绘制自身。</li><li><code>ViewGroup</code>需要重写<code>onDraw</code>方法绘制自身以及遍历子元素对它们进行绘制。</li></ol><h2 id="view的工作流程图"><a class="markdownIt-Anchor" href="#view的工作流程图"></a> View的工作流程图</h2><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-3d1255a5093de81fd5bdc27a300d2f0d_720w.jpg" alt="" /></p><h1 id="todo自定义view"><a class="markdownIt-Anchor" href="#todo自定义view"></a> <em>TODO</em>：自定义<code>View</code></h1>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 动画深入分析</title>
      <link href="/posts/89ece43bd0a9/"/>
      <url>/posts/89ece43bd0a9/</url>
      
        <content type="html"><![CDATA[<h1 id="动画的三个分类"><a class="markdownIt-Anchor" href="#动画的三个分类"></a> 动画的三个分类</h1><ol><li><p>View动画</p></li><li><p>帧动画</p></li><li><p>属性动画</p></li></ol><h1 id="view动画"><a class="markdownIt-Anchor" href="#view动画"></a> <code>View</code>动画</h1><h2 id="四个动画效果"><a class="markdownIt-Anchor" href="#四个动画效果"></a> 四个动画效果</h2><p><code>View</code>动画的作用对象是<code>View</code>，它有四个动画效果：平移动画、缩放动画、旋转动画、透明度动画。</p><p><code>View</code>动画的四个变化效果对应着<code>Animation</code>的四个子类：</p><ol><li>平移动画：<code>TranslateAnimation</code>，<code>XML</code>中对应的标签为<code>&lt;translate&gt;</code></li><li>缩放动画：<code>ScaleAnimation</code>，<code>XML</code>中对应的标签为<code>&lt;scale&gt;</code></li><li>旋转动画：<code>RotateAnimation</code>，<code>XML</code>中对应的标签为<code>&lt;rotate&gt;</code></li><li>透明度动画：<code>AlphaAnimation</code>，<code>XML</code>中对应的标签为<code>&lt;alpha&gt;</code></li></ol><h2 id="set标签"><a class="markdownIt-Anchor" href="#set标签"></a> <code>&lt;set&gt;</code>标签</h2><p><code>&lt;set&gt;</code>标签表示动画的集合，对应着<code>AnimationSet</code>类，其中可以包含着若干的动画，也可以有子动画。</p><p>标签有两个属性：</p><ol><li><code>android:interpolator=&quot;@anim/...&quot;</code>：选定集合所使用的插值器。</li><li><code>android:shareInterpolator=[&quot;true&quot;|&quot;false&quot;]</code>：是否让集合中的动画和集合使用相同的插值器，如果为<code>false</code>，则需要为每一个动画指定一个插值器。</li></ol><h2 id="自定义view动画"><a class="markdownIt-Anchor" href="#自定义view动画"></a> 自定义<code>View</code>动画</h2><p>通过继承抽象类<code>Animation</code>，并重写其中的<code>intialize</code>和<code>applyTransformation</code>方法。</p><p><code>intialize</code>方法做初始化工作。</p><p><code>applyTransformation</code>方法中进行相应的矩阵变换，很多时候需要采用<code>Camera</code>类来简化矩阵变换的过程。</p><h2 id="view动画的特殊使用场景"><a class="markdownIt-Anchor" href="#view动画的特殊使用场景"></a> <code>View</code>动画的特殊使用场景</h2><h3 id="layoutanimation"><a class="markdownIt-Anchor" href="#layoutanimation"></a> <code>LayoutAnimation</code></h3><p><code>LayoutAnimation</code>作用于<code>ViewGroup</code>，为<code>ViewGroup</code>指定一个动画，这样当这个<code>ViewGroup</code>的子元素出场时都会具有这个动画效果。</p><p>常常被用在<code>ListView</code>中，让其中的<code>item</code>在出场时都具有动画效果。</p><p><strong>使用步骤：</strong></p><ol><li><p>在<code>XML</code>中定义<code>LayoutAnimation</code>，标签为<code>&lt;layoutAnimation&gt;</code>。其中有两个参数：<code>android:delay</code>和<code>android:animationOrder</code>。两者的作用如下：</p><ol><li><code>android:delay</code>：使子元素的出场时间向后延迟指定的时间，单位为毫秒。</li><li><code>android:animationOrder</code>：指定子元素的出场顺序。有三种选项：<code>normal</code>顺序出场、<code>reverse</code>逆序出场、<code>random</code>随机出场。</li></ol></li><li><p>在<code>XML</code>中指定出场时的动画。</p></li><li><p>在<code>XML</code>中的<code>ViewGroup</code>部分使用<code>android:layoutAnimation</code>参数指定第1步中的<code>LayoutAnimation</code>文件，便可以为<code>ViewGroup</code>中的子元素指定出场动画。</p><p>除了可以在<code>XML</code>中指定<code>ViewGroup</code>的<code>android:layoutAnimation</code>属性，也可以在代码中通过<code>LayoutAnimationController</code>来实现。</p></li></ol><h3 id="activity的切换效果"><a class="markdownIt-Anchor" href="#activity的切换效果"></a> <code>Activity</code>的切换效果</h3><p><code>View</code>动画也可以对<code>Activity</code>的切换效果进行设置，效果如<code>Navigation</code>的<code>Fragment</code>切换效果。</p><p>这个效果是可以自定义的，我们可以通过<code>overridePendingTransition(int enterAnim, int exitAnim)</code>方法，这个方法<code>startActivity(Intent intent)</code>函数或者<code>finish()</code>函数之后被调用才能生效，否则动画效果将不起作用。</p><p>两个参数分别是设置的<strong>入场动画</strong>和<strong>退场动画</strong>的资源Id。</p><p>使用方法例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(...);</span><br><span class="line">startActivity(intent);</span><br><span class="line">overridePendingTransition(R.anim.enter_anim, R.anim.exit_anim);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finish</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.finish();</span><br><span class="line">    overridePendingTransition(R.anim.enter_anim, R.anim.exit_anim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fragment的切换效果"><a class="markdownIt-Anchor" href="#fragment的切换效果"></a> <code>Fragment</code>的切换效果</h3><p>由于<code>Fragment</code>类是在<code>API11</code>中才被新加入的，所以我们使用<code>support-v4</code>这个兼容包。</p><p>我们使用<code>FragmentTransaction</code>类中的<code>setCustomAnimation()</code>方法来添加切换动画，该处的动画<strong>需要是<code>View</code>动画</strong>，而<strong>不能是属性动画</strong>。</p><h1 id="帧动画"><a class="markdownIt-Anchor" href="#帧动画"></a> 帧动画</h1><p>通过<code>&lt;animation-list&gt;</code>标签，并在其中预设好一组图片，类似于电影的播放，按顺序依次播放。</p><p>系统中提供<code>AnimationDrawable</code>类来使用帧动画。</p><p>应避免使用尺寸较大的图片，以防止<code>OOM</code>的发生。</p><h1 id="属性动画"><a class="markdownIt-Anchor" href="#属性动画"></a> 属性动画</h1><p>属性动画<strong>可以对任意对象的属性进行动画</strong>而不仅仅是<code>View</code>。</p><p>动画的默认时间间隔为<code>300ms</code>，默认的帧率为<code>10ms/帧</code>。</p><p>达到的效果是：在一个时间间隔内完成对象从一个属性值到另一个属性值的改变。</p><p>常用的几个动画类是：<code>ValueAnimator</code>、<code>ObjectAnimator</code>和<code>AnimatorSet</code>。</p><p>其中，<code>ObjectAnimator</code>继承自<code>ValueAnimator</code>，<code>AnimatorSet</code>是动画集合，可以定义一组动画。</p><h2 id="nineoldandroids"><a class="markdownIt-Anchor" href="#nineoldandroids"></a> <code>Nineoldandroids</code></h2><p><code>API11</code>前，可以使用<code>nineoldandroids</code>开源动画库完成类似属性动画的效果，其使用的语法与<code>API11</code>后属性动画的语法完全一致，不同的是，<code>nineoldandroids</code>通过<code>View</code>动画来完成属性动画的效果。</p><h2 id="使用方式"><a class="markdownIt-Anchor" href="#使用方式"></a> 使用方式</h2><p>属性动画可以通过代码的方式完成，也可以在<code>XML</code>文件中定义。属性动画需要定义在<code>res/animator</code>中。</p><p>上述三个动画类在<code>XML</code>文件中的表示方式如下：</p><h3 id="animatorset"><a class="markdownIt-Anchor" href="#animatorset"></a> <code>AnimatorSet</code></h3><p>对应的标签为<code>&lt;set&gt;</code>。</p><p>其中的属性<code>android:ordering=[&quot;together&quot;|&quot;sequentially&quot;]</code>有两个可选值：</p><ol><li><code>together</code>表示集合中所有的子动画同时播放。</li><li><code>sequentially</code>表示集合中的子动画依次播放。</li></ol><h3 id="objectanimator"><a class="markdownIt-Anchor" href="#objectanimator"></a> <code>ObjectAnimator</code></h3><p>对应的标签为<code>&lt;objectAnimator&gt;</code>。</p><p>部分属性即解释如下：</p><ul><li><p><code>android:propertyName=&quot;string&quot;</code>：表示属性动画的作用对象的属性的名称。</p></li><li><p><code>android:startOffset=&quot;int&quot;</code>：表示动画的延迟时间，当动画开始后，需要延迟多少毫秒才会真正播放此动画。</p></li><li><p><code>android:repeatCount=&quot;int&quot;</code>：表示动画的重复次数，默认值为<code>0</code>，<code>-1</code>表示无限循环。</p></li><li><p><code>android:repearMode=[&quot;restart&quot;|&quot;reverse&quot;]</code>：表示动画的重复模式。</p><ul><li><code>&quot;restart&quot;</code>表示连续重复，即每次都重新开始播放。</li><li><code>&quot;reverse&quot;</code>表示逆向重复，即第一次正放动画，第二次倒放动画，第三次正放动画，第四次倒放动画，如此反复。</li></ul></li><li><p><code>&quot;android:valueType=[&quot;intType&quot;|&quot;floatType&quot;]</code>：表示<code>android:perpertyName</code>所指定的属性的类型，如果指定的属性为颜色，那么不需要指定该属性，系统会自动对颜色类型的属性做处理。</p></li></ul><h3 id="valueanimator"><a class="markdownIt-Anchor" href="#valueanimator"></a> <code>ValueAnimator</code></h3><p>对应的标签为<code>&lt;animator&gt;</code></p><p>其属性比<code>ObjectAnimator</code>少了一个<code>android:perpertyName</code>，其余的属性都是一样的，故不多介绍。</p><h2 id="理解插值器和估值器"><a class="markdownIt-Anchor" href="#理解插值器和估值器"></a> 理解插值器和估值器</h2><p>插值器和估值器是实现非匀速动画的重要手段。</p><h3 id="timeinterpolator"><a class="markdownIt-Anchor" href="#timeinterpolator"></a> <code>TimeInterpolator</code></h3><p>时间插值器。作用为<strong>根据时间的流逝的百分比计算当前属性值改变的百分比</strong>。</p><p>预设的有多种插值器，常见的三种如下：</p><ol><li><code>LinearInterpolator</code>——线性插值器：匀速动画</li><li><code>AccelerateDecelerateInterpolator</code>——加速减速插值器：动画两头慢中间快</li><li><code>DecelerateInterpolator</code>——减速插值器：动画越来越慢</li></ol><p>三个类都实现了<code>Interpolartor</code>接口，接口内部只有一个用来计算属性值的改变的百分比的<code>getInterpolation</code>方法需要实现。</p><h3 id="typeevaluator"><a class="markdownIt-Anchor" href="#typeevaluator"></a> <code>TypeEvaluator</code></h3><p>类型估值算法，也叫估值器。作用是<strong>根据属性值改变的百分比来计算改变后的属性值</strong>。</p><p>系统预置的有3种：</p><ol><li><code>IntEvaluator</code>：针对整形属性</li><li><code>FloatEvaluator</code>：针对浮点型属性</li><li><code>ArgbEvaluator</code>：针对Color属性</li></ol><p>三个类都实现了<code>TypeEvalator</code>接口，接口内部只有一个用来计算改变后的属性值的<code>evaluate</code>方法需要实现。</p><h3 id="计算顺序"><a class="markdownIt-Anchor" href="#计算顺序"></a> 计算顺序</h3><p>系统会根据当前的帧所在时刻与动画播放的总时间求出时间的流逝的百分比，再通过插值器计算出当前属性值改变的百分比，后用此值通过估值器计算出当前的属性改变后的确定的值是多少并通过<code>set</code>方法对属性赋值。</p><p>故属性动画要求对象的该属性有<code>set</code>方法（必须有）和<code>get</code>方法（可选）。</p><h3 id="自定义插值器和估值器"><a class="markdownIt-Anchor" href="#自定义插值器和估值器"></a> 自定义插值器和估值器</h3><p>我们可以自定义插值器和估值器，来实现自己想要的动画效果。实现方式也很简单。</p><p>因为插值器和估值器都是一个接口，且内部都只有一个方法，所以我们只需要派生一个类并实现接口就可以了，然后就可以做出千奇百怪的动画效果了。即：</p><ul><li>自定义插值器需要实现<code>Interpolator</code>或者<code>TimeInterpolator</code>接口</li><li>自定义估值器需要实现<code>TypeEvaluator</code>接口。</li></ul><h2 id="属性动画的监听器"><a class="markdownIt-Anchor" href="#属性动画的监听器"></a> 属性动画的监听器</h2><p>监听器用于监听动画的播放过程，主要有两个接口：<code>AnimatorUpdateListener</code>和<code>AnimatorListener</code>。</p><h3 id="animatorupdatelistener"><a class="markdownIt-Anchor" href="#animatorupdatelistener"></a> <code>AnimatorUpdateListener</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">AnimatorUpdateListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口会监听整个动画过程，即每播放一帧，<code>onAnimationUpdate</code>就会被调用一次。</p><h3 id="animatorlistener"><a class="markdownIt-Anchor" href="#animatorlistener"></a> <code>AnimatorListener</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">AnimatiorListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onAnimatorStart</span><span class="params">(Animator animation)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onAnimatorEnd</span><span class="params">(Animator animation)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onAnimatorCancel</span><span class="params">(Animator animation)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onAnimatorRepeat</span><span class="params">(Animator animation)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口会监听动画的开始、结束、取消以及重复播放。同时为了方便开发，系统还提供了<code>AnimatorListenerAdapter</code>这个类，它是<code>AnimatorListener</code>的适配器类，这样我们就可以有选择地实现上面的4个方法了。</p><h2 id="对任意属性做动画"><a class="markdownIt-Anchor" href="#对任意属性做动画"></a> 对任意属性做动画</h2><p>属性动画<strong>可以对任意对象的属性进行动画</strong>而不仅仅是<code>View</code>。</p><h3 id="属性动画的工作流程"><a class="markdownIt-Anchor" href="#属性动画的工作流程"></a> 属性动画的工作流程</h3><p>属性动画要求动画作用的对象提供该属性的<code>set</code>方法，属性动画根据你传递的该属性的初始值和最终值，以动画的效果多次去调用<code>set</code>方法。每次传递给<code>set</code>方法的值都不一样，确切来说是随着时间的推移，所传递的值越来越接近最终值。如果动画的时候没有传递初始值，那么还要提供<code>get</code>方法，因为系统要去获取属性的初始值。即：</p><ul><li><p>必须要有该属性的<code>set</code>方法（如果这条不满足则会无效果）</p></li><li><p>如果没有传递初始值，那么必须要有该属性的<code>get</code>方法（如果这条不满足则程序直接Crash）</p></li></ul><h3 id="动画不生效时的解决方法"><a class="markdownIt-Anchor" href="#动画不生效时的解决方法"></a> 动画不生效时的解决方法</h3><p>当有些对象的内部并没有该属性的<code>set</code>方法时，动画会无效果，那么我们有三个方法去解决这个问题：</p><ol><li><p><strong>如果有权限的话，直接给对象加上<code>get</code>和<code>set</code>方法</strong></p><p>很多时候，我们是没有权限的去添加方法的，比如我们给<code>Button</code>或者<code>TextView</code>等等，因为这些都是Android SDK内部实现的，我们无法更改。</p></li><li><p><strong>用一个类来包装原始对象，间隔为其提供<code>get</code>和<code>set</code>方法</strong></p><p>因为属性动画可以对任意对象进行动画，所以我们可以用一个类来包装原始对象，并在该类中为原始对象提供<code>get</code>和<code>set</code>方法。</p><p>然后对该类进行属性动画，即可修改原始对象的属性值。</p></li><li><p><strong>利用<code>ValueAnimator</code>，监听动画过程，自己实现属性的改变</strong></p><p>使用<code>AnimatorUpdateListener</code>接口监听整个动画过程，在其中的<code>onAnimationUpdate</code>方法中，对每一帧通过调用插值器和估值器计算当前的属性值，并通过<code>set</code>方法直接为该属性赋值，实现属性的改变。</p></li></ol><p><strong>注：自己写的<code>set</code>方法中，在对属性值进行修改后，需要调用<code>view.requestLayout()</code>方法重绘界面，否则无法显示更改后的界面。</strong></p><h2 id="属性动画的工作原理"><a class="markdownIt-Anchor" href="#属性动画的工作原理"></a> 属性动画的工作原理</h2><p><code>ObjectAnimatior#start</code>方法会调用其父类<code>ValueAnimator#start</code>方法，在父类的<code>start</code>方法中会调用<code>AnimationHandler#start</code>方法，<code>AnimationHandler</code>是一个<code>Runnable</code>，我已属性动画需要运行在有<code>Looper</code>的线程中。</p><p>中间通过一系列的方法调用，然后会使用<code>ValueAnimator#doAnimationFrame</code>方法，在此方法中又调用了<code>animationFrame</code>方法，内部又调用了<code>animateValue</code>方法，其中的<code>calculateValue</code>方法就是计算每帧动画所对应的属性的值，其中的<code>setupValue</code>方法通过反射调用对象的<code>get</code>方法，<code>setAnimationValue</code>方法通过反射的方式调用了对象的<code>set</code>方法。</p><h1 id="使用动画的注意事项"><a class="markdownIt-Anchor" href="#使用动画的注意事项"></a> 使用动画的注意事项</h1><p><strong>来源：《Android开发艺术探索》</strong></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/Android%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90.png" alt="img" /></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Animation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 Window 和 WindowManager [转载]</title>
      <link href="/posts/1c94cec68685/"/>
      <url>/posts/1c94cec68685/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自：</p><ul><li><a href="https://www.jianshu.com/p/1c4059d3865b">Android源码-深入理解Window和WindowManager - 简书</a></li></ul></blockquote><hr /><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p><code>Window</code> 表示一个窗口的概念，<code>Android</code>中所有的视图都是通过<code>Window</code>来呈现的，不管是<code>Activity</code>、<code>Dialog</code>、还是<code>Toast</code>，它们的视图实际上都是附加在<code>Window</code>上的，因此，<code>Window</code>实际是<code>View</code>的管理者。<code>Window</code>是一个非常重要的子系统，这也是我们常说的<code>WMS</code>(<code>WindowManagerService</code>)。下面我们就分析一下<code>Window</code>、<code>WMS</code>、<code>View</code>建立关联以及交互的一个基本过程。</p><h2 id="window体系相关uml类图"><a class="markdownIt-Anchor" href="#window体系相关uml类图"></a> <code>Window</code>体系相关UML类图</h2><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/%E7%90%86%E8%A7%A3Window%E5%92%8CWindowManager.jpg" alt="" /></p><ul><li><strong><code>Session</code></strong> :是一个<code>Binder</code>对象，代表一个活跃的客户端会话，在每个进程中都有一个<br /><strong><code>Session</code></strong> 与 <strong><code>WindowManager</code></strong> 交互的对象。</li><li><strong><code>WindowManagerService</code></strong> ：也是一个<code>Binder</code>对象，负责对窗口的管理。</li><li><strong><code>Window</code></strong> ：应用程序用来与窗口管理器交谈的界面。</li><li><strong><code>PhoneWindow</code></strong> ： <strong><code>Window</code></strong> 的具体实现。</li><li><strong><code>WindowManagerImpl</code></strong> ： 负责与系统窗口管理器通信、绑定到上下文、显示的操作。</li><li><strong><code>ViewRootImpl</code></strong> ：负责 <strong><code>View</code></strong> 的(测量、摆放、绘制)三大流程。</li><li><strong><code>WindowManagerGlobal</code></strong> ： <strong><code>WindowManager</code></strong> 的具体实现。</li><li><strong><code>WindowSession</code></strong> ：一个<code>Binder</code>对象，负责<code>ViewRootImpl</code>与<code>WMS</code>的<code>IPC</code>通信。</li></ul><h2 id="windowmanager"><a class="markdownIt-Anchor" href="#windowmanager"></a> <code>WindowManager</code></h2><p>与<code>WindowManager</code>联系上的第一步就是通过<code>Context</code>的<code>getSystemService</code>()方法，在分析文章<a href="https://www.jianshu.com/p/865e870186fa">Android源码中单例模式</a> 中我们知道，<strong>各种系统服务会注册到<code>ContextImpl</code>的一个<code>map</code>容器中，然后通过该服务的字符串键获取</strong>，<code>WindowManager</code>也是<code>ContextImpl</code>中注册的众多服务之一，我们看下下面这段程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//窗口服务</span></span><br><span class="line">registerService(Context.WINDOW_SERVICE, WindowManager.class,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CachedServiceFetcher</span>&lt;WindowManager&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> WindowManager <span class="title function_">createService</span><span class="params">(ContextImpl ctx)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowManagerImpl</span>(ctx);</span><br><span class="line">    &#125;&#125;);</span><br></pre></td></tr></table></figure><p>最后一行代码中，我们看到了<code>WindowManager</code>在Java层的具体实现，也就是<code>WindowManagerImpl</code>。那<code>Activity</code>或者<code>Dialog</code>又是如何获取到<code>WindowManager</code>对象呢？我们从上述代码知道，<strong><code>WindowManager</code>是注册到<code>ContextImpl</code>中的，而<code>getSystemService</code>也是<code>Context</code>定义的接口</strong>，因此，我们就从<code>Dialog</code>的构造函数和<code>Activity</code>入手，因为<code>Context</code>是传到<code>Dialog</code>构造函数的。</p><h4 id="dialog构造函数"><a class="markdownIt-Anchor" href="#dialog构造函数"></a> <code>Dialog</code>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Dialog(<span class="meta">@NonNull</span> Context context, <span class="meta">@StyleRes</span> <span class="type">int</span> themeResId, <span class="type">boolean</span> createContextThemeWrapper) &#123;</span><br><span class="line">    <span class="comment">//获取WindowManager</span></span><br><span class="line">    mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Window</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneWindow</span>(mContext);</span><br><span class="line">    mWindow = w;</span><br><span class="line">    <span class="comment">//设置Window回调</span></span><br><span class="line">    w.setCallback(<span class="built_in">this</span>);</span><br><span class="line">    w.setOnWindowDismissedCallback(<span class="built_in">this</span>);</span><br><span class="line">    w.setOnWindowSwipeDismissedCallback(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCancelable) &#123;</span><br><span class="line">            cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//设置Window的WindowManager对象</span></span><br><span class="line">    w.setWindowManager(mWindowManager, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    w.setGravity(Gravity.CENTER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="activity的attach方法"><a class="markdownIt-Anchor" href="#activity的attach方法"></a> <code>Activity</code>的<code>attach</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span><br><span class="line"><span class="params">        Instrumentation instr, IBinder token, <span class="type">int</span> ident,</span></span><br><span class="line"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span><br><span class="line"><span class="params">        CharSequence title, Activity parent, String id,</span></span><br><span class="line"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span><br><span class="line"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        Window window)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">//创建Window并设置window的监听</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> <span class="title class_">PhoneWindow</span>(<span class="built_in">this</span>, window);</span><br><span class="line">    mWindow.setWindowControllerCallback(<span class="built_in">this</span>);</span><br><span class="line">    mWindow.setCallback(<span class="built_in">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="built_in">this</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//Window设置WindowManager对象</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="literal">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**无论是<code>Dialog</code>还是<code>Activity</code>都是通过<code>Window</code>对象的<code>setWindowManager</code>方法将<code>WindowManager</code>与<code>Window</code>关联。**该函数是在<code>Window</code>中，看看实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWindowManager</span><span class="params">(WindowManager wm, IBinder appToken, String appName,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> hardwareAccelerated)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (wm == <span class="literal">null</span>) &#123;</span><br><span class="line">        wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> WindowManagerImpl <span class="title function_">createLocalWindowManager</span><span class="params">(Window parentWindow)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowManagerImpl</span>(mContext, parentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用的是<code>WindowManagerImpl</code>的<code>createLocalWindowManager</code>方法，这里与<code>ContextImpl</code>注册的<code>WindowManagerImpl</code>不同的是，这里多了一个<code>parentWindow</code>参数，也就是说，此时构建的<code>WindowManagerImpl</code>对象是与具体的<code>Window</code>关联的，而<code>ContextImpl</code>注册的并没有此参数。这是<code>Window</code>已经和<code>WindowManager</code>建立了初步联系。为什么这么说呢？我们看下<code>WindowManagerImpl</code> 的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WindowManagerImpl</span> <span class="keyword">implements</span> <span class="title class_">WindowManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">WindowManagerGlobal</span> <span class="variable">mGlobal</span> <span class="operator">=</span> WindowManagerGlobal.getInstance();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Window mParentWindow;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> &#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateViewLayout</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> &#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.updateViewLayout(view, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeView</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        mGlobal.removeView(view, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeViewImmediate</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        mGlobal.removeView(view, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Display <span class="title function_">getDefaultDisplay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mContext.getDisplay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然<code>WindowManagerImpl</code>还没有实现对视图的操作，添加、更新、删除都交给了<code>WindowManagerGlobal</code>这个类，通过以上分析对<code>VIew</code>的操作实际上是调用的是<code>WindowManagerGlobal</code>的方法，继续跟踪：</p><h2 id="windowmanagerglobal对view的操作"><a class="markdownIt-Anchor" href="#windowmanagerglobal对view的操作"></a> <code>WindowManagerGlobal</code>对<code>View</code>的操作</h2><p>看上面<code>UML</code>类图我看到<code>WindowManagerGlobal</code>有几个重要的属性，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;View&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ViewRootImpl&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;WindowManager.LayoutParams&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArraySet&lt;View&gt; mDyingViews = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;View&gt;();</span><br></pre></td></tr></table></figure><p>在上面声明中，<code>mViews</code>存储的是所有<code>Window</code>所对应的<code>View</code>，<code>mRoots</code>存储的是所有<code>Window</code>所对应的<code>ViewRootImpl</code>,<code>mParams</code>存储的是所有<code>Window</code>的布局参数，而<code>mDyingViews</code>则存储了那些整被删除的<code>View</code>对象，或者说那些已经调用<code>removeView</code>方法但是删除操作还未完成的<code>Window</code>对象，在<code>addView</code>中将<code>Window</code>一系列对象添加到容器中。</p><h3 id="windowmanagerglobal的addview过程"><a class="markdownIt-Anchor" href="#windowmanagerglobal的addview过程"></a> <code>WindowManagerGlobal</code>的<code>addView</code>过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span><br><span class="line"><span class="params">        Display display, Window parentWindow)</span> &#123;</span><br><span class="line">    ...<span class="comment">//省略参数检查代码</span></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    <span class="type">View</span> <span class="variable">panelParentView</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//创建ViewRootImpl</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">ViewRootImpl</span>(view.getContext(), display);</span><br><span class="line">        <span class="comment">//设置参数</span></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        <span class="comment">//添加到容器列表中</span></span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用ViewRootImpl的setView方法将View显示到手机上</span></span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序主要完成以下工作;</p><ul><li>构建**<code>ViewRootImpl</code>**；</li><li>将布局参数设置给**<code>View</code>**；</li><li>存储这些**<code>ViewRootImpl</code><strong>、</strong><code>View</code><strong>、</strong><code>LayoutParam</code>**到列表中；</li><li>通过**<code>ViewRootImpl</code><strong>的</strong><code>setView</code><strong>将</strong><code>View</code>**显示到窗口。</li></ul><p>很多人对<code>ViewRootImpl</code>并不陌生，从<strong>UML</strong>类图可以看出这个类里面有一个我们熟知的<code>performTraversals</code>方法，<code>ViewRootImpl</code>收到系统绘制View的消息后<code>performTraversals</code>就会调用视图树的各个节点的<code>meature</code>、<code>layout</code>、<code>draw</code>方法来绘制整颗视图树。</p><p>从上述代码分析来看，第一个重要步骤就是创建了<code>ViewRootImpl</code>对象，我们看看它的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ViewRootImpl</span><span class="params">(Context context, Display display)</span> &#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    <span class="comment">//获取Window Session，也就是也WindowManagerService建立联系</span></span><br><span class="line">    mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">    <span class="comment">//保存当前线程，，更新Ui的 线程只能是创建ViewRootImpl时的线程，</span></span><br><span class="line">    <span class="comment">//我们在开发中，如果在子线程更新UI会抛出异常，但并不是因为只有UI线程才能更新UI</span></span><br><span class="line">    <span class="comment">//而是因为ViewRootImpl是在UI线程中创建的</span></span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>ViewRootImpl</code>通过<code>WindowSession</code>实现与<code>WMS</code>的沟通<br /><code>WindowManagerGlobal.getWindowSession</code>方法内部已经通过<code>IPC</code>机制处理完毕，可直接使用</p></blockquote><h2 id="获取windowmanagerservice"><a class="markdownIt-Anchor" href="#获取windowmanagerservice"></a> 获取<code>WindowManagerService</code></h2><p>我们看下<code>ViewRootImpl</code>的构造函数中是如何获取到<code>WindowManagerService</code>的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title function_">getWindowSession</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowSession == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">InputMethodManager</span> <span class="variable">imm</span> <span class="operator">=</span> InputMethodManager.getInstance();</span><br><span class="line">                <span class="comment">//获取WindowManagerService</span></span><br><span class="line">                <span class="type">IWindowManager</span> <span class="variable">windowManager</span> <span class="operator">=</span> getWindowManagerService();</span><br><span class="line">                sWindowSession = windowManager.openSession(</span><br><span class="line">                        imm.getClient(), imm.getInputContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取WindowManagerService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IWindowManager <span class="title function_">getWindowManagerService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowManagerService == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//aidl</span></span><br><span class="line">            sWindowManagerService = IWindowManager.Stub.asInterface(</span><br><span class="line">            ServiceManager.getService(<span class="string">&quot;window&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowManagerService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>getWindowSession</code>方法中，<code>FrameWork</code>层首先通过<code>getWindowManagerService</code>方法获取<code>IWindowManager</code>对象，该函数中通过<code>ServiceManager</code>.<code>getService</code>方法获取<code>WMS</code>，并且将<code>WMS</code>转换为<code>IWindowManager</code>类型，我们先看看<code>ServiceManager</code>.<code>getService</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IBinder <span class="title function_">getService</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">service</span> <span class="operator">=</span> sCache.get(name);</span><br><span class="line">        <span class="keyword">if</span> (service != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> service;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Binder.allowBlocking(getIServiceManager().getService(name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;error in getService&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从程序中可以看到<code>ServiceManager.getService</code>返回的是一个<code>IBinder</code>对象，也就是说<code>Android Framework</code>层与<code>WMS</code>之间也是通过<code>Binder</code>机制进行通讯。获取<code>WMS</code>之后，又调用<code>IWindowManager</code>.<code>Stub</code>类的<code>asInterface</code>方法，看到这里我们就会想起<code>AIDL</code>，详情请看这篇文章<a href="https://www.jianshu.com/p/8624a5fdf03f">理解AIDL</a>  ，将获取到的<code>WMS</code>的<code>IBinder</code>对象转换成<code>WindowManager</code>对象，最后，通过<code>openSession</code>函数来与<code>WMS</code>建立一个通信会话，相当于<code>Framework</code>层与<code>native</code>层建立了一个长期合作的”办事处“，双方有什么需求都通过这个<code>Session</code>来交换信息。</p><h2 id="viewrootimpl的setview方法"><a class="markdownIt-Anchor" href="#viewrootimpl的setview方法"></a> <code>ViewRootImpl</code>的<code>setView</code>方法</h2><p>与<code>WMS</code>建立<code>Session</code>后就到了<code>ViewRootImpl</code>的<code>setView</code>方法了，该方法会向<code>WMS</code>发起显示<code>Dialog</code>或者<code>Activity</code>中的<code>DecorView</code>请求，具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Schedule the first layout -before- adding to the window</span></span><br><span class="line">            <span class="comment">// manager, to make sure we do the relayout before receiving</span></span><br><span class="line">            <span class="comment">// any other events from the system.</span></span><br><span class="line">            <span class="comment">//请求布局</span></span><br><span class="line">            requestLayout();</span><br><span class="line">            <span class="comment">//向WMS发起请求</span></span><br><span class="line">            res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                        getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                        mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setView</code>过程比较复杂，但我们只需要关注两步:</p><ul><li><strong>requestLayout</strong></li><li>向 <strong><code>WMS</code></strong> 发起显示当前 <strong><code>Window</code></strong> 请求</li></ul><h3 id="viewrootimpl的requestlayout过程"><a class="markdownIt-Anchor" href="#viewrootimpl的requestlayout过程"></a> <code>ViewRootImpl</code>的<code>requestLayout</code>过程</h3><p>我们再来看下<code>requestLayout</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestLayout</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//发起绘制</span></span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">//注意第二个参数，第一个第三个省略</span></span><br><span class="line">        mChoreographer.postCallback(...  , mTraversalRunnable , ... );</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子线程去绘制</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">TraversalRunnable</span> <span class="variable">mTraversalRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TraversalRunnable</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//绘制入口</span></span><br><span class="line">    performTraversals();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会执行<code>performTraversals</code>();方法，这是一个极其复杂有非常重要的函数。主要做了如下操作：</p><ul><li>获取 <strong><code>Surface</code></strong> 对象，同于图形绘制</li><li>测量视图树中各个 <strong><code>View</code></strong> 的大小, <strong><code>performMeasure</code></strong></li><li>摆放整个视图树,<strong><code>performLayout</code></strong></li><li>绘制整棵视图树,<strong><code>performDraw</code></strong></li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//会调用View的onMeasure</span></span><br><span class="line">    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    <span class="comment">//会调用View的onLayout</span></span><br><span class="line">    performLayout(lp, mWidth, mHeight);</span><br><span class="line">    <span class="comment">//会调用View的Draw</span></span><br><span class="line">    performDraw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>performDraw</code>方法中，<code>Framework</code>层获取到图形绘制表面的<code>Surface</code>对象，然后获取它的可绘制区域，也就是我们的<code>Canvas</code>对象，然后<code>Framework</code>在这个<code>Canvas</code>对象上绘制，具体代码如下;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performDraw</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">        draw(fullRedrawNeeded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">boolean</span> fullRedrawNeeded)</span> &#123;</span><br><span class="line">    <span class="comment">//获取绘制表面</span></span><br><span class="line">    <span class="type">Surface</span> <span class="variable">surface</span> <span class="operator">=</span> mSurface;</span><br><span class="line">    <span class="keyword">if</span> (!surface.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</span><br><span class="line">        <span class="comment">//使用GPU绘制，也就是硬件加速</span></span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="literal">null</span> &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//使用CPU绘制图形</span></span><br><span class="line">            <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>draw</code>方法中会获取到需要绘制的区域，以及判断是否使用<code>GPU</code>进行绘制。通常情况下使用的是<code>CPU</code>绘制，也就是调用的是<code>drawSoftware</code>()。我们看看该函数的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用CPU绘制</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="type">int</span> xoff, <span class="type">int</span> yoff,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> scalingRequired, Rect dirty)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw with software renderer.</span></span><br><span class="line">    <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取指定区域的获取指定区域的Canvas对象对象，用于绘制</span></span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//从DecorView开始绘制，也就是整个Window的根视图，整棵树都会绘制</span></span><br><span class="line">        mView.draw(canvas);     </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//释放Canvas锁，然后通知Surface更新这块区域，与开头照应</span></span><br><span class="line">            surface.unlockCanvasAndPost(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，上述的视图树绘制代码主要分为下面几个步骤：</p><ul><li>判断是 <strong><code>CPU</code></strong> 还是 <strong><code>GPU</code></strong> 绘制</li><li>获取绘制表面的 <strong><code>Surface</code></strong> 对象</li><li>通过 <strong><code>Surface</code></strong> 对象获取并锁住 <strong><code>Canvas</code></strong> 绘图对象</li><li>从 <strong><code>DecorView</code></strong> 开始发起整颗树的绘制流程</li><li><strong><code>Surface</code></strong> 对象解锁 <strong><code>Canvas</code></strong> ，并通知 <strong><code>SurfaceFlinger</code></strong> 更新视图</li></ul><p>了解具体View的三大流程请看文章：</p><ul><li><a href="https://www.jianshu.com/p/a790982fd20e">深入理解MeasureSpec</a></li><li><a href="https://www.jianshu.com/p/166889b91ada">View的工作流程-measure过程</a></li><li><a href="https://www.jianshu.com/p/f690435629ab">View的工作流程-layout过程</a></li><li><a href="https://www.jianshu.com/p/f5e0c8636e54">View的工作流程-Draw过程</a></li></ul><p>以上就是整个视图的绘制过程，但是此时<code>Dialog</code>或者<code>Activity</code>的<code>View</code>并不能显示在手机屏幕上，<code>WMS</code>只是负责管理手机上的<code>View</code>，也就是说<code>WMS</code>管理当前状态下那个<code>View</code>应该显示在最上层。其实<code>WMS</code>管理的并不是<code>Window</code>，而是<code>View</code>，只不过他管理的是属于某个<code>WIndow</code>下的<code>View</code>。</p><h3 id="viewrootimpl请求wms添加window过程"><a class="markdownIt-Anchor" href="#viewrootimpl请求wms添加window过程"></a> <code>ViewRootImpl</code>请求<code>WMS</code>添加<code>Window</code>过程</h3><p>我们上面只是分析了<code>ViewRootImpl</code>的<code>requestLayout</code>过程，下面再回到<code>ViewRootImpl</code>的<code>setView</code>方法，绘制完成接着会通过<code>WindowSession</code>最终来完成<code>WIndow</code>的添加过程，在下面的代码中<code>mWindowSession</code>的类型是<code>IWindowSession</code>，它也是一个<code>Binder</code>对象，真正的实现类是<code>Session</code>，也就是<code>Window</code>的添加过程是一次<code>IPC</code>调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">         getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">         mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">         mAttachInfo.mOutsets, mInputChannel);</span><br></pre></td></tr></table></figure><p>在Session内部会通过<code>WindowManagerService</code>来实现<code>Window</code>的添加，代码如下：</p><p><strong><code>frameworks\base\services\core\java\com\android\server\wm\Session.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addToDisplay</span><span class="params">(IWindow window, <span class="type">int</span> seq, WindowManager.LayoutParams attrs,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> viewVisibility, <span class="type">int</span> displayId, Rect outContentInsets, Rect outStableInsets,</span></span><br><span class="line"><span class="params">        Rect outOutsets, InputChannel outInputChannel)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mService.addWindow(<span class="built_in">this</span>, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">            outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样<code>Window</code>的添加过程就交给了<code>WindowManagerService</code>去处理了，在WMS内部会保留一个单独的<code>Session</code>。具体<code>Window</code>在<code>WMS</code>内部如何添加的，本篇不对分析，至此对于<code>View</code>的绘制以及视图如何添加到<code>Window</code>整个流程已经很明了了。关于<code>WMS</code>和<code>Surface</code>系统的细节可以参考市面上关于源码的书籍。我们看下<code>Window</code>的删除过程</p><h3 id="windowmanagerglobal的removeview过程"><a class="markdownIt-Anchor" href="#windowmanagerglobal的removeview过程"></a> WindowManagerGlobal的removeView过程</h3><p><code>Window</code>的删除过程和添加过程一样，都是先通过<code>WIndowManagerImpl</code>后，在进一步通过<code>WindowManagerGlobal</code>来实现删除，下面是<code>WindowManagerGlobal</code>的<code>removeView</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeView</span><span class="params">(View view, <span class="type">boolean</span> immediate)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> findViewLocked(view, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">View</span> <span class="variable">curView</span> <span class="operator">=</span> mRoots.get(index).getView();</span><br><span class="line">        removeViewLocked(index, immediate);</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>removeView</code> 的过程很清晰，首先通过<code>findViewLoched</code>来查找待删除<code>View</code>的索引，这个查找过程就是建立的数组遍历，然后再调用<code>removeViewLocked</code>来做进一步的删除，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeViewLocked</span><span class="params">(<span class="type">int</span> index, <span class="type">boolean</span> immediate)</span> &#123;</span><br><span class="line">    <span class="type">ViewRootImpl</span> <span class="variable">root</span> <span class="operator">=</span> mRoots.get(index);</span><br><span class="line">    <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> root.getView();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">InputMethodManager</span> <span class="variable">imm</span> <span class="operator">=</span> InputMethodManager.getInstance();</span><br><span class="line">        <span class="keyword">if</span> (imm != <span class="literal">null</span>) &#123;</span><br><span class="line">            imm.windowDismissed(mViews.get(index).getWindowToken());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">deferred</span> <span class="operator">=</span> root.die(immediate);</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">        view.assignParent(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (deferred) &#123;</span><br><span class="line">            mDyingViews.add(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>removeViewLocked</code>是通过<code>ViewRootImpl</code>来完成删除操作的。在<code>WindowManager</code>中提供了两个接口<code>removeView</code>和<code>removeViewImmediate</code>，分别表示异步删除和同步删除，一般不使用同步删除，以免发生意外的错误，这里主要说下异步删除的情况，具体的异步删除操作是由<code>ViewRootImpl</code>的<code>die</code>方法完成，在异步删除的情况下，<code>die</code>方法只是发送了一个请求删除的消息后就立刻返回了，这个时候<code>View</code>并没有完成删除操作，所以最后会将其添加到<code>WindowManagerGlobal</code>的待删除列表<code>mDyingViews</code>中，看下<code>ViewRootImpl</code>的<code>die</code>方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">die</span><span class="params">(<span class="type">boolean</span> immediate)</span> &#123;</span><br><span class="line">    <span class="comment">//同步删除  直接调用doDie，并返回</span></span><br><span class="line">    <span class="keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123;</span><br><span class="line">        doDie();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//发送handler消息</span></span><br><span class="line">    mHandler.sendEmptyMessage(MSG_DIE);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>die</code>方法内部只是做了简单的判断，如果是异步删除，那么就发送一个 <strong><code>MSG_DIE</code></strong> 的消息，<code>ViewRootImpl</code>中的<code>Handler</code>会调用<code>doDie</code>方法，如果是同步删除，就不发送消息，直接调用<code>doDie</code>方法，这就是这两种方法的区别。在<code>doDie</code>方法中会调用<code>dispatchDetachedFromWindow</code>方法，真正删除<code>View</code>的逻辑在<code>dispatchDetachedFromWindow</code>内部实现，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">void</span> <span class="title function_">doDie</span><span class="params">()</span> &#123;</span><br><span class="line">     dispatchDetachedFromWindow();</span><br><span class="line">     <span class="comment">//将WindowManagerGlobal的列表中移除保存的ViewRootImpl、View、Param</span></span><br><span class="line">     WindowManagerGlobal.getInstance().doRemoveView(<span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchDetachedFromWindow</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">//调用View的dispatchDetachedFromWindow();</span></span><br><span class="line">     mView.dispatchDetachedFromWindow();</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">//Session中的remove</span></span><br><span class="line">     mWindowSession.remove(mWindow);</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br><span class="line">     </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(IWindow window)</span> &#123;</span><br><span class="line">     <span class="comment">//WMS移除Window</span></span><br><span class="line">     mService.removeWindow(<span class="built_in">this</span>, window);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//WindowManagerGlobal中移除保存的ViewRootImpl、View、Param</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">doRemoveView</span><span class="params">(ViewRootImpl root)</span> &#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> mRoots.indexOf(root);</span><br><span class="line">         <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">             mRoots.remove(index);</span><br><span class="line">             mParams.remove(index);</span><br><span class="line">             <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> mViews.remove(index);</span><br><span class="line">             mDyingViews.remove(view);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以上代码主要做了一下事情：</p><ul><li>垃圾回收相关的工作，比如清除数据和消息，移除回调</li><li>通过 <strong><code>Session</code><strong>的</strong><code>remove</code><strong>方法删除</strong><code>Window</code></strong>，同样也是一个**<code>IPC</code><strong>过程，最终会调用</strong><code>WMS</code><strong>的</strong><code>removeView</code>** 方法</li><li>调用 <strong><code>View</code><strong>的</strong><code>dispatchDetachedFromWindow</code><strong>方法，对于</strong>View</strong>的**<code>dispatchDetachedFromWindow</code><strong>我们不陌生，当</strong><code>View</code><strong>从</strong><code>Window</code>** 中移除时，这个方法就会被调用，可以在这个方法内部做一些资源回收的工作，比如终止动画、停止线程。</li><li>调用 **<code>WindowManagerGlobal</code>**的 **<code>doRemoveView</code>**方法刷新数据，包括 <strong><code>mViews</code>、<code>mRoots</code>、<code>mParams</code>、<code>mDyingViews</code></strong>，需要将当前 <strong><code>Window</code></strong> 所关联的这三类对象从列表中删除。</li></ul><h3 id="windowmanagerglobal的updateviewlayout过程"><a class="markdownIt-Anchor" href="#windowmanagerglobal的updateviewlayout过程"></a> <code>WindowManagerGlobal</code>的<code>updateViewLayout</code>过程</h3><p><code>Window</code>的删除过程我们已经分析完了，下面看下<code>WIndow</code>的更新过程，还是要从<code>WindowManagerGlobal</code>的<code>updateViewLayout</code>说起，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> WindowManager.<span class="type">LayoutParams</span> <span class="variable">wparams</span> <span class="operator">=</span> (WindowManager.LayoutParams)params;</span><br><span class="line"></span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> findViewLocked(view, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">ViewRootImpl</span> <span class="variable">root</span> <span class="operator">=</span> mRoots.get(index);</span><br><span class="line">        mParams.remove(index);</span><br><span class="line">        mParams.add(index, wparams);</span><br><span class="line">        root.setLayoutParams(wparams, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updateViewLayout</code>方法做的事情就比较简单了，首先他需要更新View的<code>LayoutParams</code>并替换老的<code>LayoutParams</code>，接着再更新<code>ViewRootImpl</code>中的<code>LayoutParams</code>,这一步是通过<code>ViewRootImpl</code>的<code>setLayoutParams</code>方法来实现的。在<code>ViewRootImpl</code>的<code>setLayoutParams</code>中会通过<code>scheduleTraversals</code>方法来对<code>View</code>重新测量布局以及绘制这三个过程，在<code>performTraversales</code>会通过<code>WindowSession</code>来更新<code>Window</code>视图，这个过程最终是由<code>WMS</code>的<code>relayoutWindow</code>来具体实现的，同样也是一个<strong>IPC</strong>过程。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li>《Android开发艺术探索》</li><li>《Android源码设计模式》</li></ul><p>作者：Android天之骄子<br />链接：<a href="https://www.jianshu.com/p/1c4059d3865b">https://www.jianshu.com/p/1c4059d3865b</a><br />来源：简书<br />著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Drawable 解析</title>
      <link href="/posts/da60d3fddfed/"/>
      <url>/posts/da60d3fddfed/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><p><code>Drawable</code>是一个抽象类，表示的是一个图像的概念。每一个具体的<code>Drawable</code>都是其子类。</p><p><strong>优点：</strong></p><ol><li>使用简单，比自定义<code>View</code>的成本要低。</li><li>非图片类型的<code>Drawable</code>占用空间较小，可以有效的减少<code>apk</code>的大小。</li></ol><p><strong>内部宽/高：</strong></p><p><code>Drawable</code>有个参数比较重要，就是<strong>内部宽/高</strong>，通过<code>getIntrinsicWidth</code>和<code>getIntrinsicHeight</code>方法获得。</p><p>但是并不是所有的<code>Drawable</code>都有这两个参数，比如纯颜色的<code>Drawable</code>就没有内部宽/高的概念，它的两个值都为<code>-1</code>，它的大小就是<code>View</code>的大小，而图片类型的<code>Drawable</code>的内部宽/高决定了这个图片的固定大小。</p><h1 id="drawable的分类"><a class="markdownIt-Anchor" href="#drawable的分类"></a> <code>Drawable</code>的分类</h1><p><code>Drawable</code>的子类有许多，这里简单的说几个，具体的参数参考《Android开发艺术探索》Page 244。</p><ul><li><p><code>BitmapDrawable</code></p><p>表示一张图片。</p></li><li><p><code>NinePatchDrawable</code></p><p>表示一个.9格式的图片。</p></li><li><p><code>ShapeDrawable</code></p><p>表示通过颜色（纯色、渐变色）来表示的图形。</p></li><li><p><code>LayerDrawable</code></p><p><code>XML</code>中的标签为<code>&lt;layer-list&gt;</code>，表示的是一组层次化的<code>Drawable</code>集合，最终的效果是由上到下的<code>Drawable</code>的效果依次叠加。</p></li><li><p><code>StateListDrawable</code></p><p><code>XML</code>中的标签为<code>&lt;selector&gt;</code>，表示一个<code>Drawable</code>集合，每个<code>Drawable</code>对应着<code>View</code>的一种状态，系统会根据<code>View</code>的不同状态更换不同的<code>Drawable</code>。常见的使用场景为<code>Button</code>的按下与弹起。</p></li><li><p><code>LevelListDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;level-list&gt;</code>，表示的是一个<code>Drawable</code>集合，其中的每一个<code>Drawable</code>都有一个等级(<code>level</code>)的概念，系统在不同的<code>level</code>下自动更换为不同的<code>Drawable</code>。</p></li><li><p><code>TransitionDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;transition&gt;</code>，其作用是实现两个<code>Drawable</code>之间的淡入淡出效果。</p></li><li><p><code>InsetDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;inset&gt;</code>，可以将其他的<code>Drawable</code>内嵌到自己的<code>Drawable</code>中，并在四周留出一定的空间。其最终显示效果为内嵌的<code>Drawable</code>的显示范围相较于不使用<code>InsetDrawable</code>时变小。</p></li><li><p><code>ScaleDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;scale&gt;</code>，其可以根据自身<code>Drawable</code>所设置的等级(<code>level</code>)对其内部的<code>Drawable</code>实现缩放的效果。</p><p>当其<code>level</code>为<code>0</code>时，其内部的<code>Drawable</code>为不可见状态；为非<code>0</code>的值时，按照<code>XML</code>中的写入的缩放比例进行显示。</p><p><code>level</code>的值默认为<code>0</code>，需要在代码中自行赋值，<strong>系统内部约定<code>Drawable</code>的等级范围为<code>0</code>-<code>10000</code></strong>。</p></li><li><p><code>ClipDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;clip&gt;</code>，可以根据自己当前的等级(<code>level</code>)来裁剪另一个<code>Drawable</code>，裁剪的方向可以通过<code>android:clipOrientation</code>和<code>android:gravity</code>共同限制。</p><p>当其<code>level</code>的值为<code>0</code>时，表示完全裁剪，即整个<code>Drawable</code>变为不可见的状态；当<code>level</code>的值设置为<code>10000</code>时，表示不裁剪；</p><p>当<code>level</code>的值设置为<code>8000</code>时，表示裁剪了2000的区域，即裁剪<code>20%</code>。 m</p></li></ul><h1 id="自定义drawable"><a class="markdownIt-Anchor" href="#自定义drawable"></a> 自定义<code>Drawable</code></h1><p><code>Drawable</code>的使用场景很少，通常用在<code>View</code>的背景和作为<code>ImageView</code>中的图片两个场景。</p><p>由于自定义的<code>Drawable</code>无法在<code>XML</code>中使用，但是我们可以有其他轻便的方法来自定义<code>Drawable</code>。</p><p>通过<code>View</code>的工作原理可以知道，系统通过<code>Drawable</code>的<code>draw</code>方法来绘制<code>View</code>的背景，所以我们可以继承<code>Drawable</code>并重写<code>Drawable</code>的<code>draw</code>方法来实现自定义<code>Drawable</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Drawable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal 解析 [转载]</title>
      <link href="/posts/03160a3be19b/"/>
      <url>/posts/03160a3be19b/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/61652864">Android进阶知识：ThreadLocal - Android架构</a></li></ul></blockquote><hr /><h3 id="threadlocal是什么"><a class="markdownIt-Anchor" href="#threadlocal是什么"></a> <code>ThreadLocal</code>是什么？</h3><p><code>ThreadLocal</code>是一个线程内部数据存储类，通过他可以在指定的线程中存储数据。存储后，只能在指定的线程中获取到存储的数据，对其他线程来说无法获取到数据。</p><h3 id="threadlocal的使用场景"><a class="markdownIt-Anchor" href="#threadlocal的使用场景"></a> <code>ThreadLocal</code>的使用场景</h3><p>日常使用场景不多，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，可以考虑使用<code>ThreadLocal</code>。 <code>Android</code>源码的<code>Lopper</code>、<code>ActivityThread</code>以及<code>AMS</code>中都用到了<code>ThreadLocal</code>。</p><h3 id="threadlocal的使用示例"><a class="markdownIt-Anchor" href="#threadlocal的使用示例"></a> <code>ThreadLocal</code>的使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;String&gt; name = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_thread_local);</span><br><span class="line">        name.set(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        Log.d(<span class="string">&quot;ThreadLocalActivity&quot;</span>, <span class="string">&quot;Thread:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; name:&quot;</span> + name.get());</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;thread1&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                name.set(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">                Log.d(<span class="string">&quot;ThreadLocalActivity&quot;</span>, <span class="string">&quot;Thread:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; name:&quot;</span> + name.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;thread2&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                Log.d(<span class="string">&quot;ThreadLocalActivity&quot;</span>, <span class="string">&quot;Thread:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; name:&quot;</span> + name.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D/ThreadLocalActivity: Thread:main name:小明  </span><br><span class="line">D/ThreadLocalActivity: Thread:thread1 name:小红  </span><br><span class="line">D/ThreadLocalActivity: Thread:thread2 name:null</span><br></pre></td></tr></table></figure><p>可以看到虽然访问的是同一个<code>ThreadLocal</code>对象，但是获取到的值却是不一样的。</p><h3 id="threadlocal的源码阅读"><a class="markdownIt-Anchor" href="#threadlocal的源码阅读"></a> <code>ThreadLocal</code>的源码阅读</h3><p>那么为什么会造成这样的结果呢？这就需要去看看<code>ThreadLocal</code>的源码实现，这里的源码版本为<code>API28</code>。主要看它的<code>get</code>和<code>set</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set</code>方法中首先获取了当前线程对象，然后通过<code>getMap</code>方法传入当前线程<code>t</code>获取到一个<code>ThreadLocalMap</code>，接下来判断这个<code>map</code>是否为空，不为空就直接将当前<code>ThreadLocal</code>作为<code>key</code>，<code>set</code>方法中传入要保存的值最为<code>value</code>，存放到<code>map</code>中；如果<code>map</code>为空就调用<code>createMap</code>方法创建一个<code>map</code>并同样将当前<code>ThreadLocal</code>和要保存的值作为<code>key</code>和<code>value</code>加入到<code>map</code>中。<br />接下先看<code>getMap</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getMap</code>方法比较简单，就是返回从传入的当前线程对象的成员变量<code>threadLocals</code>。 接着是<code>createMap</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createMap</code>方法也很简单就是<code>new</code>了一个<code>ThreadLocalMap</code>并赋给当前线程对象<code>t</code>中的<code>threadLocals</code>。 原来这个<code>Map</code>是存放在<code>Thread</code>类中的。于是进入<code>Thread</code>类中查看。<br /><code>Thread.java</code>第188-190行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>根据这里的注释可以得知，每个线程<code>Thread</code>中都有一个<code>ThreadLocalMap</code>类型的<code>threadLocals</code>成员变量来保存数据，通过<code>ThreadLocal</code>类来进行维护。这样看来我们每次在不同线程调用<code>ThreadLocal</code>的<code>set</code>方法<code>set</code>的数据是存在不同线程的<code>ThreadLocalMap</code>中的，就像注释说的<code>ThreadLocal</code>只是起了个维护<code>ThreadLocalMap</code>的功能。想到是<code>get</code>方法同样也是到不同线程的<code>ThreadLocalMap</code>去取数据。<br /><code>get</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然，<code>get</code>方法中同样是先获取当前线程对象，然后在拿着这个对象<code>t</code>去获取到<code>t</code>中的<code>ThreadLocalMap</code>，只要<code>map</code>不等于<code>null</code>就调用<code>map.getEntry(this)</code>方法来获取数据，因为<code>ThreadLocalMap</code>里使用一个内部类<code>Entry</code>来存储数据的，所以调用<code>getEntry(this)</code>方法，传入的<code>key</code>是当前的<code>ThreadLocal</code>。这样获取到<code>Entry</code>类型数据<code>e</code>，只要<code>e</code>不为<code>null</code>，返回<code>e.value</code>即先前存储的数据。如果获取到的<code>map</code>为<code>null</code>又或者根据<code>key</code>获取<code>Entry</code>为<code>null</code>，就调用<code>setInitialValue</code>方法初始化一个<code>value</code>返回。<br /><code>setInitialValue</code>和<code>initialValue</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setInitialValue</code>方法中首先调用<code>initialValue</code>方法初始化了一个空<code>value</code>，之后的操作和<code>set</code>方法相同，将这个空的<code>value</code>加入到当前线程的<code>ThreadLocalMap</code>中去，<code>ThreadLocalMap</code>为空就创建个<code>Map</code>，最后返回这个空值。<br />至此，<code>ThreadLocal</code>的<code>get</code>、<code>set</code>方法就都看过了，也理解了<code>ThreadLocal</code>可以在多个线程中操作而互不干扰的原因。但是<code>ThreadLocal</code>还有一个要注意的地方就是<code>ThreadLocal</code>使用不当会造成内存泄漏。</p><h3 id="threadlocal内存泄漏的原因"><a class="markdownIt-Anchor" href="#threadlocal内存泄漏的原因"></a> <code>ThreadLocal</code>内存泄漏的原因</h3><p>内存泄漏的根本原因是当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，导致本该被回收的对象不能被回收而停留在堆内存中。那么<code>ThreadLocal</code>中是在哪里发生的呢？这就要看到<code>ThreadLocalMap</code>中存储数据的内部类<code>Entry</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/91ef76c6a7efce1b563edc5501a900dbb58f6512.jpeg" alt="img" /></p><p>可以看到这个<code>Entry</code>类，这里的<code>key</code>是使用了个弱引用，所以因为使用弱引用这里的<code>key</code>，<code>ThreadLocal</code>会在<code>JVM</code>下次<code>GC</code>回收时候被回收，而造成了个<code>key</code>为<code>null</code>的情况，而外部<code>ThreadLocalMap</code>是没办法通过<code>null</code> <code>key</code>来找到对应<code>value</code>的。如果当前线程一直在运行，那么线程中的<code>ThreadLocalMap</code>也就一直存在，而<code>map</code>中却存在<code>key</code>已经被回收为<code>null</code>对应的<code>Entry</code>和<code>value</code>却一直存在不会被回收，造成内存的泄漏。<br />不过，这一点设计者也考虑到了，在<code>get()</code>、<code>set()</code>、<code>remove()</code>方法调用的时候会清除掉线程<code>ThreadLocalMap</code>中所有<code>Entry</code>中<code>Key</code>为<code>null</code>的<code>Value</code>，并将整个<code>Entry</code>设置为<code>null</code>，这样在下次回收时就能将<code>Entry</code>和<code>value</code>回收。<br />这样看上去好像是因为<code>key</code>使用了弱引用才导致的内存泄漏，为了解决还特意添加了清除<code>null key</code>的功能，那么是不是不用弱引用就可以了呢？<br />很显然不是这样的。设计者使用弱引用是由原因的。</p><ul><li>如果使用强引用，那么如果在运行的线程中<code>ThreadLocal</code>对象已经被回收了但是<code>ThreadLocalMap</code>还持有<code>ThreadLocal</code>的强引用，若是没有手动删除，<code>ThreadLocal</code>不会被回收，同样导致内存泄漏。</li><li>如果使用弱引用<code>ThreadLocal</code>的对象被回收了，因为<code>ThreadLocalMap</code>持有的是<code>ThreadLocal</code>的弱引用，即使没有手动删除，<code>ThreadLocal</code>也会被回收。<code>nullkey</code>的<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set</code>、<code>get</code>、<code>remove</code>的时候会被清除。</li></ul><p>所以，由于<code>ThreadLocalMap</code>和线程<code>Thread</code>的生命周期一样长，如果没有手动删除<code>Map</code>的中的<code>key</code>，无论使用强引用还是弱引用实际上都会出现内存泄漏，但是使用弱引用可以多一层保护，<code>null key</code>在下一次<code>ThreadLocalMap</code>调用<code>set</code>、<code>get</code>、<code>remove</code>的时候就会被清除。 因此，<code>ThreadLocal</code>的内存内泄漏的真正原因并不能说是因为<code>ThreadLocalMap的key</code>使用了弱引用，而是因为<code>ThreadLocalMap</code>和线程<code>Thread</code>的生命周期一样长，没有手动删除<code>Map</code>的中的<code>key</code>才会导致内存泄漏。所以解决<code>ThreadLocal</code>的内存泄漏问题就要每次使用完<code>ThreadLocal</code>，都要记得调用它的<code>remove()</code>方法来清除。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20191223161153316.png" alt="在这里插入图片描述" style="zoom:67%;" /><p>总结一波：</p><p>（1）每个Thread维护着一个<code>ThreadLocalMap</code>的引用</p><p>（2）<code>ThreadLocalMap</code>是<code>ThreadLocal</code>的内部类，用Entry来进行存储</p><p>（3）<code>ThreadLocal</code>创建的副本是存储在自己的<code>threadLocals</code>中的，也就是自己的<code>ThreadLocalMap</code>。</p><p>（4）<code>ThreadLocalMap</code>的键值为<code>ThreadLocal</code>对象，而且可以有多个<code>threadLocal</code>变量，因此保存在<code>map</code>中</p><p>（5）在进行<code>get</code>之前，必须先<code>set</code>，否则会报空指针异常，当然也可以初始化一个，但是必须重写<code>initialValue</code>()方法。</p><p>（6）<code>ThreadLocal</code>本身并不存储值，它只是作为一个<code>key</code>来让线程从<code>ThreadLocalMap</code>获取<code>value</code>。</p><p>OK，现在从源码的角度上不知道你能理解不，对于<code>ThreadLocal</code>来说关键就是内部的<code>ThreadLocalMap</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Handler 机制解析</title>
      <link href="/posts/9435d0391c8a/"/>
      <url>/posts/9435d0391c8a/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文整理自：</p><ul><li>《Android 开发艺术探索》</li><li><a href="https://blog.csdn.net/zhanglianyu00/article/details/70842494">Handler sendMessageDelayed()/postDelayed()机制详解</a></li><li><a href="https://www.cnblogs.com/neo-java/p/6830681.html">主线程中的Looper.loop()为什么不会造成ANR</a></li><li><a href="https://blog.csdn.net/zenmela2011/article/details/123439527">Android Handler引发内存泄露★★★</a></li></ul></blockquote><hr /><h1 id="handler机制组成部分"><a class="markdownIt-Anchor" href="#handler机制组成部分"></a> <code>Handler</code>机制组成部分</h1><p><code>Hanler</code>机制中的几个重要的组成部分：</p><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td><code>ThreadLocal</code></td><td>将消息转存入其他指定的线程中</td></tr><tr><td><code>MessageQueue</code></td><td>消息队列，用于存储当前线程的转存入的消息</td></tr><tr><td><code>Looper</code></td><td>消息循环，不断的监控消息队列并从其中取出消息并处理</td></tr><tr><td><code>Handler</code></td><td>负责发送消息以及处理消息</td></tr></tbody></table><h1 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h1><ul><li><p>常用于在其他线程中处理UI操作。</p></li><li><p>在处理消息的线程中定义一个<code>Handler</code>，若该线程中没有定义<code>Looper</code>，则需要先定义<code>Looper</code>，否则会报错。其中主线程的<code>Looper</code>已在启动的时候默认加载了，所以在主线程中无需先定义<code>Looper</code>。</p></li><li><p>当在其中线程中需要进行UI操作的时候，需要在该线程中使用主线程的<code>Handler</code>变量的<code>sendMessage</code>方法或者<code>post</code>方法。</p></li></ul><h1 id="threadlocal注意"><a class="markdownIt-Anchor" href="#threadlocal注意"></a> <code>ThreadLocal</code>注意</h1><p><code>ThreadLocal</code>在<code>API21</code>以及<code>API28</code>中的代码实现方法不同：</p><ul><li>由<code>localValues</code>数组变为<code>TheadLocalMap</code>类。</li><li><code>ThreadLocalMap</code>为弱引用。</li></ul><h1 id="looper注意"><a class="markdownIt-Anchor" href="#looper注意"></a> <code>Looper</code>注意</h1><ul><li><code>Looper</code>每个线程只有一个，除主线程外的线程默认不自动加载，需要自己主动使用<code>Looper.prepare()</code>方法加载。</li><li>另外需要<code>looper.loop()</code>方法启动<code>Looper</code>。</li><li><code>Looper</code>启动时会同时加载<code>MessageQueue</code>。</li><li>推出<code>Looper</code>是可以使用<code>Looper#quit</code>或者<code>Looper#quitSafely</code>方法。</li></ul><h1 id="机制分析"><a class="markdownIt-Anchor" href="#机制分析"></a> 机制分析</h1><p>从<code>handler.sendMessage(Message msg)</code>出发，分析整个<code>Handler</code>的消息处理机制。</p><h2 id="handlersendmessage方法"><a class="markdownIt-Anchor" href="#handlersendmessage方法"></a> <code>Handler#sendMessage</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">            <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span><br><span class="line"><span class="params">                               <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    msg.target = <span class="built_in">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>sendMessage</code>方法的调用，以及中间的多个方法的调用，最终调用了<code>enqueueMessage</code>方法中的<code>queue.enqueueMessage</code>方法，将消息加入了<code>MessageQueue</code>中。</p><h2 id="messagequeueenqueuemessage方法"><a class="markdownIt-Anchor" href="#messagequeueenqueuemessage方法"></a> <code>MessageQueue#enqueueMessage</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法比较简单，采用<strong>线程安全</strong>的方式将 <code>Message</code> 插入到消息队列中，插入的新消息有三种可能成为消息队列的 <code>head</code>：</p><ol><li><code>MessageQueue</code> 为空。</li><li>参数 <code>when</code> 为 0，因为此时 <code>when</code> 已经转成绝对时间，所以只有 <code>AtFrontOfQueue</code> 系列的 <code>API</code> 才会满足这个条件。</li><li>当前的 <code>head Message</code> 执行时间在 <code>when</code> 之后，即消息队列中无需要在此 <code>Message</code> 之前执行的 <code>Message</code>。</li></ol><h2 id="looperloop方法"><a class="markdownIt-Anchor" href="#looperloop方法"></a> <code>Looper#loop</code>方法</h2><p>同时<code>Looper</code>的<code>loop</code>方法不断监控<code>MessageQueue</code>中是否有待处理的消息，如果有的话，就调用<code>MessageQueue#next</code>方法，该方法将取出单链表第一个消息并返回给<code>looper</code>。</p><blockquote><p><code>MessageQueue#next</code>方法链表中没有消息的情况下不返回任何信息，直到中间有了新的消息后才取出，否则将一直等待。</p><p><code>Looper#loop</code>方法是会堵塞进程的方法，如果没有消息的话，就会继续永不停止的观测，直到<code>MessageQueue#next</code>能够返回出消息。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (me.mInLoop) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Loop again would have the queued messages be executed&quot;</span></span><br><span class="line">               + <span class="string">&quot; before this one completed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    me.mInLoop = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">    <span class="comment">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">thresholdOverride</span> <span class="operator">=</span></span><br><span class="line">        SystemProperties.getInt(<span class="string">&quot;log.looper.&quot;</span></span><br><span class="line">                                + Process.myUid() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                                + Thread.currentThread().getName()</span><br><span class="line">                                + <span class="string">&quot;.slow&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Printer</span> <span class="variable">logging</span> <span class="operator">=</span> me.mLogging;</span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                                msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">            e.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dispatchStart</span> <span class="operator">=</span> needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> dispatchEnd;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">token</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">        token = observer.messageDispatchStarting();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">origWorkSource</span> <span class="operator">=</span> ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">            observer.messageDispatched(token, msg);</span><br><span class="line">        &#125;</span><br><span class="line">        dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">            observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">            Trace.traceEnd(traceTag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法的中间有<code>msg.target.dispatchMessage(msg);</code>这行代码。<code>msg.target</code>就是目标线程的<code>handler</code>对象，对该对象使用<code>Handler#dispatchMessage</code>方法，让其处理消息。</p><p>也就是说，取下一个消息的实际执行时间取决于上一个消息什么时候处理完。</p><h2 id="messagequeuenext方法"><a class="markdownIt-Anchor" href="#messagequeuenext方法"></a> <code>MessageQueue#next</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到 next() 实际上也有一个 for(;😉，而出口只有两个：</p><ol><li>消息队列已经退出，返回null；</li><li>找到了一个合适的消息，将其返回。<br />如果没有合适的消息，或者消息队列为空，会block或者由IdleHandler处理，不在本文问题范畴，暂不展开。</li></ol><p>主要看找到合适的消息的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">        nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Got a message.</span></span><br><span class="line">        mBlocked = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">            prevMsg.next = msg.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = msg.next;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No more messages.</span></span><br><span class="line">    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：</p><ol><li>如果在消息队列中顺序找到了一个消息 msg（前文分析过，消息队列的插入是由when顺序排列，所以如果当前的消息没有到执行时间，其后的也一定不会到），当前的系统时间小于 msg.when，那么会计算一个 timeout，以便在到执行时间时wake up；</li><li>如果当前系统时间大于或等于 msg.when，那么会返回msg给Looper.loop()。</li></ol><p>所以这个逻辑只能保证在 when 之前消息不被处理，不能够保证一定在when时被处理。很好理解：</p><ol><li>在 Loop.loop() 中是顺序处理消息，如果前一个消息处理耗时较长，完成之后已经超过了 when，消息不可能在 when 时间点被处理。</li><li>即使 when 的时间点没有被处理其他消息所占用，线程也有可能被调度失去 cpu 时间片。</li><li>在等待时间点 when 的过程中有可能入队处理时间更早的消息，会被优先处理，又增加了（1）的可能性。</li></ol><p><strong>所以由上述三点可知，Handler 提供的指定处理时间的 api 诸如 postDelayed() / postAtTime() / sendMessageDelayed() / sendMessageAtTime() ，只能保证在指定时间之前不被执行，不能保证在指定时间点被执行。</strong></p><h2 id="handlerdispatchmessage方法"><a class="markdownIt-Anchor" href="#handlerdispatchmessage方法"></a> <code>Handler#dispatchMessage</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Handle system messages here.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法一共有三个执行等级：</p><ol><li>如果传入的<code>Message</code>自己附带了UI操作的代码，那么就执行该代码。</li><li>如果<code>Message</code>没有附带的话，那么就是看<code>mCallback</code>是否存在，存在的话就执行该回调的<code>handleCallback</code>方法。</li><li>如果都不存在的话，就执行<code>handler</code>对象的<code>handleMessage</code>方法。</li></ol><h2 id="handlerhandlemessage方法"><a class="markdownIt-Anchor" href="#handlerhandlemessage方法"></a> <code>Handler#handleMessage</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，<code>Handler#handleMessage</code>方法是一个空方法，所以需要我们在创建的时候就进行重写。</p><p>之后目标线程就可以执行想要其执行的操作了。</p><hr /><h1 id="相关面试问题"><a class="markdownIt-Anchor" href="#相关面试问题"></a> 相关面试问题</h1><h2 id="主线程中的-looperloop-为什么不会造成-anr"><a class="markdownIt-Anchor" href="#主线程中的-looperloop-为什么不会造成-anr"></a> 主线程中的 Looper.loop() 为什么不会造成 ANR</h2><p>正如我们所知，在android中如果主线程中进行耗时操作会引发ANR（Application Not Responding）异常。</p><blockquote><p>造成ANR的原因一般有两种：</p><ol><li>当前的事件没有机会得到处理（即主线程正在处理前一个事件，没有及时的完成或者looper被某种原因阻塞住了）。</li><li>当前的事件正在处理，但没有及时完成。</li></ol></blockquote><p>ActivityThread的main方法主要就是做消息循环，一旦退出消息循环，那么你的应用也就退出了。</p><p>我们知道了消息循环的必要性，那为什么这个死循环不会造成ANR异常呢？</p><p>因为Android 的是由事件驱动的，looper.loop() 不断地接收事件、处理事件，每一个点击触摸或者说Activity的生命周期都是运行在 Looper.loop() 的控制之下，如果它停止了，应用也就停止了。只能是某一个消息或者说对消息的处理阻塞了 Looper.loop()，而不是 Looper.loop() 阻塞它。</p><p>也就说我们的代码其实就是在这个循环里面去执行的，当然不会阻塞了。</p><p>Activity的生命周期都是依靠主线程的Looper.loop，当收到不同Message时则采用相应措施。</p><p>如果某个消息处理时间过长，比如你在onCreate(),onResume()里面处理耗时操作，那么下一次的消息比如用户的点击事件不能处理了，整个循环就会产生卡顿，时间一长就成了ANR。</p><p>主线程Looper从消息队列读取消息，当读完所有消息时，主线程阻塞。子线程往消息队列发送消息，并且往管道文件写数据，主线程即被唤醒，从 管道文件读取数据，主线程被唤醒只是为了读取消息，当消息读取完毕，再次睡眠。因此loop的循环并不会对CPU性能有过多的消耗。</p><p><strong>总结：Looer.loop()方法可能会引起主线程的阻塞，但只要它的消息循环没有被阻塞，能一直处理事件就不会产生ANR异常。</strong></p><h2 id="sendmessage与sendmessagedelay如何保证message放入messagequeue中的顺序"><a class="markdownIt-Anchor" href="#sendmessage与sendmessagedelay如何保证message放入messagequeue中的顺序"></a> sendMessage与sendMessageDelay如何保证Message放入MessageQueue中的顺序</h2><p>通过对 MessageQueue#enqueue() 以及 MessageQueue#next() 源码的阅读，我们可以看到两个方法都是通过synchronized来保证了线程的安全性。</p><p><strong>由于多线程的性能开销，所以我们能够保证 Message 的顺序的正确性，但是无法保证这些 Message 执行的时间的精确性。</strong></p><h2 id="handler-内存泄漏问题"><a class="markdownIt-Anchor" href="#handler-内存泄漏问题"></a> Handler 内存泄漏问题</h2><blockquote><p>当不再需要某个实例后，这个对象却仍然被引用，阻止被垃圾回收(Prevent from being bargage collected)，这个情况就叫做内存泄露(Memory Leak)。</p></blockquote><p>考虑以下的代码；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Handler</span> <span class="variable">mLeakyHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="comment">// ... </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然不明显，但是这段代码可能导致内存泄露。Android Lint会提示以下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In Android, Handler classes should be static or leaks might occur.</span><br></pre></td></tr></table></figure><p><strong>它到底是如何泄露的呢？</strong></p><ol><li><p>当一个Android应用程序启动的时候，Android框架为这个程序的主线程即UI线程创建了一个Looper对象，用于处理Handler中的Message。<br />Looper实现了一个简单的消息队列messagequeue，不断循环的处理其中的message。<br />所有的应用程序框架的事件（比如Activity生命周期的调用，按钮的点击等）都被封装在这个Message对象里，然后被加入到Looper的Messagequeue，最后一个一个的处理这些Message。<br />注意，Looper在整个应用程序的生命周期中一直存在。</p></li><li><p>在主线程中实例化一个Handler对象的时候，就和它关联了主线程Looper的消息队列Messagequeue。<br />被发送到这个消息队列的Message将保持对这个Handler对象的引用，这样框架就可以在处理这个Message的时候调用Handler.handleMessage(Message)来处理消息了。<br />(也就是说，只要没有处理到这个Message，Handler就一直在队列中被引用)。</p></li><li><p>在Java中，非静态内部类和匿名内部类都隐式的保持了一个对外部类outerclass的引用。<strong>但是静态内部类不会有这个引用。</strong></p></li></ol><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/5238c9d2921c4ba6b78be289b24a7d27.jpg" style="zoom:67%;" /><p><strong>正确的解决方法：</strong></p><ol><li>静态内部类+WeakReference<Activity></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类不会持有外部类的信用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;MainActivity&gt; mActivity;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyHandler</span><span class="params">(MainActivity activity)</span> &#123;</span><br><span class="line">            mActivity = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;MainActivity&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="type">MainActivity</span> <span class="variable">activity</span> <span class="operator">=</span> mActivity.get();</span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">MyHandler</span> <span class="variable">mHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHandler</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><ol start="2"><li>静态Runnable，避免对外部类的引用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名类用static修饰后，不会再持有外部类的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">sRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState); </span><br><span class="line">        mHandler.postDelayed(sRunnable, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// Go back to the previous Activity.</span></span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类和非静态内部类的区别很微小，但是开发人员必须了解。</p><p>那么底线是什么？</p><p>当内部类可以独立于Activity的生命周期而存在的时候，应该避免使用非静态内部类，应该用静态内部类并且使用WeakReference保持对Activity的引用。</p><p><strong>深入理解</strong></p><p>像下面这样使用handler的时候，其实是将handler定义为了匿名内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mLeakyHandler=<span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123; </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<strong>匿名内部类会默认持有外部类（MainActivity）的引用</strong>。</p><p>学过handler的都知道，handler发送消息后，消息会进行入队操作，在enqueueMessage方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg.targer = <span class="built_in">this</span>;</span><br></pre></td></tr></table></figure><p>this指的就是handler，所以handler被message持有了，而message放入消息队列后，message又被MessageQueue持有了，而MessageQueue是在创建Looper的时候生成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以MessageQueue又被looper所持有。如果这个handler是主线程的handler，那么此时的looper就是指的主线程的Looper，它的声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;</span><br></pre></td></tr></table></figure><p>可以看到主线程的looper是static静态变量，而static静态变量在垃圾回收的时候是会被当做GC Root的，静态变量的生命周期与APP的生命周期、与虚拟机的生命周期是一样的，所以正是因为这个持有链的存在，导致了内存泄露。</p><p>引用链大致如下：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRstaticLooper[&quot;(static)Looper&quot;]staticLooper --&gt;|持有| MessageQueue --&gt;|持有| Message --&gt;|持有| Handler --&gt;|持有| MainActivity  </pre></div><p>所以解决 handler 内存泄露的办法就是要破坏这个持有链，比如只要 handler 不被 activity 持有就可以，所以可以把 handler 定义为static，因为 static 不会持有外部类，这样 handler 就不会持有 activity 了。</p><p><strong>怎样判断一个内部类有没有被持有外部类？</strong></p><p>比如上面的handler定义，没有加static的时候，在handleMessage方法里面可以正常使用MainActivity.this，这说明它持有了外部类。而一旦Handler加上static关键字，在handleMessage方法内部就不能再使用MainActivity.this，说明它没有持有外部类。</p><p>（为什么static变量，不会造成内存泄露？static 不会去持有外部类）</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Handler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/0242ff6238d0/"/>
      <url>/posts/0242ff6238d0/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
