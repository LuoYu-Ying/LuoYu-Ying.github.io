<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OkHttp 解析 [转载]</title>
      <link href="/2022/05/11/OkHttp-%E8%A7%A3%E6%9E%90-%E8%BD%AC%E8%BD%BD/"/>
      <url>/2022/05/11/OkHttp-%E8%A7%A3%E6%9E%90-%E8%BD%AC%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自：</p><ul><li><a href="https://blog.csdn.net/gdutxiaoxu/article/details/100545600">一步步带你读懂 Okhttp 源码</a></li><li><a href="https://www.jianshu.com/p/8522bc275390">okhttp拦截器Interceptor详解</a></li></ul></blockquote><hr /><h1 id="使用-okhttp-的基本流程"><a class="markdownIt-Anchor" href="#使用-okhttp-的基本流程"></a> 使用 OkHttp 的基本流程</h1><ol><li>创建 OkHttpClient 对象</li><li>创建 Request 对象</li><li>创建 Call 对象</li><li>同步请求调用 call.execute()；异步请求调用 call.enqueue()</li></ol><h2 id="同步执行"><a class="markdownIt-Anchor" href="#同步执行"></a> 同步执行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建OkHttpClient对象</span></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"></span><br><span class="line">String <span class="title function_">run</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="comment">//创建Request请求对象</span></span><br><span class="line">  <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建Call对象，并执行同步获取网络数据</span></span><br><span class="line">  <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">return</span> response.body().string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步执行"><a class="markdownIt-Anchor" href="#异步执行"></a> 异步执行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">runAsync</span><span class="params">(String url, Callback callback)</span> &#123;</span><br><span class="line">    <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().addInterceptor(<span class="keyword">new</span> <span class="title class_">Interceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> chain.request();</span><br><span class="line">            Request.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> request.newBuilder().addHeader(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> chain.proceed(builder.build());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).build();</span><br><span class="line">    <span class="comment">//创建Request请求对象</span></span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">            .url(url)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    client.newCall(request).enqueue(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="创建-okhttpclient-对象"><a class="markdownIt-Anchor" href="#创建-okhttpclient-对象"></a> 创建 OkHttpClient 对象</h1><p>创建 OkHttpClient 一般有两种方法，一种是直接 new OkHttpClient(),另外一种是通过 OkHttpClient.Builder()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkhttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span></span><br><span class="line">                    .Builder()</span><br><span class="line">                    .connectTimeout(<span class="number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .writeTimeout(<span class="number">10</span>,TimeUnit.SECONDS)</span><br><span class="line">                    .readTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure><p>第二种创建方式主要是通过建造者模式，来配置一些参数，比如连接超时时间，读写超时时间，超时重试次数等。这样有一个好处，可以对外屏蔽掉构建 client 的细节。</p><p>OkhttpClient 对象主要处理一些基础的配置，比如连接超时，读写超时，添加拦截器。</p><hr /><h1 id="创建-request-对象"><a class="markdownIt-Anchor" href="#创建-request-对象"></a> 创建 Request 对象</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Request</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> HttpUrl url;</span><br><span class="line">  <span class="keyword">final</span> String method;</span><br><span class="line">  <span class="keyword">final</span> Headers headers;</span><br><span class="line">  <span class="keyword">final</span> RequestBody body;</span><br><span class="line">  <span class="keyword">final</span> Object tag;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> CacheControl cacheControl; <span class="comment">// Lazily initialized.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Request 对象主要封装的是一些网络请求的信息，比如请求 url，请求方法，请求头，请求 body 等，也比较简单，这里不再展开阐述。</p><hr /><h1 id="创建-call-对象"><a class="markdownIt-Anchor" href="#创建-call-对象"></a> 创建 Call 对象</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> Call <span class="title function_">newCall</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RealCall</span>(<span class="built_in">this</span>, request, <span class="literal">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 call 对象实际是 RealCall 的实例化对象。</p><hr /><h1 id="同步请求"><a class="markdownIt-Anchor" href="#同步请求"></a> 同步请求</h1><h2 id="realcallexecute"><a class="markdownIt-Anchor" href="#realcallexecute"></a> RealCall#execute()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">    executed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  captureCallStackTrace();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行 client.dispatcher() 的 executed 方法</span></span><br><span class="line">    client.dispatcher().executed(<span class="built_in">this</span>);</span><br><span class="line">    <span class="type">Response</span> <span class="variable">result</span> <span class="operator">=</span> getResponseWithInterceptorChain();</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 最后再执行 dispatcher 的 finish 方法</span></span><br><span class="line">    client.dispatcher().finished(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 execute 方法中：</p><ol><li>首先会调用 client.dispatcher().executed(this) 加入到 runningAsyncCalls 队列当中</li><li>接着执行 getResponseWithInterceptorChain() 获取请求结果</li><li>最终再执行 client.dispatcher().finished(this) 将 realCall 从 runningAsyncCalls 队列中移除</li></ol><hr /><h1 id="拦截器-interceptor"><a class="markdownIt-Anchor" href="#拦截器-interceptor"></a> 拦截器 Interceptor</h1><h2 id="getresponsewithinterceptorchain"><a class="markdownIt-Anchor" href="#getresponsewithinterceptorchain"></a> getResponseWithInterceptorChain()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Response <span class="title function_">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">   List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   interceptors.addAll(client.interceptors());</span><br><span class="line">   interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">   interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>(client.cookieJar()));</span><br><span class="line">   interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>(client.internalCache()));</span><br><span class="line">   interceptors.add(<span class="keyword">new</span> <span class="title class_">ConnectInterceptor</span>(client));</span><br><span class="line">   <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">     interceptors.addAll(client.networkInterceptors());</span><br><span class="line">   &#125;</span><br><span class="line">   interceptors.add(<span class="keyword">new</span> <span class="title class_">CallServerInterceptor</span>(forWebSocket));</span><br><span class="line">   Interceptor.<span class="type">Chain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">       interceptors, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">   <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，首先，他会将客户端的 interceptors 添加到 List 当中，接着，再添加 okhttp 里面的 interceptor，然后构建了一个 RealInterceptorChain 对象，并将我们的 List<Interceptor> 作为成员变量，最后调用 RealInterceptorChain 的 proceed 方法。</p><p>其中，client.interceptors() 为我们自己添加的请求拦截器，通常是做一些添加统一的token之类操作。</p><p><img src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/4122684-67fcdd5d7e5f984e.jpg" alt="其余较重要的拦截器" /></p><p><strong>RetryAndFollowUpInterceptor 拦截器</strong></p><ul><li>RetryAndFollowUpInterceptor 此拦截器顾名思义就是主要负责失败重连工作，但是并不是所有的网络请求都会进行失败重连的,在此拦截器内部会进行网络请求的异常检测和响应码的判断,如果都在限制范围内,那么就可以进行失败重连。</li></ul><p><strong>CacheInterceptor 拦截器</strong></p><ul><li><p>如果当前未使用网络，并且缓存不可以使用，通过构建者模式创建一个 Response 响应,抛出504错误。</p></li><li><p>如果有缓存 但是不能使用网络 ，直接返回缓存结果。这是在进行网络请求之前所做的事情，当网络请求完成，得到下一个拦截器返回的 response 之后，判断 response 的响应码是否是 HTTP_NOT_MODIFIED = 304（未改变），是则从缓存中读取数据。</p></li></ul><h2 id="proceed"><a class="markdownIt-Anchor" href="#proceed"></a> proceed()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Response <span class="title function_">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span><br><span class="line"><span class="params">    Connection connection)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 省略无关代码</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//  生成 list 当中下一个 interceptot 的 chain 对象</span></span><br><span class="line">  <span class="type">RealInterceptorChain</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">      interceptors, streamAllocation, httpCodec, connection, index + <span class="number">1</span>, request);</span><br><span class="line">  <span class="comment">// 当前的 interceptor</span></span><br><span class="line">  <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors.get(index);</span><br><span class="line">  <span class="comment">// 当前的 intercept 处理下一个 intercept 包装的 chain 对象</span></span><br><span class="line">  <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ----</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proceed 方法也很简单，proceed方法每次从拦截器列表中取出拦截器，并调用 interceptor.intercept(next)。</p><p>熟悉 Okhttp 的应该都知道，我们在 addInterceptor 创建 Interceptor 实例，最终都会调用 chain.proceed(Request request),从而形成一种链式调用。这种便是责任链设计模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().addInterceptor(<span class="keyword">new</span> <span class="title class_">Interceptor</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> chain.request();</span><br><span class="line">        Request.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> request.newBuilder().addHeader(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(builder.build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).build();</span><br></pre></td></tr></table></figure><p>而 OkHttp 是怎样结束循环调用的，这是因为最后一个拦截器 CallServerInterceptor 并没有调用 chain.proceed(request)，所以能够结束循环调用。</p><hr /><h1 id="异步请求"><a class="markdownIt-Anchor" href="#异步请求"></a> 异步请求</h1><h2 id="dispatcher-分发器"><a class="markdownIt-Anchor" href="#dispatcher-分发器"></a> dispatcher 分发器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Dispatcher</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRequests</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRequestsPerHost</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">private</span> Runnable idleCallback;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Executes calls. Created lazily. */</span></span><br><span class="line">  <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步的请求等待队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步的正在请求的队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同步的正在请求的队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分发器 Dispatcher，里面有三个请求队列，一个是正在请求的队列，一个是等待队列，另外一个是同步的正在请求的队列，当我们执行 enqueue 方法的时候，他会判断正在请求队列数量是否超过允许的最大并发数量（默认是 64）（线程池的原理），如果超过了，会添加到等待队列里面。</p><p>execute 方法是同步执行的，每次执行会添加到同步请求队列当中，执行完毕之后会移除。</p><h2 id="realcallenqueuecallback-responsecallback"><a class="markdownIt-Anchor" href="#realcallenqueuecallback-responsecallback"></a> RealCall#enqueue(Callback responseCallback)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Callback responseCallback)</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">    executed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  captureCallStackTrace();</span><br><span class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> <span class="title class_">AsyncCall</span>(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，AsyncCall 是 Runnable 的子类，实现了 run 方法。</p><h2 id="dispatcherenqueueasynccall-call"><a class="markdownIt-Anchor" href="#dispatcherenqueueasynccall-call"></a> dispatcher().enqueue(AsyncCall call)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(AsyncCall call)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">    runningAsyncCalls.add(call);</span><br><span class="line">    executorService().execute(call);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    readyAsyncCalls.add(call);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 executorService().execute(call) 的时候，会调用 run 方法， run 方法又会调用到 execute 方法进行网络请求，请求完成之后，会调用 client.dispatcher().finished(this) 从队列里面移除。</p><hr /><p>到此， Okhttp 的主要流程已经讲完。</p><hr /><h1 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h1><ol><li><p>有一个分发器 Dispatcher，里面有三个请求队列，一个是正在请求的队列，一个是等待队列，另外一个是同步的正在请求的队列，当我们执行 enqueue 方法的时候，他会判断正在请求队列数量是否超过允许的最大并发数量（默认是 64）（线程池的原理），如果超过了，会添加到等待队列里面。<br />excute 方法是同步执行的，每次执行会添加到同步请求队列当中，执行完毕之后会移除。</p></li><li><p>设计的核心思想责任链模式，当我们需要拦截的时候，可以实现 Interceptor 接口，会按照添加的顺序执行 Chain.proceed 方法。</p></li><li><p>职责分明，OkhttpClient 对象主要处理一些基础的配置，比如连接超时，读写超时，添加拦截器。Request 主要配置请求方法，请求头等。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OkHttp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 不同数据类型 scanf 输入输出写法</title>
      <link href="/2022/05/08/cpp-%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-scanf-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%86%99%E6%B3%95/"/>
      <url>/2022/05/08/cpp-%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-scanf-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%86%99%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="signed-int"><a class="markdownIt-Anchor" href="#signed-int"></a> <code>signed int</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br></pre></td></tr></table></figure><h1 id="unsigned-int"><a class="markdownIt-Anchor" href="#unsigned-int"></a> <code>unsigned int</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u&quot;</span>, x);</span><br></pre></td></tr></table></figure><h1 id="long-long-int"><a class="markdownIt-Anchor" href="#long-long-int"></a> <code>long long int</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, x);</span><br></pre></td></tr></table></figure><h1 id="unsigned-long-long-int"><a class="markdownIt-Anchor" href="#unsigned-long-long-int"></a> <code>unsigned long long int</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%llu&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu&quot;</span>, x);</span><br></pre></td></tr></table></figure><h1 id="float"><a class="markdownIt-Anchor" href="#float"></a> <code>float</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, x);</span><br></pre></td></tr></table></figure><h1 id="double"><a class="markdownIt-Anchor" href="#double"></a> <code>double</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, x);</span><br></pre></td></tr></table></figure><h1 id="long-double"><a class="markdownIt-Anchor" href="#long-double"></a> <code>long double</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, x);</span><br></pre></td></tr></table></figure><h1 id="char"><a class="markdownIt-Anchor" href="#char"></a> <code>char</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br></pre></td></tr></table></figure><h1 id="string"><a class="markdownIt-Anchor" href="#string"></a> <code>string</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[LEN];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> XCPC </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K 短路模板</title>
      <link href="/2022/04/28/K%E7%9F%AD%E8%B7%AF%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/04/28/K%E7%9F%AD%E8%B7%AF%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="k-短路"><a class="markdownIt-Anchor" href="#k-短路"></a> K 短路</h1><h2 id="input"><a class="markdownIt-Anchor" href="#input"></a> Input</h2><p>第一行输入五个数字，依次表示为图的点数 N、边数 M、所求的第 K 段路、开始的点号 S、结尾的点号 T。<br />后面的 M 行，每行三个数字，代表一条单向边，分别为 From, To, Distance。</p><h2 id="output"><a class="markdownIt-Anchor" href="#output"></a> Output</h2><p>一个数字，表示第 K 短路的值。</p><h2 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Kth_Path &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        N nodes, M edges, find the K-th path from S to T.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> N, M, S, T, K;</span><br><span class="line">    <span class="type">int</span> dist[MAXN], cnt, fa[MAXN];</span><br><span class="line">    <span class="type">bool</span> tf[MAXN], vis[MAXN], onTree[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Path</span> &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>, head[MAXN];</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">            <span class="type">int</span> next, to, dis;</span><br><span class="line">        &#125; G[MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> dis)</span> </span>&#123;</span><br><span class="line">            G[++num] = &#123;head[from], to, dis&#125;;</span><br><span class="line">            head[from] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; E1, E2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> x, val;</span><br><span class="line"></span><br><span class="line">        Node *<span class="keyword">operator</span>=(Node a) &#123;</span><br><span class="line">            x = a.x;</span><br><span class="line">            val = a.val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Node a) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> val &gt; a.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; A;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;Node&gt; Q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">        vis[s] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = E2.head[s]; i; i = E2.G[i].next) &#123;</span><br><span class="line">            <span class="type">int</span> to = E2.G[i].to;</span><br><span class="line">            <span class="keyword">if</span> (vis[to])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (dist[to] == dist[s] + E2.G[i].dis) &#123;</span><br><span class="line">                fa[to] = s;</span><br><span class="line">                onTree[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LeftistTree</span> &#123;</span><br><span class="line">        <span class="type">int</span> num, rt[MAXN], lc[MAXN * <span class="number">20</span>], rc[MAXN * <span class="number">20</span>], dist[MAXN * <span class="number">20</span>];</span><br><span class="line">        Node v[MAXN &lt;&lt; <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">LeftistTree</span>() &#123;</span><br><span class="line">            dist[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">newNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">            v[++num] = node;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!x || !y)</span><br><span class="line">                <span class="keyword">return</span> x + y;</span><br><span class="line">            <span class="keyword">if</span> (v[x] &lt; v[y])</span><br><span class="line">                <span class="built_in">swap</span>(x, y);</span><br><span class="line">            <span class="type">int</span> p = ++num;</span><br><span class="line">            lc[p] = lc[x];</span><br><span class="line">            v[p] = v[x];</span><br><span class="line">            rc[p] = <span class="built_in">merge</span>(rc[x], y);</span><br><span class="line">            <span class="keyword">if</span> (dist[lc[p]] &lt; dist[rc[p]])</span><br><span class="line">                <span class="built_in">swap</span>(lc[p], rc[p]);</span><br><span class="line">            dist[p] = dist[rc[p]] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ST;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">        vis[s] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (fa[s])</span><br><span class="line">            ST.rt[s] = ST.<span class="built_in">merge</span>(ST.rt[s], ST.rt[fa[s]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = E2.head[s]; i; i = E2.G[i].next) &#123;</span><br><span class="line">            <span class="type">int</span> to = E2.G[i].to;</span><br><span class="line">            <span class="keyword">if</span> (fa[to] == s &amp;&amp; !vis[to])</span><br><span class="line">                <span class="built_in">dfs</span>(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; M &gt;&gt; K &gt;&gt; S &gt;&gt; T;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> x, y, z;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            E1.<span class="built_in">addEdge</span>(x, y, z);</span><br><span class="line">            E2.<span class="built_in">addEdge</span>(y, x, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  Solve the K-th path problem.</span></span><br><span class="line"><span class="comment">        if answer is -1, there is no k-th path in this graph.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Q.<span class="built_in">push</span>(&#123;T, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (Q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            A = Q.<span class="built_in">top</span>();</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (tf[A.x])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            tf[A.x] = <span class="literal">true</span>;</span><br><span class="line">            dist[A.x] = A.val;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = E2.head[A.x]; i; i = E2.G[i].next) &#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(&#123;E2.G[i].to, A.val + E2.G[i].dis&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tf[S])</span><br><span class="line">                <span class="keyword">return</span> dist[S];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(T);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tf[i])</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = E1.head[i]; j; j = E1.G[j].next)</span><br><span class="line">                    <span class="keyword">if</span> (!onTree[j])</span><br><span class="line">                        <span class="keyword">if</span> (tf[E1.G[j].to])</span><br><span class="line">                            ST.rt[i] = ST.<span class="built_in">merge</span>(</span><br><span class="line">                                ST.rt[i],</span><br><span class="line">                                ST.<span class="built_in">newNode</span>(&#123;</span><br><span class="line">                                    E1.G[j].to,</span><br><span class="line">                                    dist[E1.G[j].to] + E1.G[j].dis - dist[i]</span><br><span class="line">                                &#125;)</span><br><span class="line">                            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs2</span>(T);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ST.rt[S])</span><br><span class="line">            Q.<span class="built_in">push</span>(&#123;</span><br><span class="line">                ST.rt[S],</span><br><span class="line">                dist[S] + ST.v[ST.rt[S]].val</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            A = Q.<span class="built_in">top</span>();</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt == K - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> A.val;</span><br><span class="line">            <span class="keyword">if</span> (ST.lc[A.x])</span><br><span class="line">                Q.<span class="built_in">push</span>(&#123;</span><br><span class="line">                    ST.lc[A.x],</span><br><span class="line">                    A.val - ST.v[A.x].val + ST.v[ST.lc[A.x]].val</span><br><span class="line">                &#125;);</span><br><span class="line">            <span class="keyword">if</span> (ST.rc[A.x])</span><br><span class="line">                Q.<span class="built_in">push</span>(&#123;</span><br><span class="line">                    ST.rc[A.x],</span><br><span class="line">                    A.val - ST.v[A.x].val + ST.v[ST.rc[A.x]].val</span><br><span class="line">                &#125;);</span><br><span class="line">            <span class="type">int</span> X = ST.rt[ST.v[A.x].x];</span><br><span class="line">            <span class="keyword">if</span> (X)</span><br><span class="line">                Q.<span class="built_in">push</span>(&#123;X, A.val + ST.v[X].val&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Kth_Path::<span class="built_in">input</span>();</span><br><span class="line">    cout &lt;&lt; Kth_Path::<span class="built_in">solve</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> XCPC </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> XCPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串哈希</title>
      <link href="/2022/04/28/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"/>
      <url>/2022/04/28/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="http://www.yhzq-blog.cc/%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E6%80%BB%E7%BB%93/">字符串Hash总结 | 远航休息栈</a></li></ul></blockquote><hr /><h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> StringHash &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> BASE = <span class="number">131</span>;</span><br><span class="line">    <span class="type">char</span> s[MAXN]; <span class="comment">// cin &gt;&gt; (s + 1);</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> hash[MAXN], power[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">preHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        power[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) </span><br><span class="line">            power[i] = power[i - <span class="number">1</span>] * BASE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calcHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            hash[i] = hash[i - <span class="number">1</span>] * BASE + s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">getHash</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)hash[r] - hash[l - <span class="number">1</span>] * power[r - l + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cin &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">        len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringHash::<span class="built_in">input</span>();</span><br><span class="line">    StringHash::<span class="built_in">preHash</span>();</span><br><span class="line">    StringHash::<span class="built_in">calcHash</span>();</span><br><span class="line">    cout &lt;&lt; StringHash::<span class="built_in">getHash</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="使用字符串哈希完成其他算法"><a class="markdownIt-Anchor" href="#使用字符串哈希完成其他算法"></a> 使用字符串哈希完成其他算法</h1><h2 id="kmp"><a class="markdownIt-Anchor" href="#kmp"></a> KMP</h2><blockquote><p>给两个字符串 S1、S2，求 S2 是否是 S1 的字串，并求出 S2 在 S1 中出现的次数。</p></blockquote><p>将 S2 哈希后，在 S1 中查询所有长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mn>2</mn><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|S2|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">2</span><span class="mord">∣</span></span></span></span> 的字串，并进行哈希比较。</p><blockquote><p>复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mn>1</mn><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|S1|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。</p></blockquote><h2 id="ac-自动机"><a class="markdownIt-Anchor" href="#ac-自动机"></a> AC 自动机</h2><blockquote><p>给出 N 个单词串，和一个文章串，求每个单词串是否是文章串的子串，并求每个单词在文章中出现的次数。</p></blockquote><p>先把每一个单词串哈希，再把文章的每一个子串也进行整数，接下来只需要进行整数上的查找即可。</p><blockquote><p>复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>A</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|A|^2+|S|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|S|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span></span></span></span> 是单词串总长，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>A</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|A|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mord">∣</span></span></span></span> 是文章串长度。</p></blockquote><h2 id="后缀数组"><a class="markdownIt-Anchor" href="#后缀数组"></a> 后缀数组</h2><blockquote><p>给出两个字符串 S1、S2，求它们的最长公共子串的长度。</p></blockquote><p>将 S1 的每一个子串都哈希成一个整数，再对 S2 的每一个字串进行哈希，并判断是否与 S1 的某一个字串相同，不断维护相同的字串的长度最大值即可。</p><blockquote><p>复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mn>1</mn><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mn>2</mn><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|S1|^2+|S2|^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">2</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p></blockquote><h2 id="马拉车"><a class="markdownIt-Anchor" href="#马拉车"></a> 马拉车</h2><blockquote><p>给一个字符串 S，求 S 的最长回文子串。</p></blockquote><p>将 S 从前后两个方向分别进行字符车哈希。<br />先求子串长度位奇数的，再求偶数的。<br />枚举回文子串的中心位置，然后二分子串的长度，直到找到一个该位置的最长回文子串，不断维护长度最大值即可。</p><blockquote><p>复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|S|log|S|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。</p></blockquote><h2 id="扩展-kmp"><a class="markdownIt-Anchor" href="#扩展-kmp"></a> 扩展 KMP</h2><blockquote><p>给一个字符串 S，求 S 的每个后缀与S的最长公共前缀。</p></blockquote><p>枚举每一个后缀的起始位置，二分长度，求出每个后缀与S的最长公共前缀。</p><blockquote><p>复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|S|log|S|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> XCPC </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View 的事件体系</title>
      <link href="/2022/04/27/View-%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"/>
      <url>/2022/04/27/View-%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="view基础知识"><a class="markdownIt-Anchor" href="#view基础知识"></a> View基础知识</h1><h2 id="一-view的相关坐标和位置"><a class="markdownIt-Anchor" href="#一-view的相关坐标和位置"></a> 一、<code>View</code>的相关坐标和位置</h2><img src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/20180802114150486" alt="这里写图片描述" style="zoom: 80%;" /><p><strong>先来了解一个概念：</strong></p><p><code>view动画</code>不改变<code>view</code>的真实位置，就是肉眼看上去，<code>view</code>位置发生了变化，但是它的点击区域还是在原来的位置。</p><p>为了方便描述，下文中的的 <code>真实View</code>，表示真实位置的<code>View</code>，<code>看到的View</code>，表示肉眼看到的<code>View</code>。</p><p>属性动画和 <code>setTranslationX</code> / <code>setTranslationY</code> ，会改变显示位置和真实位置。</p><p>上图中<code>view1</code>是初始位置，通过执行<code>setTranslation</code>函数，得到的<code>view2</code>位置，其中<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>这几个值不会改变。</p><h3 id="lefttoprightbottom"><a class="markdownIt-Anchor" href="#lefttoprightbottom"></a> <code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code></h3><p><code>View</code>的位置主要由它的四个顶点的位置来决定，分别对应 View 的四个属性：<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>。对应的函数是<code>getLeft</code>，<code>getTop</code>，<code>getRight</code>，<code>getBottom</code>。</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>left</code></td><td><code>View</code> 左上顶点相对于父容器的横坐标</td></tr><tr><td><code>top</code></td><td><code>View</code> 左上顶点相对于父容器的纵坐标</td></tr><tr><td><code>right</code></td><td><code>View</code> 右下顶点相对于父容器的横坐标</td></tr><tr><td><code>bottom</code></td><td><code>View</code> 右下顶点相对于父容器的纵坐标</td></tr></tbody></table><p>这几个值表示的是View的真身位置，它表示哪里，点击区域就在哪里。和肉眼在屏幕上看到的位置可能不一样。</p><h3 id="xy"><a class="markdownIt-Anchor" href="#xy"></a> <code>X</code>，<code>Y</code></h3><p>上面说到view动画不改变<code>view</code>的真实位置（也就是不改变<code>view</code>的<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>）。</p><p>看到的view相对于真实<code>view</code>，位置发生了变化，但是它的点击区域还是在真实view的位置。</p><p>从 Android 3.0 开始，<code>View</code> 增加了 x，y，<code>translationX</code> 和 <code>translationY</code>。</p><p>x，y 是看到的<code>view</code>的左上角相对父容器的坐标，但不同于 left 和 top ，这两个坐标点的值并一定都是相等的。</p><p>真实<code>view</code> 和 看到<code>view</code>的偏差用 <code>translationX</code> 和 <code>translationY</code> <code>来表示</code>。</p><h3 id="translationxtranslationy"><a class="markdownIt-Anchor" href="#translationxtranslationy"></a> <code>translationX</code>，<code>translationY</code></h3><p>**android开发艺术探索中，关于<code>translationX</code>的讲解是错误的。**真实情况是，<code>translationX</code>是<code>真实view</code> 相对于<code>看到view</code>的 x 方向偏移量。</p><p>从上图可以得知：<code>x</code> = <code>left</code> + <code>translationX</code>。</p><h2 id="二-点击事件的xy坐标"><a class="markdownIt-Anchor" href="#二-点击事件的xy坐标"></a> 二、点击事件的<code>XY</code>坐标</h2><img src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/20180802143219331" style="zoom:50%;" /><h2 id="三-motionevent"><a class="markdownIt-Anchor" href="#三-motionevent"></a> 三、<code>MotionEvent</code></h2><p>常见的触摸动作一共有三个：</p><ol><li><code>ACTION_DOWN</code>手指按下动作</li><li><code>ACTION_MOVE</code>手指滑动动作</li><li><code>ACTION_UP</code>    手指抬起动作</li></ol><h2 id="四-gesturedetector"><a class="markdownIt-Anchor" href="#四-gesturedetector"></a> 四、<code>GestureDetector</code></h2><p>手势检测，检测用户的单击、双击、长按等操作。</p><p>通过创建<code>GestureDetector</code>对象并实现<code>OnGestureListener</code>接口（检测单击相关手势）或者<code>OnDoubleTapListener</code>接口（检测双击相关动作）。</p><h2 id="五-touchslop"><a class="markdownIt-Anchor" href="#五-touchslop"></a> 五、<code>TouchSlop</code></h2><p>不同安卓设备认为的最小的滑动距离，低于此距离，将不认为用户在滑动，开发者可自行更改，默认为<code>8dp</code>。</p><h2 id="六-velocitytracker"><a class="markdownIt-Anchor" href="#六-velocitytracker"></a> 六、<code>VelocityTracker</code></h2><p>速度检测，可以计算出用户的手势的滑动速度。</p><p>注意，在<code>VelocityTracker#computeCurrentVelocity(int time)</code>中的<code>time</code>参数是我们计算速度的单位时间，相同的速度用不同的单位时间会有不同的表示方法。</p><h2 id="七-scroller"><a class="markdownIt-Anchor" href="#七-scroller"></a> 七、<code>Scroller</code></h2><p>弹性滑动对象，由于View中的<code>scrollTo/scrollBy</code>都是瞬间完成位移的。对用户的使用体验不太友好，所以引入弹性滑动对象，使得<code>View</code>的滑动变得可视化。</p><h1 id="view的滑动"><a class="markdownIt-Anchor" href="#view的滑动"></a> View的滑动</h1><h2 id="一-scrolltoscrollby"><a class="markdownIt-Anchor" href="#一-scrolltoscrollby"></a> 一、<code>scrollTo</code>/<code>scrollBy</code></h2><p>View有专门的方法实现滑动，即<code>scrollTo()</code>, <code>scrollBy()</code>;</p><p>这两个函数只能将<code>View</code>中间的内容进行位移，但是不能改变<code>View</code>本身的位置。</p><p>可以方便的实现滑动效果并且不影响内部元素的点击事件。</p><p><code>scrollTo(int destX, int destY)</code>直接让View出现在目标位置，无中间动画。</p><p>参数变量的单位都是像素级。</p><h2 id="二-使用动画"><a class="markdownIt-Anchor" href="#二-使用动画"></a> 二、使用动画</h2><p>有两种动画的使用方法。</p><ol><li><p><code>View</code>动画</p><p>在<code>XML</code>文件里面通过改变<code>translationX</code>/<code>translationY</code>的方式来实现View的移动效果。</p></li><li><p>属性动画</p><p>在<code>Android3.0</code>版本以上，可以使用<code>ObjectAnimator</code>类来实现属性动画的效果。</p><p>在<code>Android3.0</code>以下的版本中，我们需要自己加载开源动画库<code>NineOldAndroids</code>。</p></li></ol><p>在<code>XML</code>文件中，有一个<code>andoird:fillAfter=&quot;true|false&quot;</code>的选项。</p><p>当为<code>true</code>的时候，View在动画结束后，图像将停留在目标位置上。</p><p>当为<code>false</code>的时候，View会在动画结束后，从末位置消失，重新在初位置出现。</p><p>不论是<code>true</code>还是<code>false</code>，View的点击事件的坐标还是在原先的初始位置上，并不会随着<code>View</code>的移动而移动。</p><p>在<code>Android3.0</code>以上使用属性动画可以解决这样的问题。</p><h2 id="三-改变布局参数"><a class="markdownIt-Anchor" href="#三-改变布局参数"></a> 三、改变布局参数</h2><p>通过修改<code>View</code>的<code>marginLeft</code>等等布局参数，以此来达到<code>View</code>滑动的效果。</p><h1 id="弹性滑动"><a class="markdownIt-Anchor" href="#弹性滑动"></a> 弹性滑动</h1><h2 id="一-scroller"><a class="markdownIt-Anchor" href="#一-scroller"></a> 一、<code>Scroller</code></h2><p><code>Scroller#smoothScrollTo(int destX, int destY)</code>将<strong>目标位置与初始位置的偏移值delta</strong>计算后调用<code>startScroller()</code>方法存储相关参数，并开始使用<code>invalidate()</code>方法重绘<code>View</code>。重绘<code>View</code>时的<code>draw()</code>方法会调用<code>computeScroll()</code>方法，其中又会调用<code>invalidate</code>方法重绘<code>View</code>，不断的循环。由于<code>scrollTo(int destX, int destY)</code>直接让View出现在目标位置，所以我们在<code>computeScroll()</code>方法中采取微分法的做法，即将一段长距离拆分成许多微小的距离。不断通过<code>scrollTo()</code>的直接滑动以及<code>computeScrollOffset()</code>的重新计算下一个短距离的相关参数以及<code>postInvalidate()</code>的重绘View，最终达到弹性滑动的效果。</p><p><code>computeScrollOffset()</code>方法通过计算目前已经位移的百分比来计算下一次的位移目标以及是否已经完成的滑动，不通过计时器等工具。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart TDA[startScroll]B[invalidate]C[computeScroll]D[computeScrollOffset : boolean]E[invalidate]A --&gt; B --&gt;|draw| C --&gt; D --&gt;|not finish| E --&gt;|draw| CD --&gt;|finish| F[finish]  </pre></div><h2 id="二-通过动画"><a class="markdownIt-Anchor" href="#二-通过动画"></a> 二、通过动画</h2><p>通过<code>ObjectAnimator类</code>我们可以直接的通过动画完成<code>View</code>的弹性滑动。</p><p>我们也可以通过<code>onAnimatorUpdate</code>方法还自定义自己想要的动画效果。</p><h2 id="三-使用延时策略"><a class="markdownIt-Anchor" href="#三-使用延时策略"></a> 三、使用延时策略</h2><p>可以通过<code>Thread#sleep</code>或者<code>Handler#postDelayed</code>方法来达到间隔一定的时间就改变一次微小位置变化的操作。</p><p>在此次的<code>scrollTo</code>方法执行结束后，通过<code>sleep|postDelayed</code>方法暂停一定的时间，然后重复执行<code>scrollTo</code>的方法，以此来达到弹性滑动的效果。</p><p>**注意：**无法在精准的时间内移动固定的位移，因为系统的消息调度（<code>sleep|postDelayed</code>）也是需要时间的。</p><h1 id="view的事件分发机制"><a class="markdownIt-Anchor" href="#view的事件分发机制"></a> <code>View</code>的事件分发机制</h1><h2 id="一-点击事件的传递规则"><a class="markdownIt-Anchor" href="#一-点击事件的传递规则"></a> 一、点击事件的传递规则</h2><p>点击事件分发过程，即将一系列的<code>MotionEvent</code>事件序列（由<code>ACTION_DOWN</code>开始到<code>ACTION_UP</code>结束的一连串操作）交给一个<code>View</code>执行的过程。</p><p>点击事件的分发主要由三个重要方法构成：<code>dispatchTouchEvent</code>, <code>onInterceptTouchEvent</code>,<code>onTouchEvent</code>。</p><p>三个方法的执行顺序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123; <span class="comment">// 对当前的View进行事件的分发</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">consume</span> <span class="operator">=</span> <span class="literal">false</span>;                        <span class="comment">// 判断是否可以消耗这个事件序列</span></span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123;                <span class="comment">// 如果准备拦截此次事件序列</span></span><br><span class="line">        consume = onTouchEvent(ev);                 <span class="comment">// 事件由该View执行，并返回结果</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        consume = child.dispatchTouchEvent(ev);     <span class="comment">// 若不准备拦截，则交给子View进行判断</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consume;                                 <span class="comment">// 向父级返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中执行事件序列的不同方法中同样由优先顺序：<code>onTouchListener &gt; onTouchEvent &gt; onClickListener</code></p><p>当点击事件发生后，它的传递过程会遵循以下的顺序：<code>Activity　-&gt; Window -&gt; DecorView -&gt; View -&gt; ...</code>、</p><p>同时，如果子级发现无法执行这个事件的时候，那么它的父容器的<code>onTouchEvent</code>就会重新调用，直到<code>Activity</code>。</p><p>其中，<code>ViewGroup</code>默认不拦截任何事件，<code>View</code>没有<code>onInterceptTouchEvent</code>方法。</p><h2 id="二-事件分发解析"><a class="markdownIt-Anchor" href="#二-事件分发解析"></a> 二、事件分发解析</h2><h3 id="activity对点击事件的分发"><a class="markdownIt-Anchor" href="#activity对点击事件的分发"></a> <code>Activity</code>对点击事件的分发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">diapatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) <span class="comment">// 如果Window可以处理点击事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev); <span class="comment">// 返回Activity自己处理点击事件的结果(true|false)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="window对点击事件的分发"><a class="markdownIt-Anchor" href="#window对点击事件的分发"></a> <code>Window</code>对点击事件的分发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> PhoneWindow#superDispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">  <span class="keyword">return</span> mDecor.superDispatchTouchEvent(ev); <span class="comment">// 返回DecorView的处理结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顶级view对点击事件的分发"><a class="markdownIt-Anchor" href="#顶级view对点击事件的分发"></a> <code>顶级View</code>对点击事件的分发</h3><p>由此开始，将执行（一）所讲述的事件传递规则。其主要的部分是<code>ViewGroup</code>的事件传递。<code>顶级View</code>一般来说都是<code>ViewGroup</code>。</p><h4 id="判断当前viewgroup是否拦截点击事件"><a class="markdownIt-Anchor" href="#判断当前viewgroup是否拦截点击事件"></a> 判断当前<code>ViewGroup</code>是否拦截点击事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION.DOWN || mFirstTouchTarget != NULL) &#123; <span class="comment">// 意思见下方文字</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>; <span class="comment">// 判断是否允许屏蔽自身的onInterceptTouchEvent方法</span></span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123; <span class="comment">// 如果允许拦截</span></span><br><span class="line">        intercepted = onInterceptTouchEvent(ev); <span class="comment">// 询问能否拦截并赋值</span></span><br><span class="line">        ev.setAction(action); <span class="comment">// 防止事件被修改，存储事件的动作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="literal">false</span>; <span class="comment">// 由于不允许拦截，则直接赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    intercepted = <span class="literal">true</span>; <span class="comment">// 由于直接拦截，则不用询问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的几个变量的作用：</p><ol><li><p>当事件由<code>ViewGroup</code>的子元素处理成功时，<code>mFirstTouchTarget</code>就会被赋值并指向子元素，此时的<code>mFirstTouchTarget != NULL</code>。</p></li><li><p><code>FLAG_DISALLOW_INTERCEPT</code>一旦被设置后，那么当前的<code>ViewGroup</code>就无法拦截<code>ACTION_MOVE</code>以及<code>ACTION_UP</code>。</p><p>由于事件为<code>ACTION_DOWN</code>的时候，<code>ViewGroup</code>会重置<code>FLAG_DISALLOW_INTERCEPT</code>，所以每次事件为<code>ACTION_DOWN</code>的时候，都会执行一次<code>onInterceptTouchEvent</code>方法。</p></li></ol><p>第3行的判断语句的意思为：</p><ol><li>如果当前的事件为<code>ACTION_DOWN</code>时，作为一个点击事件的开始，需要向子元素传递，返回<code>true</code>。允许向子元素传递。</li><li>如果当前的事件为<code>ACTION_MOVE</code>或者<code>ACTION_UP</code>的时候，如果<code>ACTION_DOWN</code>已经被子元素处理了（<code>mFirstTouchTarget != NULL</code>），那么由于一系列的点击事件都要有同一个<code>View</code>处理，则不能在此拦截，故返回<code>true</code>。反之，如果<code>mFirstTouchTarget == NULL</code>，则代表<code>ACTION_DOWN</code>是由<code>ViewGroup</code>自身处理的，则不能向下传递，返回<code>false</code>。</li></ol><h4 id="viewgroup在action_down到来时的重置操作"><a class="markdownIt-Anchor" href="#viewgroup在action_down到来时的重置操作"></a> <code>ViewGroup</code>在<code>ACTION_DOWN</code>到来时的重置操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle an initial down.</span></span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">cancelAndClearTouchTargets(ev);</span><br><span class="line">resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>resetTouchState</code>方法中会对<code>FLAG_DISALLOW_INTERCEPT</code>进行重置。</p><p>因此<code>子View</code>的<code>requestDisallowInterceptTouchEvent</code>方法并不能影响<code>ViewGroup</code>对<code>ACTION_DOWN</code>事件的处理。</p><h4 id="viewgroup不拦截事件时对点击事件的分发"><a class="markdownIt-Anchor" href="#viewgroup不拦截事件时对点击事件的分发"></a> <code>ViewGroup</code>不拦截事件时，对点击事件的分发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> View[] = mChildren;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 获取每一个子View的位置以及其他信息</span></span><br><span class="line">    <span class="keyword">if</span> (子元素正在播放动画 || 点击事件的坐标落在当前子元素的区域外) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    newTouchTarget = getTouchTarget(child); </span><br><span class="line">    <span class="keyword">if</span> (newTouchTarget != NULL) &#123; <span class="comment">// 如果不是NULL的话(该child之前初始化过)，就直接向其中添加元素就行了</span></span><br><span class="line">        newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果 newTouchTarget == NULL, 那么就初始化 + 添加第一个可用子元素</span></span><br><span class="line">    resetCancelNextUpFlag(child);</span><br><span class="line">    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="literal">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">        alreadyDispatchedToNewTouchTarget = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不断的遍历当前<code>ViewGroup</code>的所有子元素，如果<strong>子元素不在播放动画</strong>以及<strong>点击事件的坐标落在当前子元素的区域内</strong>，那么这个子元素就是一个可以传递的。</p><blockquote><p>由<code>TouchTarget</code>源码可知：</p><p><code>TouchTarget</code>保存了响应触摸事件的子<code>view</code>和该子view上的触摸点ID集合，表示一个触摸事件派发目标。通过<code>next</code>成员可以看出，它支持作为一个链表节点储存。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TouchTarget</span> &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The touched child view.</span></span><br><span class="line">    <span class="comment">// 被触摸的子元素</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> View child;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The combined bit mask of pointer ids for all pointers captured by the target.</span></span><br><span class="line">    <span class="comment">// 指针 id 的位的掩码组合，用于目标捕获的所有指针</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> pointerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The next target in the target list.</span></span><br><span class="line">    <span class="comment">// 目标列表中的下一个目标</span></span><br><span class="line">    <span class="keyword">public</span> TouchTarget next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「分则能成」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/dehang0/article/details/104317611</span></span><br></pre></td></tr></table></figure></blockquote><p>如果是第一个可传递元素，那么就会进入初始化部分，其中的<code>dispatchTransformedTouchEvent</code>方法实际上就是调用的子元素的<code>dispatchTouchEvent</code>方法。在该方法中有如下的一段内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == NULL) &#123;</span><br><span class="line">    handled = <span class="built_in">super</span>.dispatchTouchTarget(event);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handled = child.dispatchTouchTarget(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于前面的代码中<code>dispatchTransformedTouchEvent</code>方法的第三个参数为<code>child</code>，所以会执行子元素的<code>dispatchTouchEvent</code>方法，点击事件交由子元素处理，从而完成了一轮事件的分发。</p><p>当子元素的<code>dispatchTouchEvent</code>方法返回<code>true</code>时，<code>dispatchTransformedTouchEvent</code>方法同样也会返回<code>true</code>，接着便执行<code>if语句</code>的代码块部分了。如果<code>dispatchTouchEvent</code>方法返回<code>false</code>的话，<code>ViewGroup</code>就会把事件向后遍历，寻找新的可传递的子元素。在<code>if语句</code>的代码块中，<code>mFirstTouchTarget</code>会被赋值同时跳出<code>for循环</code>。</p><p>其中<code>mFirstTouchTarget</code>的赋值由<code>addTouchTarget</code>方法完成，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TouchTarget <span class="title function_">addTouchTarget</span><span class="params">(View child, <span class="type">int</span> pointerIdBits)</span> &#123;</span><br><span class="line">    <span class="type">TouchTarget</span> <span class="variable">target</span> <span class="operator">=</span> TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">   target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很容易的看出，<code>mFirstTouchTarget</code>其实是一个<strong>单链表结构</strong>，<code>mFirstTouchTarget</code>是否被赋值，将直接影响<code>ViewGroup</code>对事件的拦截策略。</p><h4 id="viewgroup中没有合适的子元素"><a class="markdownIt-Anchor" href="#viewgroup中没有合适的子元素"></a> <code>ViewGroup</code>中没有合适的子元素</h4><p>有两种情况，<code>ViewGroup</code>中会没有合适的子元素可以传递：</p><ol><li><code>ViewGroup</code>没有子元素</li><li>子元素处理了点击事件，但是<code>dispatchTouchEvent</code>方法返回了<code>false</code>，这一般是因为子元素在<code>onTouchEvent</code>中返回了<code>false</code>。</li></ol><p>在这两种情况中，<code>ViewGroup</code>都会自己处理点击事件。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == NULL) &#123;</span><br><span class="line"><span class="comment">// 没有可分发子元素，就当其是一个普通的View</span></span><br><span class="line">handled = dispatchTransformedTouchEvent(ev, canceled, <span class="literal">null</span>, TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，代码中的<code>dispatchTransformedTouchEvent</code>方法的第三个参数将其设置为<code>null</code>，此时它就会调用<code>super.dispatchTouchTarget</code>方法了。</p><h3 id="view对点击事件的处理过程"><a class="markdownIt-Anchor" href="#view对点击事件的处理过程"></a> <code>View</code>对点击事件的处理过程</h3><p>这里的<code>View</code>不包含<code>ViewGroup</code>，因为没有子元素，所以不用向下分发事件，只能自己处理事件。</p><p>先看它的<code>dispatchTouchEvent</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="type">ListenerInfo</span> <span class="variable">li</span> <span class="operator">=</span> mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="literal">null</span> &amp;&amp; .li.mOnTouchListener.onTouch(<span class="built_in">this</span>, event) &amp;&amp; ...) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可以看出，<code>View</code>对点击事件的处理流程中，首先会判断有没有设置<code>onTouchListener</code>，如果有且其中的<code>onTouch</code>方法返回<code>true</code>，则<code>onTouchEvent</code>方法就不会被调用。</p><p>从其他的代码中也可以得出的一些结论：</p><ol><li>如果<code>View</code>的<code>CLICKABLE</code>以及<code>LONG_CLICKABLE</code>中有一个为<code>true</code>，不论<code>View</code>是否为<code>DISABLE</code>，都会消耗事件（也就是即使<code>View</code>看起来没有任何的反应，但是也消耗了点击事件）。</li><li><code>View</code>的<code>LONG_CLICKABLE</code>默认为<code>false</code>，而<code>CLICKABLE</code>是否为<code>false</code>与其<code>View</code>有关，如<code>button</code>的默认为<code>true</code>、<code>textview</code>的默认为<code>false</code>。</li><li>当<code>ACTION_UP</code>事件发生时，会触发<code>performClick</code>方法，如果<code>View</code>设置了<code>OnClickListener</code>，那么<code>performClick</code>方法就会调用它的<code>onClick</code>方法。（即<code>onClick</code>的触发前提时<code>View</code>是可点击的，且收到了<code>DOWN</code>和<code>UP</code>的点击事件。）</li><li><code>setOnClickListener</code>方法会自动将<code>CLICKABLE</code>设置为<code>true</code>，<code>setOnLongClickListener</code>方法会自动将<code>LONG_CLICKABLE</code>设置为<code>true</code>。</li></ol><h1 id="view的滑动冲突"><a class="markdownIt-Anchor" href="#view的滑动冲突"></a> <code>View</code>的滑动冲突</h1><p>总共会出现三种滑动冲突的情况：</p><ol><li><code>内部View</code>与<code>外部View</code>的滑动方向相反。</li><li><code>内部View</code>与<code>外部View</code>的滑动方向相同。</li><li>前两种情况的嵌套。</li></ol><p>三种情况的处理思路：</p><ol><li>通过手势滑动的角度判断滑动的方向。</li><li>通过当前处于的不同的页面状态来判断应该滑动的<code>View</code>。</li><li>通过前两种的综合使用。</li></ol><h2 id="滑动冲突的解决方式"><a class="markdownIt-Anchor" href="#滑动冲突的解决方式"></a> 滑动冲突的解决方式</h2><h3 id="外部拦截法"><a class="markdownIt-Anchor" href="#外部拦截法"></a> 外部拦截法</h3><p>通过重写<strong>父容器的</strong><code>onInterceptTouchEvent</code>方法，所有的事件都先经过父容器的筛选，对其中父容器需要的事件进行拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">intercepted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) event.getX();</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) event.getY();</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN : &#123;</span><br><span class="line">            intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE : &#123;</span><br><span class="line">            <span class="keyword">if</span> (父容器需要当前的点击事件)</span><br><span class="line">                intercepted = <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">                intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP : &#123;</span><br><span class="line">            intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastXIntercept = x;</span><br><span class="line">    mLastYIntercept = y;</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部拦截法"><a class="markdownIt-Anchor" href="#内部拦截法"></a> 内部拦截法</h3><p>父元素拦截除<code>ACTION_DOWN</code>以外的其他事件，当事件到达子元素后，由子元素判断是否需要这些事件，不需要的事件将重新交由父容器来处理。这种方法和Android的事件分发机制不一致，需要配合<code>requestDisallowInterceptTouchEvent</code>方法才能正常的工作。</p><p>相关阅读链接：<a href="https://www.jianshu.com/p/fe3d109eb27e">Android TouchEvent之requestDisallowInterceptTouchEvent - 简书 (jianshu.com)</a></p><h4 id="子元素的dispatchtouchevent方法"><a class="markdownIt-Anchor" href="#子元素的dispatchtouchevent方法"></a> 子元素的<code>dispatchTouchEvent</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) event.getX();</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) event.getY();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN : &#123;</span><br><span class="line">            parent.requestDisallowInterceptTouchEvent(<span class="literal">true</span>); <span class="comment">// 此子View的所有父ViewGroup会跳过onInterceptTouchEvent回调</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE : &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">deltaX</span> <span class="operator">=</span> x - mLastX;</span><br><span class="line">            <span class="type">int</span> <span class="variable">deltaY</span> <span class="operator">=</span> y - mLastY;</span><br><span class="line">            <span class="keyword">if</span> (父容器需要当前的点击事件) &#123;</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP : &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> : </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastX = x;</span><br><span class="line">    mLastY = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="父容器的onintercepttouchevent方法"><a class="markdownIt-Anchor" href="#父容器的onintercepttouchevent方法"></a> 父容器的<code>onInterceptTouchEvent</code>方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCPC 读入操作模板</title>
      <link href="/2022/04/23/XCPC-%E8%AF%BB%E5%85%A5%E6%93%8D%E4%BD%9C%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/04/23/XCPC-%E8%AF%BB%E5%85%A5%E6%93%8D%E4%BD%9C%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考：</p><ul><li><a href="https://www.cnblogs.com/AlvinZH/p/6798023.html">C/C++如何整行读入字符串？</a></li></ul></blockquote><hr /><h1 id="快速读入-int"><a class="markdownIt-Anchor" href="#快速读入-int"></a> 快速读入 <code>int</code></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        f = (ch == <span class="number">45</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> f ? (~x + <span class="number">1</span>) : x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="字符串整行读入"><a class="markdownIt-Anchor" href="#字符串整行读入"></a> 字符串整行读入</h1><h2 id="char-整行读入"><a class="markdownIt-Anchor" href="#char-整行读入"></a> char[] 整行读入</h2><h3 id="使用-gets-推荐"><a class="markdownIt-Anchor" href="#使用-gets-推荐"></a> 使用 <code>gets()</code> [推荐]</h3><p>读入不需要考虑换行符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[LEN];</span><br><span class="line"><span class="built_in">gets</span>(s);</span><br></pre></td></tr></table></figure><h3 id="使用-scanf"><a class="markdownIt-Anchor" href="#使用-scanf"></a> 使用 <code>scanf()</code></h3><p>无法读入末尾的换行符，需使用 <code>getchar()</code> 额外读取以便下一行的正常读入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[LEN];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%[^\m]&quot;</span>, s);</span><br><span class="line"><span class="built_in">getchar</span>(); <span class="comment">// 读取末尾换行符</span></span><br></pre></td></tr></table></figure><h3 id="使用-getchar"><a class="markdownIt-Anchor" href="#使用-getchar"></a> 使用 <code>getchar()</code></h3><p>无法读入末尾的换行符，需使用 <code>getchar()</code> 额外读取以便下一行的正常读入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[LEN];</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((s[len] = <span class="built_in">getchar</span>()) != <span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line">  len++;</span><br><span class="line"><span class="built_in">getchar</span>(); <span class="comment">// 读取末尾换行符</span></span><br></pre></td></tr></table></figure><h3 id="使用-getline"><a class="markdownIt-Anchor" href="#使用-getline"></a> 使用 <code>getline()</code></h3><p>读入不需要考虑换行符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[LEN];</span><br><span class="line">cin.<span class="built_in">getline</span>(s, LEN);</span><br></pre></td></tr></table></figure><h2 id="string-整行读入"><a class="markdownIt-Anchor" href="#string-整行读入"></a> string 整行读入</h2><h3 id="使用-getline-2"><a class="markdownIt-Anchor" href="#使用-getline-2"></a> 使用 <code>getline()</code></h3><p>读入不需要考虑换行符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin, s);</span><br></pre></td></tr></table></figure><hr />]]></content>
      
      
      <categories>
          
          <category> XCPC </category>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XCPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 面试问题整理</title>
      <link href="/2022/04/23/Java-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/"/>
      <url>/2022/04/23/Java-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>本文持续更新中~</strong></p></blockquote><hr /><h2 id="java-并发包提供了哪些并发工具"><a class="markdownIt-Anchor" href="#java-并发包提供了哪些并发工具"></a> Java 并发包提供了哪些并发工具？</h2><blockquote><p>解答</p></blockquote><p>同步结构</p><ul><li><p>Semaphore 信号量</p><ul><li>通过一个<strong>计数器</strong>来实现并发。</li><li>其基本逻辑 基于 <strong>acquire/release</strong> ,并没有什么太复杂的同步逻辑。</li></ul></li><li><p>CatchDownLatch</p><ul><li>可以做到等待不同的线程处理完各自的数据。</li></ul></li></ul><p>线程安全的容器</p><ul><li>ConcurrentHashMap</li><li>ConcurrentSkipListMap</li></ul><p><em>TODO : 参考极客时间 整理相关内容</em><br />…</p><h2 id="接口和抽象类的区别"><a class="markdownIt-Anchor" href="#接口和抽象类的区别"></a> 接口和抽象类的区别</h2><blockquote><p>解答</p></blockquote><p>接口和抽象类是 Java 面向对象设计的两个基础机制。</p><p>接口是对行为的抽象：</p><ol><li>是抽象方法的集合。</li><li>不能实例化。</li><li>不能包含任何非常量成员，任何变量都是 <code>public static final</code> 。</li><li>没有非静态方法的实现，要么是抽象方法，要么是静态方法。但是在 Java 8 以后，接口也是可以进行方法实现的。</li><li>使用 implements 来实现接口。</li></ol><p>抽象类是不能实例化的类：</p><ol><li>用 abstract 关键字写实 class ，其目的是代码重用。</li><li>除了不能实例化，形式上和一般的 Java 类并没有太大的区别。</li><li>使用 extends 继承抽象类。</li></ol><h2 id="string-stringbuffer-stringbuilder-有什么区别"><a class="markdownIt-Anchor" href="#string-stringbuffer-stringbuilder-有什么区别"></a> String, StringBuffer, StringBuilder 有什么区别</h2><blockquote><p>解答</p></blockquote><p>String：</p><ol><li>是 Java 非常基础和重要的类。</li><li>是典型的 Immutable 类，被声明为 final class，所有的属性也都是 final。</li><li>由于不可变性，所有对字符串的操作，都会产生新的 String 对象。</li></ol><p>StringBuffer：</p><ol><li>是一个 <strong>线程安全</strong> 的可修改字符序列，保证了线程的安全，但是同时带来了额外的性能开销。</li><li>提供了 append 以及 add 等方法，可以将一个字符串添加到已有序列的末尾。</li><li><strong>线程安全</strong> 本质上是对各种能够修改数据的方法都添加了 synchronized 关键字。</li></ol><p>StringBuilder：</p><ol><li>在 StringBuffer 的基础上，去除了线程安全的部分，减少了性能的开销。</li></ol><p>StringBuffer 和 StringBuilder 的底层在 JDK 9 以前使用了 char 数组，在 JDK 9 以后使用了 byte 数组，二者都继承了 AbstractStringBuilder。<br />二者初始化的时候，默认的长度都是16，可以自行更改。扩容会进行额外的开销，因为需要抛弃原有数组、建立新的数组，然后再进行数组的复制。</p><h2 id="对比-vector-arraylist-linkedlist"><a class="markdownIt-Anchor" href="#对比-vector-arraylist-linkedlist"></a> 对比 Vector, ArrayList, LinkedList</h2><blockquote><p>解答</p></blockquote><p>三者都是实现了 List 接口的类，即都是有序集合。</p><ul><li><p>Vector 是 Java 早期提供的 线程安全的动态数组，扩容时会提高当前的1倍容量。</p></li><li><p>ArrayList 并不是线程安全的，所以它有更好的性能。</p><ul><li>第一次插入元素时创建的大小为10。</li><li>与 Vector 不同，ArrayList 的扩容量为之前的50%，如果扩充了50%的容量后仍达不到需求值，则直接扩充为需求值。扩容函数为 <code>ensureCapacityInternal</code>。</li></ul></li><li><p>LinkedList 为双向链表，也不是线程安全的。</p><ul><li>如果访问的位置在链表的后半部分，则直接从末尾开始遍历访问。将时间复杂度变为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span></span></span></span>。</li></ul></li></ul><h2 id="set-的实现"><a class="markdownIt-Anchor" href="#set-的实现"></a> Set 的实现</h2><blockquote><p>解答</p></blockquote><p>在源码中，Set 的实现是通过对应的 Map 实现的。<br />如 HashSet 的内部是一个 HashMap，TreeSet 的内部是一个 TreeMap。</p><h2 id="java-中的不同的-sort-的实现原理"><a class="markdownIt-Anchor" href="#java-中的不同的-sort-的实现原理"></a> Java 中的不同的 sort() 的实现原理</h2><blockquote><p>解答</p></blockquote><p>Java 中的不同 sort() 的原理是不一样的。</p><ul><li>对于原始数据类型，目前使用的是所谓的双轴快速排序，早期使用的是传统的快速排序。</li><li>对视对象数据类型，目前使用的是 TimSort，思想上是一种归并和二分插入排序结合的优化排序算法。</li></ul><h2 id="一个线程调用了两次-start-会发生什么"><a class="markdownIt-Anchor" href="#一个线程调用了两次-start-会发生什么"></a> 一个线程调用了两次 start() 会发生什么</h2><blockquote><p>解答</p></blockquote><p>Java 线程不允许启动两次，第二次启动的时候必定会抛出 <code>IllegalThreadStateException</code>。</p><h2 id="线程生命周期的不同状态"><a class="markdownIt-Anchor" href="#线程生命周期的不同状态"></a> 线程生命周期的不同状态</h2><blockquote><p>解答</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%%&#123;init : &#123;&#x27;theme&#x27; : &#x27;default&#x27;, &quot;flowchart&quot; : &#123;&#x27;curve&#x27; : &#x27;&#x27;&#125;&#125;&#125;%%</span><br><span class="line"></span><br><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">Runnable --&gt; Waiting --&gt; Runnable</span><br><span class="line">New --&gt; Runnable --&gt; Terminated</span><br><span class="line">Runnable --&gt; Blocked --&gt; Runnable</span><br></pre></td></tr></table></figure><h2 id="jvm-的类加载机制"><a class="markdownIt-Anchor" href="#jvm-的类加载机制"></a> JVM 的类加载机制</h2><blockquote><p>解答</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">subgraph 链接</span><br><span class="line">    验证 ==&gt; 准备 ==&gt; 解析</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">加载 ==&gt; 验证</span><br><span class="line">解析 ==&gt; 初始化</span><br></pre></td></tr></table></figure><h2 id="jvm-的类加载器"><a class="markdownIt-Anchor" href="#jvm-的类加载器"></a> JVM 的类加载器</h2><blockquote><p>解答</p></blockquote><p><strong>Java 8 及以前</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">应用类加载器 --&gt;|父-类加载器| 扩展类加载器 --&gt;|父-类加载器| 启动类加载器</span><br></pre></td></tr></table></figure><p><strong>Java 9 以后</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">平台类加载器 --&gt;|父-类加载器|启动类加载器 </span><br></pre></td></tr></table></figure><h2 id="如何保证集合的线程安全"><a class="markdownIt-Anchor" href="#如何保证集合的线程安全"></a> 如何保证集合的线程安全？</h2><blockquote><p>解答</p></blockquote><ul><li>HashTable：在 HashMap 的 put、get 方法前面加上 synchronized 来保证线程的安全。性能大大的降低。</li><li>ConcurrentHashMap：依赖于 Java 内存模型，提升了性能，经过多次的优化。</li></ul><h2 id="concurrenthashmap-解析"><a class="markdownIt-Anchor" href="#concurrenthashmap-解析"></a> ConcurrentHashMap 解析</h2><blockquote><p>解答</p></blockquote><p>Java 9 以前使用：分段锁 + HashEntry + 红黑树</p><p>Java 9 以后使用：CAS + HashEntry + 红黑树</p><h2 id="treemap-解析"><a class="markdownIt-Anchor" href="#treemap-解析"></a> TreeMap 解析</h2><blockquote><p>解答</p></blockquote><p>TreeMap 可以在保证 Key 的大小有序的情况下，存储键值对。<br />TreeMap 通过使用<strong>红黑树</strong>来进行存储和取出，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log \space n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mspace"> </span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。<br />TreeMap 通过<strong>中序遍历</strong>的方式来有序的输出键值对（以 Key 的大小排序）。</p><h2 id="hashmap-解析"><a class="markdownIt-Anchor" href="#hashmap-解析"></a> HashMap 解析</h2><blockquote><p>解答</p></blockquote><p><em>TODO ：完成相关内容</em></p><h2 id="泛型-解析"><a class="markdownIt-Anchor" href="#泛型-解析"></a> 泛型 解析</h2><blockquote><p>解答</p></blockquote><ol><li><p>泛型的好处</p><ul><li>类型安全，类型的错误在编译器就可以被捕获到了，提高了程序的可靠性。</li><li>消除了代码的许多的强制类型转换，增强了代码的可读性。</li><li>为较大的优化带来了可能性。</li></ul></li><li><p>在静态方法、静态初始化块或者静态变量的生命和初始化中不允许使用类型形参。由于系统中并不会真正生成泛型类，所以 instanceof 运算符后不能使用泛型类。</p></li></ol><h2 id="java-反射"><a class="markdownIt-Anchor" href="#java-反射"></a> Java 反射</h2><blockquote><p>解答</p></blockquote><p><strong>Java 反射机制的应用场景</strong></p><ol><li>与注解相结合的框架，如 Retrofit</li><li>单纯的反射机制应用框架，如 EventBus</li><li>动态生成类框架，如 Gson</li><li>逆向代码，例如反编译</li></ol><h2 id="java-注释annotation"><a class="markdownIt-Anchor" href="#java-注释annotation"></a> Java 注释（Annotation）</h2><blockquote><p>解答</p></blockquote><p>理解注释的作用，就要先理解 Java 中元数据的概念。</p><ol><li><p>元数据概念<br />元数据是关于数据的数据。在编程语言的上下文中，元数据是添加到程序元素如方法、字段、类和包上的额为撒信息。对数据进行说明描述的数据。</p></li><li><p>元数据的作用（注释的作用）</p></li><li><p>编写代码</p></li><li><p>代码分析</p></li><li><p>编译检查</p></li></ol><p><strong>注意：<strong>注释 Annotation 就是 Java 平台的元数据，该机制允许在 Java 代码中添加自定义注释，并允许通过</strong>反射（Reflection）</strong>，以编程的方式访问元数据注释。如果想以编程的方法获得注释，可以通过反射的 <code>getAnnotation</code> 方法获得。</p><ol start="3"><li>内建注解<br />Java 内部提供了多种内建的注解，常用的四个注解如下：</li><li>@Override</li><li>@Deprecated</li><li>@SuppressWarnings</li><li>@FunctinoalInterface</li></ol><h2 id="java-nio"><a class="markdownIt-Anchor" href="#java-nio"></a> Java NIO</h2><blockquote><p>解答</p></blockquote><p>Java NIO(New IO) 是一个新式的 IO 标准，与之前的普通 IO 的工作方式不同：</p><ul><li>标准的 IO 基于字节流和字符流进行操作的。</li><li>NIO 是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入通道也类似。</li></ul><p>Java NIO 由以下几个核心部分组成：</p><ul><li>Buffer</li><li>Channel</li><li>Selector</li></ul><h2 id="java-异常解析"><a class="markdownIt-Anchor" href="#java-异常解析"></a> Java 异常解析</h2><blockquote><p>解答</p></blockquote><ol><li>异常的种类</li></ol><p><em>TODO：补充类图</em></p><ol start="2"><li>finally 和 return 的执行顺序<ol><li>finally 语句在 return 语句执行之后，return 返回之前执行。</li><li>finally 里的修改语句可能会影响 try 和 catch 中 return 已经确定的返回值。</li><li>如果 finally 里面也有 return 语句，则会覆盖 try 和 catch 中的 return 语句直接返回。</li></ol></li></ol><h2 id="java-transient-解析"><a class="markdownIt-Anchor" href="#java-transient-解析"></a> Java transient 解析</h2><blockquote><p>解答</p></blockquote><ol><li>transient 关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被 transient 关键字修饰的。变量如果是用户自定义的类变量，则该类是要实现 Serializable 接口。</li><li>一旦变量被 transient 修饰，变量将不是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li><li>静态变量不管是否被 transient 修饰，都无法被序列化。</li></ol><p>**注意：**被 transient 修饰的变量也是可以被序列化的<br />Java 中，对象的序列化可以通过实现两个接口实现：</p><ul><li>若实现的是 Serializable 接口，则所有的序列化都将会自动进行，被 transient 修饰的变量将不会被序列化。</li><li>若实现的是 Externalizable 接口，则任何东西都需要自己在 writeExternal 方法中自己手动指定需要序列化的变量。任何变量都可以序列化，与变量是否被 transient 修饰无关。</li></ul><h2 id="java-aqs-解析"><a class="markdownIt-Anchor" href="#java-aqs-解析"></a> Java AQS 解析</h2><blockquote><p>解答</p></blockquote><p>参考 <a href="https://blog.csdn.net/mulinsen77/article/details/84583716">AQS详解（面试）</a></p><h2 id="java-中-和-equals-的区别"><a class="markdownIt-Anchor" href="#java-中-和-equals-的区别"></a> Java 中 == 和 equals() 的区别</h2><blockquote><p>解答</p></blockquote><ol><li><code>equals()</code> 是方法，而 <code>==</code> 是操作符。</li><li>对于基本类型，只能使用 <code>==</code>。因为基本类型没有 equals 方法。</li><li><code>==</code> 比较的是两者的值。</li><li>equals 方法是 Object 类中的方法。除了子类重写 equals 方法，完成特定的比较内容，如 String 类中 equals 方法是比较两个字符串的值，默认的 equals 方法是比较两者在内存中的存放地址。</li></ol><h2 id="生产者-消费者模式"><a class="markdownIt-Anchor" href="#生产者-消费者模式"></a> 生产者-消费者模式</h2><blockquote><p>解答</p></blockquote><p>生产者-消费者模式的核心是一个<strong>任务队列</strong>，生产者线程生产任务，并将任务添加到任务队列中。而消费者线程中任务队列中获取任务并执行。</p><p><strong>优点：</strong></p><ul><li>生产者和消费者没有任何的依赖关系，他们彼此之间的通信只能通过任务队列，所以 <strong>生产者-消费者模式是一个不错的解耦方案</strong>。</li><li>生产者-消费者模式支持异步，并且能够通过任务队列平衡生产者和消费者的速度差异。</li></ul><h2 id="java-死锁"><a class="markdownIt-Anchor" href="#java-死锁"></a> Java 死锁</h2><blockquote><p>解答</p></blockquote><ol><li><p>死锁的定义：<br />一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。</p></li><li><p>出现死锁的四个条件：</p><ol><li>占有且等待</li><li>不可抢占</li><li>循环等待</li><li>互斥</li></ol></li><li><p>对应的解决方法：</p><ol><li>通过一个管理对象统一申请所有资源。</li><li>通过并发包的 Lock。</li><li>对资源进行有序获取。</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 垃圾回收机制</title>
      <link href="/2022/04/22/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2022/04/22/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="http://www.cyc2018.xyz/">Java 虚拟机 | CS-Notes</a></li><li><a href="https://blog.csdn.net/jisuanjiguoba/article/details/80156781">JVM中的新生代和老年代（Eden空间、两个Survior空间）</a></li></ul></blockquote><h1 id="判断一个对象是否可以被回收"><a class="markdownIt-Anchor" href="#判断一个对象是否可以被回收"></a> 判断一个对象是否可以被回收</h1><ol><li>引用计数算法</li><li>可达性分析算法</li><li>方法区的回收</li><li><code>finalize</code> 方法</li></ol><h1 id="四种引用类型"><a class="markdownIt-Anchor" href="#四种引用类型"></a> 四种引用类型</h1><ol><li>强引用：被强引用关联的对象不会被回收。</li><li>软引用：被软引用关联的对象只会在内存不足的情况下被回收。</li><li>弱引用：被弱引用关联的对象一定会被回收，只能活到下次垃圾回收之前。</li><li>虚引用：无法通过虚引用创建一个对象。为对象创建虚引用的唯一目的是在这个对象在被回收时受到一个系统消息。</li></ol><h1 id="垃圾收集算法"><a class="markdownIt-Anchor" href="#垃圾收集算法"></a> 垃圾收集算法</h1><ol><li>标记-清除算法</li><li>标记-复制算法</li><li>复制算法</li><li>分代收集算法</li></ol><h1 id="垃圾收集器"><a class="markdownIt-Anchor" href="#垃圾收集器"></a> 垃圾收集器</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><ol><li>并行与串行</li><li>单线程与多线程</li></ol><h2 id="主要收集器"><a class="markdownIt-Anchor" href="#主要收集器"></a> 主要收集器</h2><h3 id="cms"><a class="markdownIt-Anchor" href="#cms"></a> CMS</h3><p>CMS(Concurrent Mark Sweep，即多线程的标记-清除算法)</p><p>分为四个流程：</p><ol><li><strong>初始标记</strong><br />仅仅是标记一下 GC Roots 能直接关联到的对象。</li><li><strong>并发标记</strong><br />进行 GC Roots Trancing 的过程。</li><li><strong>重新标记</strong><br />为了修正并发标记期间因用户线程继续运作而产生变动的那一部分的对象的标记记录。</li><li><strong>并发清除</strong><br />对标记出来的垃圾进行清除操作。</li></ol><p>具有以下的缺点：</p><ol><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不高。</li><li>标记-清除算法导致的空间碎片，导致往往出现老年代空间剩余，但是无法找到一段连续的空间用于存储对象，而不得不进行一次 Full GC。</li><li>无法处理浮动垃圾，而导致 Concurrent Mode Failure。其中，浮动垃圾是指在并发清除阶段由于用户线程的继续运行而产生的垃圾。</li></ol><h3 id="g1garbage-first"><a class="markdownIt-Anchor" href="#g1garbage-first"></a> G1(Garbage First)</h3><p>G1 垃圾收集器是面向客户端的垃圾收集器，在多 CPU 和大内存场景下有很好的性能。</p><p>堆被分为新生代和老年代，G1 收集器可以直接对新生代和老年代一起回收。</p><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p>G1 收集器的运作大致分为以下的几个部分：</p><ol><li><strong>初始标记</strong><br />仅仅是标记 GC Roots 能够直接标记到的对象。</li><li><strong>并发标记</strong><br />进行 GC Roots Tracing 的过程。</li><li><strong>最终标记</strong><br />为了修正在并发标记期间因用户线程继续运行而导致标记产生变动的那一部分标记记录。</li><li><strong>筛选回收</strong><br />首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ol><p>具备如下的特点：</p><ol><li>空间整合：从整体上看是基于标记-整理算法实现的收集器，从局部上看是居于复制算法实现的，这就意味着运行期间不会产生内存空闲碎片。</li><li>可预测的停顿：能够有用户自定义 GC收集器 上所消耗的时间。</li></ol><h2 id="其他收集器"><a class="markdownIt-Anchor" href="#其他收集器"></a> 其他收集器</h2><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph TBsubgraph 新生代     Serial    ParNew    Parallel_Scaevnge[Parallel Scavenge]endsubgraph 老年代    Serial_Old[Serial Old]    Parallel_Old[Parallel Old]end  </pre></div><h1 id="内存分配和回收策略"><a class="markdownIt-Anchor" href="#内存分配和回收策略"></a> 内存分配和回收策略</h1><h2 id="回收策略"><a class="markdownIt-Anchor" href="#回收策略"></a> 回收策略</h2><ol><li>Minor GC</li><li>Full GC</li></ol><h2 id="内存分配策略"><a class="markdownIt-Anchor" href="#内存分配策略"></a> 内存分配策略</h2><ol><li><p>一个人（对象）出来（new 出来）后会在Eden Space（伊甸园）无忧无虑的生活，直到GC到来打破了他们平静的生活。GC会逐一问清楚每个对象的情况，有没有钱（此对象的引用）啊，因为GC想赚钱呀，有钱的才可以敲诈嘛。然后富人就会进入Survivor Space（幸存者区），穷人的就直接kill掉。</p></li><li><p>并不是进入Survivor Space（幸存者区）后就保证人身是安全的，但至少可以活段时间。GC会定期（可以自定义）会对这些人进行敲诈，亿万富翁每次都给钱，GC很满意，就让其进入了Genured Gen(养老区)。万元户经不住几次敲诈就没钱了，GC看没有啥价值啦，就直接kill掉了。</p></li><li><p>进入到养老区的人基本就可以保证人身安全啦，但是亿万富豪有的也会挥霍成穷光蛋，只要钱没了，GC还是kill掉。</p></li></ol><p><strong>总结</strong></p><ol><li>对象优先在 Eden 分配</li><li>大对象直接进入老年代</li><li>长期存活的对象直接进入老年代</li><li>动态对象年龄判定</li><li>空间分配担保</li></ol><h2 id="full-gc-出触发条件"><a class="markdownIt-Anchor" href="#full-gc-出触发条件"></a> Full GC 出触发条件</h2><ol><li>调用 <code>System.gc()</code></li><li>老年代空间不足</li><li>空间分配担保失败</li><li>JDK 1.8 之前的永久代空间不足</li><li>Concurrent Mode Failure</li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改 mermaid 流程图的样式以及连线的曲直</title>
      <link href="/2022/04/21/%E4%BF%AE%E6%94%B9-mermaid-%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E6%A0%B7%E5%BC%8F%E4%BB%A5%E5%8F%8A%E8%BF%9E%E7%BA%BF%E7%9A%84%E6%9B%B2%E7%9B%B4/"/>
      <url>/2022/04/21/%E4%BF%AE%E6%94%B9-mermaid-%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%9A%84%E6%A0%B7%E5%BC%8F%E4%BB%A5%E5%8F%8A%E8%BF%9E%E7%BA%BF%E7%9A%84%E6%9B%B2%E7%9B%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="修改前的效果"><a class="markdownIt-Anchor" href="#修改前的效果"></a> 修改前的效果</h1><p>若直接使用 mermaid 完成一个流程图的画，我们可能会在默认样式的图中得到众多曲线。</p><p>比如通过下方的代码便可以得到对应的流程图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A --&gt; B --&gt; C &amp; D &amp; E &amp; F</span><br><span class="line">C --&gt; A</span><br><span class="line">D --&gt; C</span><br></pre></td></tr></table></figure><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph TBA --&gt; B --&gt; C &amp; D &amp; E &amp; FC --&gt; AD --&gt; C  </pre></div><hr /><h1 id="修改方法及解析"><a class="markdownIt-Anchor" href="#修改方法及解析"></a> 修改方法及解析</h1><p>在 <code>graph</code> 所在行的前面加上如下设定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%%&#123;init : &#123;&#x27;theme&#x27; : &#x27;default&#x27;, &quot;flowchart&quot; : &#123;&#x27;curve&#x27; : &#x27;linear&#x27;&#125; &#125; &#125;%%</span><br></pre></td></tr></table></figure><h2 id="样式部分"><a class="markdownIt-Anchor" href="#样式部分"></a> 样式部分</h2><p><code>init</code> 代码块中的前半部分 <code>'theme' : 'default'</code> 是流程图的样式，官方提供四种样式：</p><ul><li><code>default</code></li><li><code>forest</code></li><li><code>neutral</code></li><li><code>dark</code></li></ul><p>我们可以只为流程图设置样式，那么只需要在 <code>graph</code> 前面添加如下部分即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%%&#123;init: &#123;&#x27;theme&#x27;: &#x27;neutral&#x27; &#125; &#125;%%</span><br></pre></td></tr></table></figure><h2 id="连线曲直部分解析"><a class="markdownIt-Anchor" href="#连线曲直部分解析"></a> 连线曲直部分解析</h2><p>后半部分 <code>&quot;flowchart&quot; : &#123;'curve' : 'linear'&#125;</code> 则是选择连线的曲直，内部的 <code>curve</code> 也有两个取值：</p><ul><li><code>basis</code></li><li><code>linear</code></li></ul><p>两个选项分别对应着曲线和直线。</p><p>同样，如果我们只希望修改连线的曲直，那么我们就可以添加如下部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%%&#123;init : &#123;&quot;flowchart&quot; : &#123;&#x27;curve&#x27; : &#x27;linear&#x27;&#125; &#125; &#125;%%</span><br></pre></td></tr></table></figure><hr /><h1 id="修改后的效果"><a class="markdownIt-Anchor" href="#修改后的效果"></a> 修改后的效果</h1><p>我们对上方的 <code>mermaid</code> 代码进行修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%%&#123;init : &#123;&#x27;theme&#x27; : &#x27;forest&#x27;, &quot;flowchart&quot; : &#123;&#x27;curve&#x27; : &#x27;linear&#x27;&#125; &#125; &#125;%%</span><br><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">A --&gt; B --&gt; C &amp; D &amp; E &amp; F</span><br><span class="line">C --&gt; A</span><br><span class="line">D --&gt; C</span><br></pre></td></tr></table></figure><p>就可以得到 <code>forest</code> 样式的直线连线图了：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  %%{init : {&#39;theme&#39; : &#39;forest&#39;, &quot;flowchart&quot; : {&#39;curve&#39; : &#39;linear&#39;} } }%%graph TBA --&gt; B --&gt; C &amp; D &amp; E &amp; FC --&gt; AD --&gt; C  </pre></div>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
          <category> mermaid </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> mermaid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ikbc 键盘 Win 键无法响应</title>
      <link href="/2022/04/21/ikbc-%E9%94%AE%E7%9B%98-Win-%E9%94%AE%E6%97%A0%E6%B3%95%E5%93%8D%E5%BA%94/"/>
      <url>/2022/04/21/ikbc-%E9%94%AE%E7%9B%98-Win-%E9%94%AE%E6%97%A0%E6%B3%95%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用 ikbc 键盘时，<code>Win</code> 键无法响应？</p></blockquote><p>可能是通过 <code>Fn</code> + <code>左Win</code> 进行了加锁操作，导致无法正常使用 <code>Win</code> 键。</p><p>可以通过 <code>Fn</code> + <code>右Win</code> 进行解锁操作，这样就可以正常使用 <code>Win</code> 键了。</p>]]></content>
      
      
      <categories>
          
          <category> ikbc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ikbc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM  运行时数据区域</title>
      <link href="/2022/04/20/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/"/>
      <url>/2022/04/20/JVM-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph subgraph 运行时数据区    subgraph 线程共享        方法区        堆    end    subgraph 线程私有        虚拟机栈        程序计数器        本地方法栈    endend  </pre></div><hr /><h1 id="线程私有内存"><a class="markdownIt-Anchor" href="#线程私有内存"></a> 线程私有内存</h1><h2 id="程序计数器program-counter-register"><a class="markdownIt-Anchor" href="#程序计数器program-counter-register"></a> 程序计数器(Program Counter Register)</h2><p>程序计数器可以看作是当前线程所执行的字节码的行号指示器。</p><p>字节码解释器工作是就是通过改变程序计数器的值来选取下一条需要执行的字节码指令（执行本地方法的时候，程序计数器的值为 <code>null</code>）。</p><p>每条线程都需要有一个独立的程序计数器，各条的程序计数器互不影响，独立存储。</p><p>此内存区域是唯一一个没有规定任何 <code>OutOfMemoryError</code> 情况的区域。</p><h2 id="java-虚拟机栈vm-stack"><a class="markdownIt-Anchor" href="#java-虚拟机栈vm-stack"></a> Java 虚拟机栈(VM Stack)</h2><p>Java 虚拟机栈为虚拟机执行 Java 方法服务。</p><p>Java 虚拟机栈的生命周期和线程相同。</p><p>虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会在虚拟机栈中同步创建一个<strong>栈帧</strong>用于存储局部变量表、操作数栈、方法出口等信息。</p><p>每一个方法被调用直至执行完毕的过程，就对应这一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graphsubgraph 栈帧    局部变量表    操作数栈    动态链接    方法出口    ...end  </pre></div><h2 id="本地方法栈native-method-stack"><a class="markdownIt-Anchor" href="#本地方法栈native-method-stack"></a> 本地方法栈(Native Method Stack)</h2><p>本地方法栈为虚拟机使用本地方法服务。</p><hr /><h1 id="线程共享内存"><a class="markdownIt-Anchor" href="#线程共享内存"></a> 线程共享内存</h1><h2 id="java-堆java-heap"><a class="markdownIt-Anchor" href="#java-堆java-heap"></a> Java 堆(Java Heap)</h2><p>Java 堆是虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p><p>此内存区域的唯一目的就是存放对象实例，Java 世界里“几乎”所有的对象实例都在这里分配内存。</p><p>Java 堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”。</p><p>Java 堆可以处于物理上不连续的内存空间中，但在逻辑上都连续存放。</p><p>从分配内存的角度看，所有线程共享的 Java 堆中可以划分出多个线程私有的分配缓冲区，以提升对象分配时的效率。无论如何划分，无论是那个区域，存储的都只能是对象的实例。</p><p>Java 堆既可以实现成固定大小的，也可以是扩展的。如果在 Java 堆中没有内存完成对象分配时，并且堆也无法再扩展时，Java 虚拟机将会抛出 <code>OutOfMemoryError</code> 异常。</p><h2 id="方法区method-area"><a class="markdownIt-Anchor" href="#方法区method-area"></a> 方法区(Method Area)</h2><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>如果方法区无法满足新的内存分配需求时，将抛出 <code>OutOfMemoryError</code> 异常。</p><p>在 JDK 1.8 之前，HotSpot 虚拟机把它当作永久代进行垃圾回收。</p><p>在 JDK 1.8 以后，移除永久代，并将永久代拆分至堆和元空间。元空间位于本地内存中，而不是虚拟机内存中，存储类的元数据；堆中则额外存放方法区的静态变量和常量池等。</p><h3 id="运行时常量池runtime-constant-pool"><a class="markdownIt-Anchor" href="#运行时常量池runtime-constant-pool"></a> 运行时常量池(Runtime Constant Pool)</h3><p>运行时常量池是方法区的一部分。</p><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>除了保存 Class 文件中描述的符号引用外，还会把符号引用翻译出来的直接引用也存储再运行时常量池中。</p><p>运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 类加载机制</title>
      <link href="/2022/04/19/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/04/19/JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a class="markdownIt-Anchor" href="#引言"></a> 引言</h1><p>Java 语言的类型可以分为两个大类：基本类型和引用类型。</p><p>其中的引用类型，Java 又将其细分为了四种：类、接口、数组类以及泛型参数。</p><p>其中，泛型参数会在编译过程中被擦除，数组类则是由 Java 虚拟机直接在内存中动态构造出来的。所以我们只讨论类和接口的加载过程。</p><hr /><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRsubgraph 类加载过程     subgraph 链接        验证 --&gt; 准备 --&gt; 解析    end    加载 --&gt; 验证    解析 --&gt; 初始化end  </pre></div><hr /><h1 id="触发类加载的条件主动加载"><a class="markdownIt-Anchor" href="#触发类加载的条件主动加载"></a> 触发类加载的条件（主动加载）</h1><ol><li><p>遇到 <code>new</code>，<code>getstatic</code>，<code>putstatic</code> 或 <code>invokestatic</code> 这4条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。<br />生成这4条指令的最常见的Java代码场景是：</p><ol><li>使用new关键字实例化对象的时候</li><li>读取或设置一个类的静态字段的时候</li><li>调用一个类的静态方法的时候</li></ol></li><li><p>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用的时候。</p></li><li><p>当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先出发父类的初始化。</p></li><li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 <code>main()</code> 方法的那个类），虚拟机会先初始化这个主类。</p></li></ol><hr /><h1 id="加载"><a class="markdownIt-Anchor" href="#加载"></a> 加载</h1><p>加载阶段是类加载的第一个部分，在此阶段需要完成三件事情：</p><ol><li>通过类的完全限定名找到该类对应的二进制字节流。</li><li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li><li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li></ol><p>对于非数组类的其他类而言，Java 虚拟机需要通过类加载器来完成查找字节流的过程。</p><h2 id="类加载器"><a class="markdownIt-Anchor" href="#类加载器"></a> 类加载器</h2><p>加载过程需要使用类加载器来完成。</p><p>在 Java 9 以前，一共有三种类加载器：</p><ul><li>启动类加载器</li><li>扩展类加载器</li><li>应用类加载器</li></ul><p>在 Java 9 之后，经过更改后变成了两种：</p><ul><li>启动类加载器</li><li>平台类加载器</li></ul><p>启动类加载器是所有类加载器的祖先，由 C++ 编程，没有对应的 Java 对象，因此在 Java 中用 <code>null</code> 来指代。</p><p>除了启动类加载器，其他的加载器都有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。</p><h2 id="双亲委派机制"><a class="markdownIt-Anchor" href="#双亲委派机制"></a> 双亲委派机制</h2><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRsubgraph 双亲委派模型    自定义类加载器 --&gt; 应用类加载器 --&gt; 扩展类加载器 --&gt; 启动类加载器end  </pre></div><h1 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h1><p>验证阶段是连接阶段的第一步，目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><h1 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h1><p>准备阶段是正式为类变量（即静态变量，被 <code>static</code> 修饰的变量）分配内存并设置类变量初始值的阶段。</p><p>这些变量所使用的内存都将在方法区中分配，只包括类变量。</p><p>初始值“通常情况”下是数据类型的零值。</p><p>“特殊情况”下，如果类字段的字段属性表中存在 ConstantValue 属性（即被 <code>final</code> 修饰的变量），那么在准备阶段变量的值就会被初始化为 ConstantValue 属性所指定的值。</p><h1 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h1><p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p><h1 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h1><p>类加载过程中的最后一步。</p><p>初始化阶段是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。</p><p><code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。</p><p><code>&lt;clinit&gt;()</code> 与类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</p><p><strong>简单地说，初始化就是对类变量进行赋值及执行静态代码块。</strong></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> Class Loading </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>View 的工作原理</title>
      <link href="/2022/04/18/View-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
      <url>/2022/04/18/View-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><h2 id="viewroot"><a class="markdownIt-Anchor" href="#viewroot"></a> <code>ViewRoot</code></h2><p><code>ViewRoot</code>对应于<code>ViewRootImpl</code>类，它是连接<code>WindowManager</code>和<code>DecorView</code>的纽带。<code>View</code>的三大流程都是通过<code>ViewRoot</code>来完成的。</p><p>在<code>ActivityThread</code>中，当<code>Activity</code>对象被创建完毕后，会将<code>DecorView</code>添加到<code>Window</code>中，同时也会创建<code>ViewRootImpl</code>对象，并将<code>ViewRootImpl</code>对象与<code>DecorView</code>建立关联。</p><h2 id="view的三大绘制流程"><a class="markdownIt-Anchor" href="#view的三大绘制流程"></a> <code>View</code>的三大绘制流程</h2><p><code>View</code>的绘制流程主要有<code>measure</code>、<code>layout</code>和<code>draw</code>过程。</p><ol><li><code>measure</code>：用来确定<code>View</code>的测量宽高。</li><li><code>layout</code>：用来确定<code>View</code>的最终宽高以及四个顶点的位置。</li><li><code>draw</code>：将<code>View</code>绘制在屏幕上。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/v2-d165daed428c4a5312c1ce1af6a9693a_720w.jpg" alt="" /></p><p><code>View</code>的绘制流程由<code>ViewRoot</code>的<code>performTraversals</code>方法开始。</p><p><code>performTraversals</code>方法会依次调用<code>performMeasure</code>、<code>performLayout</code>、<code>performDraw</code>方法。<strong>这三个方法会分别完成<code>顶层View</code>的<code>measure</code>、<code>layout</code>、<code>draw</code>过程。</strong></p><p>其中、<code>performMeasure</code>方法会调用其中的<code>measure</code>方法，在<code>measure</code>方法中又会调用<code>onMeasure</code>方法，在<code>onMeasure</code>方法中会对所有的子元素进行<code>measure</code>过程，这个时候<code>measure</code>的流程就从父容器传递到了子元素中，这样就完成了一轮<code>measure</code>过程。不断的对子元素进行<code>measure</code>过程。如此反复便完成了对<code>View</code>树的遍历。</p><p>其中，<code>performMeasure</code>方法位于<code>ViewRootImpl</code>中的<code>measureHierarchy</code>方法中(<code>hierarchy</code>：<code>n.</code>层次结构)。</p><p><code>performLayout</code>方法、<code>performDraw</code>方法的流程与之同理，需要注意一点的是，<code>draw</code>流程的传递是通过<code>draw</code>方法中的<code>dispatchDraw</code>实现的，不过并无本质的区别。</p><h2 id="decorview"><a class="markdownIt-Anchor" href="#decorview"></a> <code>DecorView</code></h2><p><code>DecorView</code>作为<code>顶层View</code>，继承自<code>FrameLayout</code>。一般情况下它的内部都会包含一个<code>LinearLayout</code>。而<code>LinearLayout</code>中有上下两个部分，分别为标题栏和内容栏。我们平时设置指定布局文件的方法<code>setContentView</code>，就是指的是内容栏中的布局。</p><img src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/v2-8f887429daf00df80319901f69cd1d35_720w.jpg" alt="img" style="zoom:67%;" /><p>通过源码，我们可以得知，<strong><code>DecorView</code>其实是一个<code>LinearLayout</code></strong>，<code>View</code>层的事件都先通过<code>DecorView</code>，然后才传递给我们的<code>View</code>。</p><h2 id="measurespec"><a class="markdownIt-Anchor" href="#measurespec"></a> <code>MeasureSpec</code></h2><blockquote><p><code>spec</code> <strong><code>英[spek]</code></strong><code>n.</code>规格 <code>vt.</code>按特定标准设计并制造</p></blockquote><p><code>MeasureSpec</code>参与了<code>View</code>的<code>measure</code>过程。在测量过程中，系统将<code>View</code>的<code>LayoutParams</code>根据父容器所施加的规则转换成对应的<code>MeasureSpec</code>，然后再根据这个<code>MeasureSpec</code>来测量出<code>View</code>的测量宽/高。</p><p><code>MeasureSpec</code>代表一个32位的<code>int</code>值，高两位代表 测量模式<code>SpecMode</code>，低30位代表 该测量模式下的规格大小<code>SpecSize</code>。</p><p><code>MeasureSpec</code>与<code>SpecMode</code>、<code>SpecSize</code>之间可以通过位运算互相求出。</p><p>每个<code>View</code>的<code>measure</code>过程之前都会先计算其<code>MeasureSpec</code>的值，然后再对其进行<code>measure</code>。</p><p><strong>注意</strong>：<code>View</code>的宽和高各有一个<code>MeasureSpec</code>值，分别为<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>。</p><h3 id="specmode的三种状态"><a class="markdownIt-Anchor" href="#specmode的三种状态"></a> <code>SpecMode</code>的三种状态</h3><ol><li><p><code>UNSPECIFIED</code></p><p>父容器不对<code>View</code>做任何的限制，要多大给多大。<strong>这种情况一般用于系统的内部</strong>，表示一种测量方式的状态。</p></li><li><p><code>EXACTLY</code></p><p>父容器已经测出了<code>View</code>所需要的精确大小，此时的大小就是<code>View</code>的最终大小。</p><p>它对应于<code>LayoutParams</code>的<code>match_parent</code>和具体的数值这两种模式。</p></li><li><p><code>AT_MOST</code></p><p>父容器指定了一个可用的大小，<code>View</code>的大小不能大于这个值。</p><p>它对应于<code>LayoutParams</code>中的<code>wrap_content</code>。</p></li></ol><h3 id="measurespec和layoutparams的对应关系"><a class="markdownIt-Anchor" href="#measurespec和layoutparams的对应关系"></a> <code>MeasureSpec</code>和<code>LayoutParams</code>的对应关系</h3><p>对于<code>DecorView</code>和普通<code>View</code>来说，<code>MeasureSpec</code>的转化过程略有不同。</p><p><strong>对于<code>DecorView</code>：</strong></p><p><strong><code>DecorView</code>的<code>MeasureSpec</code>由窗口的大小和<code>DecorView</code>自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在<code>ViewRootImpl</code>中的<code>measureHierarchy</code>方法中，调用<code>getRootMeasureSpec</code>方法，获得<code>DecorView</code>的<code>MeasureSpec</code>。</p><p>其中<code>getRootMeasureSpec</code>方法中，根据自身<code>LayoutParams</code>的不同大小，共有三种情况：</p><ol><li><code>LayoutParams.MATCH_PARENT</code>：精确模式，大小就是窗口的大小。</li><li><code>LayoutParams.WRAP_CONTENT</code>：最大模式，大小不定，但是不能超过窗口的大小。</li><li>固定大小(比如100dp)：精确模式，大小为<code>LayoutParams</code>中指定的大小。</li></ol><p><strong>对于普通<code>View</code>：</strong></p><p><strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在父容器的<code>measureChildWithMargins</code>中的<code>getChildMeasureSpec</code>方法获得<code>View</code>的<code>MeasureSpec</code>。</p><p>其中<code>getChildMeasureSpec</code>方法的参数中使用到了父容器的<code>MeasureSpec</code>。在这个方法中通过<code>switch</code>和<code>if</code>语句，对<code>View</code>的<code>MeasureSpec</code>进行了决定。结果如下：</p><table><thead><tr><th><code>childLayoutParams</code> \ <code>parentMeasureSpec</code></th><th><code>EXACTLY</code></th><th><code>AT_MOST</code></th><th><code>UNSPECIFIED</code></th></tr></thead><tbody><tr><td><code>dp</code>/<code>px</code></td><td><code>EXACTLY</code><br>childSize</td><td><code>EXACTLY</code><br/>childSize</td><td><code>EXACTLY</code><br/>childSize</td></tr><tr><td><code>match_parent</code></td><td><code>EXACTLY</code><br/>parentSize</td><td><code>AT_MOST</code><br>parentSize</td><td><code>UNSPECIFIED</code><br>0</td></tr><tr><td><code>wrap_content</code></td><td><code>AT_MOST</code><br>parentSize</td><td><code>AT_MOST</code><br/>parentSize</td><td><code>UNSPECIFIED</code><br/>0</td></tr></tbody></table><p>上图可以简单记为：除了<code>dp</code>/<code>px</code>的精确模式情况外，三种<code>MeasureSpec</code>的级别为：<code>EXACTLY</code> &lt; <code>AT_MOST</code> &lt; <code>UNSPECIFIED</code> 且<code>childMeasureSpec</code> = max(<code>childLayoutParams</code> , <code>parentMeasureSpec</code>)。（<strong>实际上并无级别之分</strong>）</p><p>通过上面的表格，可以更加直观的看出：<strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><h1 id="view的工作流程"><a class="markdownIt-Anchor" href="#view的工作流程"></a> <code>View</code>的工作流程</h1><h2 id="measure过程"><a class="markdownIt-Anchor" href="#measure过程"></a> <code>measure</code>过程</h2><p><code>measure</code>过程分为两种情况：</p><ol><li><code>View</code>的<code>measure</code>过程：只需要测量自身即可。</li><li><code>ViewGroup</code>的<code>measure</code>过程：则除了完成自己的测量外，还需要遍历去调用所有子元素的<code>measure</code>过程。</li></ol><p>以下对这两种情况分别讨论。</p><h3 id="view的measure过程"><a class="markdownIt-Anchor" href="#view的measure过程"></a> <code>View</code>的<code>measure</code>过程</h3><p><code>View</code>的<code>measure</code>方法是<code>final</code>类型的方法，不可以重写，<code>measure</code>方法里面调用了<code>onMeasure</code>方法。</p><p>在<code>onMeasure</code>方法里面也只调用了一个<code>setMeasuredDimension</code>方法来设置<code>View</code>的宽/高的测量值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onMeasure</span><span class="params">(<span class="type">int</span> widthMeasureSpec, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMininumWidth(), </span><br><span class="line">                                        widthMeasureSpec), </span><br><span class="line">                      getDefaultSize(getSuggestedMininumHeight(), </span><br><span class="line">                                        heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在<code>setMeasureDimension</code>方法的参数中，则使用了<code>getDefaultSize</code>的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getDefaultSize</span><span class="params">(<span class="type">int</span> size, <span class="type">int</span> measureSpec)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="type">int</span> <span class="variable">specMode</span> <span class="operator">=</span> MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="type">int</span> <span class="variable">specSize</span> <span class="operator">=</span> Measurespec.getSize(measureSpec);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">            result = size;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">            result = specsize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对于at_most和exactly的情况"><a class="markdownIt-Anchor" href="#对于at_most和exactly的情况"></a> 对于<code>AT_MOST</code>和<code>EXACTLY</code>的情况</h4><p>通过代码可以看出，最终返回的值就是传入的<code>MeasureSpec</code>的中<code>View</code><strong>测量后</strong>的大小（<code>View</code>的<strong>最终的</strong>大小是在<code>layout</code>阶段确定的，但是几乎所有情况下，<code>View</code>的测量大小和最终大小都是相同的）。</p><h4 id="对于unspecified的情况"><a class="markdownIt-Anchor" href="#对于unspecified的情况"></a> 对于<code>UNSPECIFIED</code>的情况</h4><p><code>getDefaultSize</code>方法返回的值是<code>getsuggestedMininumWidth</code>方法和<code>getsuggestedMininumHeight</code>方法决定的。</p><p>这里只讨论<code>getsuggestedMininumWidth</code>方法的逻辑，另一个方法同理：</p><ol><li>如果<code>View</code>没有设置背景，那么此方法的返回值就是<code>android:minWidth</code>这个属性所指定的值，这个值默认为0。</li><li>如果<code>View</code>设置了背景，则返回<code>android:minWidth</code>和背景的最小宽度这两者中的最大值。</li></ol><h4 id="对于自定义view的情况"><a class="markdownIt-Anchor" href="#对于自定义view的情况"></a> 对于自定义<code>View</code>的情况</h4><p>对于直接继承<code>View</code>的自定义<code>View</code>来说，<strong>需要重写<code>onMeasure</code>方法并设置在<code>wrap_content</code>情况时的自身大小</strong>，否则在布局中使用<code>wrap_content</code>就相当于使用<code>match_parent</code>。</p><p>因为当自定义<code>View</code>处于<code>wrap_content</code>时，它的<code>SpecMode</code>为<code>AT_MOST</code>模式，由前文可知，当父容器无论为<code>AT_MOST</code>还是<code>ECACTLY</code>模式时，自定义<code>View</code>都为<code>AT_MOST</code>模式且尺寸大小为<code>parentSize</code>，也就是父容器的剩余空间，即自定义<code>View</code>的大小变得与父容器的剩余空间大小一致，显然不是我们需要的。</p><p><strong>解决方法：</strong></p><p>解决方法也是非常简单的。我们只需要在<code>onMeasure</code>方法中对</p><ol><li>仅<code>width</code>方向为<code>AT_MOST</code>模式</li><li>仅<code>height</code>方向为<code>AT_MOST</code>模式</li><li><code>width</code>方向以及<code>height</code>方向都为<code>AT_MOST</code>模式</li><li>其他的情况</li></ol><p>这四个状态单独判断，分别使用<code>setMeasuredDimension</code>方法直接为自定义<code>View</code>设置我们需要的值即可。</p><p>源码中对于<code>TextView</code>、<code>ImageView</code>等控件的<code>wrap_content</code>也做了特殊的处理。</p><h3 id="viewgroup的measure过程"><a class="markdownIt-Anchor" href="#viewgroup的measure过程"></a> <code>ViewGroup</code>的<code>measure</code>过程</h3><p>对于<code>ViewGroup</code>来说，处理要完成它自己的<code>measure</code>过程，还需要遍历去调用所有子元素的<code>measure</code>方法，对子元素也进行<code>measure</code>过程。</p><p>由于<code>ViewGroup</code>是一个抽象类，不能重写<code>View</code>的<code>onMeasure</code>方法，但是他提供了一个<code>measureChildren</code>的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">measureChildren</span><span class="params">(<span class="type">int</span> widthMeasureSepc, <span class="type">int</span> heightMeasureSpec)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">View</span> <span class="variable">child</span> <span class="operator">=</span> children[i];</span><br><span class="line">        <span class="keyword">if</span> (...) &#123;</span><br><span class="line">            measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中，可以清晰的看出，<code>measureChildren</code>方法遍历了所有的子元素，并对他们使用了<code>measureChild</code>方法。</p><p>在<code>measureChild</code>方法中，通过</p><ol><li>参数<code>child</code>获得了<code>child.LayoutParams</code>；</li><li><code>measureChild</code>方法中的<code>getChildMeasureSpec</code>方法配合参数中父容器的两个<code>MeasureSpec</code>值，得到子元素的两个<code>MeasureSpec</code>值。</li></ol><p>接着将子元素的两个<code>MeasureSpec</code>值传递给<code>child.measure</code>方法来进行测量，到此便结束了一轮的<code>measure</code>过程。</p><p><strong>注意</strong>：不同的<code>ViewGroup</code>有着不同的布局特性，不易写出通用的供<code>ViewGroup</code>使用的<code>onMeasure</code>方法。故设置成抽象类，需要测量过程中的各个子类（如<code>LinearLayout</code>、<code>RelativeLayout</code>等）自己去具体实现<code>onMeasure</code>方法。</p><h3 id="在activity启动时获得一个view的宽高信息的方法"><a class="markdownIt-Anchor" href="#在activity启动时获得一个view的宽高信息的方法"></a> 在<code>Activity</code>启动时获得一个<code>View</code>的宽/高信息的方法</h3><p>由于<code>Activity</code>的启动和<code>View</code>的测量过程并不是同步进行的，因此无法保证在<code>Activity</code>启动时某个<code>View</code>已经测量完毕了。所以我们在<code>Activity</code>启动的时候，如果直接通过<code>getMeasuredWidth</code>/<code>getMeasuredHeight</code>方法获得的值可能为0。</p><p>以下有四种方法可以解决这个问题（详细代码见《Android开发艺术探索》190页）。</p><ol><li><p><code>Activity/View#onWindowFocusChanged</code></p><p>在<code>Activity</code>的<code>onResume</code>和<code>onPause</code>方法启动时，<code>onWindowFocusChanged</code>方法也会同时被调用，可以重写里面的内容，使之计算<code>View</code>的宽高。</p><p><strong>注意</strong>：<code>onWindowFocusChanged</code>方法会在<code>View</code>已经初始化完毕后才开始调用。</p></li><li><p><code>view.post(runnable)</code></p><p>通过<code>post</code>可以将一个<code>runnable</code>投递都消息队列的尾部，然后等待<code>Looper</code>调用此<code>runnable</code>的时候，<code>View</code>也已经初始化好了。</p></li><li><p><code>ViewTreeObserver</code></p><p><code>ViewTreeObserver</code>中的众多回调可以完成这个功能。</p><p>比如<code>OnGlobalLayoutListener</code>接口，当<code>View</code>树的状态发生改变或者<code>View</code>树内部的<code>View</code>的可见性发生改变的时候，<code>onGlobalLayout</code>方法将被回调，此时就可以获取<code>View</code>的宽高了。</p></li><li><p><code>view.measure(int widthMeasureSpec, int heightMeasureSpec)</code></p><p>可以主动调用该方法开始计算<code>view</code>的宽高。</p><ol><li><p><strong><code>match_parent</code></strong></p><p>由于正常的<code>measure</code>过程中，我们需要父容器的<code>MeasureSpec</code>的值，而此时父容器并没开始计算，我们无从得知这两个值的大小。故我们无法对<code>match_parent</code>的<code>view</code>计算其宽高。</p></li><li><p><strong><code>dp</code>/<code>px</code></strong></p><p>因为有精确的数值了，所以我们可以直接使用这个精确的数值通过<code>MeasureSpec.makeMeasureSpec</code>方法构建<code>view</code>的<code>MeasureSpec</code>。</p></li><li><p><strong><code>wrap_content</code></strong></p><p>直接将<code>MeasureSpec.makeMeasureSpec</code>方法中参数的值设置为<code>(1&lt;&lt;30)-1</code>即可，这是<code>View</code>理论上可以支持的最大值，所以这样构建<code>MeasureSpec</code>是合理的。</p></li></ol></li></ol><h2 id="layout过程"><a class="markdownIt-Anchor" href="#layout过程"></a> <code>layout</code>过程</h2><p><code>layout</code>的作用是<code>ViewGroup</code>用来确定子元素的位置。当调用一个<code>View</code>的<code>layout</code>方法时，它会在<code>layout</code>方法中通过<code>setFrame</code>方法确定自身的位置，然后调用<code>onLayout</code>方法确定子元素的位置。</p><p>在<code>onLayout</code>方法中，会遍历所有子元素，对它们计算各自的位置后，调用子元素的<code>layout</code>方法，完成一轮<code>layout</code>过程。</p><p><code>View</code>中实现了<code>layout</code>方法，但是由于<code>onLayout</code>的实现与不同<code>View</code>各自的布局有关，所以源码中仅给出了一个空<code>onLayout</code>方法。需要每个<code>View</code>和<code>ViewGroup</code>自己去重写。</p><p><strong>注意</strong>：单一<code>View</code>一般不需要重写<code>onLayout</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Assign a size and position to a view and all of its</span></span><br><span class="line"><span class="comment"> * descendants</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is the second phase of the layout mechanism.</span></span><br><span class="line"><span class="comment"> * (The first is measuring). In this phase, each parent calls</span></span><br><span class="line"><span class="comment"> * layout on all of its children to position them.</span></span><br><span class="line"><span class="comment"> * This is typically done using the child measurements</span></span><br><span class="line"><span class="comment"> * that were stored in the measure pass().&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Derived classes should not override this method.</span></span><br><span class="line"><span class="comment"> * Derived classes with children should override</span></span><br><span class="line"><span class="comment"> * onLayout. In that method, they should</span></span><br><span class="line"><span class="comment"> * call layout on each of their children.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * 为视图及其所有子体指定大小和位置</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 这是布局机制的第二阶段。</span></span><br><span class="line"><span class="comment"> * （第一个是测量）。在此阶段中，每个父级调用其所有子级上的layout来定位它们。</span></span><br><span class="line"><span class="comment"> * 这通常使用存储在方法pass()中的子测量值来完成。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 派生类不应重写此方法。</span></span><br><span class="line"><span class="comment"> * 具有子级的派生类应重写onLayout。在该方法中，他们应该对每个子对象调用布局。  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onLayout</span><span class="params">(<span class="type">boolean</span> changed, <span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="draw过程"><a class="markdownIt-Anchor" href="#draw过程"></a> <code>draw</code>过程</h2><p><code>draw</code>过程就比较简单，它的作用是将<code>View</code>绘制到屏幕上面。</p><p><code>View</code>的绘制过程遵循以下的4步：</p><ol><li>绘制背景：<code>background.draw(canvas)</code></li><li>绘制自己：<code>onDraw</code>方法</li><li>绘制children：<code>dispatchDraw</code>方法</li><li>绘制装饰：<code>onDrawScrollBars</code>方法</li></ol><p>所有的绘制过程都在<code>draw</code>方法中进行。</p><p>其中，<code>View</code>绘制过程的传递是通过<code>dispatchDraw</code>方法实现的，<code>dispatchDraw</code>方法会遍历所有的子元素并调用他们的<code>draw</code>方法，完成一轮的<code>draw</code>过程。</p><p><strong>注意</strong>：</p><ol><li>单一<code>View</code>需要重写<code>onDraw</code>方法绘制自身。</li><li><code>ViewGroup</code>需要重写<code>onDraw</code>方法绘制自身以及遍历子元素对它们进行绘制。</li></ol><h2 id="view的工作流程图"><a class="markdownIt-Anchor" href="#view的工作流程图"></a> View的工作流程图</h2><p>f<br /><img src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/v2-3d1255a5093de81fd5bdc27a300d2f0d_720w.jpg" alt="" /></p><h1 id="todo自定义view"><a class="markdownIt-Anchor" href="#todo自定义view"></a> <em>TODO</em>：自定义<code>View</code></h1>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/04/18/hello-world/"/>
      <url>/2022/04/18/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android 动画深入分析</title>
      <link href="/2022/04/17/Android-%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
      <url>/2022/04/17/Android-%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="动画的三个分类"><a class="markdownIt-Anchor" href="#动画的三个分类"></a> 动画的三个分类</h1><ol><li><p>View动画</p></li><li><p>帧动画</p></li><li><p>属性动画</p></li></ol><h1 id="view动画"><a class="markdownIt-Anchor" href="#view动画"></a> <code>View</code>动画</h1><h2 id="四个动画效果"><a class="markdownIt-Anchor" href="#四个动画效果"></a> 四个动画效果</h2><p><code>View</code>动画的作用对象是<code>View</code>，它有四个动画效果：平移动画、缩放动画、旋转动画、透明度动画。</p><p><code>View</code>动画的四个变化效果对应着<code>Animation</code>的四个子类：</p><ol><li>平移动画：<code>TranslateAnimation</code>，<code>XML</code>中对应的标签为<code>&lt;translate&gt;</code></li><li>缩放动画：<code>ScaleAnimation</code>，<code>XML</code>中对应的标签为<code>&lt;scale&gt;</code></li><li>旋转动画：<code>RotateAnimation</code>，<code>XML</code>中对应的标签为<code>&lt;rotate&gt;</code></li><li>透明度动画：<code>AlphaAnimation</code>，<code>XML</code>中对应的标签为<code>&lt;alpha&gt;</code></li></ol><h2 id="set标签"><a class="markdownIt-Anchor" href="#set标签"></a> <code>&lt;set&gt;</code>标签</h2><p><code>&lt;set&gt;</code>标签表示动画的集合，对应着<code>AnimationSet</code>类，其中可以包含着若干的动画，也可以有子动画。</p><p>标签有两个属性：</p><ol><li><code>android:interpolator=&quot;@anim/...&quot;</code>：选定集合所使用的插值器。</li><li><code>android:shareInterpolator=[&quot;true&quot;|&quot;false&quot;]</code>：是否让集合中的动画和集合使用相同的插值器，如果为<code>false</code>，则需要为每一个动画指定一个插值器。</li></ol><h2 id="自定义view动画"><a class="markdownIt-Anchor" href="#自定义view动画"></a> 自定义<code>View</code>动画</h2><p>通过继承抽象类<code>Animation</code>，并重写其中的<code>intialize</code>和<code>applyTransformation</code>方法。</p><p><code>intialize</code>方法做初始化工作。</p><p><code>applyTransformation</code>方法中进行相应的矩阵变换，很多时候需要采用<code>Camera</code>类来简化矩阵变换的过程。</p><h2 id="view动画的特殊使用场景"><a class="markdownIt-Anchor" href="#view动画的特殊使用场景"></a> <code>View</code>动画的特殊使用场景</h2><h3 id="layoutanimation"><a class="markdownIt-Anchor" href="#layoutanimation"></a> <code>LayoutAnimation</code></h3><p><code>LayoutAnimation</code>作用于<code>ViewGroup</code>，为<code>ViewGroup</code>指定一个动画，这样当这个<code>ViewGroup</code>的子元素出场时都会具有这个动画效果。</p><p>常常被用在<code>ListView</code>中，让其中的<code>item</code>在出场时都具有动画效果。</p><p><strong>使用步骤：</strong></p><ol><li><p>在<code>XML</code>中定义<code>LayoutAnimation</code>，标签为<code>&lt;layoutAnimation&gt;</code>。其中有两个参数：<code>android:delay</code>和<code>android:animationOrder</code>。两者的作用如下：</p><ol><li><code>android:delay</code>：使子元素的出场时间向后延迟指定的时间，单位为毫秒。</li><li><code>android:animationOrder</code>：指定子元素的出场顺序。有三种选项：<code>normal</code>顺序出场、<code>reverse</code>逆序出场、<code>random</code>随机出场。</li></ol></li><li><p>在<code>XML</code>中指定出场时的动画。</p></li><li><p>在<code>XML</code>中的<code>ViewGroup</code>部分使用<code>android:layoutAnimation</code>参数指定第1步中的<code>LayoutAnimation</code>文件，便可以为<code>ViewGroup</code>中的子元素指定出场动画。</p><p>除了可以在<code>XML</code>中指定<code>ViewGroup</code>的<code>android:layoutAnimation</code>属性，也可以在代码中通过<code>LayoutAnimationController</code>来实现。</p></li></ol><h3 id="activity的切换效果"><a class="markdownIt-Anchor" href="#activity的切换效果"></a> <code>Activity</code>的切换效果</h3><p><code>View</code>动画也可以对<code>Activity</code>的切换效果进行设置，效果如<code>Navigation</code>的<code>Fragment</code>切换效果。</p><p>这个效果是可以自定义的，我们可以通过<code>overridePendingTransition(int enterAnim, int exitAnim)</code>方法，这个方法<code>startActivity(Intent intent)</code>函数或者<code>finish()</code>函数之后被调用才能生效，否则动画效果将不起作用。</p><p>两个参数分别是设置的<strong>入场动画</strong>和<strong>退场动画</strong>的资源Id。</p><p>使用方法例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(...);</span><br><span class="line">startActivity(intent);</span><br><span class="line">overridePendingTransition(R.anim.enter_anim, R.anim.exit_anim);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finish</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.finish();</span><br><span class="line">    overridePendingTransition(R.anim.enter_anim, R.anim.exit_anim);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fragment的切换效果"><a class="markdownIt-Anchor" href="#fragment的切换效果"></a> <code>Fragment</code>的切换效果</h3><p>由于<code>Fragment</code>类是在<code>API11</code>中才被新加入的，所以我们使用<code>support-v4</code>这个兼容包。</p><p>我们使用<code>FragmentTransaction</code>类中的<code>setCustomAnimation()</code>方法来添加切换动画，该处的动画<strong>需要是<code>View</code>动画</strong>，而<strong>不能是属性动画</strong>。</p><h1 id="帧动画"><a class="markdownIt-Anchor" href="#帧动画"></a> 帧动画</h1><p>通过<code>&lt;animation-list&gt;</code>标签，并在其中预设好一组图片，类似于电影的播放，按顺序依次播放。</p><p>系统中提供<code>AnimationDrawable</code>类来使用帧动画。</p><p>应避免使用尺寸较大的图片，以防止<code>OOM</code>的发生。</p><h1 id="属性动画"><a class="markdownIt-Anchor" href="#属性动画"></a> 属性动画</h1><p>属性动画<strong>可以对任意对象的属性进行动画</strong>而不仅仅是<code>View</code>。</p><p>动画的默认时间间隔为<code>300ms</code>，默认的帧率为<code>10ms/帧</code>。</p><p>达到的效果是：在一个时间间隔内完成对象从一个属性值到另一个属性值的改变。</p><p>常用的几个动画类是：<code>ValueAnimator</code>、<code>ObjectAnimator</code>和<code>AnimatorSet</code>。</p><p>其中，<code>ObjectAnimator</code>继承自<code>ValueAnimator</code>，<code>AnimatorSet</code>是动画集合，可以定义一组动画。</p><h2 id="nineoldandroids"><a class="markdownIt-Anchor" href="#nineoldandroids"></a> <code>Nineoldandroids</code></h2><p><code>API11</code>前，可以使用<code>nineoldandroids</code>开源动画库完成类似属性动画的效果，其使用的语法与<code>API11</code>后属性动画的语法完全一致，不同的是，<code>nineoldandroids</code>通过<code>View</code>动画来完成属性动画的效果。</p><h2 id="使用方式"><a class="markdownIt-Anchor" href="#使用方式"></a> 使用方式</h2><p>属性动画可以通过代码的方式完成，也可以在<code>XML</code>文件中定义。属性动画需要定义在<code>res/animator</code>中。</p><p>上述三个动画类在<code>XML</code>文件中的表示方式如下：</p><h3 id="animatorset"><a class="markdownIt-Anchor" href="#animatorset"></a> <code>AnimatorSet</code></h3><p>对应的标签为<code>&lt;set&gt;</code>。</p><p>其中的属性<code>android:ordering=[&quot;together&quot;|&quot;sequentially&quot;]</code>有两个可选值：</p><ol><li><code>together</code>表示集合中所有的子动画同时播放。</li><li><code>sequentially</code>表示集合中的子动画依次播放。</li></ol><h3 id="objectanimator"><a class="markdownIt-Anchor" href="#objectanimator"></a> <code>ObjectAnimator</code></h3><p>对应的标签为<code>&lt;objectAnimator&gt;</code>。</p><p>部分属性即解释如下：</p><ul><li><p><code>android:propertyName=&quot;string&quot;</code>：表示属性动画的作用对象的属性的名称。</p></li><li><p><code>android:startOffset=&quot;int&quot;</code>：表示动画的延迟时间，当动画开始后，需要延迟多少毫秒才会真正播放此动画。</p></li><li><p><code>android:repeatCount=&quot;int&quot;</code>：表示动画的重复次数，默认值为<code>0</code>，<code>-1</code>表示无限循环。</p></li><li><p><code>android:repearMode=[&quot;restart&quot;|&quot;reverse&quot;]</code>：表示动画的重复模式。</p><ul><li><code>&quot;restart&quot;</code>表示连续重复，即每次都重新开始播放。</li><li><code>&quot;reverse&quot;</code>表示逆向重复，即第一次正放动画，第二次倒放动画，第三次正放动画，第四次倒放动画，如此反复。</li></ul></li><li><p><code>&quot;android:valueType=[&quot;intType&quot;|&quot;floatType&quot;]</code>：表示<code>android:perpertyName</code>所指定的属性的类型，如果指定的属性为颜色，那么不需要指定该属性，系统会自动对颜色类型的属性做处理。</p></li></ul><h3 id="valueanimator"><a class="markdownIt-Anchor" href="#valueanimator"></a> <code>ValueAnimator</code></h3><p>对应的标签为<code>&lt;animator&gt;</code></p><p>其属性比<code>ObjectAnimator</code>少了一个<code>android:perpertyName</code>，其余的属性都是一样的，故不多介绍。</p><h2 id="理解插值器和估值器"><a class="markdownIt-Anchor" href="#理解插值器和估值器"></a> 理解插值器和估值器</h2><p>插值器和估值器是实现非匀速动画的重要手段。</p><h3 id="timeinterpolator"><a class="markdownIt-Anchor" href="#timeinterpolator"></a> <code>TimeInterpolator</code></h3><p>时间插值器。作用为<strong>根据时间的流逝的百分比计算当前属性值改变的百分比</strong>。</p><p>预设的有多种插值器，常见的三种如下：</p><ol><li><code>LinearInterpolator</code>——线性插值器：匀速动画</li><li><code>AccelerateDecelerateInterpolator</code>——加速减速插值器：动画两头慢中间快</li><li><code>DecelerateInterpolator</code>——减速插值器：动画越来越慢</li></ol><p>三个类都实现了<code>Interpolartor</code>接口，接口内部只有一个用来计算属性值的改变的百分比的<code>getInterpolation</code>方法需要实现。</p><h3 id="typeevaluator"><a class="markdownIt-Anchor" href="#typeevaluator"></a> <code>TypeEvaluator</code></h3><p>类型估值算法，也叫估值器。作用是<strong>根据属性值改变的百分比来计算改变后的属性值</strong>。</p><p>系统预置的有3种：</p><ol><li><code>IntEvaluator</code>：针对整形属性</li><li><code>FloatEvaluator</code>：针对浮点型属性</li><li><code>ArgbEvaluator</code>：针对Color属性</li></ol><p>三个类都实现了<code>TypeEvalator</code>接口，接口内部只有一个用来计算改变后的属性值的<code>evaluate</code>方法需要实现。</p><h3 id="计算顺序"><a class="markdownIt-Anchor" href="#计算顺序"></a> 计算顺序</h3><p>系统会根据当前的帧所在时刻与动画播放的总时间求出时间的流逝的百分比，再通过插值器计算出当前属性值改变的百分比，后用此值通过估值器计算出当前的属性改变后的确定的值是多少并通过<code>set</code>方法对属性赋值。</p><p>故属性动画要求对象的该属性有<code>set</code>方法（必须有）和<code>get</code>方法（可选）。</p><h3 id="自定义插值器和估值器"><a class="markdownIt-Anchor" href="#自定义插值器和估值器"></a> 自定义插值器和估值器</h3><p>我们可以自定义插值器和估值器，来实现自己想要的动画效果。实现方式也很简单。</p><p>因为插值器和估值器都是一个接口，且内部都只有一个方法，所以我们只需要派生一个类并实现接口就可以了，然后就可以做出千奇百怪的动画效果了。即：</p><ul><li>自定义插值器需要实现<code>Interpolator</code>或者<code>TimeInterpolator</code>接口</li><li>自定义估值器需要实现<code>TypeEvaluator</code>接口。</li></ul><h2 id="属性动画的监听器"><a class="markdownIt-Anchor" href="#属性动画的监听器"></a> 属性动画的监听器</h2><p>监听器用于监听动画的播放过程，主要有两个接口：<code>AnimatorUpdateListener</code>和<code>AnimatorListener</code>。</p><h3 id="animatorupdatelistener"><a class="markdownIt-Anchor" href="#animatorupdatelistener"></a> <code>AnimatorUpdateListener</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">AnimatorUpdateListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口会监听整个动画过程，即每播放一帧，<code>onAnimationUpdate</code>就会被调用一次。</p><h3 id="animatorlistener"><a class="markdownIt-Anchor" href="#animatorlistener"></a> <code>AnimatorListener</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">interface</span> <span class="title class_">AnimatiorListener</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onAnimatorStart</span><span class="params">(Animator animation)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onAnimatorEnd</span><span class="params">(Animator animation)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onAnimatorCancel</span><span class="params">(Animator animation)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">onAnimatorRepeat</span><span class="params">(Animator animation)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该接口会监听动画的开始、结束、取消以及重复播放。同时为了方便开发，系统还提供了<code>AnimatorListenerAdapter</code>这个类，它是<code>AnimatorListener</code>的适配器类，这样我们就可以有选择地实现上面的4个方法了。</p><h2 id="对任意属性做动画"><a class="markdownIt-Anchor" href="#对任意属性做动画"></a> 对任意属性做动画</h2><p>属性动画<strong>可以对任意对象的属性进行动画</strong>而不仅仅是<code>View</code>。</p><h3 id="属性动画的工作流程"><a class="markdownIt-Anchor" href="#属性动画的工作流程"></a> 属性动画的工作流程</h3><p>属性动画要求动画作用的对象提供该属性的<code>set</code>方法，属性动画根据你传递的该属性的初始值和最终值，以动画的效果多次去调用<code>set</code>方法。每次传递给<code>set</code>方法的值都不一样，确切来说是随着时间的推移，所传递的值越来越接近最终值。如果动画的时候没有传递初始值，那么还要提供<code>get</code>方法，因为系统要去获取属性的初始值。即：</p><ul><li><p>必须要有该属性的<code>set</code>方法（如果这条不满足则会无效果）</p></li><li><p>如果没有传递初始值，那么必须要有该属性的<code>get</code>方法（如果这条不满足则程序直接Crash）</p></li></ul><h3 id="动画不生效时的解决方法"><a class="markdownIt-Anchor" href="#动画不生效时的解决方法"></a> 动画不生效时的解决方法</h3><p>当有些对象的内部并没有该属性的<code>set</code>方法时，动画会无效果，那么我们有三个方法去解决这个问题：</p><ol><li><p><strong>如果有权限的话，直接给对象加上<code>get</code>和<code>set</code>方法</strong></p><p>很多时候，我们是没有权限的去添加方法的，比如我们给<code>Button</code>或者<code>TextView</code>等等，因为这些都是Android SDK内部实现的，我们无法更改。</p></li><li><p><strong>用一个类来包装原始对象，间隔为其提供<code>get</code>和<code>set</code>方法</strong></p><p>因为属性动画可以对任意对象进行动画，所以我们可以用一个类来包装原始对象，并在该类中为原始对象提供<code>get</code>和<code>set</code>方法。</p><p>然后对该类进行属性动画，即可修改原始对象的属性值。</p></li><li><p><strong>利用<code>ValueAnimator</code>，监听动画过程，自己实现属性的改变</strong></p><p>使用<code>AnimatorUpdateListener</code>接口监听整个动画过程，在其中的<code>onAnimationUpdate</code>方法中，对每一帧通过调用插值器和估值器计算当前的属性值，并通过<code>set</code>方法直接为该属性赋值，实现属性的改变。</p></li></ol><p><strong>注：自己写的<code>set</code>方法中，在对属性值进行修改后，需要调用<code>view.requestLayout()</code>方法重绘界面，否则无法显示更改后的界面。</strong></p><h2 id="属性动画的工作原理"><a class="markdownIt-Anchor" href="#属性动画的工作原理"></a> 属性动画的工作原理</h2><p><code>ObjectAnimatior#start</code>方法会调用其父类<code>ValueAnimator#start</code>方法，在父类的<code>start</code>方法中会调用<code>AnimationHandler#start</code>方法，<code>AnimationHandler</code>是一个<code>Runnable</code>，我已属性动画需要运行在有<code>Looper</code>的线程中。</p><p>中间通过一系列的方法调用，然后会使用<code>ValueAnimator#doAnimationFrame</code>方法，在此方法中又调用了<code>animationFrame</code>方法，内部又调用了<code>animateValue</code>方法，其中的<code>calculateValue</code>方法就是计算每帧动画所对应的属性的值，其中的<code>setupValue</code>方法通过反射调用对象的<code>get</code>方法，<code>setAnimationValue</code>方法通过反射的方式调用了对象的<code>set</code>方法。</p><h1 id="使用动画的注意事项"><a class="markdownIt-Anchor" href="#使用动画的注意事项"></a> 使用动画的注意事项</h1><p><strong>来源：《Android开发艺术探索》</strong></p><p><img src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/Android%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90.png" alt="" /></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Animation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 Window 和 WindowManager [转载]</title>
      <link href="/2022/04/17/%E7%90%86%E8%A7%A3-Window-%E5%92%8C-WindowManager/"/>
      <url>/2022/04/17/%E7%90%86%E8%A7%A3-Window-%E5%92%8C-WindowManager/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自：</p><ul><li><a href="https://www.jianshu.com/p/1c4059d3865b">Android源码-深入理解Window和WindowManager - 简书</a></li></ul></blockquote><hr /><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p><code>Window</code> 表示一个窗口的概念，<code>Android</code>中所有的视图都是通过<code>Window</code>来呈现的，不管是<code>Activity</code>、<code>Dialog</code>、还是<code>Toast</code>，它们的视图实际上都是附加在<code>Window</code>上的，因此，<code>Window</code>实际是<code>View</code>的管理者。<code>Window</code>是一个非常重要的子系统，这也是我们常说的<code>WMS</code>(<code>WindowManagerService</code>)。下面我们就分析一下<code>Window</code>、<code>WMS</code>、<code>View</code>建立关联以及交互的一个基本过程。</p><h2 id="window体系相关uml类图"><a class="markdownIt-Anchor" href="#window体系相关uml类图"></a> <code>Window</code>体系相关UML类图</h2><p><img src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/%E7%90%86%E8%A7%A3Window%E5%92%8CWindowManager" alt="" /></p><ul><li><strong><code>Session</code></strong> :是一个<code>Binder</code>对象，代表一个活跃的客户端会话，在每个进程中都有一个<br /><strong><code>Session</code></strong> 与 <strong><code>WindowManager</code></strong> 交互的对象。</li><li><strong><code>WindowManagerService</code></strong> ：也是一个<code>Binder</code>对象，负责对窗口的管理。</li><li><strong><code>Window</code></strong> ：应用程序用来与窗口管理器交谈的界面。</li><li><strong><code>PhoneWindow</code></strong> ： <strong><code>Window</code></strong> 的具体实现。</li><li><strong><code>WindowManagerImpl</code></strong> ： 负责与系统窗口管理器通信、绑定到上下文、显示的操作。</li><li><strong><code>ViewRootImpl</code></strong> ：负责 <strong><code>View</code></strong> 的(测量、摆放、绘制)三大流程。</li><li><strong><code>WindowManagerGlobal</code></strong> ： <strong><code>WindowManager</code></strong> 的具体实现。</li><li><strong><code>WindowSession</code></strong> ：一个<code>Binder</code>对象，负责<code>ViewRootImpl</code>与<code>WMS</code>的<code>IPC</code>通信。</li></ul><h2 id="windowmanager"><a class="markdownIt-Anchor" href="#windowmanager"></a> <code>WindowManager</code></h2><p>与<code>WindowManager</code>联系上的第一步就是通过<code>Context</code>的<code>getSystemService</code>()方法，在分析文章<a href="https://www.jianshu.com/p/865e870186fa">Android源码中单例模式</a> 中我们知道，<strong>各种系统服务会注册到<code>ContextImpl</code>的一个<code>map</code>容器中，然后通过该服务的字符串键获取</strong>，<code>WindowManager</code>也是<code>ContextImpl</code>中注册的众多服务之一，我们看下下面这段程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//窗口服务</span></span><br><span class="line">registerService(Context.WINDOW_SERVICE, WindowManager.class,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CachedServiceFetcher</span>&lt;WindowManager&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> WindowManager <span class="title function_">createService</span><span class="params">(ContextImpl ctx)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowManagerImpl</span>(ctx);</span><br><span class="line">    &#125;&#125;);</span><br></pre></td></tr></table></figure><p>最后一行代码中，我们看到了<code>WindowManager</code>在Java层的具体实现，也就是<code>WindowManagerImpl</code>。那<code>Activity</code>或者<code>Dialog</code>又是如何获取到<code>WindowManager</code>对象呢？我们从上述代码知道，<strong><code>WindowManager</code>是注册到<code>ContextImpl</code>中的，而<code>getSystemService</code>也是<code>Context</code>定义的接口</strong>，因此，我们就从<code>Dialog</code>的构造函数和<code>Activity</code>入手，因为<code>Context</code>是传到<code>Dialog</code>构造函数的。</p><h4 id="dialog构造函数"><a class="markdownIt-Anchor" href="#dialog构造函数"></a> <code>Dialog</code>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Dialog(<span class="meta">@NonNull</span> Context context, <span class="meta">@StyleRes</span> <span class="type">int</span> themeResId, <span class="type">boolean</span> createContextThemeWrapper) &#123;</span><br><span class="line">    <span class="comment">//获取WindowManager</span></span><br><span class="line">    mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Window</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneWindow</span>(mContext);</span><br><span class="line">    mWindow = w;</span><br><span class="line">    <span class="comment">//设置Window回调</span></span><br><span class="line">    w.setCallback(<span class="built_in">this</span>);</span><br><span class="line">    w.setOnWindowDismissedCallback(<span class="built_in">this</span>);</span><br><span class="line">    w.setOnWindowSwipeDismissedCallback(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCancelable) &#123;</span><br><span class="line">            cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//设置Window的WindowManager对象</span></span><br><span class="line">    w.setWindowManager(mWindowManager, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    w.setGravity(Gravity.CENTER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="activity的attach方法"><a class="markdownIt-Anchor" href="#activity的attach方法"></a> <code>Activity</code>的<code>attach</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span><br><span class="line"><span class="params">        Instrumentation instr, IBinder token, <span class="type">int</span> ident,</span></span><br><span class="line"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span><br><span class="line"><span class="params">        CharSequence title, Activity parent, String id,</span></span><br><span class="line"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span><br><span class="line"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span><br><span class="line"><span class="params">        Window window)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="comment">//创建Window并设置window的监听</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> <span class="title class_">PhoneWindow</span>(<span class="built_in">this</span>, window);</span><br><span class="line">    mWindow.setWindowControllerCallback(<span class="built_in">this</span>);</span><br><span class="line">    mWindow.setCallback(<span class="built_in">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="built_in">this</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//Window设置WindowManager对象</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="literal">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**无论是<code>Dialog</code>还是<code>Activity</code>都是通过<code>Window</code>对象的<code>setWindowManager</code>方法将<code>WindowManager</code>与<code>Window</code>关联。**该函数是在<code>Window</code>中，看看实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWindowManager</span><span class="params">(WindowManager wm, IBinder appToken, String appName,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> hardwareAccelerated)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (wm == <span class="literal">null</span>) &#123;</span><br><span class="line">        wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> WindowManagerImpl <span class="title function_">createLocalWindowManager</span><span class="params">(Window parentWindow)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowManagerImpl</span>(mContext, parentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后调用的是<code>WindowManagerImpl</code>的<code>createLocalWindowManager</code>方法，这里与<code>ContextImpl</code>注册的<code>WindowManagerImpl</code>不同的是，这里多了一个<code>parentWindow</code>参数，也就是说，此时构建的<code>WindowManagerImpl</code>对象是与具体的<code>Window</code>关联的，而<code>ContextImpl</code>注册的并没有此参数。这是<code>Window</code>已经和<code>WindowManager</code>建立了初步联系。为什么这么说呢？我们看下<code>WindowManagerImpl</code> 的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WindowManagerImpl</span> <span class="keyword">implements</span> <span class="title class_">WindowManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">WindowManagerGlobal</span> <span class="variable">mGlobal</span> <span class="operator">=</span> WindowManagerGlobal.getInstance();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Window mParentWindow;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> &#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateViewLayout</span><span class="params">(<span class="meta">@NonNull</span> View view, <span class="meta">@NonNull</span> ViewGroup.LayoutParams params)</span> &#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.updateViewLayout(view, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeView</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        mGlobal.removeView(view, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeViewImmediate</span><span class="params">(View view)</span> &#123;</span><br><span class="line">        mGlobal.removeView(view, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Display <span class="title function_">getDefaultDisplay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mContext.getDisplay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然<code>WindowManagerImpl</code>还没有实现对视图的操作，添加、更新、删除都交给了<code>WindowManagerGlobal</code>这个类，通过以上分析对<code>VIew</code>的操作实际上是调用的是<code>WindowManagerGlobal</code>的方法，继续跟踪：</p><h2 id="windowmanagerglobal对view的操作"><a class="markdownIt-Anchor" href="#windowmanagerglobal对view的操作"></a> <code>WindowManagerGlobal</code>对<code>View</code>的操作</h2><p>看上面<code>UML</code>类图我看到<code>WindowManagerGlobal</code>有几个重要的属性，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;View&gt; mViews = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;View&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ViewRootImpl&gt; mRoots = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ViewRootImpl&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;WindowManager.LayoutParams&gt; mParams =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;WindowManager.LayoutParams&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArraySet&lt;View&gt; mDyingViews = <span class="keyword">new</span> <span class="title class_">ArraySet</span>&lt;View&gt;();</span><br></pre></td></tr></table></figure><p>在上面声明中，<code>mViews</code>存储的是所有<code>Window</code>所对应的<code>View</code>，<code>mRoots</code>存储的是所有<code>Window</code>所对应的<code>ViewRootImpl</code>,<code>mParams</code>存储的是所有<code>Window</code>的布局参数，而<code>mDyingViews</code>则存储了那些整被删除的<code>View</code>对象，或者说那些已经调用<code>removeView</code>方法但是删除操作还未完成的<code>Window</code>对象，在<code>addView</code>中将<code>Window</code>一系列对象添加到容器中。</p><h3 id="windowmanagerglobal的addview过程"><a class="markdownIt-Anchor" href="#windowmanagerglobal的addview过程"></a> <code>WindowManagerGlobal</code>的<code>addView</code>过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span><br><span class="line"><span class="params">        Display display, Window parentWindow)</span> &#123;</span><br><span class="line">    ...<span class="comment">//省略参数检查代码</span></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    <span class="type">View</span> <span class="variable">panelParentView</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//创建ViewRootImpl</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">ViewRootImpl</span>(view.getContext(), display);</span><br><span class="line">        <span class="comment">//设置参数</span></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        <span class="comment">//添加到容器列表中</span></span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用ViewRootImpl的setView方法将View显示到手机上</span></span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面程序主要完成以下工作;</p><ul><li>构建**<code>ViewRootImpl</code>**；</li><li>将布局参数设置给**<code>View</code>**；</li><li>存储这些**<code>ViewRootImpl</code><strong>、</strong><code>View</code><strong>、</strong><code>LayoutParam</code>**到列表中；</li><li>通过**<code>ViewRootImpl</code><strong>的</strong><code>setView</code><strong>将</strong><code>View</code>**显示到窗口。</li></ul><p>很多人对<code>ViewRootImpl</code>并不陌生，从<strong>UML</strong>类图可以看出这个类里面有一个我们熟知的<code>performTraversals</code>方法，<code>ViewRootImpl</code>收到系统绘制View的消息后<code>performTraversals</code>就会调用视图树的各个节点的<code>meature</code>、<code>layout</code>、<code>draw</code>方法来绘制整颗视图树。</p><p>从上述代码分析来看，第一个重要步骤就是创建了<code>ViewRootImpl</code>对象，我们看看它的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ViewRootImpl</span><span class="params">(Context context, Display display)</span> &#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    <span class="comment">//获取Window Session，也就是也WindowManagerService建立联系</span></span><br><span class="line">    mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line">    <span class="comment">//保存当前线程，，更新Ui的 线程只能是创建ViewRootImpl时的线程，</span></span><br><span class="line">    <span class="comment">//我们在开发中，如果在子线程更新UI会抛出异常，但并不是因为只有UI线程才能更新UI</span></span><br><span class="line">    <span class="comment">//而是因为ViewRootImpl是在UI线程中创建的</span></span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>ViewRootImpl</code>通过<code>WindowSession</code>实现与<code>WMS</code>的沟通<br /><code>WindowManagerGlobal.getWindowSession</code>方法内部已经通过<code>IPC</code>机制处理完毕，可直接使用</p></blockquote><h2 id="获取windowmanagerservice"><a class="markdownIt-Anchor" href="#获取windowmanagerservice"></a> 获取<code>WindowManagerService</code></h2><p>我们看下<code>ViewRootImpl</code>的构造函数中是如何获取到<code>WindowManagerService</code>的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title function_">getWindowSession</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowSession == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">InputMethodManager</span> <span class="variable">imm</span> <span class="operator">=</span> InputMethodManager.getInstance();</span><br><span class="line">                <span class="comment">//获取WindowManagerService</span></span><br><span class="line">                <span class="type">IWindowManager</span> <span class="variable">windowManager</span> <span class="operator">=</span> getWindowManagerService();</span><br><span class="line">                sWindowSession = windowManager.openSession(</span><br><span class="line">                        imm.getClient(), imm.getInputContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取WindowManagerService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IWindowManager <span class="title function_">getWindowManagerService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowManagerService == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//aidl</span></span><br><span class="line">            sWindowManagerService = IWindowManager.Stub.asInterface(</span><br><span class="line">            ServiceManager.getService(<span class="string">&quot;window&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowManagerService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>getWindowSession</code>方法中，<code>FrameWork</code>层首先通过<code>getWindowManagerService</code>方法获取<code>IWindowManager</code>对象，该函数中通过<code>ServiceManager</code>.<code>getService</code>方法获取<code>WMS</code>，并且将<code>WMS</code>转换为<code>IWindowManager</code>类型，我们先看看<code>ServiceManager</code>.<code>getService</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IBinder <span class="title function_">getService</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">IBinder</span> <span class="variable">service</span> <span class="operator">=</span> sCache.get(name);</span><br><span class="line">        <span class="keyword">if</span> (service != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> service;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Binder.allowBlocking(getIServiceManager().getService(name));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;error in getService&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从程序中可以看到<code>ServiceManager.getService</code>返回的是一个<code>IBinder</code>对象，也就是说<code>Android Framework</code>层与<code>WMS</code>之间也是通过<code>Binder</code>机制进行通讯。获取<code>WMS</code>之后，又调用<code>IWindowManager</code>.<code>Stub</code>类的<code>asInterface</code>方法，看到这里我们就会想起<code>AIDL</code>，详情请看这篇文章<a href="https://www.jianshu.com/p/8624a5fdf03f">理解AIDL</a>  ，将获取到的<code>WMS</code>的<code>IBinder</code>对象转换成<code>WindowManager</code>对象，最后，通过<code>openSession</code>函数来与<code>WMS</code>建立一个通信会话，相当于<code>Framework</code>层与<code>native</code>层建立了一个长期合作的”办事处“，双方有什么需求都通过这个<code>Session</code>来交换信息。</p><h2 id="viewrootimpl的setview方法"><a class="markdownIt-Anchor" href="#viewrootimpl的setview方法"></a> <code>ViewRootImpl</code>的<code>setView</code>方法</h2><p>与<code>WMS</code>建立<code>Session</code>后就到了<code>ViewRootImpl</code>的<code>setView</code>方法了，该方法会向<code>WMS</code>发起显示<code>Dialog</code>或者<code>Activity</code>中的<code>DecorView</code>请求，具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Schedule the first layout -before- adding to the window</span></span><br><span class="line">            <span class="comment">// manager, to make sure we do the relayout before receiving</span></span><br><span class="line">            <span class="comment">// any other events from the system.</span></span><br><span class="line">            <span class="comment">//请求布局</span></span><br><span class="line">            requestLayout();</span><br><span class="line">            <span class="comment">//向WMS发起请求</span></span><br><span class="line">            res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                        getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                        mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setView</code>过程比较复杂，但我们只需要关注两步:</p><ul><li><strong>requestLayout</strong></li><li>向 <strong><code>WMS</code></strong> 发起显示当前 <strong><code>Window</code></strong> 请求</li></ul><h3 id="viewrootimpl的requestlayout过程"><a class="markdownIt-Anchor" href="#viewrootimpl的requestlayout过程"></a> <code>ViewRootImpl</code>的<code>requestLayout</code>过程</h3><p>我们再来看下<code>requestLayout</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">requestLayout</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//发起绘制</span></span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">scheduleTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="literal">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">//注意第二个参数，第一个第三个省略</span></span><br><span class="line">        mChoreographer.postCallback(...  , mTraversalRunnable , ... );</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建子线程去绘制</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="type">TraversalRunnable</span> <span class="variable">mTraversalRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TraversalRunnable</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">doTraversal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//绘制入口</span></span><br><span class="line">    performTraversals();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会执行<code>performTraversals</code>();方法，这是一个极其复杂有非常重要的函数。主要做了如下操作：</p><ul><li>获取 <strong><code>Surface</code></strong> 对象，同于图形绘制</li><li>测量视图树中各个 <strong><code>View</code></strong> 的大小, <strong><code>performMeasure</code></strong></li><li>摆放整个视图树,<strong><code>performLayout</code></strong></li><li>绘制整棵视图树,<strong><code>performDraw</code></strong></li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performTraversals</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//会调用View的onMeasure</span></span><br><span class="line">    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    <span class="comment">//会调用View的onLayout</span></span><br><span class="line">    performLayout(lp, mWidth, mHeight);</span><br><span class="line">    <span class="comment">//会调用View的Draw</span></span><br><span class="line">    performDraw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>performDraw</code>方法中，<code>Framework</code>层获取到图形绘制表面的<code>Surface</code>对象，然后获取它的可绘制区域，也就是我们的<code>Canvas</code>对象，然后<code>Framework</code>在这个<code>Canvas</code>对象上绘制，具体代码如下;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">performDraw</span><span class="params">()</span> &#123;</span><br><span class="line">  </span><br><span class="line">        draw(fullRedrawNeeded);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">(<span class="type">boolean</span> fullRedrawNeeded)</span> &#123;</span><br><span class="line">    <span class="comment">//获取绘制表面</span></span><br><span class="line">    <span class="type">Surface</span> <span class="variable">surface</span> <span class="operator">=</span> mSurface;</span><br><span class="line">    <span class="keyword">if</span> (!surface.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</span><br><span class="line">        <span class="comment">//使用GPU绘制，也就是硬件加速</span></span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="literal">null</span> &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">            ...</span><br><span class="line">            mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//使用CPU绘制图形</span></span><br><span class="line">            <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>draw</code>方法中会获取到需要绘制的区域，以及判断是否使用<code>GPU</code>进行绘制。通常情况下使用的是<code>CPU</code>绘制，也就是调用的是<code>drawSoftware</code>()。我们看看该函数的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用CPU绘制</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="type">int</span> xoff, <span class="type">int</span> yoff,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> scalingRequired, Rect dirty)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw with software renderer.</span></span><br><span class="line">    <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取指定区域的获取指定区域的Canvas对象对象，用于绘制</span></span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//从DecorView开始绘制，也就是整个Window的根视图，整棵树都会绘制</span></span><br><span class="line">        mView.draw(canvas);     </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//释放Canvas锁，然后通知Surface更新这块区域，与开头照应</span></span><br><span class="line">            surface.unlockCanvasAndPost(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上所述，上述的视图树绘制代码主要分为下面几个步骤：</p><ul><li>判断是 <strong><code>CPU</code></strong> 还是 <strong><code>GPU</code></strong> 绘制</li><li>获取绘制表面的 <strong><code>Surface</code></strong> 对象</li><li>通过 <strong><code>Surface</code></strong> 对象获取并锁住 <strong><code>Canvas</code></strong> 绘图对象</li><li>从 <strong><code>DecorView</code></strong> 开始发起整颗树的绘制流程</li><li><strong><code>Surface</code></strong> 对象解锁 <strong><code>Canvas</code></strong> ，并通知 <strong><code>SurfaceFlinger</code></strong> 更新视图</li></ul><p>了解具体View的三大流程请看文章：</p><ul><li><a href="https://www.jianshu.com/p/a790982fd20e">深入理解MeasureSpec</a></li><li><a href="https://www.jianshu.com/p/166889b91ada">View的工作流程-measure过程</a></li><li><a href="https://www.jianshu.com/p/f690435629ab">View的工作流程-layout过程</a></li><li><a href="https://www.jianshu.com/p/f5e0c8636e54">View的工作流程-Draw过程</a></li></ul><p>以上就是整个视图的绘制过程，但是此时<code>Dialog</code>或者<code>Activity</code>的<code>View</code>并不能显示在手机屏幕上，<code>WMS</code>只是负责管理手机上的<code>View</code>，也就是说<code>WMS</code>管理当前状态下那个<code>View</code>应该显示在最上层。其实<code>WMS</code>管理的并不是<code>Window</code>，而是<code>View</code>，只不过他管理的是属于某个<code>WIndow</code>下的<code>View</code>。</p><h3 id="viewrootimpl请求wms添加window过程"><a class="markdownIt-Anchor" href="#viewrootimpl请求wms添加window过程"></a> <code>ViewRootImpl</code>请求<code>WMS</code>添加<code>Window</code>过程</h3><p>我们上面只是分析了<code>ViewRootImpl</code>的<code>requestLayout</code>过程，下面再回到<code>ViewRootImpl</code>的<code>setView</code>方法，绘制完成接着会通过<code>WindowSession</code>最终来完成<code>WIndow</code>的添加过程，在下面的代码中<code>mWindowSession</code>的类型是<code>IWindowSession</code>，它也是一个<code>Binder</code>对象，真正的实现类是<code>Session</code>，也就是<code>Window</code>的添加过程是一次<code>IPC</code>调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">         getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">         mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">         mAttachInfo.mOutsets, mInputChannel);</span><br></pre></td></tr></table></figure><p>在Session内部会通过<code>WindowManagerService</code>来实现<code>Window</code>的添加，代码如下：</p><p><strong><code>frameworks\base\services\core\java\com\android\server\wm\Session.java</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addToDisplay</span><span class="params">(IWindow window, <span class="type">int</span> seq, WindowManager.LayoutParams attrs,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> viewVisibility, <span class="type">int</span> displayId, Rect outContentInsets, Rect outStableInsets,</span></span><br><span class="line"><span class="params">        Rect outOutsets, InputChannel outInputChannel)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> mService.addWindow(<span class="built_in">this</span>, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">            outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样<code>Window</code>的添加过程就交给了<code>WindowManagerService</code>去处理了，在WMS内部会保留一个单独的<code>Session</code>。具体<code>Window</code>在<code>WMS</code>内部如何添加的，本篇不对分析，至此对于<code>View</code>的绘制以及视图如何添加到<code>Window</code>整个流程已经很明了了。关于<code>WMS</code>和<code>Surface</code>系统的细节可以参考市面上关于源码的书籍。我们看下<code>Window</code>的删除过程</p><h3 id="windowmanagerglobal的removeview过程"><a class="markdownIt-Anchor" href="#windowmanagerglobal的removeview过程"></a> WindowManagerGlobal的removeView过程</h3><p><code>Window</code>的删除过程和添加过程一样，都是先通过<code>WIndowManagerImpl</code>后，在进一步通过<code>WindowManagerGlobal</code>来实现删除，下面是<code>WindowManagerGlobal</code>的<code>removeView</code>的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeView</span><span class="params">(View view, <span class="type">boolean</span> immediate)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> findViewLocked(view, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">View</span> <span class="variable">curView</span> <span class="operator">=</span> mRoots.get(index).getView();</span><br><span class="line">        removeViewLocked(index, immediate);</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>removeView</code> 的过程很清晰，首先通过<code>findViewLoched</code>来查找待删除<code>View</code>的索引，这个查找过程就是建立的数组遍历，然后再调用<code>removeViewLocked</code>来做进一步的删除，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeViewLocked</span><span class="params">(<span class="type">int</span> index, <span class="type">boolean</span> immediate)</span> &#123;</span><br><span class="line">    <span class="type">ViewRootImpl</span> <span class="variable">root</span> <span class="operator">=</span> mRoots.get(index);</span><br><span class="line">    <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> root.getView();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">InputMethodManager</span> <span class="variable">imm</span> <span class="operator">=</span> InputMethodManager.getInstance();</span><br><span class="line">        <span class="keyword">if</span> (imm != <span class="literal">null</span>) &#123;</span><br><span class="line">            imm.windowDismissed(mViews.get(index).getWindowToken());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">deferred</span> <span class="operator">=</span> root.die(immediate);</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="literal">null</span>) &#123;</span><br><span class="line">        view.assignParent(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (deferred) &#123;</span><br><span class="line">            mDyingViews.add(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>removeViewLocked</code>是通过<code>ViewRootImpl</code>来完成删除操作的。在<code>WindowManager</code>中提供了两个接口<code>removeView</code>和<code>removeViewImmediate</code>，分别表示异步删除和同步删除，一般不使用同步删除，以免发生意外的错误，这里主要说下异步删除的情况，具体的异步删除操作是由<code>ViewRootImpl</code>的<code>die</code>方法完成，在异步删除的情况下，<code>die</code>方法只是发送了一个请求删除的消息后就立刻返回了，这个时候<code>View</code>并没有完成删除操作，所以最后会将其添加到<code>WindowManagerGlobal</code>的待删除列表<code>mDyingViews</code>中，看下<code>ViewRootImpl</code>的<code>die</code>方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">die</span><span class="params">(<span class="type">boolean</span> immediate)</span> &#123;</span><br><span class="line">    <span class="comment">//同步删除  直接调用doDie，并返回</span></span><br><span class="line">    <span class="keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123;</span><br><span class="line">        doDie();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//发送handler消息</span></span><br><span class="line">    mHandler.sendEmptyMessage(MSG_DIE);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>die</code>方法内部只是做了简单的判断，如果是异步删除，那么就发送一个 <strong><code>MSG_DIE</code></strong> 的消息，<code>ViewRootImpl</code>中的<code>Handler</code>会调用<code>doDie</code>方法，如果是同步删除，就不发送消息，直接调用<code>doDie</code>方法，这就是这两种方法的区别。在<code>doDie</code>方法中会调用<code>dispatchDetachedFromWindow</code>方法，真正删除<code>View</code>的逻辑在<code>dispatchDetachedFromWindow</code>内部实现，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">void</span> <span class="title function_">doDie</span><span class="params">()</span> &#123;</span><br><span class="line">     dispatchDetachedFromWindow();</span><br><span class="line">     <span class="comment">//将WindowManagerGlobal的列表中移除保存的ViewRootImpl、View、Param</span></span><br><span class="line">     WindowManagerGlobal.getInstance().doRemoveView(<span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dispatchDetachedFromWindow</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">//调用View的dispatchDetachedFromWindow();</span></span><br><span class="line">     mView.dispatchDetachedFromWindow();</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">//Session中的remove</span></span><br><span class="line">     mWindowSession.remove(mWindow);</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br><span class="line">     </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(IWindow window)</span> &#123;</span><br><span class="line">     <span class="comment">//WMS移除Window</span></span><br><span class="line">     mService.removeWindow(<span class="built_in">this</span>, window);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//WindowManagerGlobal中移除保存的ViewRootImpl、View、Param</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">doRemoveView</span><span class="params">(ViewRootImpl root)</span> &#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> mRoots.indexOf(root);</span><br><span class="line">         <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">             mRoots.remove(index);</span><br><span class="line">             mParams.remove(index);</span><br><span class="line">             <span class="keyword">final</span> <span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> mViews.remove(index);</span><br><span class="line">             mDyingViews.remove(view);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以上代码主要做了一下事情：</p><ul><li>垃圾回收相关的工作，比如清除数据和消息，移除回调</li><li>通过 <strong><code>Session</code><strong>的</strong><code>remove</code><strong>方法删除</strong><code>Window</code></strong>，同样也是一个**<code>IPC</code><strong>过程，最终会调用</strong><code>WMS</code><strong>的</strong><code>removeView</code>** 方法</li><li>调用 <strong><code>View</code><strong>的</strong><code>dispatchDetachedFromWindow</code><strong>方法，对于</strong>View</strong>的**<code>dispatchDetachedFromWindow</code><strong>我们不陌生，当</strong><code>View</code><strong>从</strong><code>Window</code>** 中移除时，这个方法就会被调用，可以在这个方法内部做一些资源回收的工作，比如终止动画、停止线程。</li><li>调用 **<code>WindowManagerGlobal</code>**的 **<code>doRemoveView</code>**方法刷新数据，包括 <strong><code>mViews</code>、<code>mRoots</code>、<code>mParams</code>、<code>mDyingViews</code></strong>，需要将当前 <strong><code>Window</code></strong> 所关联的这三类对象从列表中删除。</li></ul><h3 id="windowmanagerglobal的updateviewlayout过程"><a class="markdownIt-Anchor" href="#windowmanagerglobal的updateviewlayout过程"></a> <code>WindowManagerGlobal</code>的<code>updateViewLayout</code>过程</h3><p><code>Window</code>的删除过程我们已经分析完了，下面看下<code>WIndow</code>的更新过程，还是要从<code>WindowManagerGlobal</code>的<code>updateViewLayout</code>说起，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">final</span> WindowManager.<span class="type">LayoutParams</span> <span class="variable">wparams</span> <span class="operator">=</span> (WindowManager.LayoutParams)params;</span><br><span class="line"></span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> findViewLocked(view, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">ViewRootImpl</span> <span class="variable">root</span> <span class="operator">=</span> mRoots.get(index);</span><br><span class="line">        mParams.remove(index);</span><br><span class="line">        mParams.add(index, wparams);</span><br><span class="line">        root.setLayoutParams(wparams, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updateViewLayout</code>方法做的事情就比较简单了，首先他需要更新View的<code>LayoutParams</code>并替换老的<code>LayoutParams</code>，接着再更新<code>ViewRootImpl</code>中的<code>LayoutParams</code>,这一步是通过<code>ViewRootImpl</code>的<code>setLayoutParams</code>方法来实现的。在<code>ViewRootImpl</code>的<code>setLayoutParams</code>中会通过<code>scheduleTraversals</code>方法来对<code>View</code>重新测量布局以及绘制这三个过程，在<code>performTraversales</code>会通过<code>WindowSession</code>来更新<code>Window</code>视图，这个过程最终是由<code>WMS</code>的<code>relayoutWindow</code>来具体实现的，同样也是一个<strong>IPC</strong>过程。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ul><li>《Android开发艺术探索》</li><li>《Android源码设计模式》</li></ul><p>作者：Android天之骄子<br />链接：<a href="https://www.jianshu.com/p/1c4059d3865b">https://www.jianshu.com/p/1c4059d3865b</a><br />来源：简书<br />著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Drawable 解析</title>
      <link href="/2022/04/16/Drawable-%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/04/16/Drawable-%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h1><p><code>Drawable</code>是一个抽象类，表示的是一个图像的概念。每一个具体的<code>Drawable</code>都是其子类。</p><p><strong>优点：</strong></p><ol><li>使用简单，比自定义<code>View</code>的成本要低。</li><li>非图片类型的<code>Drawable</code>占用空间较小，可以有效的减少<code>apk</code>的大小。</li></ol><p><strong>内部宽/高：</strong></p><p><code>Drawable</code>有个参数比较重要，就是<strong>内部宽/高</strong>，通过<code>getIntrinsicWidth</code>和<code>getIntrinsicHeight</code>方法获得。</p><p>但是并不是所有的<code>Drawable</code>都有这两个参数，比如纯颜色的<code>Drawable</code>就没有内部宽/高的概念，它的两个值都为<code>-1</code>，它的大小就是<code>View</code>的大小，而图片类型的<code>Drawable</code>的内部宽/高决定了这个图片的固定大小。</p><h1 id="drawable的分类"><a class="markdownIt-Anchor" href="#drawable的分类"></a> <code>Drawable</code>的分类</h1><p><code>Drawable</code>的子类有许多，这里简单的说几个，具体的参数参考《Android开发艺术探索》Page 244。</p><ul><li><p><code>BitmapDrawable</code></p><p>表示一张图片。</p></li><li><p><code>NinePatchDrawable</code></p><p>表示一个.9格式的图片。</p></li><li><p><code>ShapeDrawable</code></p><p>表示通过颜色（纯色、渐变色）来表示的图形。</p></li><li><p><code>LayerDrawable</code></p><p><code>XML</code>中的标签为<code>&lt;layer-list&gt;</code>，表示的是一组层次化的<code>Drawable</code>集合，最终的效果是由上到下的<code>Drawable</code>的效果依次叠加。</p></li><li><p><code>StateListDrawable</code></p><p><code>XML</code>中的标签为<code>&lt;selector&gt;</code>，表示一个<code>Drawable</code>集合，每个<code>Drawable</code>对应着<code>View</code>的一种状态，系统会根据<code>View</code>的不同状态更换不同的<code>Drawable</code>。常见的使用场景为<code>Button</code>的按下与弹起。</p></li><li><p><code>LevelListDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;level-list&gt;</code>，表示的是一个<code>Drawable</code>集合，其中的每一个<code>Drawable</code>都有一个等级(<code>level</code>)的概念，系统在不同的<code>level</code>下自动更换为不同的<code>Drawable</code>。</p></li><li><p><code>TransitionDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;transition&gt;</code>，其作用是实现两个<code>Drawable</code>之间的淡入淡出效果。</p></li><li><p><code>InsetDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;inset&gt;</code>，可以将其他的<code>Drawable</code>内嵌到自己的<code>Drawable</code>中，并在四周留出一定的空间。其最终显示效果为内嵌的<code>Drawable</code>的显示范围相较于不使用<code>InsetDrawable</code>时变小。</p></li><li><p><code>ScaleDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;scale&gt;</code>，其可以根据自身<code>Drawable</code>所设置的等级(<code>level</code>)对其内部的<code>Drawable</code>实现缩放的效果。</p><p>当其<code>level</code>为<code>0</code>时，其内部的<code>Drawable</code>为不可见状态；为非<code>0</code>的值时，按照<code>XML</code>中的写入的缩放比例进行显示。</p><p><code>level</code>的值默认为<code>0</code>，需要在代码中自行赋值，<strong>系统内部约定<code>Drawable</code>的等级范围为<code>0</code>-<code>10000</code></strong>。</p></li><li><p><code>ClipDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;clip&gt;</code>，可以根据自己当前的等级(<code>level</code>)来裁剪另一个<code>Drawable</code>，裁剪的方向可以通过<code>android:clipOrientation</code>和<code>android:gravity</code>共同限制。</p><p>当其<code>level</code>的值为<code>0</code>时，表示完全裁剪，即整个<code>Drawable</code>变为不可见的状态；当<code>level</code>的值设置为<code>10000</code>时，表示不裁剪；</p><p>当<code>level</code>的值设置为<code>8000</code>时，表示裁剪了2000的区域，即裁剪<code>20%</code>。 m</p></li></ul><h1 id="自定义drawable"><a class="markdownIt-Anchor" href="#自定义drawable"></a> 自定义<code>Drawable</code></h1><p><code>Drawable</code>的使用场景很少，通常用在<code>View</code>的背景和作为<code>ImageView</code>中的图片两个场景。</p><p>由于自定义的<code>Drawable</code>无法在<code>XML</code>中使用，但是我们可以有其他轻便的方法来自定义<code>Drawable</code>。</p><p>通过<code>View</code>的工作原理可以知道，系统通过<code>Drawable</code>的<code>draw</code>方法来绘制<code>View</code>的背景，所以我们可以继承<code>Drawable</code>并重写<code>Drawable</code>的<code>draw</code>方法来实现自定义<code>Drawable</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Drawable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal 解析 [转载]</title>
      <link href="/2022/04/16/ThreadLocal-%E8%A7%A3%E6%9E%90-%E8%BD%AC%E8%BD%BD/"/>
      <url>/2022/04/16/ThreadLocal-%E8%A7%A3%E6%9E%90-%E8%BD%AC%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文转载自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/61652864">Android进阶知识：ThreadLocal - Android架构</a></li></ul></blockquote><hr /><h3 id="threadlocal是什么"><a class="markdownIt-Anchor" href="#threadlocal是什么"></a> <code>ThreadLocal</code>是什么？</h3><p><code>ThreadLocal</code>是一个线程内部数据存储类，通过他可以在指定的线程中存储数据。存储后，只能在指定的线程中获取到存储的数据，对其他线程来说无法获取到数据。</p><h3 id="threadlocal的使用场景"><a class="markdownIt-Anchor" href="#threadlocal的使用场景"></a> <code>ThreadLocal</code>的使用场景</h3><p>日常使用场景不多，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，可以考虑使用<code>ThreadLocal</code>。 <code>Android</code>源码的<code>Lopper</code>、<code>ActivityThread</code>以及<code>AMS</code>中都用到了<code>ThreadLocal</code>。</p><h3 id="threadlocal的使用示例"><a class="markdownIt-Anchor" href="#threadlocal的使用示例"></a> <code>ThreadLocal</code>的使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line"><span class="keyword">private</span> ThreadLocal&lt;String&gt; name = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_thread_local);</span><br><span class="line">    name.set(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    Log.d(<span class="string">&quot;ThreadLocalActivity&quot;</span>, <span class="string">&quot;Thread:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; name:&quot;</span> + name.get());</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;thread1&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            name.set(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">            Log.d(<span class="string">&quot;ThreadLocalActivity&quot;</span>, <span class="string">&quot;Thread:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; name:&quot;</span> + name.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;thread2&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            Log.d(<span class="string">&quot;ThreadLocalActivity&quot;</span>, <span class="string">&quot;Thread:&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; name:&quot;</span> + name.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D/ThreadLocalActivity: Thread:main name:小明  </span><br><span class="line">D/ThreadLocalActivity: Thread:thread1 name:小红  </span><br><span class="line">D/ThreadLocalActivity: Thread:thread2 name:null</span><br></pre></td></tr></table></figure><p>可以看到虽然访问的是同一个<code>ThreadLocal</code>对象，但是获取到的值却是不一样的。</p><h3 id="threadlocal的源码阅读"><a class="markdownIt-Anchor" href="#threadlocal的源码阅读"></a> <code>ThreadLocal</code>的源码阅读</h3><p>那么为什么会造成这样的结果呢？这就需要去看看<code>ThreadLocal</code>的源码实现，这里的源码版本为<code>API28</code>。主要看它的<code>get</code>和<code>set</code>方法。<br /><code>set</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set</code>方法中首先获取了当前线程对象，然后通过<code>getMap</code>方法传入当前线程<code>t</code>获取到一个<code>ThreadLocalMap</code>，接下来判断这个<code>map</code>是否为空，不为空就直接将当前<code>ThreadLocal</code>作为<code>key</code>，<code>set</code>方法中传入要保存的值最为<code>value</code>，存放到<code>map</code>中；如果<code>map</code>为空就调用<code>createMap</code>方法创建一个<code>map</code>并同样将当前<code>ThreadLocal</code>和要保存的值作为<code>key</code>和<code>value</code>加入到<code>map</code>中。<br />接下先看<code>getMap</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getMap</code>方法比较简单，就是返回从传入的当前线程对象的成员变量<code>threadLocals</code>。 接着是<code>createMap</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createMap</code>方法也很简单就是<code>new</code>了一个<code>ThreadLocalMap</code>并赋给当前线程对象<code>t</code>中的<code>threadLocals</code>。 原来这个<code>Map</code>是存放在<code>Thread</code>类中的。于是进入<code>Thread</code>类中查看。<br /><code>Thread.java</code>第188-190行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>根据这里的注释可以得知，每个线程<code>Thread</code>中都有一个<code>ThreadLocalMap</code>类型的<code>threadLocals</code>成员变量来保存数据，通过<code>ThreadLocal</code>类来进行维护。这样看来我们每次在不同线程调用<code>ThreadLocal</code>的<code>set</code>方法<code>set</code>的数据是存在不同线程的<code>ThreadLocalMap</code>中的，就像注释说的<code>ThreadLocal</code>只是起了个维护<code>ThreadLocalMap</code>的功能。想到是<code>get</code>方法同样也是到不同线程的<code>ThreadLocalMap</code>去取数据。<br /><code>get</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然，<code>get</code>方法中同样是先获取当前线程对象，然后在拿着这个对象<code>t</code>去获取到<code>t</code>中的<code>ThreadLocalMap</code>，只要<code>map</code>不等于<code>null</code>就调用<code>map.getEntry(this)</code>方法来获取数据，因为<code>ThreadLocalMap</code>里使用一个内部类<code>Entry</code>来存储数据的，所以调用<code>getEntry(this)</code>方法，传入的<code>key</code>是当前的<code>ThreadLocal</code>。这样获取到<code>Entry</code>类型数据<code>e</code>，只要<code>e</code>不为<code>null</code>，返回<code>e.value</code>即先前存储的数据。如果获取到的<code>map</code>为<code>null</code>又或者根据<code>key</code>获取<code>Entry</code>为<code>null</code>，就调用<code>setInitialValue</code>方法初始化一个<code>value</code>返回。<br /><code>setInitialValue</code>和<code>initialValue</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setInitialValue</code>方法中首先调用<code>initialValue</code>方法初始化了一个空<code>value</code>，之后的操作和<code>set</code>方法相同，将这个空的<code>value</code>加入到当前线程的<code>ThreadLocalMap</code>中去，<code>ThreadLocalMap</code>为空就创建个<code>Map</code>，最后返回这个空值。<br />至此，<code>ThreadLocal</code>的<code>get</code>、<code>set</code>方法就都看过了，也理解了<code>ThreadLocal</code>可以在多个线程中操作而互不干扰的原因。但是<code>ThreadLocal</code>还有一个要注意的地方就是<code>ThreadLocal</code>使用不当会造成内存泄漏。</p><h3 id="threadlocal内存泄漏的原因"><a class="markdownIt-Anchor" href="#threadlocal内存泄漏的原因"></a> <code>ThreadLocal</code>内存泄漏的原因</h3><p>内存泄漏的根本原因是当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，导致本该被回收的对象不能被回收而停留在堆内存中。那么<code>ThreadLocal</code>中是在哪里发生的呢？这就要看到<code>ThreadLocalMap</code>中存储数据的内部类<code>Entry</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/91ef76c6a7efce1b563edc5501a900dbb58f6512.jpeg" alt="img" /></p><p>可以看到这个<code>Entry</code>类，这里的<code>key</code>是使用了个弱引用，所以因为使用弱引用这里的<code>key</code>，<code>ThreadLocal</code>会在<code>JVM</code>下次<code>GC</code>回收时候被回收，而造成了个<code>key</code>为<code>null</code>的情况，而外部<code>ThreadLocalMap</code>是没办法通过<code>null</code> <code>key</code>来找到对应<code>value</code>的。如果当前线程一直在运行，那么线程中的<code>ThreadLocalMap</code>也就一直存在，而<code>map</code>中却存在<code>key</code>已经被回收为<code>null</code>对应的<code>Entry</code>和<code>value</code>却一直存在不会被回收，造成内存的泄漏。<br />不过，这一点设计者也考虑到了，在<code>get()</code>、<code>set()</code>、<code>remove()</code>方法调用的时候会清除掉线程<code>ThreadLocalMap</code>中所有<code>Entry</code>中<code>Key</code>为<code>null</code>的<code>Value</code>，并将整个<code>Entry</code>设置为<code>null</code>，这样在下次回收时就能将<code>Entry</code>和<code>value</code>回收。<br />这样看上去好像是因为<code>key</code>使用了弱引用才导致的内存泄漏，为了解决还特意添加了清除<code>null key</code>的功能，那么是不是不用弱引用就可以了呢？<br />很显然不是这样的。设计者使用弱引用是由原因的。</p><ul><li>如果使用强引用，那么如果在运行的线程中<code>ThreadLocal</code>对象已经被回收了但是<code>ThreadLocalMap</code>还持有<code>ThreadLocal</code>的强引用，若是没有手动删除，<code>ThreadLocal</code>不会被回收，同样导致内存泄漏。</li><li>如果使用弱引用<code>ThreadLocal</code>的对象被回收了，因为<code>ThreadLocalMap</code>持有的是<code>ThreadLocal</code>的弱引用，即使没有手动删除，<code>ThreadLocal</code>也会被回收。<code>nullkey</code>的<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set</code>、<code>get</code>、<code>remove</code>的时候会被清除。</li></ul><p>所以，由于<code>ThreadLocalMap</code>和线程<code>Thread</code>的生命周期一样长，如果没有手动删除<code>Map</code>的中的<code>key</code>，无论使用强引用还是弱引用实际上都会出现内存泄漏，但是使用弱引用可以多一层保护，<code>null key</code>在下一次<code>ThreadLocalMap</code>调用<code>set</code>、<code>get</code>、<code>remove</code>的时候就会被清除。 因此，<code>ThreadLocal</code>的内存内泄漏的真正原因并不能说是因为<code>ThreadLocalMap的key</code>使用了弱引用，而是因为<code>ThreadLocalMap</code>和线程<code>Thread</code>的生命周期一样长，没有手动删除<code>Map</code>的中的<code>key</code>才会导致内存泄漏。所以解决<code>ThreadLocal</code>的内存泄漏问题就要每次使用完<code>ThreadLocal</code>，都要记得调用它的<code>remove()</code>方法来清除。</p><p><img src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/20191223161153316.png" alt="在这里插入图片描述" /></p><p>总结一波：</p><p>（1）每个Thread维护着一个<code>ThreadLocalMap</code>的引用</p><p>（2）<code>ThreadLocalMap</code>是<code>ThreadLocal</code>的内部类，用Entry来进行存储</p><p>（3）<code>ThreadLocal</code>创建的副本是存储在自己的<code>threadLocals</code>中的，也就是自己的<code>ThreadLocalMap</code>。</p><p>（4）<code>ThreadLocalMap</code>的键值为<code>ThreadLocal</code>对象，而且可以有多个<code>threadLocal</code>变量，因此保存在<code>map</code>中</p><p>（5）在进行<code>get</code>之前，必须先<code>set</code>，否则会报空指针异常，当然也可以初始化一个，但是必须重写<code>initialValue</code>()方法。</p><p>（6）<code>ThreadLocal</code>本身并不存储值，它只是作为一个<code>key</code>来让线程从<code>ThreadLocalMap</code>获取<code>value</code>。</p><p>OK，现在从源码的角度上不知道你能理解不，对于<code>ThreadLocal</code>来说关键就是内部的<code>ThreadLocalMap</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Handler 机制解析</title>
      <link href="/2022/04/16/Handler-%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/04/16/Handler-%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文整理自：</p><ul><li>《Android 开发艺术探索》</li><li><a href="https://blog.csdn.net/zhanglianyu00/article/details/70842494">Handler sendMessageDelayed()/postDelayed()机制详解</a></li><li><a href="https://www.cnblogs.com/neo-java/p/6830681.html">主线程中的Looper.loop()为什么不会造成ANR</a></li></ul></blockquote><hr /><h1 id="handler机制组成部分"><a class="markdownIt-Anchor" href="#handler机制组成部分"></a> <code>Handler</code>机制组成部分</h1><p><code>Hanler</code>机制中的几个重要的组成部分：</p><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td><code>ThreadLocal</code></td><td>将消息转存入其他指定的线程中</td></tr><tr><td><code>MessageQueue</code></td><td>消息队列，用于存储当前线程的转存入的消息</td></tr><tr><td><code>Looper</code></td><td>消息循环，不断的监控消息队列并从其中取出消息并处理</td></tr><tr><td><code>Handler</code></td><td>负责发送消息以及处理消息</td></tr></tbody></table><h1 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h1><ul><li><p>常用于在其他线程中处理UI操作。</p></li><li><p>在处理消息的线程中定义一个<code>Handler</code>，若该线程中没有定义<code>Looper</code>，则需要先定义<code>Looper</code>，否则会报错。其中主线程的<code>Looper</code>已在启动的时候默认加载了，所以在主线程中无需先定义<code>Looper</code>。</p></li><li><p>当在其中线程中需要进行UI操作的时候，需要在该线程中使用主线程的<code>Handler</code>变量的<code>sendMessage</code>方法或者<code>post</code>方法。</p></li></ul><h1 id="threadlocal注意"><a class="markdownIt-Anchor" href="#threadlocal注意"></a> <code>ThreadLocal</code>注意</h1><p><code>ThreadLocal</code>在<code>API21</code>以及<code>API28</code>中的代码实现方法不同：</p><ul><li>由<code>localValues</code>数组变为<code>TheadLocalMap</code>类。</li><li><code>ThreadLocalMap</code>为弱引用。</li></ul><h1 id="looper注意"><a class="markdownIt-Anchor" href="#looper注意"></a> <code>Looper</code>注意</h1><ul><li><code>Looper</code>每个线程只有一个，除主线程外的线程默认不自动加载，需要自己主动使用<code>Looper.prepare()</code>方法加载。</li><li>另外需要<code>looper.loop()</code>方法启动<code>Looper</code>。</li><li><code>Looper</code>启动时会同时加载<code>MessageQueue</code>。</li><li>推出<code>Looper</code>是可以使用<code>Looper#quit</code>或者<code>Looper#quitSafely</code>方法。</li></ul><h1 id="机制分析"><a class="markdownIt-Anchor" href="#机制分析"></a> 机制分析</h1><p>从<code>handler.sendMessage(Message msg)</code>出发，分析整个<code>Handler</code>的消息处理机制。</p><h2 id="handlersendmessage方法"><a class="markdownIt-Anchor" href="#handlersendmessage方法"></a> <code>Handler#sendMessage</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">sendMessageDelayed</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> delayMillis)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMessageAtTime</span><span class="params">(<span class="meta">@NonNull</span> Message msg, <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                <span class="built_in">this</span> + <span class="string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);</span><br><span class="line">        Log.w(<span class="string">&quot;Looper&quot;</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(<span class="meta">@NonNull</span> MessageQueue queue, <span class="meta">@NonNull</span> Message msg,</span></span><br><span class="line"><span class="params">        <span class="type">long</span> uptimeMillis)</span> &#123;</span><br><span class="line">    msg.target = <span class="built_in">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>sendMessage</code>方法的调用，以及中间的多个方法的调用，最终调用了<code>enqueueMessage</code>方法中的<code>queue.enqueueMessage</code>方法，将消息加入了<code>MessageQueue</code>中。</p><h2 id="messagequeueenqueuemessage方法"><a class="markdownIt-Anchor" href="#messagequeueenqueuemessage方法"></a> <code>MessageQueue#enqueueMessage</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">enqueueMessage</span><span class="params">(Message msg, <span class="type">long</span> when)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Message must have a target.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(msg + <span class="string">&quot; This message is already in use.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    msg.target + <span class="string">&quot; sending message to a Handler on a dead thread&quot;</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">p</span> <span class="operator">=</span> mMessages;</span><br><span class="line">        <span class="type">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="literal">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="literal">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法比较简单，采用<strong>线程安全</strong>的方式将 <code>Message</code> 插入到消息队列中，插入的新消息有三种可能成为消息队列的 <code>head</code>：</p><ol><li><code>MessageQueue</code> 为空。</li><li>参数 <code>when</code> 为 0，因为此时 <code>when</code> 已经转成绝对时间，所以只有 <code>AtFrontOfQueue</code> 系列的 <code>API</code> 才会满足这个条件。</li><li>当前的 <code>head Message</code> 执行时间在 <code>when</code> 之后，即消息队列中无需要在此 <code>Message</code> 之前执行的 <code>Message</code>。</li></ol><h2 id="looperloop方法"><a class="markdownIt-Anchor" href="#looperloop方法"></a> <code>Looper#loop</code>方法</h2><p>同时<code>Looper</code>的<code>loop</code>方法不断监控<code>MessageQueue</code>中是否有待处理的消息，如果有的话，就调用<code>MessageQueue#next</code>方法，该方法将取出单链表第一个消息并返回给<code>looper</code>。</p><blockquote><p><code>MessageQueue#next</code>方法链表中没有消息的情况下不返回任何信息，直到中间有了新的消息后才取出，否则将一直等待。</p><p><code>Looper#loop</code>方法是会堵塞进程的方法，如果没有消息的话，就会继续永不停止的观测，直到<code>MessageQueue#next</code>能够返回出消息。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Looper</span> <span class="variable">me</span> <span class="operator">=</span> myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (me.mInLoop) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">&quot;Loop again would have the queued messages be executed&quot;</span></span><br><span class="line">                + <span class="string">&quot; before this one completed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    me.mInLoop = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ident</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">    <span class="comment">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">thresholdOverride</span> <span class="operator">=</span></span><br><span class="line">            SystemProperties.getInt(<span class="string">&quot;log.looper.&quot;</span></span><br><span class="line">                    + Process.myUid() + <span class="string">&quot;.&quot;</span></span><br><span class="line">                    + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">&quot;.slow&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Printer</span> <span class="variable">logging</span> <span class="operator">=</span> me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="literal">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                    msg.callback + <span class="string">&quot;: &quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">e.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> <span class="variable">dispatchStart</span> <span class="operator">=</span> needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">long</span> dispatchEnd;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">token</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">            token = observer.messageDispatchStarting();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">origWorkSource</span> <span class="operator">=</span> ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">                observer.messageDispatched(token, msg);</span><br><span class="line">            &#125;</span><br><span class="line">            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="literal">null</span>) &#123;</span><br><span class="line">                observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法的中间有<code>msg.target.dispatchMessage(msg);</code>这行代码。<code>msg.target</code>就是目标线程的<code>handler</code>对象，对该对象使用<code>Handler#dispatchMessage</code>方法，让其处理消息。</p><p>也就是说，取下一个消息的实际执行时间取决于上一个消息什么时候处理完。</p><h2 id="messagequeuenext方法"><a class="markdownIt-Anchor" href="#messagequeuenext方法"></a> <code>MessageQueue#next</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">Message <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ptr</span> <span class="operator">=</span> mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pendingIdleHandlerCount</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextPollTimeoutMillis</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis();</span><br><span class="line">            <span class="type">Message</span> <span class="variable">prevMsg</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span> &amp;&amp; msg.target == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="literal">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="literal">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                    mBlocked = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="literal">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> <span class="title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">IdleHandler</span> <span class="variable">idler</span> <span class="operator">=</span> mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="literal">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"> </span><br><span class="line">            <span class="type">boolean</span> <span class="variable">keep</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">&quot;IdleHandler threw exception&quot;</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到 next() 实际上也有一个 for(;😉，而出口只有两个：</p><ol><li>消息队列已经退出，返回null；</li><li>找到了一个合适的消息，将其返回。<br />如果没有合适的消息，或者消息队列为空，会block或者由IdleHandler处理，不在本文问题范畴，暂不展开。</li></ol><p>主要看找到合适的消息的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">        <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">        nextPollTimeoutMillis = (<span class="type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Got a message.</span></span><br><span class="line">        mBlocked = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (prevMsg != <span class="literal">null</span>) &#123;</span><br><span class="line">            prevMsg.next = msg.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessages = msg.next;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">&quot;Returning message: &quot;</span> + msg);</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No more messages.</span></span><br><span class="line">    nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到：</p><ol><li>如果在消息队列中顺序找到了一个消息 msg（前文分析过，消息队列的插入是由when顺序排列，所以如果当前的消息没有到执行时间，其后的也一定不会到），当前的系统时间小于 msg.when，那么会计算一个 timeout，以便在到执行时间时wake up；</li><li>如果当前系统时间大于或等于 msg.when，那么会返回msg给Looper.loop()。</li></ol><p>所以这个逻辑只能保证在 when 之前消息不被处理，不能够保证一定在when时被处理。很好理解：</p><ol><li>在 Loop.loop() 中是顺序处理消息，如果前一个消息处理耗时较长，完成之后已经超过了 when，消息不可能在 when 时间点被处理。</li><li>即使 when 的时间点没有被处理其他消息所占用，线程也有可能被调度失去 cpu 时间片。</li><li>在等待时间点 when 的过程中有可能入队处理时间更早的消息，会被优先处理，又增加了（1）的可能性。</li></ol><p><strong>所以由上述三点可知，Handler 提供的指定处理时间的 api 诸如 postDelayed() / postAtTime() / sendMessageDelayed() / sendMessageAtTime() ，只能保证在指定时间之前不被执行，不能保证在指定时间点被执行。</strong></p><h2 id="handlerdispatchmessage方法"><a class="markdownIt-Anchor" href="#handlerdispatchmessage方法"></a> <code>Handler#dispatchMessage</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Handle system messages here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dispatchMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="literal">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法一共有三个执行等级：</p><ol><li>如果传入的<code>Message</code>自己附带了UI操作的代码，那么就执行该代码。</li><li>如果<code>Message</code>没有附带的话，那么就是看<code>mCallback</code>是否存在，存在的话就执行该回调的<code>handleMessage</code>方法。</li><li>如果都不存在的话，就执行<code>handler</code>对象的<code>handleMessage</code>方法。</li></ol><h2 id="handlerhandlemessage方法"><a class="markdownIt-Anchor" href="#handlerhandlemessage方法"></a> <code>Handler#handleMessage</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses must implement this to receive messages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，<code>Handler#handleMessage</code>方法是一个空方法，所以需要我们在创建的时候就进行重写。</p><p>之后目标线程就可以执行想要其执行的操作了。</p><hr /><h1 id="相关面试问题"><a class="markdownIt-Anchor" href="#相关面试问题"></a> 相关面试问题</h1><h2 id="主线程中的-looperloop-为什么不会造成-anr"><a class="markdownIt-Anchor" href="#主线程中的-looperloop-为什么不会造成-anr"></a> 主线程中的 Looper.loop() 为什么不会造成 ANR</h2><p>正如我们所知，在android中如果主线程中进行耗时操作会引发ANR（Application Not Responding）异常。</p><blockquote><p>造成ANR的原因一般有两种：</p><ol><li>当前的事件没有机会得到处理（即主线程正在处理前一个事件，没有及时的完成或者looper被某种原因阻塞住了）。</li><li>当前的事件正在处理，但没有及时完成。</li></ol></blockquote><p>ActivityThread的main方法主要就是做消息循环，一旦退出消息循环，那么你的应用也就退出了。</p><p>我们知道了消息循环的必要性，那为什么这个死循环不会造成ANR异常呢？</p><p>因为Android 的是由事件驱动的，looper.loop() 不断地接收事件、处理事件，每一个点击触摸或者说Activity的生命周期都是运行在 Looper.loop() 的控制之下，如果它停止了，应用也就停止了。只能是某一个消息或者说对消息的处理阻塞了 Looper.loop()，而不是 Looper.loop() 阻塞它。</p><p>也就说我们的代码其实就是在这个循环里面去执行的，当然不会阻塞了。</p><p>Activity的生命周期都是依靠主线程的Looper.loop，当收到不同Message时则采用相应措施。</p><p>如果某个消息处理时间过长，比如你在onCreate(),onResume()里面处理耗时操作，那么下一次的消息比如用户的点击事件不能处理了，整个循环就会产生卡顿，时间一长就成了ANR。</p><p>主线程Looper从消息队列读取消息，当读完所有消息时，主线程阻塞。子线程往消息队列发送消息，并且往管道文件写数据，主线程即被唤醒，从 管道文件读取数据，主线程被唤醒只是为了读取消息，当消息读取完毕，再次睡眠。因此loop的循环并不会对CPU性能有过多的消耗。</p><p><strong>总结：Looer.loop()方法可能会引起主线程的阻塞，但只要它的消息循环没有被阻塞，能一直处理事件就不会产生ANR异常。</strong></p><h2 id="sendmessage与sendmessagedelay如何保证message放入messagequeue中的顺序"><a class="markdownIt-Anchor" href="#sendmessage与sendmessagedelay如何保证message放入messagequeue中的顺序"></a> sendMessage与sendMessageDelay如何保证Message放入MessageQueue中的顺序</h2><p>通过对 MessageQueue#enqueue() 以及 MessageQueue#next() 源码的阅读，我们可以看到两个方法都是通过synchronized来保证了线程的安全性。</p><p>由于多线程的性能开销，所以我们能够保证 Message 的顺序的正确性，但是无法保证这些 Message 执行的时间的精确性。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Handler </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
