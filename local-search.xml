<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>UML 类图详解</title>
    <link href="/posts/6070f0351e80/"/>
    <url>/posts/6070f0351e80/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>UML 类图是使用最频繁的 UML 图之一。</p><p>类图是面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。类图中最基本的元素是类、接口。软件设计师设计出类图后，程序员就可以用代码实现类图中包含的内容。</p><hr><h1 id="类、接口和包的表示方法"><a href="#类、接口和包的表示方法" class="headerlink" title="类、接口和包的表示方法"></a>类、接口和包的表示方法</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类（具体类和抽象类）在类图中用矩形框表示，矩形框分为三层：第一层是类名字；第二层是类的成员变量；第三层是类的方法。</p><div class="note note-info">            <p>更多具体规范可以查看：<a href="https://www.visual-paradigm.com/guide/uml-unified-modeling-language/what-is-class-diagram/"><em>What is Class Diagram? (visual-paradigm.com)</em></a></p>          </div><p>UML 规定类图中属性的表示方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs uml">可见性 名称 : 类型 [ = 缺省值]<br></code></pre></td></tr></table></figure><p>类图中的方法可以表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs uml">可见性 方法名 (参数名 : 参数类型) : 返回值类型<br></code></pre></td></tr></table></figure><p>其中，方法的多个参数间用逗号隔开，无返回值时，其类型为 <code>void</code>。</p><p>成员变量以及方法前的访问修饰符用符号来表示（即表示方法中的<strong>可见性</strong>部分）：</p><ul><li><code>-</code>：(<em>短横线</em>)表示 <code>private</code></li><li><code>#</code>：表示 <code>protected</code></li><li><code>~</code>：表示 <code>default</code>，也就是包权限</li><li><code>_</code>：(<em>下划线</em>)表示 <code>static</code></li><li><code>+</code>：表示 <code>public</code></li><li><code>斜体</code>：(<em>斜体</em>)表示 <code>abstract</code>，<strong>抽象类的类名</strong>以及抽象方法的名字都需要用斜体字表示</li></ul><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> name; &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> age; &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123; <span class="hljs-built_in">this</span>.name = name; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230119220818088.png" alt="" style="zoom:67%;" /></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口在类图中也是用矩形框表示，但是与类的表示法不同的是，接口在类图中的第一层顶端用构造型 <code>«interface»</code> 表示，下面是接口的名字，第二层是方法。</p><p>接口中方法和类中方法的表示形式一样。</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getCircumference</span><span class="hljs-params">()</span><br>&#125;<br></code></pre></td></tr></table></figure>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230119221447542.png" alt="" style="zoom:67%;" /></blockquote><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>类和接口一般都出现在包中，UML 类图中包的表示形式如下图所示。</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> AAA;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BBB</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230119222716762.png" alt="" style="zoom: 67%;" /></blockquote><hr><h1 id="类图中的关系"><a href="#类图中的关系" class="headerlink" title="类图中的关系"></a>类图中的关系</h1><p>UML 类图中共有 6 种关系，如下图所示：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/UML%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB.png" alt="UML-类图关系" style="zoom: 75%;" /><h2 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h2><p>很多面向对象编程语言（如 <code>Java</code>）中都引入了接口的概念。实现关系是指接口及其实现类之间的关系。在 <code>Java</code> 代码中，实现关系可以直接翻译为关键字 <code>implements</code>。</p><p>在 UML 类图中，实现关系用空心三角和虚线组成的箭头来表示，箭头指向方法为从实现类指向接口。</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FileSaveable</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FileSavealbe</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230124220612234.png" alt="" style="zoom:67%;" /></blockquote><h2 id="泛化关系"><a href="#泛化关系" class="headerlink" title="泛化关系"></a>泛化关系</h2><p>泛化关系，用于描述父类与子类之间的关系，其中父类又称作超类，子类又称为派生类。注意，父类和子类都可为抽象类或者具体类。</p><p>在 <code>Java</code> 代码中，对象之间的泛化关系可以直接翻译为关键字 <code>extends</code>。</p><p>在 UML 类图中泛化关系使用一条实线空心箭头由子类指向父类。</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230125151514457.png" alt="" style="zoom:67%;" /></blockquote><h2 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h2><p>关联关系是指对象和对象之间的连接，它使一个对象知道另一个对象的属性和方法。在 <code>Java</code> 中实现关联关系时，通常将一个类的对象作为另一个类的成员变量。</p><p>在 UML 类图中，用实线连接有关联关系的类，并可在关联线上标注角色名或关系名。</p><p>关联关系有双向关联、单向关联、自关联和多重性关联四种，下面将分别介绍。</p><h3 id="双向关联"><a href="#双向关联" class="headerlink" title="双向关联"></a>双向关联</h3><p>如果两个对象都知道（即可以调用）对方的公共属性和操作，那么二者就是双向关联。</p><p>在 UML 图中，双向关联关系用带双箭头的实线或者无箭头的实线表示。</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseAdmin</span> &#123;<br>    <span class="hljs-keyword">private</span> Database database;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Database</span> &#123;<br>    <span class="hljs-keyword">private</span> DatabaseAdmin admin;<br>&#125;<br></code></pre></td></tr></table></figure>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230125155839310.png" alt="" style="zoom:67%;" /></blockquote><h3 id="单向关联"><a href="#单向关联" class="headerlink" title="单向关联"></a>单向关联</h3><p>如果只有一个对象知道（即可以调用）另一个对象的公共属性和操作，那么就是单向关联。大多数关联都是单向关联，单向关联关系更容易建立和维护，有助于寻找可重用的类。</p><p>在 UML 图中，单向关联用一个带箭头的实线表示，箭头指向被关联的对象，这就是导航性（Navigatity）。</p><hr><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/109655171">30分钟学会UML类图 - 知乎 (zhihu.com)</a></li><li><a href="https://cloud.tencent.com/developer/article/1146291">UML(一) 类图详解 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android 设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 设计模式 - 策略模式</title>
    <link href="/posts/585ed55901e2/"/>
    <url>/posts/585ed55901e2/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>考虑下面的一段没有实际用处的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> animalPrinter = AnimalPrinter()<br>    animalPrinter.printAnimal(<span class="hljs-string">&quot;CAT&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalPrinter</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printAnimal</span><span class="hljs-params">(animal: <span class="hljs-type">String</span>)</span></span> &#123;<br>        <span class="hljs-keyword">when</span> (animal) &#123;<br>            <span class="hljs-string">&quot;CAT&quot;</span> -&gt; printCat()<br>            <span class="hljs-string">&quot;DOG&quot;</span> -&gt; printDog()<br>            <span class="hljs-string">&quot;PARROT&quot;</span> -&gt; printParrot()<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printCat</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;I have a cat.&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printDog</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;I have a dog&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printParrot</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;I have a parrot&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们需要在 <code>main</code> 函数中输出其他的动物时，就需要在 <code>AnimalPrinter#printAnimal</code> 函数中添加新的动物以及对应的实现逻辑，同时在 <code>AnimalPrinter</code> 类中添加对应动物的打印函数，肯定会修改对应的源代码，但是这就违反了单一职责原则。</p><p>那么如果将这些算法或者策略抽象出来，提供一个统一的接口，不同的算法或者策略有不同的实现类，这样在程序客户端就可以通过注入不同的实现对象来实现算法或者策略的动态替换。</p><p>这种模式的可扩展性、可维护性也就更高，也就是我们所说的策略模式。</p><hr><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p><p>策略模式主要用来分离算法，在相同的行为抽象下有不同的具体实现策略。</p><p>这个模式很好地演示了开闭原则，也就是定义抽象，注入不同的实现，从而达到很好的可扩展性。</p><hr><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul><li><p>针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。</p></li><li><p>需要安全地封装多种同一类型的操作时。</p></li><li><p>出现同一抽象类有多个子类，而又需要使用 <code>if-else</code> 或者 <code>switch-case</code> 来选择具体子类时。</p></li></ul><hr><h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230114222817018.png" alt="Strategy Pattern" style="zoom:80%;" /><p>其中，上图中的类和接口的定义如下：</p><ul><li><strong>Context</strong>：用来操作策略的上下文环境。</li><li><strong>Strategy</strong>：策略的抽象接口。</li><li><strong>Concrete Strategy A</strong>、<strong>Concrete Strategy B</strong>：具体的策略实现。</li></ul><hr><h1 id="引言代码修改"><a href="#引言代码修改" class="headerlink" title="引言代码修改"></a>引言代码修改</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> animalPrinter = AnimalPrinter()<br>    <span class="hljs-comment">// 配置策略</span><br>    animalPrinter.setAnimal(DogPrinter())<br>    <span class="hljs-comment">// 调用接口中的功能</span><br>    animalPrinter.printAnimal()<br>&#125;<br><br><span class="hljs-comment">// UML 类图中 Context 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalPrinter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> animal : IAnimalPrinter<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setAnimal</span><span class="hljs-params">(mIAnimalPrinter: <span class="hljs-type">IAnimalPrinter</span>)</span></span> &#123;<br>        <span class="hljs-keyword">this</span>.animal = mIAnimalPrinter<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printAnimal</span><span class="hljs-params">()</span></span> = animal.print()<br>&#125;<br><br><span class="hljs-comment">// UML 类图中 Strategy 接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IAnimalPrinter</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">// 实现 Strategy 接口的具体实现类，即 Concrete Strategy 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CatPrinter</span> : <span class="hljs-type">IAnimalPrinter</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;I have a cat.&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DogPrinter</span> : <span class="hljs-type">IAnimalPrinter</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;I have a dog.&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParrotPrinter</span> : <span class="hljs-type">IAnimalPrinter</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;I have a parrot.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过策略模式，当我们需要添加新的动物的时候，通过创建一个实现了 <code>IAnimalPrinter</code> 接口的类并实现其中的方法，便可以直接在 <code>main</code> 函数中使用新动物了而不再需要修改任何已有的、相关的 <code>AnimalPrinter</code> 等类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> animalPrinter = AnimalPrinter()<br>    animalPrinter.setAnimal(RabbitPrinter())<br>    animalPrinter.printAnimal()<br>&#125;<br><br><span class="hljs-comment">// 省略其他代码</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitPrinter</span> : <span class="hljs-type">IAnimalPrinter</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;I have a rabbit.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Android-源码中的应用：属性动画"><a href="#Android-源码中的应用：属性动画" class="headerlink" title="Android 源码中的应用：属性动画"></a>Android 源码中的应用：属性动画</h1><p>属性动画<strong>可以对任意对象的属性进行动画</strong>而不仅仅是 <code>View</code>。达到的效果是：在一个时间间隔内完成对象从一个属性值到另一个属性值的改变。</p><p><strong>在属性动画的源码中，时间插值器（<code>TimeInterpolator</code>）就使用了策略模式。</strong></p><h2 id="插值器和估值器"><a href="#插值器和估值器" class="headerlink" title="插值器和估值器"></a>插值器和估值器</h2><p>插值器和估值器是实现非匀速动画的重要手段。</p><h3 id="TimeInterpolator"><a href="#TimeInterpolator" class="headerlink" title="TimeInterpolator"></a><code>TimeInterpolator</code></h3><p>时间插值器。作用为<strong>根据时间的流逝的百分比计算当前属性值改变的百分比</strong>。</p><p>预设的有多种插值器，常见的三种如下：</p><ol><li><p><code>LinearInterpolator</code></p><p>线性插值器：匀速动画</p></li><li><p><code>AccelerateDecelerateInterpolator</code></p><p>加速减速插值器：动画两头慢中间快</p></li><li><p><code>DecelerateInterpolator</code></p><p>减速插值器：动画越来越慢</p></li></ol><p><strong>三个类都实现了 <code>Interpolator</code> 接口，接口内部只有一个用来计算属性值的改变的百分比的 <code>getInterpolation</code> 方法需要实现。</strong></p><div class="note note-info">            <p>更多插值器即其数值变化方式可以阅读： <a href="https://blog.csdn.net/pzm1993/article/details/77926373"><em>Android动画之Interpolator(插值器)_M-Ellen的博客-CSDN博客</em></a></p>          </div><h3 id="TypeEvaluator"><a href="#TypeEvaluator" class="headerlink" title="TypeEvaluator"></a><code>TypeEvaluator</code></h3><p>类型估值算法，也叫估值器。作用是<strong>根据属性值改变的百分比来计算改变后的属性值</strong>。</p><p>系统预置的有3种：</p><ol><li><code>IntEvaluator</code>：针对整形属性</li><li><code>FloatEvaluator</code>：针对浮点型属性</li><li><code>ArgbEvaluator</code>：针对 Color 属性</li></ol><p>三个类都实现了 <code>TypeEvalator</code> 接口，接口内部只有一个用来计算改变后的属性值的 <code>evaluate</code> 方法需要实现。</p><h3 id="计算顺序"><a href="#计算顺序" class="headerlink" title="计算顺序"></a>计算顺序</h3><p>系统会根据当前的帧所在时刻与动画播放的总时间求出时间的流逝的百分比，再通过插值器计算出当前属性值改变的百分比，后用此值通过估值器计算出当前的属性改变后的确定的值是多少并通过 <code>set</code> 方法对属性赋值。</p><p>故属性动画要求对象的该属性有 <code>set</code> 方法（必须有）和 <code>get</code> 方法（可选）。</p><h3 id="自定义插值器和估值器"><a href="#自定义插值器和估值器" class="headerlink" title="自定义插值器和估值器"></a>自定义插值器和估值器</h3><p>我们可以自定义插值器和估值器，来实现自己想要的动画效果。实现方式也很简单。</p><p>因为插值器和估值器都是一个接口，且内部都只有一个方法，所以我们只需要派生一个类并实现接口就可以了，然后就可以做出千奇百怪的动画效果了。即：</p><ul><li><p>自定义插值器需要实现 <code>Interpolator</code> 或者 <code>TimeInterpolator</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TimeInterpolator</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Maps a value representing the elapsed fraction of an animation to a value that represents</span><br><span class="hljs-comment">     * the interpolated fraction. This interpolated value is then multiplied by the change in</span><br><span class="hljs-comment">     * value of an animation to derive the animated value at the current elapsed animation time.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> input A value between 0 and 1.0 indicating our current point</span><br><span class="hljs-comment">     *        in the animation where 0 represents the start and 1.0 represents</span><br><span class="hljs-comment">     *        the end</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> The interpolation value. This value can be more than 1.0 for</span><br><span class="hljs-comment">     *         interpolators which overshoot their targets, or less than 0 for</span><br><span class="hljs-comment">     *         interpolators that undershoot their targets.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">float</span> <span class="hljs-title function_">getInterpolation</span><span class="hljs-params">(<span class="hljs-type">float</span> input)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * An interpolator defines the rate of change of an animation. This allows</span><br><span class="hljs-comment"> * the basic animation effects (alpha, scale, translate, rotate) to be </span><br><span class="hljs-comment"> * accelerated, decelerated, repeated, etc.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Interpolator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TimeInterpolator</span> &#123;<br>    <span class="hljs-comment">// A new interface, TimeInterpolator, was introduced for the new android.animation</span><br>    <span class="hljs-comment">// package. This older Interpolator interface extends TimeInterpolator so that users of</span><br>    <span class="hljs-comment">// the new Animator-based animations can use either the old Interpolator implementations or</span><br>    <span class="hljs-comment">// new classes that implement TimeInterpolator directly.</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自定义估值器需要实现 <code>TypeEvaluator</code> 接口。</p></li></ul><h2 id="插值器使用方法"><a href="#插值器使用方法" class="headerlink" title="插值器使用方法"></a>插值器使用方法</h2><p>定义一个 <code>Animation</code> 对象后，使用 <code>Animation#setInterpolator</code> 方法进行插值器类型的选择：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">animation.setInterpolator(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AccelerateInterpolator</span>())<br></code></pre></td></tr></table></figure><blockquote><p>  <b><code>Animation#setInterpolator</code></b></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Interpolator mInterpolator; <span class="hljs-comment">// 插值器成员变量</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Sets the acceleration curve for this animation. Defaults to a linear</span><br><span class="hljs-comment"> * interpolation.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> i The interpolator which defines the acceleration curve</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@attr</span> ref android.R.styleable#Animation_interpolator</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setInterpolator</span><span class="hljs-params">(Interpolator i)</span> &#123;<br>    mInterpolator = i;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>查看源码中何时使用了 <code>Interpolator</code> 对象。</p><p>通过查找 <code>View#startAnimation -&gt; View#draw -&gt; View#drawAnimation -&gt; Animation#getTransformation</code>，可以看到插值器的使用。</p><p><b><code>Animation#getTransformation</code></b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java">Interpolator mInterpolator; <span class="hljs-comment">// 插值器成员变量</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Gets the transformation to apply at a specified point in time. Implementations of this</span><br><span class="hljs-comment"> * method should always replace the specified Transformation or document they are doing</span><br><span class="hljs-comment"> * otherwise.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> currentTime Where we are in the animation. This is wall clock time.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> outTransformation A transformation object that is provided by the</span><br><span class="hljs-comment"> *        caller and will be filled in by the animation.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> True if the animation is still running</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">getTransformation</span><span class="hljs-params">(<span class="hljs-type">long</span> currentTime, Transformation outTransformation)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-type">float</span> normalizedTime;<br>    <span class="hljs-comment">// 1. 计算当前时间的流逝百分比</span><br>    <span class="hljs-keyword">if</span> (duration != <span class="hljs-number">0</span>) &#123;<br>        normalizedTime = ((<span class="hljs-type">float</span>) (currentTime - (mStartTime + startOffset))) /<br>            (<span class="hljs-type">float</span>) duration;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// time is a step-change with a zero duration</span><br>        normalizedTime = currentTime &lt; mStartTime ? <span class="hljs-number">0.0f</span> : <span class="hljs-number">1.0f</span>;<br>    &#125;<br>    <span class="hljs-comment">// 动画是否已经完成</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">expired</span> <span class="hljs-operator">=</span> normalizedTime &gt;= <span class="hljs-number">1.0f</span> || isCanceled();<br>    mMore = !expired;<br><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> ((normalizedTime &gt;= <span class="hljs-number">0.0f</span> || mFillBefore) &amp;&amp; (normalizedTime &lt;= <span class="hljs-number">1.0f</span> || mFillAfter)) &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// 2. 通过插值器获取动画执行百分比</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">interpolatedTime</span> <span class="hljs-operator">=</span> mInterpolator.getInterpolation(normalizedTime);<br>        <span class="hljs-comment">// 3. 应用动画效果</span><br>        applyTransformation(interpolatedTime, outTransformation);<br>    &#125;<br><br>    <span class="hljs-comment">// 4.  如果动画执行完毕，那么出发动画完成的回调或者执行重复动画等操作</span><br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-keyword">if</span> (!mMore &amp;&amp; mOneMoreTime) &#123;<br>        mOneMoreTime = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mMore;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面代码的第 35 行，可以看到使用了 <code>Interpolator</code> 接口的 <code>getInterpolation</code> 方法进行了不同策略的执行。</p><hr><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>结构清晰明了、使用简单直观。</li><li>耦合度相对而言较低，扩展方便。</li><li>操作封装也更为彻底，数据更为安全。</li></ul><hr><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li>随着策略的增加，子类也会变得繁多。</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p>《Android 源码设计模式解析与实战》</p></li><li><p>《Android 开发艺术探索》</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android 设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>属性动画</tag>
      
      <tag>策略模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第八章</title>
    <link href="/posts/cecb127ec7d7/"/>
    <url>/posts/cecb127ec7d7/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第八章学习笔记</b></font></center><br><span id="more"></span><h1 id="堆栈帧"><a href="#堆栈帧" class="headerlink" title="堆栈帧"></a>堆栈帧</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 227</p></blockquote><p>堆栈帧 (stack frame)（或活动记录 (activation record)）是一块堆栈保留区域，用于存放<strong>被传递的实际参数</strong>、<strong>子程序的返回值</strong>、<strong>局部变量</strong>以及<strong>被保存的寄存器</strong>。堆栈帧的创建步骤如下所示：</p><ol><li>被传递的实际参数。如果有，则压入堆栈。</li><li>当子程序被调用时，使该子程序的返回值压入堆栈。</li><li>子程序开始执行时，EBP 被压入堆栈。</li><li>设置 EBP 等于 ESP。从这时开始，EBP 就变成了该子程序所有参数的引用基址。</li><li>如果有局部变量，修改 ESP 以便在堆栈中为这些变量预留空间。</li><li>如果需要保存寄存器，就将它们压入堆栈。</li></ol><blockquote><ul><li><code>ESP</code> 用于寻址堆栈（一种系统内存结构）数据。它极少用于一般算术运算和数据传输，通常被称为扩展堆栈指针 (extended stack pointer) 寄存器。</li><li>高级语言通过 <code>EBP</code> 来引用堆栈中的函数参数和局部变量。除了高级编程，它不用于一般算术运算和数据传输。它常常被称为扩展帧指针 (extended frame pointer) 寄存器。</li></ul></blockquote><p>程序内存模式和对参数传递规则的选择直接影响到堆栈帧的结构。</p><p>学习用堆栈传递参数有个好理由：几乎所有的高级语言都会用到它们。比如如果想要在 32 位 Windows 应用程序接口（API）中调用函数，就必须用堆栈传递参数。而 64 位程序可以使用另一种不同的参数传递规则。</p><h2 id="访问堆栈参数"><a href="#访问堆栈参数" class="headerlink" title="访问堆栈参数"></a>访问堆栈参数</h2><p>高级语言有多种方式来对函数调用的参数进行初始化和访问。以 C 和 C++ 语言为例，它们以保存 EBP 寄存器并使该寄存器指向栈顶的语句为开始 (prologue)。然后，根据实际情况，它们可以把某些寄存器入栈，以便在函数返回时恢复这些寄存器的值。在函数结尾 (epilogue) 部分，恢复 EBP 寄存器，并用 RET 指令返回调用者。</p><h2 id="ENTER-指令"><a href="#ENTER-指令" class="headerlink" title="ENTER 指令"></a>ENTER 指令</h2><p>ENTER 指令为被调用过程自动创建堆栈帧。它为局部变量保留堆栈空间，把 EBP 入栈。具体来说，它执行三个操作：</p><ul><li>把 EBP 入栈（<code>push EBP</code>）</li><li>把 EBP 设置为堆栈帧的基址（<code>mov EBP, ESP</code>）</li><li>为局部变量保留空间（<code>sub ESP, numbytes</code>）</li></ul><p>ENTER有两个操作数：第一个是常数，定义为局部变量保存的堆栈空间字节数；第二个定义了过程的词法嵌套级。<br>$$<br>ENTER \space \space numbytes, \space nestinglevel<br>$$<br>这两个操作数都是立即数。Numbytes 总是向上舍入为 4 的倍数，以便 ESP 对齐双字边界。Nestinglevel 确定了从主调过程堆栈帧复制到当前帧的堆栈帧指针的个数。</p><p><font size = 4><b>示例</b></font></p><p>ENTER 指令为局部变量保留了 8 个字节的堆栈空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">MySub PROC<br>    enter 8, 0<br></code></pre></td></tr></table></figure><p>它与如下指令等效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">MySub PROC<br>    push  ebp<br>    mov   ebp, esp<br>    sub   esp, 8<br></code></pre></td></tr></table></figure><p>下图为执行 ENTER 指令前后的堆栈示意图。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230103180554430.png" alt="" style="zoom: 67%;" /><h2 id="LEAVE-指令"><a href="#LEAVE-指令" class="headerlink" title="LEAVE 指令"></a>LEAVE 指令</h2><p>LEAVE 指令结束一个过程的堆栈帧。它反转了之前的 ENTER 指令操作：恢复了过程被调用时 ESP 和 EBP 的值。再次以 MySub 过程为例，现在可以编码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">MySub PROC<br>    enter 8,0<br>    .<br>    .<br>    leave<br>    ret<br>MySub ENDP<br></code></pre></td></tr></table></figure><p>下面是与之等效的指令序列，其功能是在堆栈中保存和删除 8 个字节的局部变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">MySub PROC<br>    push  ebp<br>    mov   ebp, esp<br>    sub   esp, 8<br>    .<br>    .<br>    mov   esp, ebp<br>    pop   ebp<br>    ret<br>MySub ENDP<br></code></pre></td></tr></table></figure><h2 id="LOCAL-指令"><a href="#LOCAL-指令" class="headerlink" title="LOCAL 指令"></a>LOCAL 指令</h2><p>不难想象，Microsoft 创建 LOCAL 伪指令是作为 ENTER 指令的高级替补。</p><p>LOCAL 声明一个或多个变量名，并定义其大小属性。（另一方面，ENTER 则只为局部变量保留一块未命名的堆栈空间。）如果要使用 LOCAL 伪指令，它必须紧跟在 PROC 伪指令的后面。其语法如下所示：</p><p>$$<br>LOCAL \space \space varlist<br>$$<br>$varlist$ 是变量定义列表，用逗号分隔表项，可选为跨越多行。每个变量定义采用如下格式：<br>$$<br>label: \space type<br>$$<br>其中，标号可以为任意有效标识符，类型既可以是标准类型（WORD、DWORD等），也可以是用户定义类型。</p><p><font size = 4><b>示例</b></font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">BubbleSort PROC<br>    LOCAL temp: DWORD, SwapFlag: BYTE<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第七章</title>
    <link href="/posts/3941df7fa3bf/"/>
    <url>/posts/3941df7fa3bf/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第七章学习笔记</b></font></center><br><span id="more"></span><h1 id="移位和循环移位指令"><a href="#移位和循环移位指令" class="headerlink" title="移位和循环移位指令"></a>移位和循环移位指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 192</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102210528302.png" alt="" style="zoom:80%;" /><p>移动操作数的位有两种方法。</p><ul><li>第一种是<strong>逻辑移位</strong> (logic shift)，<strong>空出来的位用 0 填充</strong>。如下图所示，一个字节的数据向右移动一位。也就是说，每一位都被移动到其旁边的低位上。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102210741593.png" alt="" style="zoom:67%;" /><ul><li>另一种移位的方法是<strong>算术移位</strong> (arithmetic shift)，空出来的位用原数据的符号位填充。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102210824137.png" alt="" style="zoom:70%;" /><h2 id="SHL-指令"><a href="#SHL-指令" class="headerlink" title="SHL 指令"></a>SHL 指令</h2><p>逻辑左移。SHL 的第一个操作数是目的操作数,第二个操作数是移位次数：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102211036985.png" alt="" style="zoom:70%;" />$$SHL \space \space destination,count$$该指令可用的操作数类型如下所示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SHL reg, imm8<br>SHL mem, imm8<br>SHL reg, CL<br>SHL mem, CL<br></code></pre></td></tr></table></figure><p>x86处理器允许 imm8 为 0～255 中的任何整数。另外，CL 寄存器包含的是移位计数。上述格式同样适用于 SHR、SAL、SAR、ROR、ROL、RCR 和  RCL 指令。</p><h2 id="SHR-指令"><a href="#SHR-指令" class="headerlink" title="SHR 指令"></a>SHR 指令</h2><p>逻辑右移。SHR 的指令格式与 SHL 相同。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102210741593.png" alt="" style="zoom:67%;" /><h2 id="SAL-和-SAR-指令"><a href="#SAL-和-SAR-指令" class="headerlink" title="SAL 和 SAR 指令"></a>SAL 和 SAR 指令</h2><p>SAL(算术左移)指令的操作与SHL指令一样。</p><p>每次移动时，SAL 都将目的操作数中的每一位移动到下一个最高位上。<strong>最低位用0填充</strong>；最高位移入进位标志位，该标志位原来的值被丢弃：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102211511996.png" alt="" style="zoom:70%;" /><p>SAR 指令为算术右移，指令格式与 SHL 相同。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102210824137.png" alt="" style="zoom:70%;" /><h2 id="ROL-指令"><a href="#ROL-指令" class="headerlink" title="ROL 指令"></a>ROL 指令</h2><p>以循环方式来移位即为位元循环 (Bitwise Rotation)。一些操作中，从数的一端移出的位立即复制到该数的另一端。还有一种类型则是把进位标志位当作移动位的中间点。</p><p>ROL（循环左移）指令把所有位都向左移。最高位复制到进位标志位和最低位。该指令格式与 SHL 指令相同：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102212019795.png" alt="image-20230102212019795" style="zoom:80%;" /><p>位循环不会丢弃位。从数的一端循环出去的位会出现在该数的另一端。</p><p><font size = 4><b>特点</b></font></p><ol><li>当循环计数值大于 1 时，进位标志位保存的是最后循环移出 MSB 的位。</li><li>位组交换利用 ROL 可以交换一个字节的高四位(位 4～7)和低四位(位 0～3)。例如，26h 向任何方向循环移动 4 位就变为 62h。当多字节整数以四位为单位进行循环移位时，其效果相当于一次向右或向左移动一个十六进制位。例如，将 6A4Bh 反复循环左移四位，最后就会回到初始值。</li></ol><h2 id="ROR-指令"><a href="#ROR-指令" class="headerlink" title="ROR 指令"></a>ROR 指令</h2><p>ROR（循环右移）指令把所有位都向右移，最低位复制到进位标志位和最高位。该指令格式与 SHL 指令相同。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102212338300.png" alt="" style="zoom:70%;" /><p>当循环计数值大于 1 时，进位标志位保存的是最后循环移出 LSB 的位。</p><h2 id="RCL-和-RCR-指令"><a href="#RCL-和-RCR-指令" class="headerlink" title="RCL 和 RCR 指令"></a>RCL 和 RCR 指令</h2><p>RCL（带进位循环左移）指令把每一位都向左移，进位标志位复制到 LSB，而 MSB 复制到进位标志位：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102212630840.png" alt="" style="zoom:70%;" /><p>RCR（带进位循环右移）指令把每一位都向右移，进位标志位复制到 MSB，而 LSB 复制到进位标志位：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102212743503.png" alt="" style="zoom:70%;" /><h2 id="SHLD-和-SHRD-指令"><a href="#SHLD-和-SHRD-指令" class="headerlink" title="SHLD 和 SHRD 指令"></a>SHLD 和 SHRD 指令</h2><p>SHLD（双精度左移）指令将目的操作数向左移动指定位数。移动形成的空位由源操作数的高位填充。源操作数不变，但是符号标志位、零标志位、辅助进位标志位、奇偶标志位和进位标志位会受影响：<br>$$<br>SHLD \space \space dest, source, count<br>$$<br>下图展示的是 SHLD 执行移动一位的过程。源操作数的最高位复制到目的操作数的最低位上。目的操作数的所有位都向左移动：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102213018857.png" alt="" style="zoom:67%;" /><p>SHRD（双精度右移）指令将目的操作数向右移动指定位数。移动形成的空位由源操作数的低位填充：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102213058864.png" alt="" style="zoom:67%;" /><p>SHLD 和 SHRD 的指令格式中，目标操作数可以是寄存器或内存操作数；<strong>源操作数必须是寄存器</strong>；移位次数可以是 CL 寄存器或者 8 位立即数。</p><h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 200</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102213650659.png" alt="" style="zoom:80%;" /><hr><h1 id="乘法和除法指令"><a href="#乘法和除法指令" class="headerlink" title="乘法和除法指令"></a>乘法和除法指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 201</p></blockquote><h2 id="MUL-指令"><a href="#MUL-指令" class="headerlink" title="MUL 指令"></a>MUL 指令</h2><p>32位模式下，MUL（<strong>无符号数</strong>乘法）指令有三种类型：</p><ul><li>第一种执行 8 位操作数与 <strong>AL 寄存器</strong>的乘法</li><li>第二种执行16位操作数与 <strong>AX 寄存器</strong>的乘法</li><li>第三种执行 32 位操作数与 <strong>EAX 寄存器</strong>的乘法</li></ul><p>乘数和被乘数的大小必须保持一致，<strong>乘积的大小则是它们的一倍</strong>。这三种类型都可以使用寄存器和内存操作数，但不能使用立即数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MUL reg/mem8<br>MUL reg/mem16<br>MUL reg/mem32<br></code></pre></td></tr></table></figure><p>MUL 指令中的单操作数是乘数。下图按照乘数的大小，列出了默认的被乘数和乘积。</p><p>由于目的操作数是被乘数和乘数大小的两倍，因此<strong>不会发生溢出</strong>。</p><p>如果乘积的高半部分不为零，则 MUL 会把<strong>进位标志位和溢出标志位</strong>置 1。因为进位标志位常常用于无符号数的算术运算。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102222115899.png" alt="" style="zoom:80%;" /><p>例如，当 AX 乘以一个 16 位操作数时，乘积存放在 DX 和 AX 寄存器对中。其中，乘积的高 16 位存放在 DX，低 16 位存放在 AX。如果 DX 不等于零，则进位标志位置 1，这就意味着隐含的目的操作数的低半部分容纳不了整个乘积。</p><h2 id="IMUL-指令"><a href="#IMUL-指令" class="headerlink" title="IMUL 指令"></a>IMUL 指令</h2><p>IMUL（有符号数乘法）指令执行有符号整数乘法。与 MUL 指令不同，IMUL 会<strong>保留乘积的符号</strong>，实现的方法是，将乘积低半部分的最高位符号扩展到高半部分。x86指令集支持三种格式的 IMUL 指令:单操作数、双操作数和三操作数。</p><p><font size = 4><b>单操作数格式</b></font></p><p>单操作数格式中，乘数和被乘数大小相同，而乘积的大小是它们的两倍。单操作数格式将乘积存放在 AX、DX:AX 或 EDX: EAX 中：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102224014015.png" style="zoom: 71%;" /><p>和 MUL 指令一样，其乘积的存储大小使得<strong>溢出不会发生</strong>。同时，如果乘积的高半部分不是其低半部分的符号扩展，则进位标志位和溢出标志位置1。利用这个特点可以决定是否忽略乘积的高半部分。</p><p><font size = 4><b>双操作数格式（32位模式）</b></font></p><p>32 位模式中的双操作数 IMUL 指令把乘积存放在第一个操作数中，这个操作数必须是寄存器。第二个操作数（乘数）可以是寄存器、内存操作数和立即数。<br>$$<br>IMUL \space \space reg, \space reg&#x2F;mem&#x2F;imm<br>$$<br>双操作数格式会按照目的操作数的大小来截取乘积。如果被丢弃的是有效位则溢出标志位和进位标志位置 1。因此，在执行了有两个操作数的 IMUL 操作后，必须检查这些标志位中的一个。</p><p><font size = 4><b>三操作数格式</b></font></p><p>32 位模式下的三操作数格式将乘积保存在第一个操作数中。第二个操作数可以是16位寄存器或内存操作数，它与第三个操作数相乘，该操作数是一个8位或16位立即数。<br>$$<br>IMUL \space \space reg, \space reg&#x2F;mem, \space imm<br>$$<br>IMUL 执行时，若乘积有效位被丢弃，则溢出标志位和进位标志位置 1。因此，在执行了有三个操作数的 IMUL 操作后,必须检查这些标志位中的一个。</p><h2 id="DIV-指令"><a href="#DIV-指令" class="headerlink" title="DIV 指令"></a>DIV 指令</h2><p>32 位模式下，DIV（无符号除法）指令执行 8 位、16 位和 32 位无符号数除法。其中，单寄存器或内存操作数是除数。格式如下:<br>$$<br>DIV\space\space reg&#x2F;mem<br>$$<br>下图给出了被除数、除数、商和余数之间的关系：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102234944257.png" style="zoom: 67%;" /><p>64 位模式下，DIV 指令用 RDX:RAX 作被除数，用 64 位寄存器和内存操作数作除数商存放到 RAX，余数存放在 RDX 中。</p><h2 id="IDIV-指令"><a href="#IDIV-指令" class="headerlink" title="IDIV 指令"></a>IDIV 指令</h2><p>IDIV（有符号除法）指令执行有符号整数除法，其操作数与 DIV 指令相同。执行 8 位除法之前，被除数 (AX) 必须完成符号扩展。余数的符号总是与被除数相同。</p><hr><h1 id="扩展加减法"><a href="#扩展加减法" class="headerlink" title="扩展加减法"></a>扩展加减法</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 212</p></blockquote><h2 id="ADC-指令"><a href="#ADC-指令" class="headerlink" title="ADC 指令"></a>ADC 指令</h2><p>ADC（带进位加法）指令将源操作数和进位标志位的值都与目的操作数相加。该指令格式与 ADD 指令一样,且操作数大小必须相同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ADC reg, reg<br>ADC mem, reg<br>ADC reg, mem<br>ADC mem, imm<br>ADC reg, imm<br></code></pre></td></tr></table></figure><h2 id="程序示例-1"><a href="#程序示例-1" class="headerlink" title="程序示例"></a>程序示例</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102235908443.png" style="zoom:60%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102235932603.png" style="zoom:60%;" /><p>下面的代码示例调用 Extended_Add，并向其传递两个 8 字节的整数。要注意为和数多分配一个字节：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230103000107626.png" style="zoom:60%;" /><p>上述程序的输出，加法产生了一个进位：<code>0122C32B0674BB5736</code></p><h2 id="SBB-指令"><a href="#SBB-指令" class="headerlink" title="SBB 指令"></a>SBB 指令</h2><p>SBB（带借位减法）指令从目的操作数中减去源操作数和进位标志位的值。允许使用的操作数与 ADC 指令相同。</p>]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第六章</title>
    <link href="/posts/049b6e9dd143/"/>
    <url>/posts/049b6e9dd143/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第六章学习笔记</b></font></center><br><span id="more"></span><h1 id="布尔和比较指令"><a href="#布尔和比较指令" class="headerlink" title="布尔和比较指令"></a>布尔和比较指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 148</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102144806527.png" alt="" style="zoom:80%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102144839025.png" style="zoom:80%;" /><h2 id="CPU的状态标志"><a href="#CPU的状态标志" class="headerlink" title="CPU的状态标志"></a>CPU的状态标志</h2><p>布尔指令影响零标志、进位标志、符号标志、溢出标志和奇偶标志。</p><ul><li>操作结果等于 0 时，零标志位置 1。</li><li>操作使得目标操作数的最高位有进位时，进位标志位置 1。</li><li>符号标志位是目标操作数高位的副本，如果标志位置 1，表示是负数；标志位清 0，表示是正数。(假设 0 为正)</li><li>指令产生的结果超出了有符号目的操作数范围时，溢出标志位置 1。</li><li>指令使得目标操作数低字节中有偶数个 1 时，奇偶标志位置 1。</li></ul><h2 id="AND-指令"><a href="#AND-指令" class="headerlink" title="AND 指令"></a>AND 指令</h2><p>AND 指令在两个操作数的对应位之间进行（按位）逻辑与 (AND) 操作，<strong>并将结果存放在目标操作数中</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">AND dest, source<br></code></pre></td></tr></table></figure><p>下列是被允许的操作数组合，但是<strong>立即操作数不能超过 32 位</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">AND reg, reg<br>AND reg, mem<br>AND reg, imm<br>AND mem, reg<br>AND mem, imm<br></code></pre></td></tr></table></figure><p>AND 指令总是<strong>清除溢出和进位标志位</strong>，并根据目标操作数的值来修改符号标志位、零标志位和奇偶标志位。</p><h2 id="OR-指令"><a href="#OR-指令" class="headerlink" title="OR 指令"></a>OR 指令</h2><p>OR指令在两个操作数的对应位之间进行（按位）逻辑或 (OR) 操作，并将结果存放在目标操作数中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">OR dest, source<br></code></pre></td></tr></table></figure><p>操作数组合与 AND 指令相同。</p><p>OR 指令总是<strong>清除溢出标志和进位标志</strong>。它根据目的操作数的值修改符号标志、零标志、奇偶标志。</p><h2 id="XOR-指令"><a href="#XOR-指令" class="headerlink" title="XOR 指令"></a>XOR 指令</h2><p>指令在每对操作数的对应数据之间执行异或 (XOR) 操作，格式与 AND 指令相同。</p><p>XOR 指令总是<strong>清除溢出标志和进位标志</strong>，它依据目的操作数的值修改符号标志、零标志和奇偶标志。</p><h2 id="NOT-指令"><a href="#NOT-指令" class="headerlink" title="NOT 指令"></a>NOT 指令</h2><p>NOT 指令将一个操作数中的所有数据位取反，得到的结果成为该操作数的反码。该指令允许下面的操作数据类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">NOT reg<br>NOT mem<br></code></pre></td></tr></table></figure><p><strong>NOT 指令不影响任何状态标志。</strong></p><h2 id="TEST-指令"><a href="#TEST-指令" class="headerlink" title="TEST 指令"></a>TEST 指令</h2><p>TEST 指令在两个操作数的对应数据位之间执行隐式的 AND 操作，并相应设置标志位。</p><p>TEST 指令和 AND 指令之间的<strong>唯一区别</strong>在于 TEST 指令<strong>不会修改目的操作数</strong>。</p><p>TEST 指令的操作数格式与 AND 相同。</p><p>该指令在测试操作数某些位是否被设置时特别有用。</p><p>TEST 指令总是<strong>清除溢出和进位标志位</strong>，其修改符号标志位、零标志位和奇偶标志位的方法与 AND 指令相同。</p><p>从下面的数据集例子中，可以推断只有当所有测试位都清 0 时,零标志位才置 1（本例中的0000 1001称为位掩码。）：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102154417565.png" alt="image" style="zoom:85%;" /><h2 id="CMP-指令"><a href="#CMP-指令" class="headerlink" title="CMP 指令"></a>CMP 指令</h2><p>CMP（比较）指令执行<strong>从目的操作数中减去源操作数</strong>的隐含减法操作，并且不修改任何操作数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">CMP dest, source<br></code></pre></td></tr></table></figure><p>当实际的减法发生时，CMP指令按照计算结果修改溢出、符号、零、进位、辅助进位和奇偶标志位。</p><p>如果比较的是两个<strong>无符号数</strong>，则零标志位和进位标志位表示的两个操作数之间的关系如下图所示：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102154711457.png" style="zoom:80%;" /><p>如果比较的是两个<strong>有符号数</strong>，则符号标志位、零标志位和溢出标志位表示的两个操作数之间的关系如下图所示：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102154729952.png" style="zoom:80%;" /><p>CMP 指令是创建条件逻辑结构的有效工具。<strong>IF 语句在汇编语言中等价于在 CMP 指令后跟一条条件跳转指令。</strong></p><h2 id="设置和清除单个-CPU-状态标志"><a href="#设置和清除单个-CPU-状态标志" class="headerlink" title="设置和清除单个 CPU 状态标志"></a>设置和清除单个 CPU 状态标志</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs assembly">test al, 0     ; 零标志位置 1<br>and  al, 0     ; 零标志位置 1<br>or   al, 1     ; 零标志位清零<br><br>or   al, 80h   ; 符号标志位置 1<br>and  al, 7Fh   ; 符号标志位清零<br><br>stc            ; 进位标志位置 1<br>clc            ; 进位标志位清零<br><br>mov  al, 7Fh   ; AL = +127<br>inc  al        ; AL = 80h (-128), OF = 1, 溢出标志位置 1<br><br>or   eax, 0    ; 溢出标志位清零<br></code></pre></td></tr></table></figure><h2 id="习题整理"><a href="#习题整理" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  下列语句中，有语法错误的是：（C）<br>  A. mov eax, arrayD[esi*4]<br>  B. popfd<br>  C. cmp val1, val2<br>  D. rep stosb</p></blockquote><p>CMP 指令两个操作数不能都为立即数。</p><hr><h1 id="条件跳转"><a href="#条件跳转" class="headerlink" title="条件跳转"></a>条件跳转</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 156</p></blockquote><h2 id="Jcond-指令"><a href="#Jcond-指令" class="headerlink" title="Jcond 指令"></a>J<i>cond</i> 指令</h2><p> 条件跳转指令在标志条件为真时分支跳转到新的目的标号处，如果条件标志为假，那么执行紧跟在跳转跳转指令之后的指令。格式如下：<br>$$<br>Jcond\space\space destination<br>$$<br> 格式中的 <em>cond</em> 指的是一个标志条件，用来表示一个或多个标志的状态。例如：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102163745683.png" alt="" style="zoom:80%;" /><p>CPU 状态标志位最常见的设置方法是通过算术运算、比较和布尔运算指令。条件跳转指令评估标志位状态，利用它们来决定是否发生跳转。</p><p>限制：MASM 在默认情况下要求跳转的目的地址在当前的过程之内，为了突破这种限制，可以声明一个全局标号（标号后面跟 <code>::</code>）。</p><h2 id="基于特定的标志值的跳转指令"><a href="#基于特定的标志值的跳转指令" class="headerlink" title="基于特定的标志值的跳转指令"></a>基于特定的标志值的跳转指令</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102164214600.png" style="zoom:80%;" /><h2 id="基于恒等性比较的跳转指令"><a href="#基于恒等性比较的跳转指令" class="headerlink" title="基于恒等性比较的跳转指令"></a>基于恒等性比较的跳转指令</h2><p>$$<br>CMP \space\space leftOp,\space rightOp<br>$$</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102164334615.png" style="zoom:80%;" /><p>JE 指令和 JZ 指令是等价的，JNZ 指令和 JNE 指令是等价的。</p><h2 id="基于无符号数比较的跳转指令"><a href="#基于无符号数比较的跳转指令" class="headerlink" title="基于无符号数比较的跳转指令"></a>基于无符号数比较的跳转指令</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102164428457.png" alt="" style="zoom:80%;" /><h2 id="基于有符号数比较的跳转指令"><a href="#基于有符号数比较的跳转指令" class="headerlink" title="基于有符号数比较的跳转指令"></a>基于有符号数比较的跳转指令</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102164453778.png" style="zoom:80%;" /><h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 160</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102192924734.png" alt="" style="zoom:80%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102193006278.png" style="zoom:80%;" /><h2 id="习题整理-1"><a href="#习题整理-1" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  条件转移指令中相等跳转的指令是：（C）<br>  A. JZ<br>  B. JNZ<br>  C. JE<br>  D. JNE</p></blockquote><p>JE 指令和 JZ 指令是等价的。</p><hr><h1 id="条件循环指令"><a href="#条件循环指令" class="headerlink" title="条件循环指令"></a>条件循环指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 163</p></blockquote><h2 id="LOOPZ-和-LOOPE-指令"><a href="#LOOPZ-和-LOOPE-指令" class="headerlink" title="LOOPZ 和 LOOPE 指令"></a>LOOPZ 和 LOOPE 指令</h2><p>ECX 大于 0，并且零标志位置 1 则循环。<br>$$<br>LOOPZ\space\space destination<br>$$</p><p>$$<br>LOOPE\space\space destination<br>$$</p><h2 id="LOOPNZ-和-LOOPNE-指令"><a href="#LOOPNZ-和-LOOPNE-指令" class="headerlink" title="LOOPNZ 和 LOOPNE 指令"></a>LOOPNZ 和 LOOPNE 指令</h2><p>ECX 大于 0，并且零标志位为 0 则循环。<br>$$<br>LOOPNZ\space\space distination<br>$$</p><p>$$<br>LOOPNE\space\space distination<br>$$</p><hr><h1 id="条件结构"><a href="#条件结构" class="headerlink" title="条件结构"></a>条件结构</h1><h2 id="IF-语句"><a href="#IF-语句" class="headerlink" title="IF 语句"></a>IF 语句</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 165</p></blockquote><p>C++ 代码翻译为汇编代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (op1 == op2)<br>&#123;<br>    X = <span class="hljs-number">1</span>;<br>    Y = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">    mov eax, op1<br>    cmp eax, op2      ; op1 == op2 ?<br>    jne L1            ; False : Skip To L1<br>    mov X, 1          ; True : X = 1<br>    mov Y, 2          ; Y = 1<br>L1: .<br>    .<br></code></pre></td></tr></table></figure><h2 id="WHILE-语句"><a href="#WHILE-语句" class="headerlink" title="WHILE 语句"></a>WHILE 语句</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 168</p></blockquote><p>C++ 代码翻译为汇编代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (val &lt; val2)<br>&#123;<br>    val1++;<br>    val2--;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">    mov eax, val1       ; eax = val1<br>beginWhile:<br>    cmp eax, val2       ; if not (val1 &lt; val2)<br>    jnl endWhile        ; 退出循环<br>    inc eax             ; val1++<br>    dec val2            ; val2--<br>    jmp beginWhile      ; 重复循环<br>endWhile:<br>    mov val1, eax       ; val1 = eax<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第五章</title>
    <link href="/posts/eddefec83d75/"/>
    <url>/posts/eddefec83d75/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第五章学习笔记</b></font></center><br><span id="more"></span><h1 id="堆栈操作"><a href="#堆栈操作" class="headerlink" title="堆栈操作"></a>堆栈操作</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 108</p></blockquote><p>堆栈数据结构 (stack data structure) 的原理与盘子堆栈相同：新值添加到栈顶，删除值也在栈顶移除。堆栈也被称为 LIFO 结构 (后进先出，Last-In First-Out)，其原因是，最后进入堆栈的值也是第一个出堆栈的值。</p><h2 id="运行时堆栈（32位模式）"><a href="#运行时堆栈（32位模式）" class="headerlink" title="运行时堆栈（32位模式）"></a>运行时堆栈（32位模式）</h2><p>运行时堆栈是内存数组，CPU 用 ESP (扩展堆栈指针，extended stack pointer) 寄存器对其进行直接管理，该寄存器被称为堆栈指针寄存器 (stack pointer register)。</p><p>32位模式下，ESP寄存器存放的是堆栈中某个位置的 32 位偏移量。ESP 基本上不会直接被程序员控制，反之，它是用 CALL、RET、PUSH 和 POP 等指令间接进行修改。</p><p><font size = 4><b>入栈操作</b></font></p><p>32位入栈操作把栈顶指针减 4，再将数值复制到栈顶指针指向的堆栈位置。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101231844357.png" alt="入栈操作" style="zoom:67%;" /><p><font size = 4><b>出栈操作</b></font></p><p>出栈操作从堆栈删除数据。数值弹出堆栈后，栈顶指针增加(按堆栈元素大小)，指向堆栈中下一个最高位置。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101231955497.png" alt="出栈操作" style="zoom:67%;" /><p><font size = 4><b>堆栈应用</b></font></p><p>运行时堆栈在程序中有一些重要用途：</p><ul><li>当寄存器用于多个目的时，堆栈可以作为寄存器的一个方便的临时保存区。在寄存器被修改后，还可以恢复其初始值。</li><li>执行 CALL 指令时，CPU 在堆栈中保存当前过程的返回地址。</li><li>调用过程时,输入数值也被称为<strong>参数</strong>，通过将其压入堆栈实现参数传递。</li><li>堆栈也为过程局部变量提供了临时存储区域。</li></ul><h2 id="PUSH-和-POP-指令"><a href="#PUSH-和-POP-指令" class="headerlink" title="PUSH 和 POP 指令"></a>PUSH 和 POP 指令</h2><h3 id="PUSH-指令"><a href="#PUSH-指令" class="headerlink" title="PUSH 指令"></a>PUSH 指令</h3><p>使用 PUSH 指令将数据压入栈内。</p><p>PUSH 指令首先减少 ESP 的值，再将源操作数复制到堆栈。操作数是 16 位的，则 ESP 减 2，操作数是 32 位的,则 ESP 减 4。</p><p>例如 <code>push eax</code> 指令执行的过程可以分为两步：</p><ol><li>指向栈顶的寄存器 <code>esp</code> 进行一个减法操作 <code>sub esp, 4 </code>。</li><li>将需要保存的元素复制到新的栈顶位置 <code>mov [esp], %eax </code>。</li></ol><h3 id="POP-指令"><a href="#POP-指令" class="headerlink" title="POP 指令"></a>POP 指令</h3><p>使用 POP 指令从内存中读取数据，并且修改栈顶指针。</p><p>POP 指令首先把 ESP 指向的堆栈元素内容复制到一个 16 位或 32 位目的操作数中，再增加 ESP  的值。如果操作数是 16 位的，ESP 加 2，如果操作数是 32 位的，ESP 加 4。</p><p>例如 <code>pop ebx</code> 指令就是将栈顶保存的数据复制到寄存器 <code>ebx</code> 中，该指令同样也可以分解成两步：</p><ol><li>从栈顶的位置读出数据，复制到寄存器 <code>ebx</code>：<code>mov ebx, [esp] </code>。</li><li>将栈顶的指针加8（因为 <code>q</code> 表示的是8个字节）：<code>add esp, 4</code>。</li></ol><h3 id="PUSHFD-和-POPFD-指令"><a href="#PUSHFD-和-POPFD-指令" class="headerlink" title="PUSHFD 和 POPFD 指令"></a>PUSHFD 和 POPFD 指令</h3><p>PUSHFD 指令把 32 位 EFLAGS 寄存器内容压入堆栈。</p><p>POPFD 指令则把栈顶单元内容弹出到 EFLAGS 寄存器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pushfd<br>popfd<br></code></pre></td></tr></table></figure><h3 id="PUSHAD-和-POPAD-指令"><a href="#PUSHAD-和-POPAD-指令" class="headerlink" title="PUSHAD 和 POPAD 指令"></a>PUSHAD 和 POPAD 指令</h3><p>PUSHAD 指令按照 EAX、ECX、EDX、EBX、ESP(执行 PUSHAD 之前的值)、EBP、ESI 和 EDI 的顺序，将所有 32 位通用寄存器压入堆栈。</p><p>POPAD 指令按照相反顺序将同样的寄存器弹出堆栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pushad<br>popad<br></code></pre></td></tr></table></figure><p>如果编写的过程会修改 32 位寄存器的值，则在过程开始时使用 PUSHAD 指令，在结束时使用 POPAD 指令，以此保存和恢复寄存器的内容。</p><h3 id="PUSHA-和-POPA-指令"><a href="#PUSHA-和-POPA-指令" class="headerlink" title="PUSHA 和 POPA 指令"></a>PUSHA 和 POPA 指令</h3><p>与之相似，PUSHA 指令按序（AX、CX、DX、BX、SP、BP、SI 和 DI) 将 16 位通用寄存器压入堆栈。</p><p>POPA 指令按照相反顺序将同样的寄存器弹出堆栈。在 16 位模式下,只能使用 PUSHA 和 POPA 指令。</p><hr><h1 id="定义并使用过程"><a href="#定义并使用过程" class="headerlink" title="定义并使用过程"></a>定义并使用过程</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 112</p></blockquote><p>在汇编语言中，通常用术语过程 (procedure) 来指代子程序。在其他语言中，子程序也被称为方法或函数。</p><h2 id="PROC-伪指令"><a href="#PROC-伪指令" class="headerlink" title="PROC 伪指令"></a>PROC 伪指令</h2><p>可以把过程非正式地定义为：以返回语句结束的命令语句块。</p><p>过程使用 PROC 伪指令和 ENDP 伪指令来声明，另外还必须给过程定义一个名字。</p><p>程序启动过程之外的其他过程以 RET 指令结束，以强制 CPU 返回到过程被调用的地方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Function PROC<br>    .<br>    .<br>    .<br>    RET<br>Function ENDP<br></code></pre></td></tr></table></figure><p>但是启动过程（main）是个特例，它以 exit 语句结束。如果程序中使用了 <code>INCLUDE Irvine32.inc</code> 语句的话，exit 语句实际上就是对 ExitProcess 函数的调用，ExitProcess 是用来终止程序的系统函数：<code>INVOKE ExitProcess, 0</code>。</p><h2 id="CALL-和-RET-指令"><a href="#CALL-和-RET-指令" class="headerlink" title="CALL 和 RET 指令"></a>CALL 和 RET 指令</h2><p>CALL 指令指挥处理器在新的内存地址执行指令，以实现过程的调用。过程使用 RET（从过程返回）指令使处理器返回到程序过程被调用的地方继续执行。</p><p>从底层细节角度来讲，CALL 指令把返回地址压入堆栈并把被调用过程的地址复制到指令指针寄存器 (EIP &#x2F; IP) 中。当程序返回时，RET 指令从堆栈中弹出返回地址并送到指令指针寄存器中。</p><p>在 32 位模式下，CPU 总是执行 EIP（指令指针寄存器）所指向的内存出的指令；在 16 位模式下，CPU 总是执行 IP 寄存器指向的指令。</p><p>需要注意的是，进入过程后如果在没有 PUSH 操作的情况下直接 POP，会将之前存入的 CALL 指令后一条指令的地址弹出，从而导致 RET 指令无法正确的返回调用该过程的地址。</p><h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><p>下面的程序通过传递一个 32 位整数数组的偏移量和长度来测试 ArraySum 过程。调用 ArraySum 之后，程序将过程的返回值保存在变量 theSum 中。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102012440040.png" alt="" style="zoom:67%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102012631839.png" style="zoom:67%;" />]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第四章</title>
    <link href="/posts/a23aca48ee77/"/>
    <url>/posts/a23aca48ee77/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第四章学习笔记</b></font></center><br><span id="more"></span><h1 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h1><h2 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 73</p></blockquote><p>x86 指令格式：<code>[label:] mnemonic [operands] [; comment]</code>。其中，指令包含的操作数个数可以是 0个，1个，2个或3个。</p><p>操作数有 3 种基本类型：</p><ul><li><strong>立即数</strong> (<code>imm</code>) ——使用数字文本表达式</li><li><strong>寄存器操作数</strong> (<code>reg</code>) ——使用 CPU 内已命名的寄存器</li><li><strong>内存操作数</strong> (<code>mem</code>) ——引用内存位置</li></ul><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101130934870.png" style="zoom: 50%;" /></center><h2 id="直接内存操作数"><a href="#直接内存操作数" class="headerlink" title="直接内存操作数"></a>直接内存操作数</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 74</p></blockquote><p>变量名引用的是数据段内的偏移量。</p><p>例如，如下变量 var1 的声明表示，该变量的大小类型为字节，值为十六进制的 10：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>var1 BYTE 10h<br></code></pre></td></tr></table></figure><p>可以编写指令，通过内存操作数的地址来解析（查找）这些操作数。</p><p>假设 var1 的地址偏移量为 10400h。如下指令将该变量的值复制到 AL 寄存器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov al var1<br></code></pre></td></tr></table></figure><p>指令会被汇编为下面的机器指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">A0 00010400<br></code></pre></td></tr></table></figure><p>这条机器指令的第一个字节是操作代码（即操作码 (opcode) ）。剩余部分是 var1 的 32 位十六进制地址。虽然编程时有可能只使用数字地址，但是如同 var1 一样的符号标号会让使用内存更加容易。</p><h2 id="直接-偏移量操作数"><a href="#直接-偏移量操作数" class="headerlink" title="直接-偏移量操作数"></a>直接-偏移量操作数</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 78</p></blockquote><p>在变量名称后加上一个偏移值，可以创建直接偏移 (direct-offset) 操作数，可以通过它来访问没有显示标号的内存地址。我们以一个名为 arrayB 的<strong>字节数组</strong>开始枚举：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>arrayB BYTE 10h, 20h, 30h, 40h, 50h ; 注意此处为 BYTE(一个字节)<br><br>.code<br>mov al, arrayB        ; AL = 10h<br>mov al, [arrayB + 1]  ; AL = 20h<br>mov al, [arrayB + 2]  ; AL = 30h<br></code></pre></td></tr></table></figure><p>如果是双字节或者双字（四个字节）或者是其他，注意偏移的时候地址分别是 2、4 或者其他等。</p><hr><h1 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 75</p></blockquote><h2 id="MOV-指令"><a href="#MOV-指令" class="headerlink" title="MOV 指令"></a>MOV 指令</h2><p>MOV指令将源操作数复制到目的操作数。</p><p>在它的基本格式中，<strong>第一个操作数是目的操作数</strong>，<strong>第二个操作数是源操作数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV destination, source<br></code></pre></td></tr></table></figure><p>其中，目的操作数的内容会发生改变，而源操作数不会改变。</p><p>下面是 MOV 指令的标准格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV reg, reg<br>MOV mem, reg<br>MOV reg, mem<br>MOV mem, imm<br>MOV reg, imm<br></code></pre></td></tr></table></figure><p><strong>需要特别注意以下的原则</strong>：</p><ul><li>两个操作数必须是同样的大小。</li><li>两个操作数不能同时为内存操作数。</li><li>指令指针寄存器 (<code>IP</code>、<code>EIP</code>、<code>RIP</code>) 不能作为目标寄存器。</li></ul><p><font size = 4><b>内存到内存</b></font></p><p>单条 MOV 指令不能用于直接将数据从一个内存位置传送到另一个内存位置。相反，在将源操作数的值赋给内存操作数之前，必须先将该数值传送给一个寄存器。在将整型常数复制到一个变量或寄存器时，必须考虑该常量需要的最少字节数。</p><p><font size = 4><b>覆盖值</b></font></p><p>下述代码示例演示了怎样通过使用不同大小的数据来修改同一个32位寄存器。</p><ul><li><p>当 oneWord 字传送到 AX 时，它就覆盖了 AL 中已有的值。</p></li><li><p>当 oneDword 传送到 EAX 时，它就覆盖了 AX 的值。</p></li><li><p>最后，当 0 被传送到 AX 时，它就<strong>覆盖了 EAX 的低半部分</strong>。</p></li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101134153188.png" alt="image" style="zoom:60%;" /><h2 id="整数的全零-x2F-符号扩展"><a href="#整数的全零-x2F-符号扩展" class="headerlink" title="整数的全零&#x2F;符号扩展"></a>整数的全零&#x2F;符号扩展</h2><p><font size = 4><b>把一个较小的值复制到一个较大的操作数</b></font></p><p>尽管 MOV 指令不能直接将较小的操作数复制到较大的操作数中，但是程序员可以想办法解决这个问题。</p><p>假设要将count (无符号，16位) 传送到ECX (32位)，可以先将 ECX 设置为 0，然后将 count 传送到 CX：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>count WORD 1<br>.code<br>mov ecx, 0<br>mov cx, count<br></code></pre></td></tr></table></figure><p>如果对一个有符号整数 -16 进行同样的操作会发生什么呢?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>signedVal SWORD -16    ; FFF0h(-16)<br>.code<br>mov ecx, 0<br>mov cx, signedVal      ; ECX = 0000FFF0h (+65520)<br></code></pre></td></tr></table></figure><p>ECX中的值 (+65520) 与 -16 完全不同。</p><p>但是，如果先将 ECX 设置为 FFFFFFFFh，然后再把 signedVal 复制到 CX，那么最后的值就是完全正确的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ecx，0FFFFFFFFh<br>mov cx, signedVal      ; ECX = FFFFFFF0h (-16)<br></code></pre></td></tr></table></figure><p>本例的有效结果是用源操作数的最高位（1）来填充目的操作数ECX的高16位，这种技术称为符号扩展( sign extension)。</p><p>当然，不能总是假设源操作数的最高位是1。</p><p>幸运的是，Intel 的工程师在设计指令集时已经预见到了这个问题，因此，设置了 <strong>MOVZX</strong> 和 <strong>MOVSX</strong> 指令来分别处理<strong>无符号整数</strong>和<strong>有符号整数</strong>。</p><h3 id="MOVZX-指令"><a href="#MOVZX-指令" class="headerlink" title="MOVZX 指令"></a>MOVZX 指令</h3><p>MOVZX 指令（进行全零扩展并传送）将源操作数复制到目的操作数，<strong>并把目的操作数<mark>0扩展</mark>到 16 位或 32 位</strong>。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101154536720.png" alt="image-20230101154536720" style="zoom:53%;" /><p>这条指令<strong>只用于无符号整数</strong>，有三种不同的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOVZX reg32, reg/mem8<br>MOVZX reg32, reg/mem16<br>MOVZX reg16, reg/mem8<br></code></pre></td></tr></table></figure><p>在三种形式中，第一个操作数（寄存器）是目的操作数，第二个操作数是源操作数。<strong>注意，源操作数不能是常数。</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101154801107.png" alt="image" style="zoom: 60%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101154848550.png" alt="" style="zoom:60%;" /><h3 id="MOVSX-指令"><a href="#MOVSX-指令" class="headerlink" title="MOVSX 指令"></a>MOVSX 指令</h3><p>MOVSX 指令（进行符号扩展并传送）将源操作数内容复制到目的操作数，<strong>并把目的操作数<mark>符号扩展</mark>到 16 位或 32 位。</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101155132150.png" alt="image-20230101155132150" style="zoom:53%;" /><p>这条指令只用于有符号整数，有三种不同的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOVSX reg32, reg/mem8<br>MOVSX reg32, reg/mem16<br>MOVSX reg16, reg/mem8<br></code></pre></td></tr></table></figure><p>操作数进行符号扩展时，在目的操作数的全部扩展位上重复(复制)长度较小操作数的最高位。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101160019171.png" style="zoom:60%;" /><h2 id="LAHF-和-SAHF-指令"><a href="#LAHF-和-SAHF-指令" class="headerlink" title="LAHF 和 SAHF 指令"></a>LAHF 和 SAHF 指令</h2><p>LAHF（<em>load</em> status <em>flags</em> into <em>AH</em>，加载状态标志位<strong>到 AH</strong>）指令将 EFLAGS 寄存器的<strong>低字节复制到 AH</strong>。被复制的标志位包括：符号标志位、零标志位、辅助进位标志位、奇偶标志位和进位标志位。使用这条指令，可以方便地把标志位副本保管在变量中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>saveflags BYTE ?<br>.code<br>lahf                ; 将标志位加载到 AH<br>mov saveflags, ah   ; 用变量保存这些标志位<br></code></pre></td></tr></table></figure><p>SAHF（<em>store</em> <em>AH</em> into status <em>flags</em>，保存 AH 内容到状态标志位）指令将 <strong>AH 内容复制到</strong> EFLAGS（或 RFLAGS）寄存器低字节。例如，可以检索之前保存到变量中的标志位数值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ah, saveflags   ; 加载被保存标志位到 AH<br>sahf                ; 复制到 FLAGS 寄存器<br></code></pre></td></tr></table></figure><h2 id="XCHG-指令"><a href="#XCHG-指令" class="headerlink" title="XCHG 指令"></a>XCHG 指令</h2><p>XCHG（<em>exchange</em> data，交换数据）指令交换两个操作数内容。该指令有三种形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">XCHG reg, reg<br>XCHG reg, mem<br>XCHG mem, reg<br></code></pre></td></tr></table></figure><p>除了 <strong>XCHG 指令不使用立即数作操作数</strong>之外，XCHG 指令操作数的要求与 MOV 指令操作数要求是一样的。即：</p><ol><li>两个操作数不能同时都为内存操作数。</li><li>任何一个操作数都不能为立即数。</li><li>指令指针寄存器 (<code>IP</code>、<code>EIP</code>、<code>RIP</code>) 不能作为目标寄存器。</li><li>两个操作数必须是同样的大小。</li></ol><p>以下是一些使用 XCHG 指令的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">xchg ax, bx      ; 交换两个 16 位寄存器的内同<br>xchg ah, al      ; 交换两个 8 位寄存器的内容<br>xchg var1, bx    ; 交换 16 位的内存操作数和 BX 寄存器内容<br>xchg eax, ebx    ; 交换两个 32 位寄存器的内同<br></code></pre></td></tr></table></figure><p>若要交换两个内存操作数，需要使用一个寄存器作为临时存储容器，并把 MOV 指令和 XCHG 指令结合起来使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov  ax, val1<br>xchg ax, val2<br>mov  val1, ax  <br></code></pre></td></tr></table></figure><h2 id="习题整理"><a href="#习题整理" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  下列语句中，有语法错误的是：（D）<br>  A. add esi, TYPE DWORD<br>  B. pop eax<br>  C. repe cmpsd<br>  D. mov val1, val2</p></blockquote><p>MOV 指令两个操作数不能同时为内存操作数。</p><hr><h1 id="程序示例1"><a href="#程序示例1" class="headerlink" title="程序示例1"></a>程序示例1</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 79</p></blockquote><p>该程序中包含了本文之前介绍的所有指令，包括：MOV、XCHG、MOVSX 和 MOVZX，展示了字节、字和双字是如何受到它们的影响。同时，程序中还包括了一些直接-偏移量操作数。</p><center><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101164424148.png" alt="" style="zoom:67%;" /><br><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101164502334.png" alt="" style="zoom:67%;" /></p></center><hr><h1 id="加法和减法"><a href="#加法和减法" class="headerlink" title="加法和减法"></a>加法和减法</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 81</p></blockquote><h2 id="INC-和-DEC-指令"><a href="#INC-和-DEC-指令" class="headerlink" title="INC 和 DEC 指令"></a>INC 和 DEC 指令</h2><p>INC (increment) 和 DEC (decrement) 指令从操作数中加 1 或减 1，格式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">INC  reg/mem<br>DEC  reg/mem<br></code></pre></td></tr></table></figure><p>根据目标操作数的值，溢出标志位、符号标志位、零标志位、辅助进位标志位、进位标志位和奇偶标志位会发生变化。</p><p>INC和 DEC指令<strong>不会影响进位标志位</strong>。</p><h2 id="ADD-指令"><a href="#ADD-指令" class="headerlink" title="ADD 指令"></a>ADD 指令</h2><p>ADD 指令将同尺寸的源操作数和目的操作数相加，格式是：<code>ADD dest, source</code>。</p><p>在操作中，源操作数不能改变，相加之<strong>和存放在目的操作数中</strong>。</p><p>该指令可以使用的操作数与 MOV 指令相同。</p><p>进位标志位、零标志位、符号标志位、溢出标志位、辅助进位标志位和奇偶标志位根据<strong>存入目标操作数的数值</strong>进行变化。</p><h2 id="SUB-指令"><a href="#SUB-指令" class="headerlink" title="SUB 指令"></a>SUB 指令</h2><p>SUB 指令<strong>将源操作数从目的操作数中减掉</strong>，操作数格式与 ADD 和 MOV 指令操作数相同。</p><p>格式是：<code>SUB dest, source</code>。</p><p>进位标志位、零标志位、符号标志位、溢出标志位、辅助进位标志位和奇偶标志位根据<strong>存入目标操作数的数值</strong>进行变化。</p><p>有一种执行减法而无需使用额外的数字电路单元的简单方法：对源操作数求补，然后把源操作数和目的操作数相加。</p><h2 id="NEG-指令"><a href="#NEG-指令" class="headerlink" title="NEG 指令"></a>NEG 指令</h2><p>NEG (negate) 指令通过将数字转换为对应的补码而求得其相反数（将目标操作数按位取反再加1，就可以得到这个数的二进制补码)。</p><p>格式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">NEG reg<br>NEG mem<br></code></pre></td></tr></table></figure><p>进位标志位、零标志位、符号标志位、溢出标志位、辅助进位标志位和奇偶标志位根据<strong>存入目标操作数的数值</strong>进行变化。</p><h2 id="加减法影响的标志位"><a href="#加减法影响的标志位" class="headerlink" title="加减法影响的标志位"></a>加减法影响的标志位</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 83</p></blockquote><ul><li>进位标志位意味着<strong>无符号整数</strong>溢出。<br>比如，如果指令目的操作数为 8 位，而指令产生的结果大于二进制的 1111 1111，那么进位标志位置 1。</li><li>溢出标志位意味着<strong>有符号整数</strong>溢出。<br>比如，指令目的操作数为 16 位，但其产生的负数结果小于十进制的 -32768，那么溢出标志位置 1。</li><li>零标志位意味着<strong>操作结果为 0</strong>。<br>比如，如果两个值相等的操作数相减，则零标志位置 1。</li><li>符号标志位意味着操作<strong>产生的结果为负数</strong>。如果目的操作数的最高有效位（MSB）置 1，则符号标志位置 1。</li><li>奇偶标志位是指，在一条算术或布尔运算指令执行后，立即判断目的操作数最低有效字节中1的个数是否为偶数。</li><li>辅助进位标志位置1，意味着目的操作数最低有效字节中位 3 有进位。</li></ul><h2 id="习题整理-1"><a href="#习题整理-1" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  下列语句中，有语法错误的是：（B）<br>  A. mov ax, WORD PTR value<br>  B. inc [esi]<br>  C. movzx cx,bl<br>  D. movsx edx,bl</p></blockquote><p>INC 指令只能对寄存器操作数和内存操作数使用。</p><hr><h1 id="和数据相关的操作符和伪指令"><a href="#和数据相关的操作符和伪指令" class="headerlink" title="和数据相关的操作符和伪指令"></a>和数据相关的操作符和伪指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 87</p></blockquote><p>MASM 操作符或伪指令<strong>获取数据的地址以及大小等特征信息</strong>：</p><ul><li><p>OFFSET 操作符返回一个变量相对于其所在段开始的偏移。</p></li><li><p>PTR 操作符允许重载变量的默认尺寸。</p></li><li><p>TYPE 操作符返回数组中每个元素的大小（以字节计算）。</p></li><li><p>LENGTHOF 操作符返回数组内元素的数目。</p></li><li><p>SIZEOF 操作符返回数组初始化时占用的字节数。</p></li></ul><p>除此之外，LABEL 伪指令可以用不同的大小类型来重新定义同一个变量。</p><h2 id="OFFSET-运算符"><a href="#OFFSET-运算符" class="headerlink" title="OFFSET 运算符"></a>OFFSET 运算符</h2><p>OFFSET 操作符返回数据标号的偏移地址。偏移地址代表标号距离数据段开始的距离，单位是以字节计算的。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101174947466.png" alt="" style="zoom:60%;" /><p>在下面的例子中，将用到如下三种类型的变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>bVal  BYTE  ?<br>wVal  WORD  ?<br>dval  DWORD ?<br>dVal2 DWORD ?<br></code></pre></td></tr></table></figure><p>假设 bVal 在偏移量为 0040 4000 (十六进制) 的位置，则 OFFSET 运算符返回值如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov esi, OFFSET bval   ; ESI = 00404000h<br>mov esi, OFFSET wval   ; ESI = 00404001h<br>mov esi, OFFSET dVal   ; ESI = 00404003h<br>mov esi ,OFFSET dval2  ; ESI = 00404007h<br></code></pre></td></tr></table></figure><p>OFFSET 也可以应用于直接-偏移量操作数。</p><p>设 myArray 包含 5 个 16 位的字。下面的 MOV 指令首先得到 myArray 的偏移量，然后加 4，再将形成的结果地址直接传送给 ESI。因此，现在可以说 ESI 指向数组中的第 3 个整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>myArray WORD 1, 2, 3, 4, 5<br>.code<br>mov esi, OFFSET myArray + 4   ; 1 WORD = 2 BYTE<br></code></pre></td></tr></table></figure><h2 id="ALIGN-运算符"><a href="#ALIGN-运算符" class="headerlink" title="ALIGN 运算符"></a>ALIGN 运算符</h2><p>ALIGN伪指令将变量的位置按字节、字、双字或段边界对齐，语法是：ALIGN <em>bound</em>。<em>bound</em> 可以取的值有：1、2、4、8、16。指令把地址直接对齐到所指定 <em>bound</em> 的倍数上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">   bVal   BYTE  ?     ;00404000<br>   ALIGN  2<br>   wVa    WORD  ?     ; 00404002<br>   bVal2  BYTE  ?     ; 00404004<br>   ALIGN  4<br>   dVal   DWORD ?     ; 00404008<br>   dVal2  DWORD ?     ; 0040400C<br></code></pre></td></tr></table></figure><p>请注意，dVal 的偏移量原本是 0040 4005，但是 <code>ALIGN 4</code> 伪指令使它的偏移量成为 0040 4008。</p><h2 id="PTR-操作符"><a href="#PTR-操作符" class="headerlink" title="PTR 操作符"></a>PTR 操作符</h2><p>PTR 操作符来重载操作数声明的默认尺寸，这在试图以不同于变量声明时所使用的尺寸属性访问变量的时候非常有用。</p><p>例如，假设要讲双字变量 myDouble 的低 16 位传送给 AX 寄存器，由于操作数大小不匹配，编译器将不允许下面的数据传送指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>myDouble DOWRD 12345678h<br><br>.code<br>MOV ax, myDouble          ; 错误<br></code></pre></td></tr></table></figure><p>但是 <code>WORD PTR</code> 操作符使得将低字（5678）传送给 AX 成为可能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV ax, WORD PTR myDouble<br></code></pre></td></tr></table></figure><p>注意，<strong>PTR 必须与一个标准汇编数据类型一起使用</strong>，这些类型包括：BYTE、SBYTE、WORD、SWORD、DWORD、SDWORD、FWORD、QWORD 或 TBYTE。</p><h2 id="TYPE-运算符"><a href="#TYPE-运算符" class="headerlink" title="TYPE 运算符"></a>TYPE 运算符</h2><p>TYPE运算符返回变量单个元素的大小，这个大小是<strong>以字节为单位</strong>计算的。</p><p>比如，TYPE为字节，返回值是1 ；TYPE为字，返回值是2；TYPE为双字，返回值是4；TYPE为四字,返回值是8。</p><p>示例如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>Var1 BYTE  ?<br>Var2 WORD  ?<br>Var3 DWORD ?<br>Var4 QWORD ?<br></code></pre></td></tr></table></figure><p>下面是每个 TYPE 表达式的值：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101191245030.png" style="zoom: 67%;" /><h2 id="LENGTHOF-运算符"><a href="#LENGTHOF-运算符" class="headerlink" title="LENGTHOF 运算符"></a>LENGTHOF 运算符</h2><p>LENGTHOF 运算符计算数组中元素的个数，元素个数是由数组标号同一行出现的数值来定义的。示例如下：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101191614251.png" style="zoom:80%;" /><p>如果数组定义中出现了嵌套的 DUP 运算符，那么 LENGTHOF 返回的是两个数值的乘积。</p><p>下表列出了每个 LENGTHOF 表达式返回的数值。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101191653807.png" style="zoom:67%;" /><h2 id="SIZEOF-运算符"><a href="#SIZEOF-运算符" class="headerlink" title="SIZEOF 运算符"></a>SIZEOF 运算符</h2><p>SIZEOF 运算符返回值等于 LENGTHOF 与 TYPE 返回值的乘积。</p><p>如下例所示，intArray 数组的 TYPE &#x3D; 2，LENGTHOF  &#x3D; 32，因此，<code>SIZEOF intArray</code> &#x3D; 64：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>intArray WORD 32 DUP(0)<br><br>.code<br>Mov eax, SIZEOF intArray ; 64<br></code></pre></td></tr></table></figure><h2 id="LABEL-伪指令"><a href="#LABEL-伪指令" class="headerlink" title="LABEL 伪指令"></a>LABEL 伪指令</h2><p>LABEL 伪指令允许插入一个标号并赋予其尺寸属性而无需任何实际的存储空间。LABEL 伪指令可以使用 BYTE、WORD、DWORD、QWORD 或 TBYTE 等任意的标准尺寸属性。LABEL 伪指令的一种常见的用法是为数据段内其后定义的变量提供一个别名以及一个不同的尺寸属性。</p><p>下例中在 val32 前面声明了一个名为 val16 的标号并赋予其 WORD 属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>Val16 LABEL WORD<br>Val32 DWORD 12345678h<br><br>.code<br>MOV ax, val16          ; AX = 5678h<br>MOV dx, [val16 + 2]    ; DX = 1234h<br></code></pre></td></tr></table></figure><p>val16 是名为 val32 的存储地址的一个别名。LABEL 伪指令本身并不占用实际存储空间。</p><h2 id="习题整理-2"><a href="#习题整理-2" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr></blockquote><blockquote><p>  下列语句中，有语法错误的是：（A）<br>  A. mov ax, PTR value<br>  B. inc esi<br>  C. xchg ebx, eax<br>  D. add esi, TYPE DWORD</p></blockquote><p><strong>PTR 必须与一个标准汇编数据类型一起使用</strong>，这些类型包括：BYTE、SBYTE、WORD、SWORD、DWORD、SDWORD、FWORD、QWORD 或 TBYTE。</p><hr><h1 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 91</p></blockquote><p>直接寻址很少用于数组处理，因为，用常数偏移量来寻址多个数组元素时，直接寻址不实用。反之，会用寄存器作为指针（称为间接寻址）并控制该寄存器的值。</p><p>如果一个操作数使用的是间接寻址,就称之为<strong>间接操作数</strong>。</p><h2 id="间接操作数"><a href="#间接操作数" class="headerlink" title="间接操作数"></a>间接操作数</h2><p>任何一个 32 位通用寄存器（EAX、EBX、ECX、EDX、ESI、EDI、EBP 和 ESP）加上括号就能构成一个间接操作数。寄存器中存放的是数据的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>val1 BYTE 10h<br><br>.code<br>mov esi, OFFSET val1<br>mov al, [esi]          ; AL = 10h<br></code></pre></td></tr></table></figure><p>如果目的操作数也是间接操作数，那么新值将存入由寄存器提供地址的内存位置。</p><p>在下面的例子中，BL 寄存器的内容复制到 ESI 寻址的内存地址中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV [esi], bl<br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>间接操作数是步进遍历数组的理想工具。</p><p>下例中，arrayB 有 3 个字节。随着 ESI 不断加 1，它就能顺序指向每一个字节：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>arrayB BYTE 10h, 20h, 30h<br><br>.code<br>mov esi, OFFSET arrayB<br>mov al, [esi]      ; AL = 10h<br>inc esi<br>mov al, [esi]      ; AL = 20h<br>inc esi<br>mov al, [esi]      ; AL = 30h<br></code></pre></td></tr></table></figure><p>如果使用 16 位的整数数组，就需要每次给 ESI 加 2 以便寻址后续的各个数组元素。</p><h2 id="变址操作数"><a href="#变址操作数" class="headerlink" title="变址操作数"></a>变址操作数</h2><p>变址操作数是指，在寄存器上加上常数产生一个有效地址。每个 32 位通用寄存器都可以用作变址寄存器。</p><p>MASM 可以用不同的符号来表示变址操作数（括号是表示符号的一部分)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">constant[reg]<br>[constant + reg]<br></code></pre></td></tr></table></figure><p>第一种形式是变量名加上寄存器。变量名由汇编器转换为常数，代表的是该变量的偏移量。</p><p>变址寻址的第二种形式是寄存器加上常数偏移量。变址寄存器保存数组或结构的基址，常数标识各个数组元素的偏移量。</p><p>两种形式的效果是相同的。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101235820435.png" alt="" style="zoom:67%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; example 1<br>.data<br>arrayB BYTE 10h, 20h, 30h<br>.code<br>mov esi, 0<br>mov al, arrayB[esi]       ; AL = 10h<br><br>; example 2<br>.data<br>arrayW WORD 1000h, 2000h, 3000h<br>.code<br>mov esi, OFFSET arrayW<br>mov ax, [esi]             ; AX = 1000h<br>mov ax, [esi + 2]         ; AX = 2000h<br>mov ax, [esi + 4]         ; AX = 3000h<br></code></pre></td></tr></table></figure><hr><h1 id="JMP-和-LOOP-指令"><a href="#JMP-和-LOOP-指令" class="headerlink" title="JMP 和 LOOP 指令"></a>JMP 和 LOOP 指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 95</p></blockquote><p>默认情况下，CPU是顺序加载并执行程序。但是，当前指令有可能是有条件的，也就是说，它按照 CPU 状态标志（零标志、符号标志、进位标志等）的值把控制转向程序中的新位置。汇编语言程序使用条件指令来实现如 IF 语句的高级语句与循环。每条条件指令都包含了一个可能的转向不同内存地址的转移（跳转）。控制转移，或分支，是一种改变语句执行顺序的方法，它有两种基本类型：</p><ul><li><p><strong>无条件转移</strong>：无论什么情况都会转移到新地址。新地址加载到指令指针寄存器，使得程序在新地址进行执行。JMP 指令实现这种转移。</p></li><li><p><strong>条件转移</strong>：满足某种条件，则程序出现分支。各种条件转移指令还可以组合起来，形成条件逻辑结构。CPU 基于 ECX 和标志寄存器的内容来解释真 &#x2F; 假条件。</p></li></ul><h2 id="JMP-指令"><a href="#JMP-指令" class="headerlink" title="JMP 指令"></a>JMP 指令</h2><p>JMP 指令无条件跳转到目标地址，该地址用代码标号来标识，并被汇编器转换为偏移量。语法是：<code>JMP destination</code>。</p><p>当 CPU 执行一个无条件转移时，目标地址的偏移量被送入指令指针寄存器，从而导致从新地址开始继续执行。</p><p>JMP 指令提供了一种简单的方法来创建循环即跳转到循环开始时的标号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">top:<br>    .<br>    .<br>    jmp top ; 不断地循环<br></code></pre></td></tr></table></figure><p>JMP 是无条件的，因此循环会无休止地进行下去，除非找到其他方法退出循环。</p><h2 id="LOOP-指令"><a href="#LOOP-指令" class="headerlink" title="LOOP 指令"></a>LOOP 指令</h2><p>LOOP指令，正式称为<strong>按照 ECX 计数器循环</strong>，将程序块重复特定次数。<strong>ECX 自动成为计数器，每循环一次计数值减 1</strong>。</p><p>语法是：<code>LOOP destination</code>。</p><p>循环目标必须距离当前地址计数器 -128 到 +127 字节范围内。</p><p>LOOP 指令的执行有两个步骤：第一步，ECX 减 1；第二步，将 ECX 与 0 比较。如果 ECX 不等于 0，则跳转到由目标给出的标号。否则如果 ECX 等于 0，则不发生跳转，并将控制传递到循环后面的指令。</p><p>在下例中，每次执行循环时 AX 加 1，当循环结束的时候 AX &#x3D; 5，ECX &#x3D; 0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">    mov ax, 0<br>    mov ecx, 5<br><br>L1:<br>    inc ax<br>    loop L1<br></code></pre></td></tr></table></figure><p>在循环内创建另一个循环的时候，必须考虑 ECX 中的外层循环计数该如何处理。一个较好的解决方案是把外层循环的技术保存在一个变量中。作为一条一般性的规则，应该尽量避免使用嵌套深度超过两层的循环。否则，管理循环计数将很复杂。</p><h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 98</p></blockquote><p><font size = 4><b>整数数组求和</b></font></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101210920217.png" alt="" style="zoom:67%;" /><p><font size = 4><b>复制字符串</b></font></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101211026618.png" style="zoom:67%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101211106805.png" alt="" style="zoom:67%;" /><p>MOV 指令不能同时有两个内存操作数，所以，每个源字符串字符送入 AL，然后再从 AL 送入目标字符串。</p>]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第三章</title>
    <link href="/posts/84d13931adf9/"/>
    <url>/posts/84d13931adf9/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第三章学习笔记</b></font></center><br><span id="more"></span><h1 id="汇编语言部分基本语言元素"><a href="#汇编语言部分基本语言元素" class="headerlink" title="汇编语言部分基本语言元素"></a>汇编语言部分基本语言元素</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 42</p></blockquote><p><font size = 5><b>整数常量</b></font></p><p>以字母开头的十六进制数必须加个前置0，以防汇编器将其解释为标识符。</p><p><font size = 5><b>字符串常量</b></font></p><p>和字符常量以整数形式存放一样，字符串常量在内存中的保存形式为<strong>整数字节数值序列</strong>。</p><p>例如，字符串常量 “ABCD” 就包含四个字节 41h、42h、43h、44h。</p><p><font size = 5><b>伪指令</b></font></p><p>伪指令 (directive) 是嵌入源代码中的命令，由汇编器识别和执行。</p><p>伪指令不在运行时执行，但是它们可以定义变量、宏和子程序；为内存段分配名称，执行许多其他与汇编器相关的日常任务。</p><p>默认情况下，伪指令不区分大小写。例如，<code>.data</code>，<code>.DATA</code> 和 <code>.Data</code> 是相同的。</p><p><font size = 5><b>定义段</b></font></p><p>汇编器伪指令的一个重要功能是定义程序区段，也称为段 (segment)。程序中的段具有不同的作用。</p><ul><li><p>数据段：<code>.DATA</code> 伪指令表示的数据段可以用于定义变量。</p></li><li><p>代码段：<code>.CODE</code> 伪指令标识的程序区段包含了可执行的指令。</p></li><li><p>堆栈段：<code>.STACK</code> 伪指令标识的程序区段定义了运行时堆栈，并设置了其大小。</p></li></ul><p><font size = 5><b>指令</b></font></p><p>指令 (instruction) 是一种语句，它在程序汇编编译时变得可执行。汇编器将指令翻译为机器语言字节，并且在运行时由 <code>CPU</code> 加载和执行。一条指令有四个组成部分：</p><ol><li>标号（可选）：是一种标识符，是指令和数据的位置标记。标号有两种类型：数据标号和代码标号。</li><li>指令助记符（必需）</li><li>操作数（通常是必需的）</li><li>注释（可选）</li></ol><h2 id="习题整理"><a href="#习题整理" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  计算机的 <code>CPU</code> 每执行一个 ( )，就完成一步基本运算。 （D）<br>  A. 软件<br>  B. 算法<br>  C. 程序<br>  D. 指令</p></blockquote><p>解析见上文整理内容。</p><blockquote><hr><p>  在 x86 汇编语言中，汇编程序常用的三个段，分别是（代码段）、（数据段）和（堆栈段）；<br>  对于 <strong>32位 CPU</strong>，用于在循环中控制循环次数的寄存器是（$ECX$），包含下一跳将要执行指令的地址的寄存器是（$EIP$）。</p></blockquote><p>解析见上文整理内容。</p><blockquote><hr><p>  一条指令有四个组成部分，分别是标号、（指令助记符）、（操作数）和（注释）。其中，标号可分为（数据标号）和（代码标号）。</p></blockquote><p>解析见上文整理内容。</p><hr><h1 id="程序模板"><a href="#程序模板" class="headerlink" title="程序模板"></a>程序模板</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 47, 52, 67</p></blockquote><p>汇编语言程序有一个简单的结构，并且变化很小。当开始编写一个新程序时，可以从一个空 shell 程序开始，里面有所有基本的元素。通过填写缺省部分，并在新名字下保存该文件就可以避免键入多余的内容。关键字大小写均可：</p><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20221231195555.png" alt="image" style="zoom:67%;" /></center><hr><h1 id="汇编、连接和运行程序"><a href="#汇编、连接和运行程序" class="headerlink" title="汇编、连接和运行程序"></a>汇编、连接和运行程序</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 53</p></blockquote><p>用汇编语言编写的源程序不能直接在其目标计算机上执行，必须通过翻译或汇编将其转换为可执行代码。汇编器生成包含机器语言的文件，称为目标文件 (object file)。</p><p>这个文件还没有准备好执行，它还需传递给一个被称为链接器 (linker) 的程序，从而生成可执行文件 (executable file)。</p><p>这个文件就准备好在操作系统命令提示符下执行。</p><p><font size = 5><b>汇编-连接-执行周期</b></font></p><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221231174038959.png" alt="汇编-连接-执行周期" style="zoom: 67%;" /></center><p>对上图每一个步骤进行说明：</p><ol><li>编程者用文本编辑器 (text editor) 创建一个 <code>ASCII</code> 文本文件，称之为<strong>源文件</strong>。</li><li><strong>汇编器</strong>读取源文件，并<strong>生成目标文件</strong>，即对程序的机器语言翻译。或者，它也会生成列表文件。只要出现任何错误，编程者就必须返回步骤1，修改程序。</li><li><strong>链接器</strong>读取并<strong>检查目标文件</strong>，以便发现该程序是否包含了任何对链接库中过程的调用。链接器从链接库中复制任何被请求的过程，将它们与目标文件组合，以生成<strong>可执行文件</strong>。</li><li>操作系统<strong>加载</strong>程序将可执行文件读入内存，并使 CPU 分支到该程序起始地址，然后程序开始执行。</li></ol><h2 id="习题整理-1"><a href="#习题整理-1" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  在汇编语言中，能将目标文件生成可执行文件的程序是： （C）<br>  A. 调试程序<br>  B. 汇编程序<br>  C. 链接程序<br>  D. 编译程序</p></blockquote><p>链接器从链接库中复制任何被请求的过程，将它们与目标文件组合，以生成<strong>可执行文件</strong>。</p><hr><h1 id="定义数据"><a href="#定义数据" class="headerlink" title="定义数据"></a>定义数据</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 55</p></blockquote><p><strong>数据定义语句</strong>形如：<code>count DWORD 12345</code>。</p><h2 id="内部数据类型"><a href="#内部数据类型" class="headerlink" title="内部数据类型"></a>内部数据类型</h2><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221231175027618.png" alt="内部数据类型" style="zoom:67%;" /></center><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221231202803655.png" alt="image-20221231202803655" style="zoom: 67%;" /></center><h2 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h2><h3 id="定义整数类型"><a href="#定义整数类型" class="headerlink" title="定义整数类型"></a>定义整数类型</h3><p>初始值数据定义中<strong>至少要有一个初始值</strong>，即使该值为 0。</p><p>其他初始值，如果有的话，用逗号分隔（例如初始化数组：<code>list BYTE 10, 20, 30</code>）。<strong>对整数数据类型而言，初始值 (initializer) 是整数常量或是与变量类型</strong>，如 <code>BTYE</code> 或 <code>WORD</code> 相匹配的整数表达式。</p><p>如果程序员希望不对变量进行初始化（随机分配数值)，可以用符号 <code>?</code> 作为初始值。使用 <code>?</code> 初始值使得变量未初始化，这意味着在运行时分配数值到该变量。</p><p>所有初始值，不论其格式，都由汇编器转换为二进制数据。初始值 00110010b、32h 和 50d 都具有相同的二进制数值。</p><h3 id="定义字符串"><a href="#定义字符串" class="headerlink" title="定义字符串"></a>定义字符串</h3><p>定义一个字符串，要用单引号或双引号将其括起来。</p><p>最常见的字符串类型是用一个空字节(值为 0)作为结束标记，称为<strong>以空字节结束的字符串</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">greeting1 BYTE &quot;Good Afternoon&quot;, 0<br>greeting2 BYTE &#x27;Good Night&#x27;, 0<br></code></pre></td></tr></table></figure><p>十六进制代码 <code>ODh</code> 和 <code>0Ah</code> 也被称为 <code>CR/LF</code> (回车换行符) 或行结束字符。在编写标准输出时，它们将光标移动到当前行的下一行的左侧。</p><h3 id="DUP-操作符"><a href="#DUP-操作符" class="headerlink" title="DUP 操作符"></a>DUP 操作符</h3><p>DUP 操作符使用一个整数表达式作为计数器，<strong>为多个数据项分配存储空间</strong>。在为字符串或数组分配存储空间时，这个操作符非常有用，它可以使用初始化或非初始化数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">BYTE 20 DUP(O)       ; 20个字节，值都为0<br>BYTE 20 DUP(?)       ; 20个字节，非初始化<br>BYTE  4 DUP(&quot;STACK&quot;) ; 20个字节<br></code></pre></td></tr></table></figure><h3 id="定义浮点类型"><a href="#定义浮点类型" class="headerlink" title="定义浮点类型"></a>定义浮点类型</h3><ul><li><p>REAL4 定义 4 字节单精度浮点变量。</p></li><li><p>REAL8 定义 8 字节双精度数值。</p></li><li><p>REAL10 定义 10 字节扩展精度数值。</p></li></ul><p>每个伪指令都需要一个或多个实常数初始值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">rVal1     REAL4   -1.2<br>rVal2     REAL8   3.2E-260<br>rVal3     REAL10  4.6E+4096<br>shortArray  REAL4   20 DUP(0.0)<br></code></pre></td></tr></table></figure><p>下图描述了标准实数类型的最少有效数字个数和近似范围：</p><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221231190349341.png" alt="标准实数类型" style="zoom:67%;" /></center><h2 id="习题整理-2"><a href="#习题整理-2" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  语句“array WORD 6 DUP (4)”分配主存的存储单元个数是：（B）<br>  A. 6<br>  B. 12<br>  C. 24<br>  D. 48</p></blockquote><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/115640956">吐血整理！这篇带你彻底理解主存中存储单元地址的分配 - 知乎 (zhihu.com)</a></p><p>通常都是以8位二进制为一个存储单元，也就是一个字节。一个 <code>WORD</code> 拥有2个字节，<code>DUP</code> 前面的数字为6，表示共创建6个 <code>WORD</code>，即共12个字节。</p><blockquote><hr><p>  语句“array WORD 10 DUP (?)”分配主存的存储单元个数是：（20）</p></blockquote><p>解析无</p><blockquote><hr><p>  语句“array DWORD 10,20,30,40”分配主存的存储单元个数是：（16）</p></blockquote><p>解析无</p><blockquote><hr><p>  语句“array WORD 10,20,30,40”分配主存的存储单元个数是：（8）</p></blockquote><p>解析无</p><blockquote><hr><p>  语句“array DWORD 10,20,30,40,50”分配主存的存储单元个数是：（20）</p></blockquote><p>解析无</p><blockquote><hr><p>  语句“array word 5 dup(1, 2)”分配主存的存储单元个数是：（10）</p></blockquote><p><em><strong>待添加注释</strong></em></p><blockquote><hr><p>  下列哪个数据伪指令定义32位无符号整数变量：（D）<br>  A. WORD<br>  B. SWORD<br>  C. BYTE<br>  D. DWORD</p></blockquote><p><code>WORD</code> 16位无符号整数；<code>SWORD</code> 16位有符号整数；<code>BYTE</code> 8位无符号整数；<code>DWORD</code> 32位无符号整数。</p><blockquote><hr><p>  下列哪个数据伪指令定义16位有符号整数变量：（B）<br>  A. WORD<br>  B. SWORD<br>  C. BYTE<br>  D. SBYTE</p></blockquote><p><code>WORD</code> 16位无符号整数；<code>SWORD</code> 16位有符号整数；<code>BYTE</code> 8位无符号整数；<code>SBYTE</code> 8位有符号整数。</p><blockquote><hr><p>  下列哪个数据伪指令定义16位无符号整数变量？（C）<br>  A. DWORD<br>  B. SWORD<br>  C. WORD<br>  D. SDWORD</p></blockquote><p>解析无</p><blockquote><hr><p>  下列哪个数据伪指令定义32位有符号整数变量？（D）<br>  A. DWORD<br>  B. SWORD<br>  C. FWORD<br>  D. SDWORD</p></blockquote><p>解析无</p><blockquote><hr><p>  下列哪个数据伪指令定义8位有符号整数变量？（SBYTE）</p></blockquote><p>解析无</p><hr><h1 id="小端顺序"><a href="#小端顺序" class="headerlink" title="小端顺序"></a>小端顺序</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 62</p></blockquote><p>x86 处理器在内存中按<strong>小端顺序</strong> (低到高) <strong>存放和检索数据</strong>。</p><p>最低有效字节存放在分配给该数据的第一个内存地址中，剩余字节存放在随后的连续内存位置中。</p><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221231191909818.png" alt="image-20221231191909818" style="zoom:60%;" /></center><p>其他有些计算机系统采用的是大端顺序(高到低)。下图展示了 12345678h 从偏移量 0000 开始的大端顺序存放。</p><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221231192011363.png" alt="image-20221231192011363" style="zoom:63%;" /></center><h2 id="习题整理-3"><a href="#习题整理-3" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  变量保存于字节编址的内存存储器中，每个存储单元保存一个8位、字节量数据。多个字节数据顺序逐个存放在主存相邻单元。<br>  一般采用<strong>小端方式</strong>存储，即高字节数据保存在（<strong>高地址</strong>）存储单元，低字节数据保存在（<strong>低地址</strong>）存储单元。</p></blockquote><p>解析见上文整理内容。</p><hr><h1 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 63</p></blockquote><h2 id="等号伪指令"><a href="#等号伪指令" class="headerlink" title="等号伪指令"></a>等号伪指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">name = expression<br></code></pre></td></tr></table></figure><p>通常，表达式是一个32位的整数值。当程序进行汇编时，在汇编器预处理阶段，所有出现的 name 都会被替换为 expression。类比 C 语言的 <code>#define name expression</code>。</p><h2 id="计算数组大小"><a href="#计算数组大小" class="headerlink" title="计算数组大小"></a>计算数组大小</h2><p><code>$</code> 运算符（当前地址计数器）返回当前程序语句的偏移量。在下例中，从当前地址计数器（<code>$</code>）中减去list的偏移量，计算得到 ListSize。<strong>ListSize 必须紧跟在 list 的后面。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">list BYTE 10, 20, 30, 40<br>ListSize = ($ - list)<br></code></pre></td></tr></table></figure><h2 id="字数组和双字数组"><a href="#字数组和双字数组" class="headerlink" title="字数组和双字数组"></a>字数组和双字数组</h2><p>当要计算元素数量的数组中包含的不是字节时，就应该用数组总的大小（按字节计）除以单个元素的大小。</p><p>比如，在下例中，由于数组中的每个字要占2个字节（16位)，因此，地址范围应该除以2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">list WORD 1000h, 2000h, 3000h, 4000h<br>ListSize = ($ - list) / 2<br></code></pre></td></tr></table></figure><p>同样，双字数组中每个元素长4个字节，因此，其总长度除以4才能产生数组元素的个数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">list DOWRD 10000000h, 20000000h, 30000000h, 40000000h<br>ListSize = ($ - list) / 4<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第一二章</title>
    <link href="/posts/0adefcb064e3/"/>
    <url>/posts/0adefcb064e3/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第一、二章学习笔记</b></font></center><br><span id="more"></span><h1 id="汇编语言基本概念"><a href="#汇编语言基本概念" class="headerlink" title="汇编语言基本概念"></a>汇编语言基本概念</h1><p><font size = 4><b>1. 汇编语言可移植吗?</b></font></p><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 3</p></blockquote><p>一种语言，如果它的源程序能够在各种各样的计算机系统中进行编译和运行，那么这种语言被称为是可移植的 (portable)。</p><p>例如，一个C++程序，除非需要特别引用某种操作系统的库函数，否则它就几乎可以在任何一台计算机上编译和运行。Java语言的一大特点就是，其编译好的程序几乎能在所有计算机系统中运行。</p><p><strong>汇编语言不是可移植的，因为它是为特定处理器系列设计的。</strong> 目前广泛使用的有多种不同的汇编语言，每一种都基于一个处理器系列。对于一些广为人知的处理器系列如 <code>Motorola68x00</code>、<code>x86</code>、<code>SUN Sparc</code>、<code>Vax</code> 和 <code>IBM-370</code>，汇编语言指令会直接与该计算机体系结构相匹配，或者在执行时用一种被称为微代码解释器 (microcode interpreter) 的处理器内置程序来进行转换。</p><p><font size = 4><b>2. 汇编语言与机器语言有什么关系?</b></font></p><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 3</p></blockquote><p>机器语言 (machine language) 是一种数字语言，专门设计成能被计算机处理器（CPU）理解。所有 <code>x86</code> 处理器都理解共同的机器语言。汇编语言 (assembly language) 包含用短助记符如 <code>ADD</code>、<code>MOV</code>、<code>SUB</code> 和 <code>CALL</code> 书写的语句。</p><p><strong>汇编语言与机器语言是一对一 (one-to-one) 的关系：每一条汇编语言指令对应一条机器语言指令。</strong></p><p><font size = 4><b>3. C++ 和 Java 与汇编语言有什么关系?</b></font></p><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 3</p></blockquote><p><strong>高级语言如 <code>Python</code>、<code>C++</code> 和 <code>Java</code> 与汇编语言和机器语言的关系是一对多 (one-to-many)。</strong></p><p>比如，<code>C++</code> 的一条语句就会扩展为多条汇编指令或机器指令。这种转换需要多条语句，因为每条汇编语句只对应一条机器指令。</p><p><font size = 4><b>4. 汇编语言有规则吗?</b></font></p><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 4</p></blockquote><p><strong>大多数汇编语言规则都是以目标处理器及其机器语言的物理局限性为基础的。</strong> 比如，CPU要求两个指令操作数的大小相同。</p><p>与 C++ 或 Java 相比，汇编语言的规则较少，因为，前者是用语法规则来减少意外的逻辑错误，而这是以限制底层数据访问为代价的。反之，汇编语言可以访问所有的内存地址。</p><p><font size = 4><b>5. 为什么高级语言这么发达还会用汇编语言？</b></font></p><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 3</p></blockquote><ul><li><p>嵌入式程序是指一些存放在专用设备中小容量存储器内的短程序。高级语言可能生成很大的可执行文件，以至于超出设备的内存容量。由于汇编语言占用内存少，因此它是编写嵌入式程序的理想工具。</p></li><li><p>处理仿真和硬件监控的实时应用程序要求精确定时和响应。高级语言不会让程序员对编译器生成的机器代码进行精确控制。汇编语言则允许程序员精确指定程序的可执行代码。</p></li><li><p>电脑游戏要求软件在减少代码大小和加快执行速度方面进行高度优化。游戏程序员经常选择汇编语言作为工具，因为汇编语言允许直接访问计算机硬件，所以，为了提高速度可以对代码进行手工优化。</p></li></ul><p><font size = 4><b>6. 汇编语言与高级语言的比较</b></font></p><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 4</p></blockquote><table><thead><tr><th>应用类型</th><th>高级语言</th><th>汇编语言</th></tr></thead><tbody><tr><td>商业或科学应用程序，为单一的中型或大型平台编写</td><td>规范结构使其易于组织和维护大量代码</td><td>最小规范结构，因此必须由具有不同程度经验的程序员来维护结构。这导致对已有代码的维护困难</td></tr><tr><td>硬件设备驱动程序</td><td>语言不一定提供对硬件的直接访问。即使提供了,可能也需要难以控制的编码技术，这导致维护困难</td><td>对硬件的访问直接且简单。当程序较短且文档良好时易于维护</td></tr><tr><td>为多个平台（不同的操作系统）编写的商业或科学应用程序</td><td>通常可移植。在每个目标操作系统上,源程序只做少量修改就能重新编译</td><td>需要为每个平台单独重新编写代码，每个汇编器都使用不同的语法。维护困难</td></tr><tr><td>需要直接访问硬件的嵌入式系统和电脑游戏</td><td>可能生成很大的可执行文件，以至于超出设备的内存容量</td><td>理想，因为可执行代码小，运行速度快</td></tr></tbody></table><h2 id="习题整理"><a href="#习题整理" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  （机器语言）是一种数字语言，专门设计成能被计算机处理器理解。<br>  （汇编语言）是包含用短助记符如 <code>ADD</code>、<code>MOV</code> 和 <code>CALL</code> 书写的语句，两者是（一对一）的关系。<br>  （高级语言）如 <code>Python</code>、<code>C++</code> 等与汇编语言的是（一对多）的关系。</p></blockquote><p>参考上文整理内容。</p><hr><h1 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h1><h2 id="整数存储大小"><a href="#整数存储大小" class="headerlink" title="整数存储大小"></a>整数存储大小</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 9</p></blockquote><p>在 <code>x86</code> 计算机中，所有数据存储的基本单位都是字节 (<code>byte</code>)，<strong>一个字节有8位</strong>。</p><p>其他的存储单位还有：</p><ul><li>字 (<code>word</code>，2个字节)</li><li>双字 ( <code>doubleword</code>，4个字节) </li><li>四字 (<code>quadword</code>，8个字节)</li></ul><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 12</p></blockquote><ol><li><p><strong>负整数使用补码表示。</strong> </p></li><li><p>将一个二进制整数按位取反(求补)再加 1，就形成了它的补码。将一个十六进制整数按位取反并加1，就生成了该十六进制整数的补码。</p></li><li><p><strong>补码操作是可逆的。</strong> 以 8 位二进制数 $0000 \space 0001$ 为例，其补码为 $1111 \space 1111$ 。同时，$1111 \space 1111$ 的补码也为 $0000 \space 0001$。</p></li></ol><h2 id="习题整理-1"><a href="#习题整理-1" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  对于下列8位有符号数来说，哪个值最大？（A）<br>  A. 81<br>  B. 0010 1100<br>  C. F5H<br>  D. 1101 0110</p></blockquote><p>A 为十进制数，值为 81；<br>B 为二进值数，值为 44；<br>C 为十六进制数，转换成二进值后为 $1111 \space 0101$，所以值为 -11；<br>D 为二进值数，值为 -42。</p><p>综上可得，A 的值最大</p><blockquote><hr><p>  A. 将16位十六进制数 55AAH 转化为二进制数的值为（$0101\space 0101\space 1010\space 1010$）；<br>  B. 将16位二进制数1100 1011 1001 0111B 转化为十六进制数的值为（$CB97$）；<br>  C. 有符号十进制整数-46的8位二进制补码是（$1101\space 0010$）；<br>  D. 十六进制整数A598 + 32A7&#x3D;（$D83F$）</p></blockquote><p>A 易得 $0101\space 0101\space 1010\space 1010$；<br>B 易得 $CB97$；<br>C 将 $46D &#x3D; 0010\space 1110B$，对 $0010\space 1110B$ 进行取反操作后 $+ 1$，可以到最终结果为 $1101\space 0010$；<br>D 通过 16 进制加法，可以计算出结果为 $D83F$。</p><blockquote><hr><p>  A. 将16位十六进制数AAF0H 转化为二进制数的值为（1010 1010 1111 0000）；<br>  B. 将16位二进制数1011 1101 0110 1001B 转化为十六进制数的值为（BD69）；<br>  C. 有符号十进制整数-98的8位二进制补码是（1001 1110）；<br>  D. 十六进制整数3A7+32F6&#x3D;（369D）</p></blockquote><p>解析无</p><blockquote><hr><p>  字长为8位的无符号数，其数值范围为（0）到（255）</p></blockquote><p>数值范围为 $2^0 \sim (2^8-1)$，即 0 ~ 255。</p><blockquote><hr><p>  将16位十六进制数6A8DH 转化为二进制数的值为（0110 1010 1000 1101）；<br>  将16位二进制数1010 0001 1110 1011B 转化为十六进制数的值为（A1EB）；<br>  有符号十进制整数-100的8位二进制补码是（1001 1100）；<br>  十六进制整数068A+7D08&#x3D;（8392）。</p></blockquote><p>解析无</p><blockquote><hr><p>  将16位十六进制数7DF6H 转化为二进制数的值为（0111 1101 1111 0110）；<br>  将16位二进制数1110 1101 0111 1000B 转化为十六进制数的值为（ED78）；<br>  有符号十进制整数-89的8位二进制补码是（1010 0111）；<br>  十六进制整数0F3D+A256&#x3D;（B193）。</p></blockquote><p>解析无</p><blockquote><hr><p>  将16位十六进制数8A5DH 转化为二进制数的值为（1000 1010 0101 1101）；<br>  将16位二进制数1010 0101 0110 1100B 转化为十六进制数的值为（A56C）；<br>  有符号十进制整数-98的8位二进制补码是（1001 1110）；<br>  十六进制整数753A+32F6&#x3D;（A830）。</p></blockquote><p>解析无</p><blockquote><hr><p>  在8位二进制数01101011中，最高有效位(MSB)的值是（0），最低有效位(LSB)的值是（1）。</p></blockquote><p>参考资料：<a href="https://blog.csdn.net/qq_29350001/article/details/51177404">LSB最低有效位和MSB最高有效位_聚优致成的博客-CSDN博客_最低有效位</a></p><p>最低有效位是指一个二进制数字中的即最低位，具有权值为 $2^0$，可以用它来检测数的奇偶性。在大端序中，<code>LSB</code> 指最右边的位。</p><p>最高有效位是指一个n位二进制数字中的最高位，具有最高的权值为 $2^n - 1$。在大端序中，<code>MSB</code> 即指最左端的位。对于有符号二进制数，负数采用反码或补码形式，此时 <code>MSB</code>用来表示符号，<code>MSB</code> 为 1 表示负数，为 0 表示正数。</p><blockquote><hr><p>  对于下列8位有符号数来说，最小的是：（D）<br>  A. 0<br>  B. 00101100B<br>  C. 75H<br>  D. 11010110B</p></blockquote><p>A B C 都为正数。而 D 的符号位为 1，表示负数。</p><blockquote><hr><p>  负数在内存里是以其哪种形式存放？（C）<br>  A. 原码<br>  B. 反码<br>  C. 补码<br>  D. 真值</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  对于下列8位有符号数来说，哪个值最大？（B）<br>  A. FFH<br>  B. 48H<br>  C. 70<br>  D. 11010110</p></blockquote><p>A ：-1；B：72；C：70；D：-42。</p><hr><h1 id="x86-处理器架构"><a href="#x86-处理器架构" class="headerlink" title="x86 处理器架构"></a>x86 处理器架构</h1><h2 id="基本微机设计"><a href="#基本微机设计" class="headerlink" title="基本微机设计"></a>基本微机设计</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 23</p></blockquote><div align="center"><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221230210411168.png" alt="image-20221230210411168" style="zoom:80%;" /></div><p>上图给出了假想机的基本设计。</p><ol><li><p>中央处理单元 (<code>CPU</code>) 是<strong>进行算术和逻辑操作</strong>的部件,包含了：</p><ul><li>寄存器 (register)<br>有限数量的存储位置。</li><li>一个高频时钟<br>时钟 (clock) <strong>对 <code>CPU</code> 内部操作与系统其他组件进行同步</strong>。</li><li>一个控制单元<br>控制单元 (control unit，<code>CU</code>) <strong>协调参与机器指令执行的步骤序列</strong>。</li><li>一个算术逻辑单元<br>算术逻辑单元 (arithmetic logic unit，<code>ALU</code>) <strong>执行算术运算</strong>，如加法和减法，以及逻辑运算，如 <code>AND</code> (与)、<code>OR</code>(或) 和 <code>NOT</code> (非)。</li></ul></li><li><p>内存存储单元 (memory storage unit) 用于<strong>在程序运行时保存指令与数据</strong>。<br> 它接受来自 <code>CPU</code> 的数据请求，<strong>将数据从随机存储器（<code>RAM</code>）传输到 <code>CPU</code>，并从 <code>CPU</code> 传输到内存</strong>。由于所有的数据处理都在 <code>CPU</code> 内进行，因此<strong>保存在内存中的程序在执行前需要被复制到 <code>CPU</code> 中</strong>。程序指令在复制到 <code>CPU</code> 时，可以一次复制一条，也可以一次复制多条。</p></li><li><p>CPU 通过主板上 CPU 插座的引脚与计算机其他部分相连。大部分引脚连接的是<strong>数据总线</strong>、<strong>控制总线</strong>和<strong>地址总线</strong>。</p></li><li><p>总线 (bus) 是一组并行线，用于<strong>将数据从计算机一个部分传送到另一个部分</strong>。<br> 一个计算机系统通常包含<strong>四类总线：数据类，I&#x2F;O类、控制类和地址类</strong>。</p><ul><li>数据总线 (data bus) <strong>在 <code>CPU</code> 和内存之间传输指令和数据</strong>。</li><li>I&#x2F;O总线<strong>在 <code>CPU</code> 和系统输入&#x2F;输出设备之间传输数据</strong>。</li><li>控制总线 (control bus) <strong>用二进制信号对所有连接在系统总线上设备的行为进行同步</strong>。</li><li>当前执行指令在 <code>CPU</code> 和内存之间传输数据时，地址总线 (address bus) <strong>用于保持指令和数据的地址</strong>。</li></ul></li><li><p>时钟︰与 CPU 和系统总线相关的每一个操作都是由一个恒定速率的内部时钟脉冲来进行同步。<br> <strong>机器指令的基本时间单位</strong>是机器周期 (machine cycle) 或<strong>时钟周期</strong> (clock cycle)。<br> 一个时钟周期的时长是一个完整时钟脉冲所需要的时间。<br> <strong>执行一条机器指令最少需要1个时钟周期</strong>，有几个需要的时钟则超过了50个（比如8088处理器中的乘法指令)。<br> 由于在 <code>CPU</code>、系统总线和内存电路之间存在速度差异，因此，<strong>需要访问内存的指令常常需要空时钟周期</strong>，也被称为<strong>等待状态</strong> (wait states )。</p></li></ol><h2 id="指令执行周期"><a href="#指令执行周期" class="headerlink" title="指令执行周期"></a>指令执行周期</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 24</p></blockquote><p>三个步骤：<strong>取指</strong> (Fetch)、<strong>译码</strong> (Decode) 和<strong>执行</strong> (Execute)。</p><p>操作数 (operand) 是指操作过程中输入或输出的值。</p><h2 id="读取内存"><a href="#读取内存" class="headerlink" title="读取内存"></a>读取内存</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 25</p></blockquote><p>作为一个常见现象，计算机<strong>从内存读取数据比从内部寄存器读取速度要慢很多</strong>。</p><p>这是因为从内存读取一个值，需要经过下述步骤：</p><ol><li>将想要读取的值的地址放到地址总线上。</li><li>设置处理器 RD（读取）引脚（改变 RD 的值）。</li><li>等待一个时钟周期给存储器芯片进行响应。</li><li>将数据从数据总线复制到目标操作数。</li></ol><p>上述每一步常常只需要一个时钟周期，虽然一共只需要4个时钟周期。但是，与CPU寄存器相比，这个速度还是慢了，因为访问寄存器一般只需要1个时钟周期。</p><p>CPU 设计者想出了一个可以减少读写内存的时间的方法——<strong>将大部分近期使用过的指令和数据存放在高速存储器 <code>cache</code> 中</strong>。</p><p>其思想是，程序更可能希望反复访问相同的内存和指令。因此，<code>cache</code> 保存这些值就能使它们能被快速访问到。此外，当 <code>CPU</code> 开始执行一个程序时，它会预先将后续（比如）一千条指令加载到 <code>cache</code> 中，这个行为是基一种假设，即这些指令很快就会被用到。如果这种情况重复发生在一个代码块中，则 <code>cache</code> 中就会有相同的指令。</p><p>当处理器能够在 <code>cache</code> 存储器中发现想要的数据，则称为 <strong><code>cache</code> 命中</strong> (cache hit)。反之，如果 <code>CPU</code> 在 <code>cache</code> 中没有找到数据，则称为 <strong><code>cache</code> 未命中</strong> (cache miss)。</p><p>x86 系列中的 <code>cache</code> 存储器有两种类型：</p><ul><li>一级 <code>cache</code> (或主 <code>cache</code>)位于 <code>CPU</code> 上</li><li>二级 <code>cache</code> (或次 <code>cache</code> )速度略慢，通过高速数据总线与 <code>CPU</code> 相连</li></ul><p>这两种 <code>cache</code> 以最佳方式一起工作。</p><p>还有一个原因使得 <code>cache</code> 存储器比传统 <code>RAM</code> 速度快—— <code>cache</code> 存储器是由一种被称为<strong>静态 <code>RAM</code></strong> ( static RAM）的特殊存储器芯片构成的。</p><h2 id="习题整理-2"><a href="#习题整理-2" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  在微型计算机中，微处理器的主要功能是：（A）<br>  A. 算术逻辑运算及全机的控制<br>  B. 逻辑运算<br>  C. 算术逻辑运算<br>  D. 算术运算</p></blockquote><p>解析无</p><blockquote><hr><p>  中央处理单元是进行算术和逻辑操作的部件，包含了（寄存器）、高频时钟、（控制单元）和（算术逻辑单元）。</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  （总线）是一组并行线，用于将数据从计算机的一个部分传到另一部分。<br>  其中，（数据总线）用于在内存和 <code>CPU</code> 之间传递指令和数据；<br>  （控制总线）使用二进制信号对所有连接在总线上的设备的行为进行同步。</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  当处理器能够在 <code>cache</code> 存储器中发现想要的数据，则称为 <code>cache</code>（命中）。<br>  反之，如果 <code>CPU</code> 在 <code>cache</code> 中没有找到数据，则称为 <code>cache</code>（未命中）。</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  CPU可以用来描述计算机的：（A）<br>  A. 运算速度<br>  B. 输入功率<br>  C. 磁盘转速<br>  D. 更新频率</p></blockquote><p><em><strong>解析待添加</strong></em></p><blockquote><hr><p>  一条指令的执行通常可分为(取指)、（编码）和（执行）三个阶段。</p></blockquote><p>解析见上文整理内容。</p><hr><h1 id="x86-处理器"><a href="#x86-处理器" class="headerlink" title="x86 处理器"></a>x86 处理器</h1><h2 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 27</p></blockquote><p>x86处理器有四个主要的操作模式：</p><ul><li>保护模式</li><li>实地址模式</li><li>系统管理模式</li><li>子模式：虚拟8086 (virtual-8086) 模式，这是保护模式的特殊情况。</li></ul><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 27</p></blockquote><p>在32位<strong>保护模式</strong>下，一个任务或程序最大可以寻址 <strong>4GB 的线性地址空间</strong>。</p><p>从 P6 处理器开始，一种被称为<strong>扩展物理寻址</strong> (extended physical addressing) 的技术使得可以被寻址的<strong>物理内存空间增加到 64GB</strong>。</p><p>与之相反，<strong>实地址模式</strong>程序只能<strong>寻址 1MB 空间</strong>。</p><p>如果处理器在<strong>保护模式下运行多个虚拟8086程序</strong>，则<strong>每个程序只能拥有自己的1MB内存空间</strong>。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 28</p></blockquote><p>寄存器是直接位于 <code>CPU</code> 内的高速存储位置，其设计访问速度远高于传统存储器。</p><div align="center"><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221230231001537.png" alt="image-20221230231001537" style="zoom: 67%;" /></div><p>上图展示的是 32位 x86 处理器的基本程序执行寄存器 (basic program execution registers)。8个通用寄存器，6个段寄存器，一个处理器状态标志寄存器 (EFLAGS)，和一个指令指针寄存器 (EIP)。下图为 64为 x86-64 处理器中的寄存器。</p><div align="center"><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-909063cd57cd5b2136ff8ed4d04bc5e6_1440w.jpg" alt="img" style="zoom:57%;" /></div><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>通用寄存器主要用于算术运算和数据传输。其中，存在一些拥有特殊用法的通过寄存器：</p><ul><li>乘除指令默认使用 <code>EAX</code>。它常常被称为扩展累加器 (extended accumulator) 寄存器。</li><li><code>CPU</code> 默认使用 <code>ECX</code> 为循环计数器。</li><li><code>ESP</code> 用于寻址堆栈（一种系统内存结构）数据。它极少用于一般算术运算和数据传输，通常被称为扩展堆栈指针 (extended stack pointer) 寄存器。</li><li><code>ESI</code> 和 <code>EDI</code> 用于高速存储器传输指令，有时也被称为扩展源变址（ extended source index）寄存器和扩展目的变址 (extended destination index) 寄存器。</li><li>高级语言通过 <code>EBP</code> 来引用堆栈中的函数参数和局部变量。除了高级编程，它不用于一般算术运算和数据传输。它常常被称为扩展帧指针 (extended frame pointer) 寄存器。</li></ul><h3 id="指令指针"><a href="#指令指针" class="headerlink" title="指令指针"></a>指令指针</h3><p>指令指针 (<code>EIP</code>) 寄存器中包含下一条将要执行指令的地址。某些机器指令能控制 <code>EIP</code>，使得程序分支转向到一个新位置。</p><h3 id="状态标志位"><a href="#状态标志位" class="headerlink" title="状态标志位"></a>状态标志位</h3><blockquote><p>  设置标志位时，该标识位 &#x3D; 1；</p><p>  清除（或重置）标识位时，该标志位 &#x3D; 0。</p></blockquote><ul><li>进位标志位 (<code>CF</code>)，与目标位置相比，<strong>无符号</strong>算术运算结果太大时，设置该标志位。</li><li>溢出标志位 (<code>OF</code>)，与目标位置相比，<strong>有符号</strong>算术运算结果太大或太小时，设置该标志位。</li><li>符号标志位 (<code>SF</code>)，算术或逻辑操作产生<strong>负结果</strong>时,设置该标志位。</li><li>零标志位 (<code>ZF</code>)，算术或逻辑操作产生的<strong>结果为零</strong>时，设置该标志位。</li><li>辅助进位标志位 (<code>AC</code>)，算术操作在8位操作数中产生了位3向位4的<strong>进位</strong>时，设置该标志位。</li><li>奇偶校验标志位 (<code>PF</code>)，结果的最低有效字节包含偶数个1时，设置该标志位，否则，清除该标志位。一般情况下，如果数据有可能被修改或损坏时，该标志位用于进行错误检测。</li></ul><h2 id="习题整理-3"><a href="#习题整理-3" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  当无符号数算术运算结果超过目标位置大小时，应设置（进位）标志位；<br>  当有符号数算术运算结果对目标位置而言太大或太小时，应设置（溢出）标志位；<br>  当运算产生负数结果时，应设置（符号）标志位；<br>  当运算结果为零时，应设置（零）标志位。</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  算术或逻辑操作产生结果为零时，设置（零）标志位；<br>  与目标位置相比，有符号算术运算结果太大或太小时，设置（溢出）标志位。</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  下列标志位中，可用来判断无符号数运算结果太大的是：（B）<br>  A. OF<br>  B. CF<br>  C. ZF<br>  D. SF</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  下列几种存储器中，存取速度最快的是：（B）<br>  A. Cache<br>  B. 寄存器<br>  C. 内存<br>  D. 光盘</p></blockquote><p>在存储器层次结构中，存储器速度从最快到最慢的排列顺序是：<strong>寄存器 -&gt; <code>cache</code> -&gt; 主存 -&gt; 辅存</strong>。</p><blockquote><hr><p>  在程序执行过程中，EIP 寄存器保存的是？（B）<br>  A. 上一条已执行指令的地址<br>  B. 下一条即将要执行指令的地址<br>  C. 正在执行指令的地址<br>  D. 当前堆栈的栈顶</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  下列标志位中，可用来判断计算结果为零的是？（$ZF$）</p></blockquote><p>零标志位 (<code>ZF</code>)、算术或逻辑操作产生的<strong>结果为零</strong>时，设置该标志位。</p><blockquote><hr><p>  算数或逻辑操作产生负结果时，设置（ 符号）标志位；<br>  与目标位置相比，无符号算术运算结果太大时，设置（进位）标志位。</p></blockquote><p>解析见上文整理内容。</p><blockquote><hr><p>  两个整数相减等于0，则标志位正确的是：（D）<br>  A. ZF&#x3D;0 , PF&#x3D;0 , SF&#x3D;0<br>  B. ZF&#x3D;1 , PF&#x3D;0 , SF&#x3D;1<br>  C. ZF&#x3D;0 , PF&#x3D;1 , SF&#x3D;0<br>  D. ZF&#x3D;1 , PF&#x3D;1 , SF&#x3D;0</p></blockquote><ul><li>零标志位 (<code>ZF</code>)，算术或逻辑操作产生的<strong>结果为零</strong>时，设置该标志位。</li><li>符号标志位 (<code>SF</code>)，算术或逻辑操作产生<strong>负结果</strong>时,设置该标志位。</li><li>奇偶校验标志位 (<code>PF</code>)，结果的最低有效字节包含偶数个1时，设置该标志位，否则，清除该标志位。</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-TCP/IP协议族</title>
    <link href="/posts/6ed3afd2e436/"/>
    <url>/posts/6ed3afd2e436/</url>
    
    <content type="html"><![CDATA[<blockquote><p>   一系列协议所组成的一个网络分层模型。</p></blockquote><hr><h1 id="为什么要分层"><a href="#为什么要分层" class="headerlink" title="为什么要分层"></a>为什么要分层</h1><p>由于现实网络的不稳定性以及不可靠性，所以需要将大数据进行分块传输，才能保障传输效率。但是应用层有许多协议，所有的协议都可能需要分块传输以及稳定传输等众多功能需求，所以为了能够复用一部分相同或者相似的功能，我们使用了分层，方便各个功能模块的解耦和复用。</p><p>如果网络能够稳定的话，那么分成两层也就够了。一层为应用层 HTTP，第二层就直接可以是数据链路层了。</p><hr><h1 id="四层网络模型"><a href="#四层网络模型" class="headerlink" title="四层网络模型"></a>四层网络模型</h1><table><thead><tr><th align="left">层级</th><th>协议</th></tr></thead><tbody><tr><td align="left">应用层</td><td>- <code>HTTP</code><br />- <code>FTP</code><br />- <code>DNS</code></td></tr><tr><td align="left">传输层</td><td>- <code>TCP</code><br />- <code>UDP</code></td></tr><tr><td align="left">网络层</td><td>- <code>IP</code></td></tr><tr><td align="left">数据链路层</td><td>- 以太网<br />- <code>Wi-Fi</code></td></tr></tbody></table><p>应用层负责完成我们所期望的实际的工作的内容。</p><p>但是因为现实网络的不稳定性以及不可靠性，所以有了传输层来用于分块传输。但是由于有些数据在网络不稳定的时候即使丢失了也不需要进行重传，所以在 TCP 之外有了一个 UDP，他们并行存在，都位于传输层。如果所有的协议都不需要重传的话，那么也就不需要这一层了。</p><p>但是为了对他们有一个共同的下位支持，所以分离出来了一个有着 IP 协议的网络层。网络层负责以最小的单位发送和接受上层分块的网络数据以及选址、路由等最下层的网络方面工作。这些工作主要就是 IP 协议做的。</p><p>最下层的数据链路层可以看作是一个物理级别的支持，当然也不止是纯粹的物理设备，比如还有线缆标准，无线网络标准等等用于保障数据的发送和接受不会出现歧义的内容。</p><hr><h1 id="七层网络模型"><a href="#七层网络模型" class="headerlink" title="七层网络模型"></a>七层网络模型</h1><p>由 OSI 制定。较四层模型更加的细致。</p><hr><h1 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a><code>TCP</code> 连接</h1><h2 id="什么是连接"><a href="#什么是连接" class="headerlink" title="什么是连接"></a>什么是连接</h2><p>通信双方建立确认「可以通信」，不会将对方的消息丢弃，即为「建立连接」。</p><p>通过双方建立连接，可以使得双方认识彼此，在以后的通信中可以不用每次确认身份而直接开始交流。</p><p>建立连接后，双方会各自确定一个端口，当使用该端口，发送或接受信息时，就可以直接确认对方的身份了。</p><p>将端口更加具象化后，就成为了 <code>Java</code> 中的 <code>Socket</code>（套接字）类，即 Java 对于 TCP 的端口的一个具体的实现。</p><blockquote><p>  Socket <code>n. 插口</code></p></blockquote><h2 id="TCP-连接的建立与关闭"><a href="#TCP-连接的建立与关闭" class="headerlink" title="TCP 连接的建立与关闭"></a><code>TCP</code> 连接的建立与关闭</h2><p><font size = 4><b>建立：三次握手</b></font></p><ul><li><p>开启双方的认识和交流。</p></li><li><p>开启端口。</p></li></ul><p><font size = 4><b>关闭：四次挥手</b></font></p><ul><li><p>忘记对方，结束双方的交流。</p></li><li><p>释放资源，关闭端口。</p></li></ul><h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><h3 id="为什么要长连接"><a href="#为什么要长连接" class="headerlink" title="为什么要长连接"></a>为什么要长连接</h3><p>因为移动网络并不在 Internet 中，而是在运营商的内网，并不具有真正的公网 IP， 因此当某个 TCP 连接在一段时间不通信之后，网关会出于网络性能考虑而关闭这条 TCP 连接和公网的连接通道，导致这个 TCP 端口不再能收到外部通信消息，即 TCP 连接被动关闭。</p><h3 id="长连接的实现方式：心跳"><a href="#长连接的实现方式：心跳" class="headerlink" title="长连接的实现方式：心跳"></a>长连接的实现方式：心跳</h3><p>在一定的时间间隔之内，不断的使用 TCP 的连接去发送一些超级短的且没有意义的消息到对方。目的是确认双方之间的连接是通畅的，让网关不能将自己定义为「空闲连接」，从而防止网关将自己的连接关闭。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP/IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-登录和授权</title>
    <link href="/posts/e26999fccebc/"/>
    <url>/posts/e26999fccebc/</url>
    
    <content type="html"><![CDATA[<h1 id="登录和授权的区别"><a href="#登录和授权的区别" class="headerlink" title="登录和授权的区别"></a><font size = 5><b>登录和授权的区别</b></font></h1><ul><li>登录：身份认证，即确认「你是你」的过程。 </li><li>授权：由身份或持有的令牌确认享有某些权限（例如获取用户信息）。而登录过程实质上的⽬的也是为了确认权限。</li></ul><hr><h1 id="登录和授权的两种方式"><a href="#登录和授权的两种方式" class="headerlink" title="登录和授权的两种方式"></a><font size = 5><b>登录和授权的两种方式</b></font></h1><ul><li><code>Cookie Header</code></li><li><code>Authorization Header</code></li></ul><hr><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><code>Cookie</code></h1><blockquote><ul><li><p>可以把任何服务器希望存在用户本地的数据都存在用户本地。</p></li><li><p>可以认为是浏览器的缓存。</p></li><li><p>是一个 <code>Header</code>，也是一种信息存储机制。</p></li><li><p>同一个服务器可以用多个 <code>Cookie</code>，只要每个 <code>Cookie</code> 的名字不一样就行了。</p></li></ul></blockquote><h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><ol><li><p>服务器需要客户端保存的内容，放在 <code>Set-Cookie</code> headers 里返回，客户端会<strong>自动</strong>保存。</p></li><li><p>客户端保存的 Cookies，会在之后的所有请求里都 <strong>自动</strong> 携带进 <code>Cookie</code> header 里发回给服务器。</p></li><li><p>客户端保存 <code>Cookie</code> 是按照 <strong>服务器域名</strong> 来分类的，例如 shop.com 发回的 <code>Cookie</code> 保存下来以后，在之后向 games.com 的请求中并不会携带。</p></li><li><p>客户端保存的 <code>Cookie</code> 在超时后会被删除、没有设置超时时间的 <code>Cookie</code> （称作 <code>Session Cookie</code>）在浏览器关闭后就会自动删除；另外，服务器也可以主动删除还未过期的客户端 Cookies。</p></li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>出现 <code>Cookie</code> 的时候还没有 <code>JavaScript</code> 语言，所以不能对 <code>Cookie</code> 进行浏览器本地计算，必须要将 <code>Cookie</code> 传到服务器处理。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li><p>会话管理：登录状态、购物车等</p><p>移动开发通常也只将 Cookie 用于登录状态管理，且现在也越来越少的进行使用了。</p><blockquote><p>  <strong>使用 <code>Cookie</code> 管理登录状态</strong></p><p>  客户端向服务器发送用户名和密码后，当服务器验证用户登录成功后，会通过 <code>Set-Cookie</code> 向客户端传输一个 <code>SessionId</code> 的字段。<code>SessionId</code> 可以是记录了用户此次登录的会话编号。</p><p>  此后客户端每次发送请求的时候通过携带该 <code>Cookie</code> 便可将 <code>HTTP</code> 从无状态变为有状态。</p><p>  当服务器从数据库中发现存在一样的 <code>SessionId</code> 后，便可确认用户的身份信息了。</p></blockquote></li><li><p>个性化：用户篇好、主题等</p><p>如果由服务器网页有多个主题以及其他个性化内容的话，可以通过存储 <code>client_id</code> 等相似字段记录用户的选择，从而记录并显示用户的偏好。</p></li><li><p>Tracking：分析用户行为，追踪用户行为。</p><p>通过记录用户访问的网站信息或者其他信息，可以更加方便得向用户推广广告。</p></li></ol><h2 id="XSS-Cross-site-scripting"><a href="#XSS-Cross-site-scripting" class="headerlink" title="XSS(Cross-site scripting)"></a><code>XSS(Cross-site scripting)</code></h2><p><strong>跨站脚本攻击。</strong>通过 <code>JavaScript</code> 获取客户端浏览器中的 <code>Cookie</code> 并利用其中的信息，如网站登录信息等。</p><p>可以通过 <code>HttpOnly</code> 进行防护，作用是让 <code>Cookie</code> 只能用于发送请求时自动携带，而无法通过 <code>JavaScript</code> 主动获取。添加方法形如 <code>Set-Cookie:session_id=123;HttpOnly</code> 即可。</p><h2 id="XSRF-Cross-site-request-forgery"><a href="#XSRF-Cross-site-request-forgery" class="headerlink" title="XSRF(Cross-site request forgery)"></a><code>XSRF(Cross-site request forgery)</code></h2><p><strong>跨站请求伪造。</strong>在用户不知情的情况下访问了一个用户保存了 <code>Cookie</code> 的网站，以此来进行一些越权操作。</p><p>例如，私自访问用户保存了 <code>Cookie</code> 的银行网站并通过添加 <code>url</code> 参数来进行转账操作等等。</p><p>可以通过 <code>Referer</code> 校验解决，通过在发送请求的时候 <strong>自动且强制</strong> 在 Header 中添加 <code>Referer</code> 参数，参数保存了从哪一个网址跳转进入了该网址。服务器只需要校验 <code>Referer</code> 参数是否在白名单中即可保证访问安全。</p><hr><h1 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a><code>Authorization</code></h1><blockquote><p>  目前较 <code>Cookie</code> 更加流行。</p></blockquote><p><font size = 5><b>两种用法</b></font></p><h2 id="Basic-token"><a href="#Basic-token" class="headerlink" title="Basic token"></a><code>Basic token</code></h2><p>格式：<code>Authorization: Basic &lt;username:password(Base64ed)&gt;</code>。其中，<code>&lt;username:password(Base64ed)&gt;</code> 部分是将 <code>username:password</code> 格式的字符串进行 <code>Base64</code> 处理后重新替换到 <code>Basic</code> 后面。</p><p>服务器对 token 进行校验，如果校验通过，那么授权验证通过，客户端就可以获取到用户信息。如果数据不对，那么就获取不到用户信息，服务器对报 401 错误，即权限不足。</p><h2 id="Bearer-token"><a href="#Bearer-token" class="headerlink" title="Bearer token"></a><code>Bearer token</code></h2><blockquote><p>  Bearer : n. 拿着的人，持票人</p></blockquote><p>格式：<code>Authorization: Bearer &lt;bearer token&gt;</code>。<code>&lt;bearer token&gt;</code> 是授权方发给我们的 <code>access token</code>。</p><h3 id="access-token-获取方法"><a href="#access-token-获取方法" class="headerlink" title="access token 获取方法"></a><code>access token</code> 获取方法</h3><h4 id="OAuth2-流程"><a href="#OAuth2-流程" class="headerlink" title="OAuth2 流程"></a><code>OAuth2</code> 流程</h4><ol start="0"><li><p>第三方网站向授权方网站申请第三方授权合作，拿到 <code>client_id</code> 和 <code>client_secret</code></p><blockquote><p>  <code>client_id</code>：申请授权的 app 的 id。</p><p>  <code>client_secret</code>：需要严格保密，保存在第三方网站服务器中，作为密码的作用，证明是第三方网站自己申请的授权。</p></blockquote></li><li><p>用户在使用第三方网站时，点击「通过 XX (如 <code>GitHub</code>) 授权」按钮，第三方网站将页面跳转到授权方网站，并传入 <code>client_id</code> 作为自己的身份标识。</p></li><li><p>授权方网站根据  <code>client_id</code>  ，将第三方网站的信息和第三方网站需要的用户权限展示给用户，并询问用户是否同意授权</p></li><li><p>用户点击「同意授权」按钮后，授权方网站将页面跳转回第三方网站，并传入 <code>Authorization code</code> 作为用户认可的凭证。</p></li><li><p>第三方网站将 <code>Authorization code</code> 发送回自己的服务器。</p></li><li><p>服务器将 <code>Authorization code</code> 和自己的 <code>client_secret</code> ⼀并发送给授权方的服务器，授权方服务器在验证通过后，返回 <code>access token</code>。OAuth 流程结束。</p></li><li><p>在上面的过程结束之后，第三方网站的服务器（或者有时客户端也会）就可以使用 <code>access token</code> 作为用户授权的令牌，通过 <code>Authorization: Bearer &lt;access token&gt;</code> 向授权方网站发送请求来获取用户信息或操作用户账户。但这已经在 OAuth 流程之外。</p></li></ol><blockquote><p>  为什么 <code>OAuth</code> 要引入 <code>Authorization code</code>，并需要申请授权的第三方将 <code>Authorization code</code> 发送回自己的服务器，再从服务器来获取 <code>access token</code>， 而不是直接返回 <code>access token</code> ？这样复杂的流程意义何在？ </p><p>  为了安全。<code>OAuth</code> 不强制授权流程必须使用 <code>HTTPS</code>，因此需要保证当通信路径中存在窃听者时，依然具有足够高的安全性。</p></blockquote><h4 id="微信登录流程"><a href="#微信登录流程" class="headerlink" title="微信登录流程"></a>微信登录流程</h4><p>第三方 App 通过微信登录的流程，也是一个 <code>OAuth2</code> 流程：</p><ol start="0"><li>第三方 App 向腾讯申请第三方授权合作，拿到 <code>client_id</code> 和 <code>client_secret</code></li><li>用户在使用第三方 App 时，点击「通过微信登录」，第三方 App 将使用微信 SDK 跳转到微信，并传入自己的 <code>client_id</code> 作为自己的身份标识</li><li>微信通过和服务器交互，拿到第三方 App 的信息，并显示在界面中，然后询问用户是否同意授权该 App 使用微信来登录。</li><li>用户点击「使用微信登录」后，微信和服务器交互将授权信息提交，然后跳转回第三方 App，并传入 <code>Authorization code</code> 作为用户认可的凭证。</li><li>第三方 App 调用自己服务器的「微信登录」API，并传入 <code>Authorization code</code>，然后等待服务器的响应。</li><li>服务器在收到登录请求后，拿收到的 <code>Authorization code</code> 去向微信的第三方授权接口发送请求，将 <code>Authorization code</code> 和自己的 <code>client_secret</code> 一起作为参数发送，微信在验证通过后，返回 <code>access token</code>。</li><li>服务器在收到 <code>access token</code> 后，立即拿着 <code>access token</code> 去向微信的用户信息接口发送请求，微信验证通过后，返回用户信息。</li><li>服务器在收到用户信息后，在自己的数据库中为用户创建一个账户，并使用从微信服务器拿来的用户信息填入自己的数据库，以及将用户的 ID 和用户的微信 ID 做关联。</li><li>用户创建完成后，服务器向客户端的请求发送响应，传送回刚创建好的用户信息。</li><li>客户端收到服务器响应，用户登录成功。</li></ol><h4 id="在自家-App-中使用-Bearer-token-登录"><a href="#在自家-App-中使用-Bearer-token-登录" class="headerlink" title="在自家 App 中使用 Bearer token 登录"></a>在自家 App 中使用 <code>Bearer token</code> 登录</h4><p>有的 App 会在 API 的设计中，将登录和授权设计成类似 OAuth2 的过程，但简化掉 <code>Authorization code</code> 概念。</p><p>即：登录接口请求成功时，会直接返回 <code>access token</code>，然后客户端在之后的请求中，就可以使用这个 <code>access token</code> 来当做 <code>bearer token</code> 进行用户操作了。</p><blockquote><p>  <strong>Refresh token</strong></p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Bearer&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxxxx&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxxxx&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;expires_time&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxxxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>  用法：</p><ul><li><code>access token</code> 有失效时间，在它失效后，调⽤ <code>refresh_token</code> 接口，传入 <code>refresh_token</code> 来获取新的 <code>access token</code>。</li></ul><p>  目的：</p><ul><li>安全。当 <code>access token</code> 失窃，由于它有失效时间，因此坏人只有较短的时间来「做坏事」。</li><li>同时，由于（在标准的 <code>OAuth2</code> 流程中）<code>refresh token</code> 永远只存在与第三方服务的服务器中，因此 <code>refresh token</code> 几乎没有失窃的风险。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OAuth2</tag>
      
      <tag>Cookie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-HTTPS</title>
    <link href="/posts/0a77f507cef9/"/>
    <url>/posts/0a77f507cef9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>   <code>HTTP Secure</code> &#x2F; <code>HTTP over SSL</code> &#x2F; <code>HTTP over TLS</code></p><p>  即工作在 <code>SSL</code>（或 <code>TLS</code>）上的 <code>HTTP</code>。说白了就是加密通信的 <code>HTTP</code>。</p><ul><li><code>SSL</code> : Secure Socket Layer（安全套接字层）（<code>TLS</code> 前身）</li><li><code>TLS</code> : Transport Layer Security（传输层安全性）</li></ul></blockquote><hr><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在 <code>HTTP</code> 和 <code>TCP</code> 之间增加了一个 <strong>安全层</strong>（安全的加密层），用于保障 <code>HTTP</code> 的加密传输。</p><p>即 <code>HTTP</code> 将数据交给 <code>TCP</code> 之前，先把数据交给 <code>TLS</code>，由 <code>TLS</code> 将数据进行加密后，再往下交给 <code>TCP</code> 进行数据去传输。</p><p>以及对面的接受方在 <code>TCP</code> 层收到数据且拼接好之后，不直接交给 <code>HTTP</code> 层，而是先交给 <code>TCP</code> 层进行解密，解密完后再由 <code>TLS</code> 交给 <code>HTTP</code>。</p><hr><h1 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h1><p>在客户端和服务器之间用 <strong>非对称加密</strong> 协商出一套 <strong>对称密钥</strong> ，每次发送信息之前将内容加密，收到之后解密，达到内容的加密传输。</p><h2 id="为什么不直接用非对称加密"><a href="#为什么不直接用非对称加密" class="headerlink" title="为什么不直接用非对称加密"></a>为什么不直接用非对称加密</h2><p>非对称加密由于使用了复杂了数学原理，因此计算相当复杂，如果完全使用非对称加密来加密通信内容，会严重影响用户网络通信的性能。</p><hr><h1 id="HTTPS-TLS-的连接"><a href="#HTTPS-TLS-的连接" class="headerlink" title="HTTPS (TLS) 的连接"></a>HTTPS (TLS) 的连接</h1><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><ol><li>客户端请求建立 <code>TLS</code> 连接</li><li>服务器发挥证书</li><li>客户端验证服务器证书</li><li>客户端信任服务器后，和服务器协商对称密钥（此时通过非对称加密的方式协商对称密钥）</li><li>使用对称密码开始通信</li></ol><h2 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h2><blockquote><p>  可以通过 WireShark 进行更加详细的查看。</p></blockquote><ol><li><p>客户端和服务器第一次打招呼。</p><p>客户端向服务器发送 Client Hello（大小为1字节的数据，值为1，这个数据的名字叫做 Client Hello）。</p><p>同时，也会再附加信息中发送服务器可选的 <code>TLS</code> 版本、可选的加密套件（对称加密算法、非对称加密算法、哈希算法）、客户端生成的随机数。</p></li><li><p>服务器收到 Client Hello 后，确定双方可以共同使用的 <code>TLS</code> 版本、加密套件 ，以及服务端自己生成的以及随机数，并将这些信息发回给客户端，称为 Server Hello。Server Hello 也是一个单字节数据，值为2。</p><p>如果没有可以共同使用的内容，那么 <code>HTTPS</code> 就直接建立失败。</p></li><li><p>服务器发送自己的证书。</p><blockquote><p>   <strong>证书中主要包含了</strong>：</p><ol><li>服务器的公钥（其实是个数据）</li><li>服务器的证书的签名（由证书签发机构的私钥对服务器证书的签名）</li><li>证书签发机构的公钥（用户验证这个“公钥签名”的另一个公钥）</li><li>证书签发机构的证书的签名</li><li>证书签发机构的签发机构（根证书机构）的公钥</li><li>服务器主机名</li></ol></blockquote><p>可以让客户端进行信息加密。客户端通过服务器的公钥进行信息加密，服务器可以通过自己的密钥进行信息的解密。</p><blockquote><p>   <strong>服务器公钥的签名</strong></p><p>   用私钥对服务器公钥的 Hash 值版进行一次非对称加密的计算得到的结果数据。这个数据可以被该私钥对应的公钥所解开。</p><p>   如果解开签名之后的值正好等于服务器公钥经过一次 Hash 计算后的结果值，那么就证明这个源数据是没有问题的。</p><p>   注意：用于解开的公钥和被签名的公钥不是同一个，它是由私钥生成的另一个公钥。</p></blockquote></li><li><p>客户端验证公钥的正确性。</p><p>证书签发机构的签发机构的证书，在所有的操作系统中都默认带有一份，被认为是最可信的证书，被称为“根证书”。</p><p>当需要查询这些证书的时候，会从设备中进行查询，如果能够查询的到的话，那么第5个文件内容就是可信的了。</p><p>当证书签发机构的签发机构的公钥是可信的话，我们就可以使用这个公钥去验证第4个内容的正确性。再使用第3个内容的公钥去验证第2个内容的正确性了。</p><p>如果第2个内容是正确的话，那么说明服务器的公钥就是正确的了。</p><blockquote><p>  除了操作系统自带的根证书，我们也可以自行往自己的设备中安装自己需要的根证书。</p></blockquote><p><strong>注：客户端除了验证公钥是否正确，还需要验证服务器主机名是否是我们所需要到达的地址。</strong></p></li><li><p>客户端发送 <code>Pre-master Secret</code> 的数据</p><p>使用的服务器的公钥加密发过去的，也是一个客户端生成的随机数。</p></li><li><p>客户端和服务器都通过上述三个随机数生成一个 <code>Master Secret</code> 的值</p><p>通过 <code>Master Secret</code> 就可以算出双方进行对称加密的密钥等相关的一些信息了。然后双方就可以进行加密通信了。</p><p><code>Master Secret</code> 会生成四个内容：</p><ol><li>客户端加密密钥</li><li>服务端加密密钥</li><li>客户端 <code>MAC Secret</code></li><li>服务端 <code>MAC Secret</code></li></ol><blockquote><p>  <strong>为什么使用三个随机数生成数据，而不是仅使用 <code>Pre-master Secret</code> 来生成数据？</strong></p><p>  为了防止<strong>重放攻击</strong>。通过多个随机数，防止攻击者使用一个以前收到的随机数就可以获取用户的身份认证。</p><blockquote><p>  <strong>重放攻击(Replay Attacks)</strong></p><p>  又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行。</p></blockquote></blockquote><blockquote><p>  为什么客户端和服务器要使用两个加密密钥呢？</p><p>  为了防止出现攻击人将客户端发送的消息重新发送给客户端，使用相同的密钥会使客户端能够解密并认为这个服务器发送的数据，从而导致数据错误。而通过两个不同的密钥，便可以防止客户端和服务器双方无法分辨数据的来源了。</p></blockquote><p>注意：</p><ol><li>客户端向服务端发送对称加密数据时，双方使用客户端加密密钥进行加解密操作。服务端向客户端发送对称加密数据时，双方使用服务端加密密钥进行加解密操作。</li><li><code>MAC Secret</code>。其中 <code>MAC</code> 也即 <code>HMAC</code> (Hash-based Message Authentication Code 哈希运算消息认证码)，可以使数据进行带密码的哈希计算。仅仅只是无密码的哈希算法容易被攻击者碰撞，但是使用带特定的密码的哈希算法就是极大的增加难度。当接收方也使用带该密码的，相同的哈希算法进行计算后，与发送过来的哈希值进行比较，如果两者一样的话，那么就可以证明数据使对方发的且是安全的。</li></ol></li><li><p>客户端向服务器发送1个字节的数据（值为20，名称为 Change Cipher Spec），通知自己将使用加密通信。</p></li><li><p>客户端将前7步得到的数据通过客户端加密密钥以及客户端 <code>MAC Secret</code> 加密，然后发送给服务器。服务器对获得的结果进行验证。</p><p>消息名称为 Encrypted Handshake Message。</p><p><strong>此步之后，客户端就可以通过对称加密发送信息了。</strong></p></li><li><p>服务器向客户端发送1个字节的数据（值为20，名称为 Change Cipher Spec），通知自己将使用加密通信。</p></li><li><p>服务器将前9步得到的数据通过服务器加密密钥以及服务器 <code>MAC Secret</code> 加密，然后发送给客户端。客户端对获得的结果进行验证。</p><p>消息名称为 Encrypted Handshake Message。</p><p><strong>此步之后，服务器也可以通过对称加密发送信息了。</strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo-theme-butterfly 修改分割线的样式</title>
    <link href="/posts/53768a5482ee/"/>
    <url>/posts/53768a5482ee/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习大佬们的博客的时候，并没有看到详细自定义分割线样式的博客，所以想记录一下自己美化分割线的过程。</p><blockquote><p>  <strong>Butterfly 主题默认分割线样式</strong></p>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221024200848426.png" alt="Butterfly 主题默认分割线样式" style="zoom:80%;" />  <p>  <strong>通过修改后的分割线样式</strong></p>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026222103059.png" alt="通过修改后的分割线样式" style="zoom:90%;" /></blockquote><hr><blockquote><p>   <strong>更改设置后需要进行 <code>hexo clean</code> 操作哦~</strong> </p></blockquote><hr><h1 id="修改浮动图标图片"><a href="#修改浮动图标图片" class="headerlink" title="修改浮动图标图片"></a>修改浮动图标图片</h1><p>将剪刀图片修改为其他的图片，如上文中的小汽车图片。</p><p>两种方式可以修改：</p><ol><li><p>修改 <code>_config.butterfly.yml</code> 文件中的 <code>hr_icon -&gt; icon</code> 内容（推荐）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># The setting of divider icon (水平分隔線圖標設置)</span><br><span class="hljs-attr">hr_icon:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;\f5e4&#x27;</span> <span class="hljs-comment"># the unicode value of Font Awesome icon, such as &#x27;\3423&#x27;</span><br>  <span class="hljs-string">//</span> <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure></li><li><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>hr -&gt; &amp;:before -&gt; content</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hr<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-selector-pseudo">&amp;:before</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attribute">content</span>: <span class="hljs-variable">$hr</span>-icon // 同样修改为如 <span class="hljs-string">&#x27;\3423&#x27;</span> 形式<br></code></pre></td></tr></table></figure></li></ol><p>如果想去除浮动图标，仅需将参数修改为 <code>&#39;&#39;</code> 即可，例如 <code>icon: &#39;&#39;</code>。</p><blockquote><p>  <strong><code>the unicode value of Font Awesome icon</code> 获取方法：</strong></p><ol><li><p>打开 <code>Font Awesome</code> 网址：<a href="https://fontawesome.com/v5/search">Search v5 Icons | Font Awesome</a></p></li><li><p>通过搜索栏选择并点击自己心仪的图标</p></li><li><p>下图中箭头所指内容即为 <code>the unicode value of Font Awesome icon</code></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026225602023.png" alt="the unicode value of Font Awesome icon" style="zoom:60%;" /></li></ol></blockquote><hr><h1 id="修改浮动图标颜色"><a href="#修改浮动图标颜色" class="headerlink" title="修改浮动图标颜色"></a>修改浮动图标颜色</h1><p>修改浮动图标的颜色，同样可以有两种方法进行更改：</p><ol><li><p>修改 <code>_config.butterfly.yml</code> 中的 <code>theme_color -&gt; hr_color</code> 内容（推荐）</p><p><strong>可能会将分割线横线的颜色同时进行更改。</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">theme_color:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-string">//</span> <span class="hljs-string">...</span><br>  <span class="hljs-attr">hr_color:</span> <span class="hljs-string">&quot;#A4D8FA&quot;</span> <span class="hljs-string">//</span> <span class="hljs-string">修改此处内容</span><br></code></pre></td></tr></table></figure></li><li><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>hr -&gt; &amp;:before -&gt; color</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hr<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-selector-pseudo">&amp;:before</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--hr-before-color) // 修改为如 <span class="hljs-number">#A4D8FA</span> 形式<br></code></pre></td></tr></table></figure></li></ol><hr><h1 id="修改浮动图标相对于横线的位置"><a href="#修改浮动图标相对于横线的位置" class="headerlink" title="修改浮动图标相对于横线的位置"></a>修改浮动图标相对于横线的位置</h1><p>可以通过两种方式进行修改：</p><ol><li><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>hr -&gt; &amp;:before -&gt; line-height</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hr<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-selector-pseudo">&amp;:before</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1</span> // 图标浮于横线中间，其他参数见下文<br></code></pre></td></tr></table></figure><blockquote><p>  <strong><code>line-height</code> 参数说明：</strong></p><ul><li><p><code>1</code></p><p>图标浮于横线中间</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026230524821.png" style="zoom:80%;" /></li><li><p><code>0</code></p><p>图标浮于横线上方</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026230609189.png" style="zoom:80%;" /></li><li><p><code>-1</code></p><p>图标浮于横线下方</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026230634557.png" style="zoom:80%;" /></li></ul></blockquote></li><li><p>修改 <code>_config.butterfly.yml</code> 文件中的 <code>hr_icon -&gt; icon-top</code> 内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># The setting of divider icon (水平分隔線圖標設置)</span><br><span class="hljs-attr">hr_icon:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-string">//</span> <span class="hljs-string">...</span><br>  <span class="hljs-attr">icon-top:</span><br></code></pre></td></tr></table></figure></li></ol><hr><h1 id="修改横线虚实"><a href="#修改横线虚实" class="headerlink" title="修改横线虚实"></a>修改横线虚实</h1><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>hr -&gt; border</code> 中的 <code>dashed</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hr<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> dashed <span class="hljs-built_in">var</span>(--hr-border)<br></code></pre></td></tr></table></figure><blockquote><p>  <strong>其中第二个参数说明：</strong></p><ul><li><p><code>dashed</code></p><p>虚线效果</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026222103059.png" alt="通过修改后的分割线样式" style="zoom:90%;" /></li><li><p><code>solid</code></p><p>实线效果</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221115165404929.png" alt="pic" style="zoom:80%;" /></li></ul></blockquote><hr><h1 id="修改横线粗细"><a href="#修改横线粗细" class="headerlink" title="修改横线粗细"></a>修改横线粗细</h1><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>hr -&gt; border</code> 中的 <code>2px</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hr<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> dashed <span class="hljs-built_in">var</span>(--hr-border)<br></code></pre></td></tr></table></figure><blockquote><p>  <strong>数字效果对比：</strong></p><ul><li><p><code>2px</code></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026222103059.png" alt="通过修改后的分割线样式"  /></li><li><p><code>5px</code></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221115174052677.png" alt="image-20221115174052677" style="zoom:90%;" /></li></ul></blockquote><hr><h1 id="修改横线颜色"><a href="#修改横线颜色" class="headerlink" title="修改横线颜色"></a>修改横线颜色</h1><ol><li><p>修改 <code>_config.butterfly.yml</code> 中的 <code>theme_color -&gt; hr_color</code> 内容（推荐）</p><p><strong>可能会将分割线横线的颜色同时进行更改。</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">theme_color:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-string">//</span> <span class="hljs-string">...</span><br>  <span class="hljs-attr">hr_color:</span> <span class="hljs-string">&quot;#A4D8FA&quot;</span> <span class="hljs-string">//</span> <span class="hljs-string">修改此处内容</span><br></code></pre></td></tr></table></figure></li><li><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>:root -&gt; --hr-border</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-pseudo">:root</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">--hr-border</span>: <span class="hljs-built_in">lighten</span>(<span class="hljs-variable">$theme</span>-hr-<span class="hljs-attribute">color</span>,;<span class="hljs-number">50%</span>)<br></code></pre></td></tr></table></figure><p>将 <code>lighten($theme-hr-color,;50%)</code> 部分修改为<strong>十六进制颜色表示方式</strong>即可。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo-theme-butterfly</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AutoHotkey v1 变量和字符串</title>
    <link href="/posts/f6aa7ef17973/"/>
    <url>/posts/f6aa7ef17973/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Variables.htm">变量和表达式 | AutoHotkey (autoahk.com)</a></li><li><a href="https://www.autohotkey.com/boards/viewtopic.php?t=14633">String literal that spans multiple lines? - AutoHotkey Community</a></li></ul></blockquote><hr><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>有关一般说明和变量如何工作的详细信息，请参阅变量。</p><h2 id="给变量赋值"><a href="#给变量赋值" class="headerlink" title="给变量赋值"></a><strong>给变量赋值</strong></h2><p>要将字符串或数字存储在变量中，有两种方法: 传统方式和表达式。传统方法使用等号运算符(&#x3D;) 来指定<strong>不加引号的</strong>原义字符串或用百分号括起来的变量。例如:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs AutoHotKey">MyNumber = <span class="hljs-number">123</span><br>MyString = This is a literal string.<br>CopyOfVar = <span class="hljs-variable">%Var%</span>  <span class="hljs-comment">; 和 = 运算符一起使用时，需要使用百分号来获取变量的内容。</span><br></code></pre></td></tr></table></figure><p>与之相比，表达式方法使用冒号等号运算符(:&#x3D;) 来保存数字，<strong>加引号的</strong>字符串和其他类型的表达式。以下示例在功能上与前面的例子相同:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs AutoHotKey">MyNumber := <span class="hljs-number">123</span><br>MyString := <span class="hljs-string">&quot;This is a literal string.&quot;</span><br>CopyOfVar := Var  <span class="hljs-comment">; 和前面段落中与其作用相同的语句不同，百分号不和 := 运算符一起使用。</span><br></code></pre></td></tr></table></figure><p><strong>后一种方法由于其更清晰并且与其他许多语言几乎一致的表达式语法成为大多数人的首选方法.</strong></p><p>从上面的例子中您可能已经想到了有两种方法来清除变量的内容(即让变量为空):</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs AutoHotKey">MyVar =<br>MyVar := <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>上面的这对空引号只能和 :&#x3D; 运算符一起使用，因为和 &#x3D; 运算符一起使用时，则会在变量中保存两个原义的引号字符。</p><h2 id="获取变量的内容"><a href="#获取变量的内容" class="headerlink" title="获取变量的内容"></a><strong>获取变量的内容</strong></h2><p>如同赋值有两种方法，获取变量的内容也有两种方法: 传统方法和表达式方法。传统方法需要将变量名包围在百分号中来获取变量的内容。例如:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs AutoHotKey">MsgBox The value in the variable named Var is <span class="hljs-variable">%Var%</span>.<br>CopyOfVar = <span class="hljs-variable">%Var%</span><br></code></pre></td></tr></table></figure><p>与之相比，表达式方法省去了变量名两边的百分号，但原义的字符串必须包围在双引号中。所以，下面的表达式作用等同于上面的例子:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs AutoHotKey"><span class="hljs-built_in">MsgBox %</span> <span class="hljs-string">&quot;The value in the variable named Var is &quot;</span> . Var . <span class="hljs-string">&quot;.&quot;</span>  <span class="hljs-comment">; 使用句点连接(join 拼接) 两个字符串。</span><br>CopyOfVar := Var<br></code></pre></td></tr></table></figure><p>在上面的 MsgBox 这行，通过使用百分号和空格把参数从传统模式改变为表达式模式。因为所有的命令默认情况下使用传统模式(除了另外注明的那些), 所以这是必须的。</p><h2 id="变量的比较"><a href="#变量的比较" class="headerlink" title="变量的比较"></a><strong>变量的比较</strong></h2><p>请阅读下面表达式部分中关于不同类型变量比较的重要提示，尤其是关于何时使用小括号的内容。</p><hr><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="保存带有引号的字符串"><a href="#保存带有引号的字符串" class="headerlink" title="保存带有引号的字符串"></a>保存带有引号的字符串</h2><p>如果我们想用变量保存一个带有双引号的字符串，需要使用 &#x3D; 操作符：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs AutoHotKey">var = this is <span class="hljs-string">&quot; ; 输出的字符串中包含双引号</span><br></code></pre></td></tr></table></figure><h2 id="保存多行字符串"><a href="#保存多行字符串" class="headerlink" title="保存多行字符串"></a>保存多行字符串</h2><p>如果我们想要保存多行的字符串，可以使用 <code>()</code> 包含文本内容并使用 <code>=</code> 且 <strong>不加 <code>&quot;&quot;</code></strong> 的方式（文本中每行的字符串形式与使用 <code>=</code> 操作符保存单行字符串的形式相同）：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs AutoHotKey">var = string<br><br>exampleString =<br>(                      <span class="hljs-comment">; 左括号右侧的字符会被自动忽略，正文从下行开始</span><br>    multiple<br>        lines          <span class="hljs-comment">; 该行字符的所有字符（包括空格）会全部输出</span><br>                       <span class="hljs-comment">; 空行也会如实输出  </span><br><span class="hljs-built_in">    of</span><br><span class="hljs-built_in">        %</span>var%<br>)                      <span class="hljs-comment">; 右括号左侧不能有其他字符，否则将报错</span><br><span class="hljs-built_in"></span><br><span class="hljs-built_in">MsgBox,</span> % exampleString<br></code></pre></td></tr></table></figure><p>输出结果截图（第一个非空字符前的空格将忽略）：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220723170233064.png" alt="image-20220723170233064" style="zoom: 50%;" /><p><strong>注意：</strong></p><ol><li>该方式中的 <code>()</code> 必须分别、单独在一行，不能接在其他语句末尾。且文本将严格按照输入形式输出，两个括号之间的空行和空格也会如实输出，但是第一个非空字符前的空格将忽略。</li><li>左括号右侧的字符会被自动忽略，正文从下行开始；右括号左侧不能有其他字符，否则将报错。</li><li>如果需要使用 <code>:=</code> 操作符进行多行字符串保存，请使用 &#96;n 转义字符进行换行操作。</li></ol>]]></content>
    
    
    <categories>
      
      <category>AutoHotkey</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AutoHotkey</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AutoHotkey v1 类的定义与部分使用技巧</title>
    <link href="/posts/de88f66d3fa1/"/>
    <url>/posts/de88f66d3fa1/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>本文所使用的 AHK 版本为 AutoHotKey v1 。</p>          </div><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本人想在 AHK 中使用面向对象的方式编写代码，但是发现在官方文档中仅有较少关于 <code>class</code> 的操作代码示例，所以根据自己这两天的代码编写过程，整理出常用的一些使用技巧供大家参考。</p><hr><h1 id="类的创建和使用"><a href="#类的创建和使用" class="headerlink" title="类的创建和使用"></a>类的创建和使用</h1><p>类的创建使用 <code>class</code>  关键字。可以显式定义构造方法以及析构方法：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs AutoHotKey"><span class="hljs-comment">; 类的创建</span><br>class A &#123;<br>    <span class="hljs-comment">; 静态变量的创建</span><br>    static var1 := Expression1<br>    <span class="hljs-comment">; 类字段的创建</span><br>    var2 := Expression2<br>    <br>    <span class="hljs-comment">; 构造方法，可传入任意参数，也可不传入参数</span><br>    __New(...) &#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">; 方法的创建</span><br>    <span class="hljs-comment">; 可传入任意参数，参数支持默认参数值</span><br>    <span class="hljs-comment">; 根据需要可不写 return</span><br>    methodName(...) &#123;<br>        ...<br>        <span class="hljs-keyword">return</span> ...<br>    &#125;<br>    <br>    <span class="hljs-comment">; 析构方法</span><br>    __Delete() &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类的使用：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">a := <span class="hljs-keyword">new</span> A(...)   <span class="hljs-comment">; 类的实例化，根据构造方法传入对应的参数</span><br>a.methodName(...) <span class="hljs-comment">; 使用变量的方法</span><br></code></pre></td></tr></table></figure><hr><h1 id="在类中创建热键并绑定类方法"><a href="#在类中创建热键并绑定类方法" class="headerlink" title="在类中创建热键并绑定类方法"></a>在类中创建热键并绑定类方法</h1><p>使用面向对象的思想编写代码的话，我们或许需要在类中创建热键及其响应逻辑的方法：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">class A &#123;<br>    <span class="hljs-comment">; 自定义的一个方法，用于加载类中所有的热键</span><br>    loadHotKey() &#123;<br>        <span class="hljs-comment">; 创建响应方法的方法引用</span><br>        varFunctionA := ObjBindMethod(this, <span class="hljs-string">&quot;functionA&quot;</span>)<br><br>        <span class="hljs-comment">; 创建 Alt + A 的热键以及绑定其响应方法</span><br><span class="hljs-built_in">        HotKey,</span> !A, % varFunctionA, On<br>    &#125;<br>    <br>    functionA() &#123;<br>    <span class="hljs-comment">; 热键的响应逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码便在类中创建了一个使用类中方法作为响应逻辑的热键。其中：</p><ol><li><code>varFunctionA := ObjBindMethod(this, &quot;functionA&quot;)</code> 部分：<ol><li><code>&quot;functionA&quot;</code> 中双引号必须保留，双引号中间内容为对应的方法名。</li><li><code>varFunctionName</code> 为自定义的变量名称，与第7行第3个参数相对应。</li></ol></li><li><code>HotKey, !A, % varFunctionA, On</code> 部分：<ol><li><code>!A</code> 为热键的内容，具体可以参考文档中 <strong>热键</strong> 部分内容。</li><li><code>% varFunctionA</code> 中百分号必须保留，后面的内容对应上面一行自定义的变量名。</li></ol></li></ol><p>热键的使用：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-keyword">new</span> A().loadHotKey()<br></code></pre></td></tr></table></figure><p>通过对该类的实例化并调用实例化对象的 <code>loadHotKey</code> 方法即可。</p><hr><h1 id="在类中绘制-UI-并绑定类方法"><a href="#在类中绘制-UI-并绑定类方法" class="headerlink" title="在类中绘制 UI 并绑定类方法"></a>在类中绘制 <code>UI</code> 并绑定类方法</h1><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">class B &#123;<br>    <span class="hljs-comment">; 自定义的一个方法，用于绘制 UI 以及绑定响应的方法</span><br>    loadView() &#123;<br>        <span class="hljs-comment">; 绘制了一个按钮</span><br><span class="hljs-built_in">        Gui,</span> Add, Button, w200 h35 hwndHFuncB, This is a button.<br><br>        <span class="hljs-comment">; 创建了响应方法的方法引用</span><br>        varFuncB := ObjBindMethod(this, <span class="hljs-string">&quot;functionB&quot;</span>)<br><br>        <span class="hljs-comment">; 通过 HWND 将按钮与方法绑定</span><br><span class="hljs-built_in">        GuiControl,</span> +g, <span class="hljs-variable">%HFuncB%</span>, % varFuncB<br>    &#125;<br>    <br>    functionB() &#123;<br>        <span class="hljs-comment">; 按钮的响应逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><code>Gui, Add, Button, w200 h35 hwndHFuncB, This is a button.</code> 中 <code>hwndHFuncB</code> 部分：<ol><li>形式为 <code>hwnd + 自定义变量名</code></li><li>自定义变量名与第9行中第3个参数相对应。</li></ol></li><li><code>varFuncB := ObjBindMethod(this, &quot;functionB&quot;)</code> 部分：<ol><li><code>varFuncB</code> 为另一个自定义变量名，与第9行中第4个变量名相对应。</li><li><code>&quot;functionB&quot;</code> 中双引号必须保留，双引号中间内容为对应的方法名。</li></ol></li><li><code>GuiControl, +g, %HFuncB%, % varFuncB</code> 中第3、4个参数分别为上述的两个自定义变量名。</li></ol><hr><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><blockquote><p>  使用面向对象思想重构 <a href="https://luoyu-ying.github.io/posts/050a11a7817a/">通过 AutoHotKey 简化 Hexo 操作 | 洛语 の Blog (luoyu-ying.github.io)</a> 中 Deploy 部分的操作。</p></blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-comment">; 加载类的 UI 以及热键</span><br><span class="hljs-keyword">new</span> Deploy().load()<br><br><span class="hljs-comment">; -------------------------</span><br><br><span class="hljs-comment">; 类的创建</span><br>class Deploy &#123;<br><br>    load() &#123;<br>        this.loadView()<br>        this.loadHotKey()<br>    &#125;<br>    <br>    <span class="hljs-comment">; 本代码中 GAD -&gt; generate and deploy</span><br>    <br>    loadView() &#123;<br><span class="hljs-built_in">        Gui,</span> Add, Button, w200 h35 hwndHGAD, Generate &amp;&amp; Deploy<br>        <br>        varGAD := ObjBindMethod(this, <span class="hljs-string">&quot;generateDeploy&quot;</span>)<br><span class="hljs-built_in">        </span><br><span class="hljs-built_in">        GuiControl,</span> +g, <span class="hljs-variable">%HGAD%</span>, % varGAD<br>    &#125;<br>    <br>    loadHotKey() &#123;<br>        varGAD := ObjBindMethod(this, <span class="hljs-string">&quot;generateDeploy&quot;</span>)<br><span class="hljs-built_in">        </span><br><span class="hljs-built_in">        Hotkey,</span> CapsLock &amp; G, % varGAD, On<br>    &#125;<br>    <br>    generateDeploy() &#123;<br><span class="hljs-built_in">        Run,</span> <span class="hljs-variable">%comSpec%</span> /c hexo g &amp;&amp; hexo d, , Min<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AutoHotkey</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AutoHotkey</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AutoHotkey v1 问题解决记录</title>
    <link href="/posts/1bfe28981f7d/"/>
    <url>/posts/1bfe28981f7d/</url>
    
    <content type="html"><![CDATA[<blockquote><p>更多的资料请参考 AHK 官方技术文档以及 AHK 社区。</p></blockquote><hr><h1 id="代码中有些代码总是无法运行"><a href="#代码中有些代码总是无法运行" class="headerlink" title="代码中有些代码总是无法运行"></a>代码中有些代码总是无法运行</h1><blockquote><p>  处理方法参考自：</p><ul><li><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Scripts.htm#auto">脚本 - 定义与使用 | AutoHotkey (autoahk.com)</a></li></ul></blockquote><blockquote><p>  下文中的所有链接皆为 AHK 技术文档中该词条的链接，可正常使用。</p></blockquote><p><strong><font size="4"><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Scripts.htm#auto">脚本顶部(自动执行段)</a></font></strong></p><p>脚本加载完成后, 它会从顶行开始执行, 直到遇到 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Return.htm">Return</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Exit.htm">Exit</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Hotkeys.htm">热键&#x2F;热字串标签</a> 或脚本的底部(无论最先遇到哪个). 脚本的这个顶端部分被称为 <em>自动执行段</em>.</p><blockquote><p>   <strong>注意:</strong> 虽然脚本的 <em>第一个</em> 热键&#x2F;热字串标签与 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Return.htm">return(返回)</a> 的效果相同, 但其他热键和标签却没有.</p></blockquote><p>如果脚本不是<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/_Persistent.htm">持续运行的</a>, 它将在自动执行部分完成后终止. 否则, 它会以空闲状态持续运行, 从而对诸如<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Hotkeys.htm">热键</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Hotstrings.htm">热字串</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Gui.htm#label">GUI 事件</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Menu.htm">自定义菜单项</a>和<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/SetTimer.htm">计时器</a>等事件做出响应. 如果一个脚本包含了热键, 热字串, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/OnMessage.htm">OnMessage()</a> 或 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Gui.htm">GUI</a>, 以及一些其他情况, 它就会自动变为持续运行的. 也可以用 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/_Persistent.htm">#Persistent</a> 指令来显式地使脚本持续运行.</p><hr><h1 id="通过函数创建热键"><a href="#通过函数创建热键" class="headerlink" title="通过函数创建热键"></a>通过函数创建热键</h1><p>通过 <code>HotKey</code> 函数动态的创建一个热键。</p><blockquote><p>   具体参数可以查看文档：<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Hotkey.htm">Hotkey | AutoHotkey (autoahk.com)</a></p></blockquote><p>示例：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-comment">; 创建一个 CapsLock + K 的一个热键，效果为 Sfunction Lable 中的内容</span><br><span class="hljs-built_in">HotKey,</span> CapsLocks &amp; K, function<br><br>function() &#123;<br><span class="hljs-built_in">MsgBox,</span> <span class="hljs-string">&quot;Hello World!&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="通过函数创建热字串"><a href="#通过函数创建热字串" class="headerlink" title="通过函数创建热字串"></a>通过函数创建热字串</h1><p>通过 <code>HotString</code> 函数动态的创建一个热字串。</p><blockquote><p>  具体的参数可以查看文档：<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Hotstring.htm">Hotstring() | AutoHotkey (autoahk.com)</a></p></blockquote><hr><h1 id="无法正常使用分号（注释符号）"><a href="#无法正常使用分号（注释符号）" class="headerlink" title="无法正常使用分号（注释符号）"></a>无法正常使用分号（注释符号）</h1><p>当我们想要使用 分号 作为热键中的一部分时，我们可以使用 <code>SC027</code> 替换分号的位置，以达到分号的作用、</p><p>示例：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-comment">; 创建一个 CapsLock + K 的一个热键，效果为 function Lable 中的内容</span><br><span class="hljs-built_in">HotKey,</span> CapsLocks &amp; SC027, function <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AutoHotkey</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AutoHotkey</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin 函数嵌套</title>
    <link href="/posts/47063eb1b5ed/"/>
    <url>/posts/47063eb1b5ed/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li><li><a href="https://www.cnblogs.com/Anker/archive/2013/03/04/2943498.html">递归与尾递归总结 - Rabbit_Dale - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/zsp765098084/article/details/90901260">kotlin学习笔记之尾递归优化（tailrec）_mictoy_朱的博客-CSDN博客_kotlin tailrec</a></li></ul></blockquote><hr><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>在 <code>Kotlin</code> 中，我们可以在函数的代码块中创建另一个新的函数并使用该函数。并且该函数可以使用外部函数的变量。</p><p>如下方的代码；</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">outerMethod</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-comment">// 计算 1 + 2 + 3 + ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">innerMethod</span><span class="hljs-params">(c: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span>)</span></span> &#123;<br>        sum += c<br>        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span>)<br>        innerMethod(c - <span class="hljs-number">1</span>)<br>    &#125;  <br>    <br>    innerMethod()<br>  println(sum)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    outerMethod()<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>函数嵌套在工程中应尽量少的使用，容易造成代码可读性的降低。</p><p>但是在两种情况下可以创建内部函数：</p><ol><li>在某些情况下需要临时使用 <strong>递归</strong> 函数，如上文中的代码。</li><li>不希望被外部函数访问到的函数。</li></ol><hr><h1 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h1><p>实际上，在函数式编程当中，我们有时候也会使用递归来替代循环。</p><p>我们知道，递归都是有调用栈开销的，所以我们应该尽量使用 <strong>尾递归</strong>。对于这种类型的递归，在经过栈复用优化以后，它的开销就可以忽略不计了，我们可以认为它的空间复杂度是 O(1)。</p><blockquote><p>  尾递归就是从最后开始计算，每递归一次就算出相应的结果，也就是说, 函数调用出现在调用者函数的尾部，因为是尾部，所以根本没有必要去保存任何局部变量，直接让被调用的函数返回时越过调用者，返回到调用者的调用者去。</p><p>  <strong>尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数</strong>，深层函数所面对的不是越来越简单的问题，而是越来越复杂的问题，因为参数里带有前面若干步的运算路径。</p><p>  尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。</p></blockquote><h2 id="尾递归的特点"><a href="#尾递归的特点" class="headerlink" title="尾递归的特点"></a>尾递归的特点</h2><ul><li>递归的一种特殊形式</li><li>调用自身后无其他操作</li><li><code>tailrec</code> 关键字提示编译器尾递归优化</li></ul><p>示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-keyword">val</span> value: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">var</span> next: ListNode? = <span class="hljs-literal">null</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findListNode</span><span class="hljs-params">(head: <span class="hljs-type">ListNode</span>?, value: <span class="hljs-type">Int</span>)</span></span>: ListNode? &#123; <span class="hljs-comment">// 定义一个递归函数</span><br>    head ?: <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">if</span> (head.value == value) <span class="hljs-keyword">return</span> head<br>    <span class="hljs-keyword">return</span> findListNode(head.next, value) <span class="hljs-comment">// return 除了调用自己，没有多余的操作，所以是尾递归</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="尾递归优化的使用"><a href="#尾递归优化的使用" class="headerlink" title="尾递归优化的使用"></a>尾递归优化的使用</h2><p>在 <code>Kotlin</code> 语言中，我们即使写出了符合尾递归的递归函数，编译器也不会自动帮我们进行优化。</p><p>我们需要在 <code>fun</code> 关键字前面加上 <code>tailrec</code> 关键字以表示我们需要进行尾递归优化。</p><p>示例代码1：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-keyword">val</span> value: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">var</span> next: ListNode? = <span class="hljs-literal">null</span>)<br><br><span class="hljs-keyword">tailrec</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findListNode</span><span class="hljs-params">(head: <span class="hljs-type">ListNode</span>?, value: <span class="hljs-type">Int</span>)</span></span>: ListNode? &#123; <span class="hljs-comment">// 定义一个递归函数</span><br>    head ?: <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">if</span> (head.value == value) <span class="hljs-keyword">return</span> head<br>    <span class="hljs-keyword">return</span> findListNode(head.next, value) <span class="hljs-comment">// return 除了调用自己，没有多余的操作，所以是尾递归</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例代码2：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">recursionLoop</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br><span class="hljs-comment">// 变化在这里</span><br><span class="hljs-comment">//     ↓</span><br>    <span class="hljs-keyword">tailrec</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">go</span><span class="hljs-params">(i: <span class="hljs-type">Int</span>, sum: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> =<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">10</span>) sum <span class="hljs-keyword">else</span> go(i + <span class="hljs-number">1</span>, sum + i)<br><br>    <span class="hljs-keyword">return</span> go(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="尾递归优化的实质"><a href="#尾递归优化的实质" class="headerlink" title="尾递归优化的实质"></a>尾递归优化的实质</h2><p>通过对上文中的 <code>findListNode</code> 方法对 <strong>加了 <code>tailrec</code> 关键字</strong> 与 <strong>去除 <code>tailrec</code> 关键字</strong> 的两份代码分别进行反编译，我们发现：</p><ul><li><p>没有优化的 <code>findListNode</code> 对应的 <code>Java</code> 代码依然是递归函数，并且递归运行次数较大时出现了 <code>StackOverflowError</code> 错误；</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135701617.png" alt="img" style="zoom: 90%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135611929.png" alt="img" style="zoom:87%;" /></li><li><p>优化后（即添加了 <code>tailrec</code> 关键字）的 <code>findListNode</code> 方法对应的 <code>Java</code> 代码已经不再是递归函数，而是通过循环来实现功能，这样就不会再出现 <code>stackoverflowerror</code> 了。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135710491.png" alt="img" style="zoom:90%;" /></li></ul><p>这样我们就在 <code>Kotlin</code> 中既实现了递归函数代码简洁的优势，又规避了在 <code>Java</code> 中使用递归函数容易出出现的问题。</p>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin 类的创建与继承</title>
    <link href="/posts/8aab3d7fde77/"/>
    <url>/posts/8aab3d7fde77/</url>
    
    <content type="html"><![CDATA[<blockquote><p><code>Kotlin</code> 官方在线编程网址：</p><ul><li><a href="https://play.kotlinlang.org/">https://play.kotlinlang.org/</a></li></ul></blockquote><hr><blockquote><p>  本文参考自：</p><ul><li>《第一行代码  Android 第3版》</li><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li><li><a href="https://blog.csdn.net/c1392851600/article/details/80990570">Kotlin之类的继承及属性和方法的重写_c1392851600的博客-CSDN博客</a></li></ul></blockquote><hr><h1 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>通过 <code>class</code> 关键字创建一个类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">var</span> age = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$name</span> is eating.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例化方式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> person = Person()<br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>默认所有非抽象类都是不可以被继承的</strong>。</p><p>如果需要将其变为父类，则需要在 <code>class</code> 前使用 <code>open</code> 关键字。 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">var</span> age = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$name</span> is eating.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要继承另一个类，则使用 <code>:</code> 符号：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-type">Person</span>() &#123;<br>    <span class="hljs-keyword">var</span> grade = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><h3 id="重写父类的方法"><a href="#重写父类的方法" class="headerlink" title="重写父类的方法"></a>重写父类的方法</h3><p>需要注意的是如果父类的方法没有 <code>open</code> 声明，那么该方法是不允许被重写的。重写方法的时候需要使用 <code>override</code> 关键字注明。还有一点就是子类可以选择不重写父类的方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;汪汪&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;萌萌哒&quot;</span>)<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Husky</span> : <span class="hljs-type">Dog</span>() &#123;<br>    <span class="hljs-comment">// 由于父类的shout方法没有写open, 也就是默认是final的, 所以这里不能重写shout方法</span><br>    <span class="hljs-comment">// Error:(15, 5) Kotlin: &#x27;shout&#x27; in &#x27;Dog&#x27; is final and cannot be overridden 不能重写 shout 因为默认是 final 的</span><br>    <span class="hljs-comment">/* override fun shout() &#123;</span><br><span class="hljs-comment">        println(&quot;汪汪汪&quot;)</span><br><span class="hljs-comment">    &#125;*/</span><br> <br>    <span class="hljs-comment">// 重写父类方法的时候要加上override关键字, show方法也可以选择不进行重写</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;喵喵&quot;</span>)<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> husky =  Husky()<br>    husky.shout()<br>    husky.show()<br>&#125;<br></code></pre></td></tr></table></figure><p>再次需要注意的是，如果一个类集成了多个类&#x2F;接口，并且父类&#x2F;接口中有相同名字的方法需要重写的时候，那么子类这时候必须重写该方法，并且如果子类想区分开父类的方法的时候，可以使用 <code>super</code> 关键字调用不同父类的方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;汪汪&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;萌萌哒&quot;</span>)<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">WatchDog</span> &#123;<br>    <span class="hljs-comment">// interface里不用写open, 因为默认就是open的</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;看门电子狗&quot;</span>)<br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">// 使用接口的时候不用写(), 是因为接口是没有构造函数的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Husky</span> : <span class="hljs-type">Dog</span>(), WatchDog &#123;<br>    <span class="hljs-comment">// 由于父类的shout方法没有写open, 也就是默认是final的, 所以这里不能重写父类的方法</span><br>    <span class="hljs-comment">// Error:(15, 5) Kotlin: &#x27;shout&#x27; in &#x27;Dog&#x27; is final and cannot be overridden  不能重写shout因为默认是final的</span><br>    <span class="hljs-comment">/*override fun shout() &#123;</span><br><span class="hljs-comment">        println(&quot;汪汪汪&quot;)</span><br><span class="hljs-comment">    &#125;*/</span><br> <br>    <span class="hljs-comment">// 重写父类方法的时候要加上override关键字</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 当重写的方法在父类中有多个实现的时候, 如果继承的多个类中, 有相同的方法需要重写的时候, 则子类必须重写该方法, 并且, 为了区分, 可以使用super关键字来调用不同的父类中的方法</span><br>        <span class="hljs-keyword">super</span>&lt;WatchDog&gt;.show()  <span class="hljs-comment">// 看萌电子狗</span><br>        <span class="hljs-keyword">super</span>&lt;Dog&gt;.show() <span class="hljs-comment">// 萌萌哒</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> husky =  Husky()<br>    husky.shout()   <span class="hljs-comment">// 汪汪</span><br>    husky.show()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="重写父类的变量"><a href="#重写父类的变量" class="headerlink" title="重写父类的变量"></a>重写父类的变量</h3><p>父类变量的重写的时候有几个需要注意的地方：</p><ol><li><p>被重写的变量也要有 <code>open</code> 的声明。</p></li><li><p>子类可以使用 <code>var</code> 类型的变量去重写父类 <code>val</code> 类型的变量，但是不能使用 <code>val</code> 类型的变量去重写父类 <code>var</code> 类型的变量。</p><p>如果使用 <code>val</code> 类型的变量去重写父类的 <code>var</code> 类型的变量, 那么子类这个 <code>val</code> 类型的变量会多一个 <code>set</code> 方法, 而 <code>val</code> 类型的变量是不允许有 <code>set</code> 方法的。</p></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">open</span> <span class="hljs-keyword">val</span> x: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">get</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br> <br>    <span class="hljs-keyword">open</span> <span class="hljs-keyword">var</span> y : String = <span class="hljs-string">&quot;a&quot;</span><br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-type">A</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> x: <span class="hljs-built_in">Int</span> = <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> y: String = <span class="hljs-string">&quot;b&quot;</span><br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-type">A</span>() &#123;<br>    <span class="hljs-keyword">override</span>  <span class="hljs-keyword">var</span> x : <span class="hljs-built_in">Int</span> = <span class="hljs-number">2</span><br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> y : String = <span class="hljs-string">&quot;c&quot;</span> <span class="hljs-comment">// Error: Var-property public open val y: String defined in C cannot be overridden by val-property public open var y: String defined in A</span><br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p><code>Kotlin</code> 将构造函数分为了两种：主构造函数和次构造函数。</p><h2 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h2><p>主构造函数是最常使用的构造函数，每个类默认都会有一个不带参数的主构造函数。</p><p>（特殊情况：如果在没有实现主构造函数的情况下实现了次构造函数，则会失去该不带参数的主构造函数。）</p><p>当然也是可以显式地为其指明参数。主构造函数的特点就是没有函数体，直接定义在类名的后面即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> studentNo: String, <span class="hljs-keyword">var</span> grade: <span class="hljs-built_in">Int</span>) : Person() &#123;<br>&#125;<br><br><span class="hljs-comment">// 或者可以写成</span><br><span class="hljs-comment">// class Student constructor(val studentNo: String, var grade: Int) : Person() &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>我们在实例化的时候需要传入构造函数中的所有的参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> student = Student(<span class="hljs-string">&quot;123456789&quot;</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>由于主构造函数没有函数体，所以我们无法直接在其中编写一些逻辑。但是 <code>Kotlin</code> 给我们提供了一个 <code>init</code> 结构体，所有主构造函数的逻辑都可以写在里面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> studentNo: String, <span class="hljs-keyword">var</span> grade: <span class="hljs-built_in">Int</span>) : Person() &#123;<br>    <span class="hljs-keyword">init</span> &#123;<br>        println(<span class="hljs-string">&quot;Student No is <span class="hljs-variable">$studentNo</span> AND grade is <span class="hljs-variable">$grade</span>.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据 <code>Java</code> 语言继承特性中的一个规定：子类的构造函数必须调用父类中的构造函数。这个规定在 <code>Kotlin</code> 中也要遵守。 </p><p>所以在上文中 <code>class Student : Person()</code> 以及 <code>class Student(val studentNo: String, var grade: Int) : Person()</code> 中 <code>Person</code> 类后面的一对空括号表示 <code>Student</code> 类的主构造函数在初始化的时候会调用 <code>Person</code> 类的无参数构造函数，即使在自身的主构造函数为默认的无参数的时候也是不能省略的。</p><p>现在我们将 <code>Person</code> 类改造一下，将姓名和年龄都放到主构造函数中，即：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$name</span> is eating.&quot;</span>)<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们自定义了主构造函数，所以默认提供的无参数的主构造函数就不存在了，所以我们也需要修改一下 <code>Student</code> 类的表示方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> studentNo: String, <span class="hljs-keyword">var</span> grade: <span class="hljs-built_in">Int</span>, name: String, age: <span class="hljs-built_in">Int</span>) : Person(name, age) &#123;<br>            <br>    <span class="hljs-keyword">init</span> &#123;<br>        println(<span class="hljs-string">&quot;Student No is <span class="hljs-variable">$studentNo</span> AND grade is <span class="hljs-variable">$grade</span>.&quot;</span>)<br>    &#125;    <br>            <br>&#125;<br></code></pre></td></tr></table></figure><p>注意，我们在 <code>Student</code> 类的主构造函数中增加 <code>name</code> 和 <code>age</code> 这两个字段时，不能再将它们声明成 <code>val</code>，因为在主构造函数中声明成 <code>val</code> 或者 <code>var</code> 的参数将自动成为该类的字段,这就会导致和父类中同名的 <code>name</code> 和 <code>age</code> 字段造成冲突。因此，<strong>这里的 <code>name</code> 和 <code>age</code> 参数前面我们不用加任何关键字,让它的作用域仅限定在主构造函数当中即可</strong> 。</p><p>现在就可以通过如下的代码来创建一个 <code>Student</code> 类的实例并使用了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> student = Student(<span class="hljs-string">&quot;123456789&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;LiHua&quot;</span>, <span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><h2 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h2><p>其实你几乎是用不到次构造函数的，<code>Kotlin</code> 提供了一个给函数设定参数默认值的功能，基本上可以替代次构造函数的作用。</p><p>任何一个类只能有一个主构造函数，但是可以有多个次构造函数。次构造函数也可以用于实例化一个类，这一点和主构造函数没有什么不同，只不过它是有函数体的。</p><p><code>Kotlin</code> 规定，当一个类既有主构造函数又有次构造函数时，所有的次构造函数都必须调用主构造函数（包括间接调用)。</p><p>比如以下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(name: String, age: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> studentNo: String, <span class="hljs-keyword">var</span> grade: <span class="hljs-built_in">Int</span>) : Person(name, age) &#123;<br>    <span class="hljs-keyword">init</span> &#123;<br>        println(<span class="hljs-string">&quot;name : <span class="hljs-variable">$name</span> AND age : <span class="hljs-variable">$age</span> AND studentNo : <span class="hljs-variable">$studentNo</span> AND grade : <span class="hljs-variable">$grade</span>&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">constructor</span>(name: String , age: <span class="hljs-built_in">Int</span>) : <span class="hljs-keyword">this</span>(name, age, <span class="hljs-string">&quot;12345&quot;</span>, <span class="hljs-number">2</span>) &#123;&#125;<br>    <br>    <span class="hljs-keyword">constructor</span>() : <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;XiaoMei&quot;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&quot;1234567&quot;</span>, <span class="hljs-number">1</span>) &#123;&#125; <span class="hljs-comment">// 如果 &#123;&#125; 内没有内容的话，可以省略大括号</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> student1 = Student(<span class="hljs-string">&quot;LiHua&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">val</span> student2 = Student(<span class="hljs-string">&quot;XiaoMing&quot;</span>, <span class="hljs-number">21</span>)<br>    <span class="hljs-keyword">val</span> student3 = Student()<br>&#125;<br><br><span class="hljs-comment">// 运行结果</span><br>name : LiHua AND age : <span class="hljs-number">20</span> AND studentNo : <span class="hljs-number">123456</span> AND grade : <span class="hljs-number">3</span><br>name : XiaoMing AND age : <span class="hljs-number">21</span> AND studentNo : <span class="hljs-number">12345</span> AND grade : <span class="hljs-number">2</span><br>name : XiaoMei AND age : <span class="hljs-number">19</span> AND studentNo : <span class="hljs-number">1234567</span> AND grade : <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>特殊情况：</strong></p><p>那么接下来我们就再来看一种非常特殊的情况：类中只有次构造函数，没有主构造函数。</p><p>这种情况真的十分少见，但在 <code>Kotlin</code> 中是允许的。</p><p><strong>当一个类没有显式地定义主构造函数且定义了次构造函数时，它就是没有主构造函数的。</strong></p><p>我们结合代码来看一下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-type">Person</span> &#123;<br>    <span class="hljs-keyword">constructor</span>(name: String, age: <span class="hljs-built_in">Int</span>) : <span class="hljs-keyword">super</span>(name, age) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里的代码变化，首先 <code>Student</code> 类的后面没有显式地定义主构造函数，同时又因为定义了次构造函数，所以现在 <code>Student</code> 类是没有主构造函数的。那么既然没有主构造函数，继承 <code>Person</code> 类的时候也就不需要再加上括号了（因为主构造函数会调用父类的构造函数）。</p><p>另外，由于没有主构造函数，次构造函数只能直接调用父类的构造函数，上述代码也是将 <code>this</code> 关键字换成了 <code>super</code> 关键字，这部分就很好理解了，因为和 <code>Java</code> 比较像，也就不再多说了。</p><hr><h1 id="函数的命名参数以及参数默认值"><a href="#函数的命名参数以及参数默认值" class="headerlink" title="函数的命名参数以及参数默认值"></a>函数的命名参数以及参数默认值</h1><blockquote><p>  类的构造函数同样适用于命名参数以及参数默认值，所以我们在极大多数的情况下通过这两个特性配合主构造函数来可以实现次构造函数的功能。</p></blockquote><h2 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h2><p>简单理解，就是它允许我们在调用函数的时候传入“形参的名字”。</p><p>如同以下形式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">helloFunction(name = <span class="hljs-string">&quot;Kotlin&quot;</span>)<br></code></pre></td></tr></table></figure><p>让我们看一个更具体的使用场景：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createUser</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    name: <span class="hljs-type">String</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    age: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    gender: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    friendCount: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    feedCount: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    likeCount: <span class="hljs-type">Long</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    commentCount: <span class="hljs-type">Int</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>    <span class="hljs-comment">//..</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过如下的方法使用函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">createUser(<br>    name = <span class="hljs-string">&quot;Tom&quot;</span>,<br>    age = <span class="hljs-number">30</span>,<br>    gender = <span class="hljs-number">1</span>,<br>    friendCount = <span class="hljs-number">78</span>,<br>    feedCount = <span class="hljs-number">2093</span>,<br>    likeCount = <span class="hljs-number">10937</span>,<br>    commentCount = <span class="hljs-number">3285</span><br>)<br></code></pre></td></tr></table></figure><p>可以看到，在这段代码中，我们把函数的形参加了进来，形参和实参用 <code>=</code> 连接，建立了两者的对应关系。对比前面 <code>Java</code> 风格的写法，这样的代码可读性更强了。如果将来你想修改 <code>likeCount</code> 这个参数，也可以轻松做到。这其实就体现出了 <code>Kotlin</code> 命名参数的可读性与易维护性两个优势。</p><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>而除了命名参数这个特性，<code>Kotlin</code> 还支持参数默认值，这个特性在参数较多的情况下同样有很大的优势：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createUser</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    name: <span class="hljs-type">String</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    age: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    gender: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    friendCount: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    feedCount: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    likeCount: <span class="hljs-type">Long</span> = <span class="hljs-number">0</span>L,</span></span><br><span class="hljs-params"><span class="hljs-function">    commentCount: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>    <span class="hljs-comment">//..</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，<code>gender</code>、<code>friendCount</code>、<code>feedCount</code>、<code>likeCount</code>、<code>commentCount</code> 这几个参数都被赋予了默认值。这样做的好处就在于，我们在调用的时候可以省很多事情。比如说，下面这段代码就只需要传 3 个参数，剩余的 4 个参数没有传，但是 <code>Kotlin</code> 编译器会自动帮我们填上默认值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">createUser(<br>    name = <span class="hljs-string">&quot;Tom&quot;</span>,<br>    age = <span class="hljs-number">30</span>,<br>    commentCount = <span class="hljs-number">3285</span><br>)<br></code></pre></td></tr></table></figure><p>对于无默认值的参数，编译器会强制要求我们在调用处传参；对于有默认值的参数，则可传可不传。<code>Kotlin</code> 这样的特性，在一些场景下就可以极大地提升我们的开发效率。而如果是在 <code>Java</code> 当中要实现类似的事情，我们就必须手动定义“3 个参数的 <code>createUser</code> 函数”，或者是使用 <code>Builder</code> 设计模式。</p><h2 id="在构造函数中的使用案例"><a href="#在构造函数中的使用案例" class="headerlink" title="在构造函数中的使用案例"></a>在构造函数中的使用案例</h2><p>通过写出如下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<br>    name: String = <span class="hljs-string">&quot;&quot;</span>, <br>    age: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>, <br>    <span class="hljs-keyword">val</span> studentNo: String = <span class="hljs-string">&quot;&quot;</span>, <br>    <span class="hljs-keyword">val</span> grade: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>) : Person(name, age) &#123;<br>    <span class="hljs-comment">//..</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在给主构造函数的每个参数都设定了默认值之后，我们就可以使用任何传参组合的方式来对 <code>Student</code> 类进行实例化，当然也包含了上文中的两种次构造函数的使用场景。</p><hr><h1 id="函数的可见性修饰符"><a href="#函数的可见性修饰符" class="headerlink" title="函数的可见性修饰符"></a>函数的可见性修饰符</h1><p>熟悉 <code>Java</code> 的人一定知道，<code>Java</code> 中有 <code>public</code>、 <code>private</code>、 <code>protected</code> 和 <code>default</code>(什么都不写）这4种函数可见性修饰符。</p><p><code>Kotlin</code>中也有4种，分别是 <code>public</code>、 <code>private</code>、<code>protected</code> 和 <code>internal</code>，需要使用哪种修饰符时，直接定义在 <code>fun</code> 关键字的前面即可。</p><p>下面将详细介绍一下 <code>Java</code> 和 <code>Kotlin</code> 中这些函数可见性修饰符的异同。</p><ol><li><p><code>private</code> 修饰符在两种语言中的作用是一模一样的，都表示只对当前类内部可见。</p></li><li><p><code>public</code> 修饰符的作用虽然也是一致的，表示对所有类都可见，但是在 <code>Kotlin</code>中 <code>public</code> 修饰符是默认项，而在 <code>Java</code> 中 <code>default</code> 才是默认项。前面我们定义了那么多的函数，都没有加任何的修饰符，所以它们默认都是 <code>public</code> 的。</p></li><li><p><code>protected</code> 关键字在 <code>Java</code> 中表示对当前类、子类和同一包路径下的类可见，在 <code>Kotlin</code> 中则表示只对当前类和子类可见。</p></li><li><p><code>Kotlin</code> 抛弃了 <code>Java</code> 中的 <code>default</code> 可见性（同一包路径下的类可见），引人了一种新的可见性概念，只对同一模块中的类可见，使用的是 <code>internal</code> 修饰符。比如我们开发了一个模块给别人使用，但是有一些函数只允许在模块内部调用，不想暴露给外部，就可以将这些函数声明成 <code>internal</code> 。</p></li></ol><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220708221406391.png" alt="image"></p><p>所以，我们可以通过 <code>private</code> 关键字将类的构造函数定义为私有属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 私有的主构造函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>(<br>    <span class="hljs-keyword">val</span> studentNo: String, <br>    <span class="hljs-keyword">var</span> grade: <span class="hljs-built_in">Int</span><br>) : Person() &#123;<br>    <br>    <span class="hljs-comment">// 私有的次构造函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>(grade: <span class="hljs-built_in">Int</span>) : <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;123&quot;</span>, grade) &#123;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo-theme-butterfly 修改侧边栏分类排序规则</title>
    <link href="/posts/bd6604dc1b1f/"/>
    <url>/posts/bd6604dc1b1f/</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><code>hexo-theme-butterfly</code> 主题中，主页侧边栏中的 <code>categories</code> 默认显示顺序是按 <code>name</code> 排序，导致某些分类下虽然文章数量较少，但却排序靠前。并且默认设置下，主题中侧边 <code>categories</code> 只显示8条（如需修改可以修改<strong>主题配置文件</strong>）。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220608210201564.png" alt="image" style="zoom:67%;" /><p>便想将其修改为 <strong>按照分类内文章的数量进行降序排序</strong> 。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><blockquote><p>  该方法需要修改源代码，建议及时备份需要修改的文件。</p></blockquote><ol><li><p>找到 <code>themes\butterfly\scripts\helpers\aside_categories.js</code> 文件，并修改源代码。</p></li><li><p>修改以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// const orderby = options.orderby || &#x27;name&#x27; // name(default) -&gt; 按 categories 字母顺序</span><br><span class="hljs-keyword">const</span> orderby = options.<span class="hljs-property">orderby</span> || <span class="hljs-string">&#x27;length&#x27;</span>  <span class="hljs-comment">// length -&gt; 按 categories 下文章数量排序</span><br><span class="hljs-comment">// const order = options.order || 1  // 1(default) -&gt; 升序; -1 -&gt; 逆序</span><br><span class="hljs-keyword">const</span> order = options.<span class="hljs-property">order</span> || -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>执行 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code> 查看修改效果。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220608205749969.png" alt="image" style="zoom: 67%;" /></li></ol><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><ul><li><a href="https://www.yanchengxu.top/hexo-categories-sort/">【Hexo-Butterfly】修改侧边栏分类排序规则 | yanchengxu</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo-theme-butterfly</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android面试整理 - JVM</title>
    <link href="/posts/d479c1bb49e9/"/>
    <url>/posts/d479c1bb49e9/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM-的体系结构"><a href="#JVM-的体系结构" class="headerlink" title="JVM 的体系结构"></a><code>JVM</code> 的体系结构</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/102702428">十分钟带你了解JVM的结构体系 - 知乎 (zhihu.com)</a></li></ul></blockquote><p><code>JVM</code>的组成：</p><ul><li>类加载子系统 Class loader</li><li>运行时数据区</li><li>执行引擎</li></ul><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-f3141f2dd349b87c98543fbc9fc00495_720w.jpg" alt="img"></p><hr><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><ul><li>负责加载 <code>class</code>文件(<code>class</code>文件在文件开头有特定的文件标识)，将 <code>class</code>文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构。</li><li><code>ClassLoader</code>只负责加载 <code>class</code>文件的加载，至于它是否可以运行，则由<code>Execution Engine</code>决定。</li></ul><p>在 Java 9 以前，一共有三种类加载器：</p><ul><li>启动类加载器（**<code>BootStrap ClassLoader</code>**）</li><li>扩展类加载器（**<code>Extension ClassLoader</code>**）</li><li>应用类加载器（**<code>Application ClassLoader</code>**）</li></ul><p>在 Java 9 之后，经过更改后变成了两种：</p><ul><li>启动类加载器</li><li>平台类加载器</li></ul><p>启动类加载器是所有类加载器的祖先，由 C++ 编程，没有对应的 Java 对象，因此在 Java 中用 <code>null</code> 来指代。</p><p>除了启动类加载器，其他的加载器都有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。</p><hr><h1 id="双亲委派机制及其优势"><a href="#双亲委派机制及其优势" class="headerlink" title="双亲委派机制及其优势"></a>双亲委派机制及其优势</h1><ul><li><p><strong>全盘负责：</strong> </p><p>当前线程的类加载器负责加载某个<code>Class</code>时，该<code>Class</code>所依赖的和引用的其他<code>Class</code>也将由该类加载器负责载入，除非显示使用<code>CLassLoader.loadClass()</code>指定类加载器来载入。</p></li><li><p><strong>父类委托：</strong> </p><p>先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。所以我们在开发中尽量不要使用与JDK相同的类（例如自定义一个<code>java.lang.System</code>类），因为父类加载器中已经有一份<code>java.lang.System</code>类了，它会直接将该类给程序使用，而你自定义的类压根就不会被加载。</p></li><li><p><strong>双亲委派模型：</strong></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中。</p><p>只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p></li><li><p><strong>双亲委派模型的工作流程：</strong></p><ol><li><p>当<code>AppClassLoader</code>加载一个<code>class</code>时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</p></li><li><p>当<code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrap ClassLoader</code>去完成。</p></li><li><p>如果<code>BootStrap ClassLoader</code>加载失败（例如在<code>$JAVA_HOME/jre/lib</code>里未查找到该<code>class</code>），会使用<code>ExtClassLoader</code>来尝试加载。</p></li><li><p>若<code>ExtClassLoader</code>也加载失败，则会使用<code>AppClassLoader</code>来加载，如果<code>AppClassLoader</code>也加载失败，则会报出异常<code>ClassNotFoundException</code>。</p></li></ol></li><li><p><strong>双亲委派模型的优势：</strong></p><ol><li>系统类防止内存中出现多份同样的字节码</li><li>保证<code>Java</code>程序安全稳定运行</li></ol></li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/408997874.png" alt="img" style="zoom:67%;" /><hr><h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-205a2605346856d95aec826ed9263c03_720w.jpg" alt="img"></p><h2 id="线程私有内存"><a href="#线程私有内存" class="headerlink" title="线程私有内存"></a>线程私有内存</h2><p><strong><font size="5">程序计数器(Program Counter Register)</font></strong></p><p>程序计数器可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。</p><p>字节码解释器工作是就是通过改变程序计数器的值来选取下一条需要执行的字节码指令（执行本地方法的时候，程序计数器的值为 <code>null</code>）。</p><p><strong>每条线程都需要有一个独立的程序计数器</strong>，各条的程序计数器互不影响，独立存储。</p><p>此内存区域是唯一一个没有规定任何 <code>OutOfMemoryError</code> 情况的区域。</p><p><strong><font size="5">Java 虚拟机栈(VM Stack)</font></strong></p><p>Java 虚拟机栈为虚拟机执行 Java 方法服务。</p><p><strong>Java 虚拟机栈的生命周期和线程相同。</strong></p><p>虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会在虚拟机栈中同步创建一个 <strong>栈帧</strong> 用于存储局部变量表、操作数栈、方法出口等信息。</p><p>每一个方法被调用直至执行完毕的过程，就对应这一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">栈帧：<br><span class="hljs-bullet">1.</span> 局部变量表<br><span class="hljs-bullet">2.</span> 操作数栈<br><span class="hljs-bullet">3.</span> 动态链接<br><span class="hljs-bullet">4.</span> 方法出口<br><span class="hljs-bullet">5.</span> ... <br></code></pre></td></tr></table></figure><p><strong><font size="5">本地方法栈(Native Method Stack)</font></strong></p><p>本地方法栈为虚拟机使用本地<code>Native</code>方法服务。</p><h2 id="线程共享内存"><a href="#线程共享内存" class="headerlink" title="线程共享内存"></a>线程共享内存</h2><p><strong><font size="5">Java 堆(Java Heap)</font></strong></p><p>Java 堆是虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p><p><strong>此内存区域的唯一目的就是存放对象实例</strong>，Java 世界里“几乎”所有的对象实例都在这里分配内存。</p><p>Java 堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”。</p><p>Java 堆可以处于物理上不连续的内存空间中，但在逻辑上都连续存放。</p><p>从分配内存的角度看，所有线程共享的 Java 堆中可以划分出多个线程私有的分配缓冲区，以提升对象分配时的效率。无论如何划分，无论是那个区域，存储的都只能是对象的实例。</p><p><strong>Java 堆既可以实现成固定大小的，也可以是扩展的。</strong> 如果在 Java 堆中没有内存完成对象分配时，并且堆也无法再扩展时，Java 虚拟机将会抛出 <code>OutOfMemoryError</code> 异常。</p><p><strong><font size="5">方法区(Method Area)</font></strong></p><p>方法区与 Java 堆一样，是各个线程共享的内存区域，<strong>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</strong></p><p>如果方法区无法满足新的内存分配需求时，将抛出 <code>OutOfMemoryError</code> 异常。</p><p>在 JDK 1.8 之前，<code>HotSpot</code> 虚拟机把它当作永久代进行垃圾回收。</p><p>在 JDK 1.8 以后，移除永久代，并将永久代拆分至堆和元空间。元空间位于本地内存中，而不是虚拟机内存中，存储类的元数据；堆中则额外存放方法区的静态变量和常量池等。</p><p><strong><font size="4">运行时常量池(Runtime Constant Pool)</font></strong></p><p>运行时常量池是方法区的一部分。</p><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>除了 <strong>保存 Class 文件中描述的符号引用</strong> 外，还会把符号引用翻译出来的直接引用也存储再运行时常量池中。</p><p>运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</p><hr><h1 id="类加载机制的几个阶段"><a href="#类加载机制的几个阶段" class="headerlink" title="类加载机制的几个阶段"></a>类加载机制的几个阶段</h1><blockquote><p>  Java 语言的类型可以分为两个大类：基本类型和引用类型。</p><p>  其中的引用类型，Java 又将其细分为了四种：类、接口、数组类以及泛型参数。</p><p>  其中，泛型参数会在编译过程中被擦除，数组类则是由 Java 虚拟机直接在内存中动态构造出来的。所以我们只讨论类和接口的加载过程。</p></blockquote><p><strong>类的加载过程：</strong></p><p><code>JVM</code> 将 <code>javac</code> 编译好的<code>class</code>字节码文件加载到内存中，并对该数据进行验证、解析和初始化、形成<code>JVM</code>可以直接使用的<code>JAVA</code>类，最终回收(卸载)的过程。</p><p><strong>字节码（<code>.class</code>）文件来源：</strong></p><ul><li>从本地系统中直接加载</li><li>通过网络下载<code>.class</code>文件</li><li>从<code>zip</code>, <code>jar</code>等归档文件中加载<code>.class</code>文件</li><li>从专有数据库中提取<code>.class</code>文件</li><li>将<code>Java</code>源文件动态编译为<code>.class</code>文件</li></ul><hr><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/879896-20160414224549770-60006655.png" alt="img" style="zoom:70%;" /><p><strong><font size="5">加载</font></strong></p><p>加载阶段是类加载的第一个部分，在此阶段需要完成三件事情：</p><ol><li>通过类的完全限定名找到该类对应的二进制字节流。</li><li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li><li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li></ol><p>对于非数组类的其他类而言，Java 虚拟机需要通过类加载器来完成查找字节流的过程。</p><p><strong><font size="5">验证</font></strong></p><p>验证阶段是连接阶段的第一步，目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p><strong><font size="5">准备</font></strong></p><p>准备阶段是正式为**类变量(类字段)**（即静态变量，被 <code>static</code> 修饰的变量）分配内存并设置类变量初始值的阶段。</p><p>这些变量所使用的内存都将在方法区中分配，只包括类变量。</p><p>初始值“通常情况”下是数据类型的零值。</p><p>“特殊情况”下，如果类字段的字段属性表中存在 <code>ConstantValue</code> 属性（即被 <code>final</code> 修饰的变量），那么在准备阶段变量的值就会被初始化为 <code>ConstantValue</code> 属性所指定的值。</p><p><strong><font size="5">解析</font></strong></p><p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>这个过程可以在初始化阶段之后进行。</p><p><strong><font size="5">初始化</font></strong></p><p>类加载过程中的最后一步。</p><p>初始化阶段是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。</p><p><code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。</p><p><code>&lt;clinit&gt;()</code> 与类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</p><p>如果一个类没有声明任何的类变量，也没有静态代码块，那么可以没有类<code>&lt;clinit&gt;</code>方法。</p><p><code>JVM</code> 必须确保一个类在初始化的过程中，如果是多线程需要同时初始化它，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程(所以<strong>可以利用静态内部类实现线程安全的单例模式</strong>)。</p><p><strong>简单地说，初始化就是对类变量进行赋值及执行静态代码块。</strong></p><p><strong><font size="5">使用</font></strong></p><p>程序使用 <code>JVM</code> 加载的类。</p><p><strong><font size="5">卸载</font></strong></p><p>触发卸载的五个时机：</p><ul><li>执行了 <code>System.exit()</code> 方法</li><li><code>JVM </code>垃圾回收机制触发回收</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><hr><h1 id="何时触发初始化"><a href="#何时触发初始化" class="headerlink" title="何时触发初始化"></a>何时触发初始化</h1><ol><li><p>遇到 <code>new</code>，<code>getstatic</code>，<code>putstatic</code> 或 <code>invokestatic</code> 这4条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。<br> 生成这4条指令的最常见的Java代码场景是：</p><ol><li>使用new关键字实例化对象的时候</li><li>读取或设置一个类的静态字段的时候</li><li>调用一个类的静态方法的时候</li></ol></li><li><p>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用的时候。</p></li><li><p>当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先出发父类的初始化。</p></li><li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 <code>main()</code> 方法的那个类），虚拟机会先初始化这个主类。</p></li></ol><hr><h1 id="对象实例化时的顺序"><a href="#对象实例化时的顺序" class="headerlink" title="对象实例化时的顺序"></a>对象实例化时的顺序</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/sc179/article/details/109779168">Java实例化对象时的初始化顺序_hellosc01的博客-CSDN博客</a></li></ul></blockquote><blockquote><p>   注：（A，B）表示A和B为同一阶段初始化，执行顺序取决于它们在代码中的顺序。</p></blockquote><p><strong><font size="5">无继承</font></strong></p><p>（静态变量，静态代码块）-&gt; （实例变量，普通代码块） -&gt; 构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">staticField</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;静态变量&quot;</span>;<br><br><span class="hljs-keyword">static</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;静态语句块&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;实例变量&quot;</span>;<br><br>&#123;<br>    System.out.println(<span class="hljs-string">&quot;普通语句块&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">InitialOrderTest</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;构造函数&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><font size="5">有继承</font></strong></p><ol><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ol><hr><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://time.geekbang.org/column/article/13091">11 | 垃圾回收（上） (geekbang.org)</a></li><li><a href="http://www.cyc2018.xyz/Java">Java 虚拟机 | CS-Notes (cyc2018.xyz)</a></li></ul></blockquote><h2 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h2><p><strong><font size="5">引用计数法</font></strong></p><p>它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。</p><p>它的具体实现是这样子的：如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。也就是说，我们<strong>需要截获所有的引用更新操作</strong>，并且相应地增减目标对象的引用计数器。</p><p>除了<strong>需要额外的空间来存储计数器</strong>，以及<strong>繁琐的更新操作</strong>，引用计数法还有一个重大的漏洞，那便是<strong>无法处理循环引用对象</strong>。举个例子，假设对象 a 与 b 相互引用，除此之外没有其他引用指向 a 或者 b。在这种情况下，a 和 b 实际上已经死了，但由于它们的引用计数器皆不为 0，在引用计数法的心中，这两个对象还活着。因此，这些循环引用对象所占据的空间将不可回收，从而造成了内存泄露。</p><p><strong><font size="5">可达性分析</font></strong></p><p>Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后<strong>从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中</strong>，这个过程我们也称之为标记（mark）。最终，<strong>未被探索到的对象便是死亡的，是可以回收的。</strong></p><p><strong><font size="4">GC Roots</font></strong></p><p>可以暂时理解为由堆外指向堆内的引用，一般而言，GC Roots 包括（但不限于）如下几种：</p><ul><li>Java 方法栈桢中的局部变量；</li><li>已加载类的静态变量；</li><li>JNI handles；</li><li>已启动且未停止的 Java 线程。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/83d909d2-3858-4fe1-8ff4-16471db0b180.png" alt="img" style="zoom: 67%;" /><p>可达性分析可以解决引用计数法所不能解决的循环引用问题。</p><p>虽然可达性分析的算法本身很简明，但是在实践中还是有不少其他问题需要解决的。</p><p>比如说，在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成<strong>误报</strong>（将引用设置为 null）或者<strong>漏报</strong>（将引用设置为未被访问过的对象）。</p><p>误报并没有什么伤害，Java 虚拟机至多损失了部分垃圾回收的机会。漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 Java 虚拟机崩溃。</p><p>怎么解决这个问题呢？在 Java 虚拟机里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是 <strong>Stop-the-world</strong>，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了<strong>垃圾回收所谓的暂停时间（GC pause）</strong>。</p><h2 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h2><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p><p>主要是对常量池的回收和对类的卸载。</p><p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p><p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p><ul><li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>Class</code> 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ul><h2 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a><code>finalize</code>方法</h2><p>类似 C++ 的析构函数，<strong>用于关闭外部资源</strong>。但是 try-finally 等方式可以做得更好，并且该方法<strong>运行代价很高，不确定性大</strong>，无法保证各个对象的调用顺序，因此<strong>最好不要使用</strong>。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>判定对象是否可被回收都与引用有关。</p><ol><li><p>强引用</p><p>被强引用关联的对象不会被回收。</p><p>使用 <code>new</code> 一个新对象的方式来创建强引用。</p></li><li><p>软引用</p><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>使用 <code>SoftReference</code> 类来创建软引用。</p></li><li><p>弱引用</p><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>使用 <code>WeakReference</code> 类来创建弱引用。</p></li><li><p>虚引用</p><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p><p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p><p>使用 <code>PhantomReference</code> 来创建虚引用。</p></li></ol><h2 id="垃圾回收的三种方式"><a href="#垃圾回收的三种方式" class="headerlink" title="垃圾回收的三种方式"></a>垃圾回收的三种方式</h2><ol><li><p>标记-清除</p><p>即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。</p><p>缺点：</p><ul><li>会造成内存碎片。由于 Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。</li><li>分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/005b481b-502b-4e3f-985d-d043c2b330aa.png" alt="img" style="zoom: 67%;" /></li><li><p>标记-整理（压缩）</p><p>即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但<strong>代价是压缩算法的性能开销</strong>。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ccd773a5-ad38-4022-895c-7ac318f31437.png" alt="img" style="zoom:67%;" /></li><li><p>标记-复制</p><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p><p><strong>主要不足是只使用了内存的一半。</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png" alt="img" style="zoom:67%;" /><blockquote><p>  现在的商业虚拟机都<strong>采用</strong>这种<strong>复制收集算法回收新生代</strong>，但是并不是划分为大小相等的两块，而是一块较大的 <code>Eden</code> 空间和两块较小的 <code>Survivor</code> 空间，每次使用 <code>Eden</code> 和其中一块 <code>Survivor</code>。在回收时，将 <code>Eden</code> 和 <code>Survivor</code> 中还存活着的对象全部复制到另一块 <code>Survivor</code> 上，最后清理 <code>Eden</code> 和使用过的那一块 <code>Survivor</code>。</p><p>  <code>HotSpot</code> 虚拟机的 <code>Eden</code> 和 <code>Survivor</code> 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 <code>Survivor</code> 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p></blockquote></li><li><p><strong>分代收集</strong></p><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p><p>一般将堆分为新生代和老年代。</p><ul><li>新生代使用：<strong>复制算法</strong></li><li>老年代使用：<strong>标记-清除</strong> 或者 <strong>标记-整理</strong> 算法</li></ul></li></ol><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" alt="img"  /><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。‘</p><p><strong><font size="4">基本概念</font></strong></p><ul><li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li><li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul><p>针对新生代的垃圾回收器共有三个：Serial，Parallel Scavenge 和 Parallel New。这三个采用的都是<strong>标记 - 复制</strong>算法。其中，Serial 是一个单线程的，Parallel New 可以看成 Serial 的多线程版本。Parallel Scavenge 和 Parallel New 类似，但更加注重吞吐率。此外，Parallel Scavenge 不能与 CMS 一起使用。</p><p>针对老年代的垃圾回收器也有三个：刚刚提到的 Serial Old 和 Parallel Old，以及 CMS。Serial Old 和 Parallel Old 都是<strong>标记 - 压缩</strong>算法。同样，前者是单线程的，而后者可以看成前者的多线程版本。</p><p>CMS 采用的是<strong>标记 - 清除</strong>算法，并且是并发的。除了少数几个操作需要 Stop-the-world 之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，Java 虚拟机会使用其他两个压缩型垃圾回收器进行一次垃圾回收。由于 G1 的出现，CMS 在 Java 9 中已被废弃。</p><p>G1（Garbage First）是一个横跨新生代和老年代的垃圾回收器。实际上，它已经打乱了前面所说的堆结构，直接将堆分成极其多个区域。每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。它采用的是<strong>标记 - 压缩</strong>算法，而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃圾回收。</p><p>G1 能够针对每个细分的区域来进行垃圾回收。<strong>在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。</strong> 这也是 G1 名字的由来。</p><hr><h1 id="回收策略和内存分配策略"><a href="#回收策略和内存分配策略" class="headerlink" title="回收策略和内存分配策略"></a>回收策略和内存分配策略</h1><p><strong><font size="4">Minor GC &amp; Full GC</font></strong></p><ul><li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li><li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li></ul><p><strong><font size="4">内存分配策略流程</font></strong></p><ol><li>一个人（对象）出来（new 出来）后会在Eden Space（伊甸园）无忧无虑的生活，直到GC到来打破了他们平静的生活。GC会逐一问清楚每个对象的情况，有没有钱（此对象的引用）啊，因为GC想赚钱呀，有钱的才可以敲诈嘛。然后富人就会进入Survivor Space（幸存者区），穷人的就直接kill掉。</li><li>并不是进入Survivor Space（幸存者区）后就保证人身是安全的，但至少可以活段时间。GC会定期（可以自定义）会对这些人进行敲诈，亿万富翁每次都给钱，GC很满意，就让其进入了Genured Gen(养老区)。万元户经不住几次敲诈就没钱了，GC看没有啥价值啦，就直接kill掉了。</li><li>进入到养老区的人基本就可以保证人身安全啦，但是亿万富豪有的也会挥霍成穷光蛋，只要钱没了，GC还是kill掉。</li></ol><p><strong><font size="4">内存分配策略总结</font></strong></p><ol><li><p>对象优先在 Eden 分配</p><p> 大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p></li><li><p>大对象直接进入老年代</p><p> 大对象是指<strong>需要连续内存空间的对象</strong>，最典型的大对象是那种<strong>很长的字符串以及数组</strong>。</p><p> 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p></li><li><p>长期存活的对象直接进入老年代</p><p> 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p><p> Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15，那么该对象将被晋升（promote）至老年代。</p></li><li><p>动态对象年龄判定</p><p> 另外，如果单个 Survivor 区已经被占用了 50%，那么较高复制次数的对象也会被晋升至老年代。</p></li><li><p>空间分配担保</p><p> 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。否则会继续判断其他条件，选择是否进行Full GC。</p></li></ol><p><strong><font size="4">GC 触发条件</font></strong></p><p>对于 Minor GC，其触发条件非常简单，<strong>当 Eden 空间满时，就将触发一次 Minor GC。</strong> 而 Full GC 则相对复杂，有以下条件：</p><ol><li><p>调用 <code>System.gc()</code></p><p> 只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p></li><li><p>老年代空间不足</p><p> 老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p></li><li><p>空间分配担保失败</p><p> 使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。（可参考上文“内存分配策略总结”第5点。）</p></li><li><p>Concurrent Mode Failure</p><p> 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。（可参考上文“垃圾收集器”部分。）</p></li></ol><hr><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ol><li>JVM中synchronized的实现</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试整理-2022</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM Class Loader</tag>
      
      <tag>JVM Garbage Collection</tag>
      
      <tag>JVM Data Area</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android面试整理 - BroadcastReceiver</title>
    <link href="/posts/90a21a97c0cb/"/>
    <url>/posts/90a21a97c0cb/</url>
    
    <content type="html"><![CDATA[<h1 id="广播的分类和使用场景"><a href="#广播的分类和使用场景" class="headerlink" title="广播的分类和使用场景"></a>广播的分类和使用场景</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.cnblogs.com/Lwenlong/p/15940123.html">Android面试——BroadcastReceiver篇 - 向着内核前进！ - 博客园 (cnblogs.com)</a></li></ul></blockquote><p> <strong><font size="4">分类</font></strong></p><ol><li><p>普通广播：通过Context.sendBroadcast()发送，可并行处理</p></li><li><p>系统广播：系统发送的广播，只需要注册广播接收器，并定义好action等待接收广播</p></li><li><p>有序广播：发出的广播会被接收器按照先后顺序进行接收，发送方式为sendOrderedBroadcast(intent)； 广播接受者接收的顺序规则：按照Priority属性值排序，Priority相同者，动态注册的广播优先；</p></li><li><p>APP应用内广播（Local Broadcast）：由于广播可以跨进程的特性，导致应用可能不断收到来自其他应用的广播，或者别的应用接收到当前应用的私密广播；解决方法为使用应用内广播；也称局部广播，接收者和发送者同属于一个APP，</p></li></ol><p> <strong><font size="4">使用方法</font></strong> </p><ul><li><p>方法1：注册广播时设置exported属性为false；在广播发送接收时，增加权限，用于权限验证；发送广播时执行广播接收器的包名</p></li><li><p>方法2：使用封装好的LocalBroadcastManager,这种方式的广播只能动态注册，不能静态注册</p></li></ul><p> <strong><font size="4">使用场景</font></strong> </p><ul><li><p>同一 App 内部的不同组件之间的消息通信（单个进程）；</p></li><li><p>不同 App 之间的组件之间消息通信；</p></li><li><p>Android系统在特定情况下与App之间的消息通信，如：网络变化、电池电量、屏幕开关等；</p></li></ul><h1 id="广播的两种注册方式的区别"><a href="#广播的两种注册方式的区别" class="headerlink" title="广播的两种注册方式的区别"></a>广播的两种注册方式的区别</h1><ul><li><p>静态注册</p><p>常驻系统，不受组件生命周期影响，即便应用退出，广播还是可以被接收，耗电、占内存。</p></li><li><p>动态注册</p><p>非常驻，跟随组件的生命变化，组件结束，广播结束。在组件结束前，需要先移除广播，否则容易造 成内存泄漏。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>面试整理-2022</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BroadcastReceiver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android面试整理 - View 事件分发</title>
    <link href="/posts/0557737935e1/"/>
    <url>/posts/0557737935e1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/qq_40959750/article/details/119218780">View事件分发相关面试题_打架不行的二哈的博客-CSDN博客_事件分发机制面试题</a></li></ul></blockquote><hr><h1 id="View事件分发机制"><a href="#View事件分发机制" class="headerlink" title="View事件分发机制"></a><code>View</code>事件分发机制</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://luoyu-ying.github.io/posts/38fdb1d1c50f/">View 的事件体系 | 洛语 の Blog (luoyu-ying.github.io)</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/22046c435b7d49f29b7ad04214c4c2fb.png"></p><h1 id="事件是先到-DecorView-还是先到-Window"><a href="#事件是先到-DecorView-还是先到-Window" class="headerlink" title="事件是先到 DecorView 还是先到 Window"></a>事件是先到 <code>DecorView</code> 还是先到 <code>Window</code></h1><p>由上述流程图中可以得知，事件的分发顺序为 </p><p><code>Activity -&gt; Window -&gt; DecorView -&gt; ViewGroup -&gt; View</code></p><h1 id="View的onTouchEvent、OnClickListerner和OnTouchListener的onTouch方法的三者优先级"><a href="#View的onTouchEvent、OnClickListerner和OnTouchListener的onTouch方法的三者优先级" class="headerlink" title="View的onTouchEvent、OnClickListerner和OnTouchListener的onTouch方法的三者优先级"></a><code>View</code>的<code>onTouchEvent</code>、<code>OnClickListerner</code>和<code>OnTouchListener</code>的<code>onTouch</code>方法的三者优先级</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://cloud.tencent.com/developer/article/1333422">Android View的Touch事件分发</a></li></ul></blockquote><p>点击事件的执行顺序为</p><p><code>OnTouchListener.DOWN -&gt; OnTouchEvent.DOWN -&gt; OnTouchListener.MOVE -&gt; OnTouchEvent.MOVE -&gt; OnTouchListener.UP -&gt; OnTouchEvent.UP -&gt; OnClickListener</code></p><p>所以三者的优先级为</p><p><code>OnTouchListener &gt; onTouchEvent &gt; onClick</code></p><h1 id="onTouch-和-onTouchEvent-的区别"><a href="#onTouch-和-onTouchEvent-的区别" class="headerlink" title="onTouch 和 onTouchEvent 的区别"></a><code>onTouch</code> 和 <code>onTouchEvent</code> 的区别</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/huiguixian/article/details/22193977">Android View的onTouchEvent和OnTouch区别_小小攻城师的博客-CSDN博客_ontouch和ontouchevent区别</a></li></ul></blockquote><ol><li><p><code>onTouchListener</code>的<code>onTouch</code>方法优先级比<code>onTouchEvent</code>高，会先触发。</p></li><li><p>假如<code>onTouch</code>方法返回false会接着触发<code>onTouchEvent</code>，反之<code>onTouchEvent</code>方法不会被调用。</p></li><li><p>内置诸如<code>click</code>事件的实现等等都基于<code>onTouchEvent</code>，假如<code>onTouch</code>返回<code>true</code>，这些事件将不会被触发。</p></li></ol><h1 id="Activity-、ViewGroup和View都不消费ACTION-DOWN-那么ACTION-UP事件是怎么传递的"><a href="#Activity-、ViewGroup和View都不消费ACTION-DOWN-那么ACTION-UP事件是怎么传递的" class="headerlink" title="Activity 、ViewGroup和View都不消费ACTION_DOWN,那么ACTION_UP事件是怎么传递的"></a><code>Activity</code> 、<code>ViewGroup</code>和<code>View</code>都不消费<code>ACTION_DOWN</code>,那么<code>ACTION_UP</code>事件是怎么传递的</h1><p>首先，如果大家都不消费 ACTION_DOWN，那么 ACTION_DOWN 的事件传递流程是这样的：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">-&gt; Activity.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.onInterceptTouchEvent<span class="hljs-function"><span class="hljs-params">()</span></span><br><span class="hljs-function">-&gt;</span> view1.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> view1.onTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.onTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> Activity.onTouchEvent();<br></code></pre></td></tr></table></figure><p>接着，由于大家都不消费 <code>ACTION_DOWN</code>，对于 <code>ACTION_MOVE</code> 和 <code>ACTION_UP</code> 的事件传递是这样的：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">-&gt; Activity.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span></span><br><span class="hljs-function">-&gt;</span> Activity.onTouchEvent();<br>-&gt; 消费<br></code></pre></td></tr></table></figure><h1 id="点击事件被拦截，但是想传到下面的View，如何操作"><a href="#点击事件被拦截，但是想传到下面的View，如何操作" class="headerlink" title="点击事件被拦截，但是想传到下面的View，如何操作"></a>点击事件被拦截，但是想传到下面的<code>View</code>，如何操作</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">getParent().requestDisallowInterceptTouchEvent(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>可将点击事件传到下面的<code>View</code>, 剥夺了父<code>View</code> 对除了<code>ACTION_DOWN</code>以外的事件的处理权。</p><h1 id="如何解决View的事件冲突"><a href="#如何解决View的事件冲突" class="headerlink" title="如何解决View的事件冲突"></a>如何解决<code>View</code>的事件冲突</h1><h2 id="三种出现滑动冲突的情况"><a href="#三种出现滑动冲突的情况" class="headerlink" title="三种出现滑动冲突的情况"></a>三种出现滑动冲突的情况</h2><ol><li><code>内部View</code>与<code>外部View</code>的滑动方向相反。</li><li><code>内部View</code>与<code>外部View</code>的滑动方向相同。</li><li>前两种情况的嵌套。</li></ol><p>三种情况的处理思路：</p><ol><li>通过手势滑动的角度判断滑动的方向。</li><li>通过当前处于的不同的页面状态来判断应该滑动的<code>View</code>。</li><li>通过前两种的综合使用。</li></ol><h2 id="滑动冲突的解决方式"><a href="#滑动冲突的解决方式" class="headerlink" title="滑动冲突的解决方式"></a>滑动冲突的解决方式</h2><h3 id="外部拦截法"><a href="#外部拦截法" class="headerlink" title="外部拦截法"></a>外部拦截法</h3><p>通过重写<strong>父容器的</strong><code>onInterceptTouchEvent</code>方法，所有的事件都先经过父容器的筛选，对其中父容器需要的事件进行拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">intercepted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getX();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getY();<br>    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN : &#123;<br>            intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE : &#123;<br>            <span class="hljs-keyword">if</span> (父容器需要当前的点击事件)<br>                intercepted = <span class="hljs-literal">true</span>;<br>           <span class="hljs-keyword">else</span> <br>                intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP : &#123;<br>            intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span> :<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    mLastXIntercept = x;<br>    mLastYIntercept = y;<br>    <span class="hljs-keyword">return</span> intercepted;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内部拦截法"><a href="#内部拦截法" class="headerlink" title="内部拦截法"></a>内部拦截法</h3><p>父元素拦截除<code>ACTION_DOWN</code>以外的其他事件，当事件到达子元素后，由子元素判断是否需要这些事件，不需要的事件将重新交由父容器来处理。这种方法和Android的事件分发机制不一致，需要配合<code>requestDisallowInterceptTouchEvent</code>方法才能正常的工作。</p><p>相关阅读链接：<a href="https://www.jianshu.com/p/fe3d109eb27e">Android TouchEvent之requestDisallowInterceptTouchEvent - 简书 (jianshu.com)</a></p><p><strong>子元素的<code>dispatchTouchEvent</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getX();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getY();<br>    <br>    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN : &#123;<br>            parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 此子View的所有父ViewGroup会跳过onInterceptTouchEvent回调</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE : &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">deltaX</span> <span class="hljs-operator">=</span> x - mLastX;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">deltaY</span> <span class="hljs-operator">=</span> y - mLastY;<br>            <span class="hljs-keyword">if</span> (父容器需要当前的点击事件) &#123;<br>                parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">false</span>);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP : &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span> : <br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    mLastX = x;<br>    mLastY = y;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.dispatchTouchEvent(event);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>父容器的<code>onInterceptTouchEvent</code>方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> event.getAction();<br>    <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="requestDisallowInterceptTouchEvent的调用时机"><a href="#requestDisallowInterceptTouchEvent的调用时机" class="headerlink" title="requestDisallowInterceptTouchEvent的调用时机"></a><code>requestDisallowInterceptTouchEvent</code>的调用时机</h1><p><strong><code>parent.requestDisallowInterceptTouchEvent</code>的调用需要写在<code>onTouchEvent</code>方法中</strong></p><p>我们一个手势的操作，会经历<code>ACTION_DOWN</code>、<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等操作。</p><p>子<code>view</code>调用<code>requestDisallowInterceptTouchEvent(true)</code>的时间，是必须在能拿到点击事件的时候。</p><p>比如我们在<code>ACTION_DOWN</code>的时候调用了方法，接下来的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>都会直接传递到子<code>view</code>上了；如果是在子<code>view</code>的<code>ACTION_MOVE</code>方法中调用的话，那么要确认父<code>view</code>在<code>ACTION_MOVE</code>的过程中，能否将事件传递给子<code>view</code>就好了。</p><h1 id="同时对父-View-和子-View-设置点击方法，优先响应哪个"><a href="#同时对父-View-和子-View-设置点击方法，优先响应哪个" class="headerlink" title="同时对父 View 和子 View 设置点击方法，优先响应哪个"></a>同时对父 <code>View</code> 和子 <code>View</code> 设置点击方法，优先响应哪个</h1><p>优先响应子 view。</p><p>如果先响应父 view，那么子 view 将永远无法响应。父 view 要优先响应事件，必须先调用 onInterceptTouchEvent 对事件进行拦截，那么事件不会再往下传递，直接交给父 view 的 onTouchEvent 处理。</p><p>Android系统中ViewGroup的拦截事件默认不拦截。</p><h1 id="ACTION-CANCEL什么时候触发"><a href="#ACTION-CANCEL什么时候触发" class="headerlink" title="ACTION_CANCEL什么时候触发"></a><code>ACTION_CANCEL</code>什么时候触发</h1><ol><li><p>如果在父<code>View</code>中拦截<code>ACTION_UP</code>或<code>ACTION_MOVE</code>，在第一次父视图拦截消息的瞬间，父视图指定子视图不接受后续消息了，同时子视图会收到<code>ACTION_CANCEL</code>事件。一般是系统自己处理</p></li><li><p>如果触摸某个控件，但是又不是在这个控件的区域上抬起（移动到别的地方了），就会出现<code>ACTION_CANCEL</code>。</p></li></ol><h1 id="为什么子-View-不消费-ACTION-DOWN-之后的所有事件都不会向下传递了"><a href="#为什么子-View-不消费-ACTION-DOWN-之后的所有事件都不会向下传递了" class="headerlink" title="为什么子 View 不消费 ACTION_DOWN,之后的所有事件都不会向下传递了"></a>为什么子 <code>View</code> 不消费 <code>ACTION_DOWN</code>,之后的所有事件都不会向下传递了</h1><p>答案是：<code>mFirstTouchTarget</code>。</p><p>当子 view 对事件进行处理的时，那么 <code>mFirstTouchTarget</code> 就会被赋值，若是子 <code>view</code> 不对事件进行处理，那么 <code>mFirstTouchTarget</code> 就为 <code>null</code>，之后 <code>VIewGroup</code> 就会默认拦截所有的事件。</p><p>我们可以从 <code>dispatchTouchEvent</code> 中找到如下代码，可以看出来，若是子 <code>View</code> 不处理 <code>ACTION_DOWN</code>,那么之后的事件也不会给到它了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 检查是否拦截</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> intercepted;<br><span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 省略和问题无关代码</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 默认拦截</span><br>    intercepted = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="在-ViewGroup-中的-onTouchEvent-中消费-ACTION-DOWN-事件（onInterceptTouch-默认设置），那么-ACTION-MOVE-和-ACTION-UP-事件是怎么传递的？"><a href="#在-ViewGroup-中的-onTouchEvent-中消费-ACTION-DOWN-事件（onInterceptTouch-默认设置），那么-ACTION-MOVE-和-ACTION-UP-事件是怎么传递的？" class="headerlink" title="在 ViewGroup 中的 onTouchEvent 中消费 ACTION_DOWN 事件（onInterceptTouch 默认设置），那么 ACTION_MOVE 和 ACTION_UP 事件是怎么传递的？"></a>在 <code>ViewGroup</code> 中的 <code>onTouchEvent</code> 中消费 <code>ACTION_DOWN</code> 事件（<code>onInterceptTouch</code> 默认设置），那么 <code>ACTION_MOVE</code> 和 <code>ACTION_UP</code> 事件是怎么传递的？</h1><p>首先，我们先分析一下 ACTION_DOWN 的事件走向，由于 ViewGroup 中的 onInterceptTouch 是默认设置的，那么 ACTION_DOWN 的事件最终在 ViewGroup 中的 onTouchEvent 方法中停止了，事件走向是这样的：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">-&gt; Activity.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.onInterceptTouchEvent<span class="hljs-function"><span class="hljs-params">()</span></span><br><span class="hljs-function">-&gt;</span> view1.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> view1.onTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.onTouchEvent() <br></code></pre></td></tr></table></figure><p>接着 ACTION_MOVE 和 ACTION_UP 的事件分发流程，之后 onInterceptTouch 和 View 中的方法都不会被调用了，事件分发如下：</p><p>接着 ACTION_MOVE 和 ACTION_UP 的事件分发流程，之后 onInterceptTouch 和 View 中的方法都不会被调用了，事件分发如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">-&gt; Activity.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.onTouchEvent() <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>面试整理-2022</category>
      
    </categories>
    
    
    <tags>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android面试整理 - View 绘制</title>
    <link href="/posts/76aedbc4e682/"/>
    <url>/posts/76aedbc4e682/</url>
    
    <content type="html"><![CDATA[<h1 id="View-的绘制流程"><a href="#View-的绘制流程" class="headerlink" title="View 的绘制流程"></a>View 的绘制流程</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://luoyu-ying.github.io/posts/19429a22b2b2/">View 的绘制原理 | 洛语 の Blog (luoyu-ying.github.io)</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-3d1255a5093de81fd5bdc27a300d2f0d_720w.jpg"></p><h1 id="MeasureSpec-是什么"><a href="#MeasureSpec-是什么" class="headerlink" title="MeasureSpec 是什么"></a><code>MeasureSpec</code> 是什么</h1><blockquote><p>  <code>spec</code> <strong><code>英[spek]</code></strong><code>n.</code>规格 <code>vt.</code>按特定标准设计并制造</p></blockquote><p><code>MeasureSpec</code>参与了<code>View</code>的<code>measure</code>过程。在测量过程中，系统将<code>View</code>的<code>LayoutParams</code>根据父容器所施加的规则转换成对应的<code>MeasureSpec</code>，然后再根据这个<code>MeasureSpec</code>来测量出<code>View</code>的测量宽&#x2F;高。</p><p><code>MeasureSpec</code>代表一个32位的<code>int</code>值，高两位代表 测量模式<code>SpecMode</code>，低30位代表 该测量模式下的规格大小<code>SpecSize</code>。</p><p><code>MeasureSpec</code>与<code>SpecMode</code>、<code>SpecSize</code>之间可以通过位运算互相求出。</p><p>每个<code>View</code>的<code>measure</code>过程之前都会先计算其<code>MeasureSpec</code>的值，然后再对其进行<code>measure</code>。</p><p><strong>注意</strong>：<code>View</code>的宽和高各有一个<code>MeasureSpec</code>值，分别为<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>。</p><p><strong><code>SpecMode</code>的三种状态</strong></p><ol><li><p><code>UNSPECIFIED</code></p><p>父容器不对<code>View</code>做任何的限制，要多大给多大。<strong>这种情况一般用于系统的内部</strong>，表示一种测量方式的状态。</p></li><li><p><code>EXACTLY</code></p><p>父容器已经测出了<code>View</code>所需要的精确大小，此时的大小就是<code>View</code>的最终大小。</p><p>它对应于<code>LayoutParams</code>的<code>match_parent</code>和具体的数值这两种模式。</p></li><li><p><code>AT_MOST</code></p><p>父容器指定了一个可用的大小，<code>View</code>的大小不能大于这个值。</p><p>它对应于<code>LayoutParams</code>中的<code>wrap_content</code>。</p></li></ol><h1 id="子View创建MeasureSpec创建规则是什么"><a href="#子View创建MeasureSpec创建规则是什么" class="headerlink" title="子View创建MeasureSpec创建规则是什么"></a>子View创建<code>MeasureSpec</code>创建规则是什么</h1><p><strong><code>MeasureSpec</code>和<code>LayoutParams</code>的对应关系</strong></p><p>对于<code>DecorView</code>和普通<code>View</code>来说，<code>MeasureSpec</code>的转化过程略有不同。</p><p><strong>对于<code>DecorView</code>：</strong></p><p><strong><code>DecorView</code>的<code>MeasureSpec</code>由窗口的大小和<code>DecorView</code>自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在<code>ViewRootImpl</code>中的<code>measureHierarchy</code>方法中，调用<code>getRootMeasureSpec</code>方法，获得<code>DecorView</code>的<code>MeasureSpec</code>。</p><p>其中<code>getRootMeasureSpec</code>方法中，根据自身<code>LayoutParams</code>的不同大小，共有三种情况：</p><ol><li><code>LayoutParams.MATCH_PARENT</code>：精确模式，大小就是窗口的大小。</li><li><code>LayoutParams.WRAP_CONTENT</code>：最大模式，大小不定，但是不能超过窗口的大小。</li><li>固定大小(比如100dp)：精确模式，大小为<code>LayoutParams</code>中指定的大小。</li></ol><p><strong>对于普通<code>View</code>：</strong></p><p><strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在父容器的<code>measureChildWithMargins</code>中的<code>getChildMeasureSpec</code>方法获得<code>View</code>的<code>MeasureSpec</code>。</p><p>其中<code>getChildMeasureSpec</code>方法的参数中使用到了父容器的<code>MeasureSpec</code>。在这个方法中通过<code>switch</code>和<code>if</code>语句，对<code>View</code>的<code>MeasureSpec</code>进行了决定。结果如下：</p><table><thead><tr><th>↓<code>childLayoutParams</code> \ <code>parentMeasureSpec</code>→</th><th><code>EXACTLY</code></th><th><code>AT_MOST</code></th><th><code>UNSPECIFIED</code></th></tr></thead><tbody><tr><td><code>dp</code>&#x2F;<code>px</code></td><td><code>EXACTLY</code><br>childSize</td><td><code>EXACTLY</code><br/>childSize</td><td><code>EXACTLY</code><br/>childSize</td></tr><tr><td><code>match_parent</code></td><td><code>EXACTLY</code><br/>parentSize</td><td><code>AT_MOST</code><br>parentSize</td><td><code>UNSPECIFIED</code><br>0</td></tr><tr><td><code>wrap_content</code></td><td><code>AT_MOST</code><br>parentSize</td><td><code>AT_MOST</code><br/>parentSize</td><td><code>UNSPECIFIED</code><br/>0</td></tr></tbody></table><p>上图可以简单记为：除了<code>dp</code>&#x2F;<code>px</code>的精确模式情况外，三种<code>MeasureSpec</code>的级别为：<code>EXACTLY</code> &lt; <code>AT_MOST</code> &lt; <code>UNSPECIFIED</code> 且<code>childMeasureSpec</code> &#x3D; max(<code>childLayoutParams</code> , <code>parentMeasureSpec</code>)。（<strong>实际上并无级别之分</strong>）</p><p>通过上面的表格，可以更加直观的看出：<strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><h1 id="自定义View-wrap-content不起作用的原因"><a href="#自定义View-wrap-content不起作用的原因" class="headerlink" title="自定义View wrap_content不起作用的原因"></a>自定义View <code>wrap_content</code>不起作用的原因</h1><p>对于直接继承<code>View</code>的自定义<code>View</code>来说，<strong>需要重写<code>onMeasure</code>方法并设置在<code>wrap_content</code>情况时的自身大小</strong>，否则在布局中使用<code>wrap_content</code>就相当于使用<code>match_parent</code>。</p><p>因为当自定义<code>View</code>处于<code>wrap_content</code>时，它的<code>SpecMode</code>为<code>AT_MOST</code>模式，由前文可知，当父容器无论为<code>AT_MOST</code>还是<code>ECACTLY</code>模式时，自定义<code>View</code>都为<code>AT_MOST</code>模式且尺寸大小为<code>parentSize</code>，也就是父容器的剩余空间，即自定义<code>View</code>的大小变得与父容器的剩余空间大小一致，显然不是我们需要的。</p><p><strong>解决方法：</strong></p><p>解决方法也是非常简单的。我们只需要在<code>onMeasure</code>方法中对</p><ol><li>仅<code>width</code>方向为<code>AT_MOST</code>模式</li><li>仅<code>height</code>方向为<code>AT_MOST</code>模式</li><li><code>width</code>方向以及<code>height</code>方向都为<code>AT_MOST</code>模式</li><li>其他的情况</li></ol><p>这四个状态单独判断，分别使用<code>setMeasuredDimension</code>方法直接为自定义<code>View</code>设置我们需要的值即可。</p><p>源码中对于<code>TextView</code>、<code>ImageView</code>等控件的<code>wrap_content</code>也做了特殊的处理。</p><h1 id="在Activity中获取某个View的宽高有几种方法"><a href="#在Activity中获取某个View的宽高有几种方法" class="headerlink" title="在Activity中获取某个View的宽高有几种方法"></a>在Activity中获取某个View的宽高有几种方法</h1><p>由于<code>Activity</code>的启动和<code>View</code>的测量过程并不是同步进行的，因此无法保证在<code>Activity</code>启动时某个<code>View</code>已经测量完毕了。所以我们在<code>Activity</code>启动的时候，如果直接通过<code>getMeasuredWidth</code>&#x2F;<code>getMeasuredHeight</code>方法获得的值可能为0。</p><p>以下有四种方法可以解决这个问题（详细代码见《Android开发艺术探索》190页）。</p><ol><li><p><code>Activity/View#onWindowFocusChanged</code></p><p>在<code>Activity</code>的<code>onResume</code>和<code>onPause</code>方法启动时，<code>onWindowFocusChanged</code>方法也会同时被调用，可以重写里面的内容，使之计算<code>View</code>的宽高。</p><p><strong>注意</strong>：<code>onWindowFocusChanged</code>方法会在<code>View</code>已经初始化完毕后才开始调用。</p></li><li><p><code>view.post(runnable)</code></p><p>通过<code>post</code>可以将一个<code>runnable</code>投递都消息队列的尾部，然后等待<code>Looper</code>调用此<code>runnable</code>的时候，<code>View</code>也已经初始化好了。</p></li><li><p><code>ViewTreeObserver</code></p><p><code>ViewTreeObserver</code>中的众多回调可以完成这个功能。</p><p>比如<code>OnGlobalLayoutListener</code>接口，当<code>View</code>树的状态发生改变或者<code>View</code>树内部的<code>View</code>的可见性发生改变的时候，<code>onGlobalLayout</code>方法将被回调，此时就可以获取<code>View</code>的宽高了。</p></li><li><p><code>view.measure(int widthMeasureSpec, int heightMeasureSpec)</code></p><p>可以主动调用该方法开始计算<code>view</code>的宽高。</p><ol><li><p><strong><code>match_parent</code></strong></p><p>由于正常的<code>measure</code>过程中，我们需要父容器的<code>MeasureSpec</code>的值，而此时父容器并没开始计算，我们无从得知这两个值的大小。故我们无法对<code>match_parent</code>的<code>view</code>计算其宽高。</p></li><li><p><strong><code>dp</code>&#x2F;<code>px</code></strong></p><p>因为有精确的数值了，所以我们可以直接使用这个精确的数值通过<code>MeasureSpec.makeMeasureSpec</code>方法构建<code>view</code>的<code>MeasureSpec</code>。</p></li><li><p><strong><code>wrap_content</code></strong></p><p>直接将<code>MeasureSpec.makeMeasureSpec</code>方法中参数的值设置为<code>(1&lt;&lt;30)-1</code>即可，这是<code>View</code>理论上可以支持的最大值，所以这样构建<code>MeasureSpec</code>是合理的。</p></li></ol></li></ol><h1 id="onCreate、onResume中可以获取View的宽高吗？怎么做？View-post-为什么可以获取？"><a href="#onCreate、onResume中可以获取View的宽高吗？怎么做？View-post-为什么可以获取？" class="headerlink" title="onCreate、onResume中可以获取View的宽高吗？怎么做？View#post 为什么可以获取？"></a><code>onCreate</code>、<code>onResume</code>中可以获取View的宽高吗？怎么做？<br><code>View#post</code> 为什么可以获取？</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/qq_40714317/article/details/117666277">onCreate()、onResume() 中可以获取View的宽高吗？怎么做？ View.post{} 为什么可以获取？_qq_40714317的博客</a></li><li><a href="https://github.com/Moosphan/Android-Daily-Interview/issues/126">2019-08-21：View.post()为什么可以获取到宽高信息？ · Issue #126 · Moosphan&#x2F;Android-Daily-Interview </a></li></ul></blockquote><p><strong><code>onCreate</code>、<code>onResume</code>中可以获取View的宽高吗？怎么做？</strong></p><p>View 的测绘绘制流程就是从 ViewRootImpl#performTraversals() 开始的，而这个方法的调用是在 onResume() 方法之后，所以在 onCreate() 和 onResume() 方法中拿不到 View 的测量值。</p><p> View的宽高是在onLayout阶段才能最终确定的，而在Activity#onCreate中并不能保证View已经执行到了onLayout方法，也就是说Activity的声明周期与View的绘制流程并不是一一绑定。所以onCreate() 和 onResume() 中获取不到View的宽高值。以Handler为基础，View.post() 将传入任务的执行时机调整到View 绘制完成之后。</p><p><strong><code>View#post</code> 为什么可以获取？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">view.post(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> view.getWidth();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> view.getHeight();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这样写一般是在 Activity 的 onResume 方法中，因为 onResume 执行在 View 初始化之前，如果在 onResume 中直接获取 View 宽高是获取不到的。</p><p>使用 view.post 就能获取到，因为 view.post 是向 主 Handler 的 MessageQueue 中插入一条待执行消息，但是因为系统在 ViewRoot 中初始化 View 时也是利用 Handler 机制，平且为了优先执行 View 的初始化设置了同步屏障，导致 view.post 插入的消息会在 View 初始化之后执行，那么肯定就能获取到 View 的宽高啦！</p><p><strong><code>Runnable</code>的执行时机具体是什么</strong></p><p> 在 <strong>Android 7.0</strong> 之后，view.post()中的runnbale 能确定被执执行。具体来说：</p><p>Android 7.0之后，除了<code>performTraversal</code>中会调用外，在View的<code>dispatchAttachedToWindow</code>中也会调用，但Android 7.0之后不管在主线程还是在子线程都可以成功执行<code>view.post</code>内部逻辑，并不是因为增加了调用时机，而是取消了<code>ThreadLocal</code>机制，使得 <strong>不管在主线程还是子线程调用view.post方法，都会将runnable对象丢到主线程的任务队列中，更新UI或者获取view的信息</strong>。</p><h1 id="View-post与Handler-post的区别"><a href="#View-post与Handler-post的区别" class="headerlink" title="View#post与Handler#post的区别"></a><code>View#post</code>与<code>Handler#post</code>的区别</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/7280b2d3b4d1">Handler.post和View.post的区别 - 简书 (jianshu.com)</a></li></ul></blockquote><ol><li><p><code>Handler.post</code>，它的执行时间基本是等同于<code>onCreate</code>里那行代码触达的时间；</p></li><li><p>View.post，则不同，它说白了执行时间一定是在<code>Activity#onResume</code>发生后才开始算的；或者换句话说它的效果相当于你上面的<code>View.post</code>方法是写在<code>Activity#onResume</code>里面的（但只执行一次，因为<code>onCreate</code>不像onResume会被多次触发）；</p></li><li><p>当然，虽然这里说的是<code>post</code>方法，但对应的<code>postDelayed</code>方法区别也是类似的。</p></li></ol><h1 id="getWidth-方法和getMeasureWidth-方法的区别"><a href="#getWidth-方法和getMeasureWidth-方法的区别" class="headerlink" title="getWidth()方法和getMeasureWidth()方法的区别"></a><code>getWidth()</code>方法和<code>getMeasureWidth()</code>方法的区别</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/7d8a54dd692f">getMeasureWidth和getWidth的区别 - 简书 (jianshu.com)</a></li><li><a href="https://www.cnblogs.com/yongdaimi/p/13612622.html">android: View的getWidth() 和 getMeasureWidth()方法的区别 - 夜行过客 - 博客园 (cnblogs.com)</a></li></ul></blockquote><ol><li><p><code>getMeasureWidth()</code>方法在<code>measure()</code>过程结束后就可以获取到了，而<code>getWidth()</code>方法要在<code>layout()</code>过程结束后才能获取到。<code>getMeasuredWidth()</code>获取的是<code>View</code>原始的大小，也就是这个<code>View</code>在<code>XML</code>文件中配置或者是代码中设置的大小。<code>getWidth()</code>获取的是这个<code>View</code>最终显示的大小，这个大小有可能等于原始的大小，也有可能不相等。只要在代码里重新修改了子控件的摆放位置，<code>getWidth()</code>和<code>getMeasureWidth()</code>的值就会不同。</p></li><li><p><code>getMeasureWidth()</code>方法中的值是通过<code>setMeasuredDimension()</code>方法来进行设置的，而<code>getWidth()</code>方法中的值则是通过视图右边的坐标减去左边的坐标计算出来的。</p></li></ol><h1 id="View加载流程（setContentView）"><a href="#View加载流程（setContentView）" class="headerlink" title="View加载流程（setContentView）"></a>View加载流程（setContentView）</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/pgg_cold/article/details/79481301"> Android面试题（28）-android的view加载和绘制流程_胖哥哥飘过的博客-CSDN博客_android view加载流程</a></li></ul></blockquote><ol><li><p>通过Activity的setContentView方法间接调用PhoneWindow的setContentView()，在PhoneWindow中通过getLayoutInflate()得到LayoutInflate对象。</p></li><li><p>通过LayoutInflate对象去加载View，主要步骤是：</p><ol><li>通过xml的Pull方式去解析xml布局文件，获取xml信息，并保存缓存信息，因为这些数据是静态不变的。</li><li>根据xml的tag标签通过反射创建View逐层构建View。</li><li>递归构建其中的子View，并将子View添加到父ViewGroup中。</li></ol></li></ol><p>其中，有四种加载XML文件的常用方法：</p><ol><li><p>使用view的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> View.inflate(context, R.layout.child, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure></li><li><p>通过系统获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LayoutInflater</span> <span class="hljs-variable">inflater</span> <span class="hljs-operator">=</span> (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);<br><span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> inflater.inflate(R.layout.child, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure></li><li><p>通过LayoutInflater</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LayoutInflater</span> <span class="hljs-variable">inflater</span> <span class="hljs-operator">=</span> LayoutInflater.from(context);<br><span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> inflater.inflate(R.layout.child, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure></li><li><p>通过getLayoutInflater</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> getLayoutInflater().inflate(R.layout.child, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure></li></ol><p>View 加载过程结束后，便会开始 View 的绘制流程了。</p><h1 id="invalidate-和-postInvalidate-的区别"><a href="#invalidate-和-postInvalidate-的区别" class="headerlink" title="invalidate() 和 postInvalidate() 的区别"></a><code>invalidate()</code> 和 <code>postInvalidate()</code> 的区别</h1><p>这两个方法都是在<strong>重绘当前控件</strong>的时候调用的。</p><p><strong>invalidate在UI线程中调用，postInvalidate在非UI线程中调用。</strong> 因为android的UI线程是非线程安全的，所以在非UI线程中，需要使用postInvalidate来使View重绘。</p><p>view调用invalidate将导致当前view的重绘（draw调用），view的父类将不会执行draw方法；viewGroup调用invalidate会使viewGroup的子view调用draw，也就是viewGroup内部的子view进行重绘。</p><h1 id="requestLayout-和-onLayout-的区别"><a href="#requestLayout-和-onLayout-的区别" class="headerlink" title="requestLayout() 和 onLayout() 的区别"></a><code>requestLayout()</code> 和 <code>onLayout()</code> 的区别</h1><p><strong>requestLayout()</strong></p><p><code>requestLayout</code>方法只会**导致当前<code>view</code>的<code>measure</code>和<code>layout</code>**，而<code>draw</code>不一定被执行，只有当<code>view</code>的位置发生改变才会执行<code>draw</code>方法，因此如果要使当前<code>view</code>重绘需要调用<code>invalidate</code>。</p><p><strong>onLayout()</strong></p><p>在很多情况下requestLayout是不需要被调用的。</p><p>例如，我们把一个AbsoluteLayout里面的childView挪动一下位置。我们仅仅需要调用的可能就是重新布局当前AbsoluteLayout，然后调用invalidate方法进行重绘。而不是从当前View向上的整个View树形结构都要重新layout，onLayout，measure，onMeasure一次。在这种情况下可以直接调用onLayout。然后调用invalidate进行重绘。很明显可以提升绘制效率。</p><p>由于父View的layout实现了会通知布局的listener。但是由于无法得到listener，因此调用onlayout的时候无法对其进行通知，这也是这种实现的缺陷。</p><h1 id="自定义-View-的流程和注意事项"><a href="#自定义-View-的流程和注意事项" class="headerlink" title="自定义 View 的流程和注意事项"></a>自定义 View 的流程和注意事项</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/b0f0d5462d16">自定义View学习–定义View流程和注意事项 - 简书 (jianshu.com)</a></li><li><a href="https://blog.csdn.net/lmj623565791/article/details/38339817"> Android 手把手教您自定义ViewGroup（一）_鸿洋_的博客-CSDN博客_自定义viewgroup</a></li></ul></blockquote><hr><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ol><li>invalidate怎么局部刷新</li><li>Android绘制和屏幕刷新机制原理&#96;</li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>面试整理-2022</category>
      
    </categories>
    
    
    <tags>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串哈希 模板</title>
    <link href="/posts/bb54934ff9ed/"/>
    <url>/posts/bb54934ff9ed/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="http://www.yhzq-blog.cc/%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E6%80%BB%E7%BB%93/">字符串Hash总结 | 远航休息栈</a></li></ul></blockquote><hr><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> StringHash &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">50</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> BASE = <span class="hljs-number">131</span>;<br>    <span class="hljs-type">char</span> s[MAXN]; <span class="hljs-comment">// cin &gt;&gt; (s + 1);</span><br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> hash[MAXN], power[MAXN];<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">preHash</span><span class="hljs-params">()</span> </span>&#123;<br>        power[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) <br>            power[i] = power[i - <span class="hljs-number">1</span>] * BASE;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">calcHash</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<br>            hash[i] = hash[i - <span class="hljs-number">1</span>] * BASE + s[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">getHash</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)hash[r] - hash[l - <span class="hljs-number">1</span>] * power[r - l + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">input</span><span class="hljs-params">()</span> </span>&#123;<br>        cin &gt;&gt; (s + <span class="hljs-number">1</span>);<br>        len = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    StringHash::<span class="hljs-built_in">input</span>();<br>    StringHash::<span class="hljs-built_in">preHash</span>();<br>    StringHash::<span class="hljs-built_in">calcHash</span>();<br>    cout &lt;&lt; StringHash::<span class="hljs-built_in">getHash</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="字符串哈希实现其他算法"><a href="#字符串哈希实现其他算法" class="headerlink" title="字符串哈希实现其他算法"></a>字符串哈希实现其他算法</h1><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><blockquote><p>给两个字符串 S1、S2，求 S2 是否是 S1 的字串，并求出 S2 在 S1 中出现的次数。</p></blockquote><p>将 S2 哈希后，在 S1 中查询所有长度为 $|S2|$ 的字串，并进行哈希比较。</p><blockquote><p>复杂度：$O(|S1|)$。</p></blockquote><h2 id="AC-自动机"><a href="#AC-自动机" class="headerlink" title="AC 自动机"></a>AC 自动机</h2><blockquote><p>给出 N 个单词串，和一个文章串，求每个单词串是否是文章串的子串，并求每个单词在文章中出现的次数。</p></blockquote><p>先把每一个单词串哈希，再把文章的每一个子串也进行整数，接下来只需要进行整数上的查找即可。</p><blockquote><p>复杂度：$O(|A|^2+|S|)$。$|S|$ 是单词串总长，$|A|$ 是文章串长度。</p></blockquote><h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><blockquote><p>给出两个字符串 S1、S2，求它们的最长公共子串的长度。</p></blockquote><p>将 S1 的每一个子串都哈希成一个整数，再对 S2 的每一个字串进行哈希，并判断是否与 S1 的某一个字串相同，不断维护相同的字串的长度最大值即可。</p><blockquote><p>复杂度：$O(|S1|^2+|S2|^2)$。</p></blockquote><h2 id="马拉车"><a href="#马拉车" class="headerlink" title="马拉车"></a>马拉车</h2><blockquote><p>给一个字符串 S，求 S 的最长回文子串。</p></blockquote><p>将 S 从前后两个方向分别进行字符串哈希。<br>对子串长度为奇数和偶数的情况分别进行求解。<br>枚举回文子串的中心位置，然后二分子串的长度，直到找到一个该位置的最长回文子串，不断维护长度最大值即可。</p><blockquote><p>复杂度：$O(|S|log|S|)$。</p></blockquote><h2 id="扩展-KMP"><a href="#扩展-KMP" class="headerlink" title="扩展 KMP"></a>扩展 KMP</h2><blockquote><p>给一个字符串 S，求 S 的每个后缀与S的最长公共前缀。</p></blockquote><p>枚举每一个后缀的起始位置，二分长度，求出每个后缀与S的最长公共前缀。</p><blockquote><p>复杂度：$O(|S|log|S|)$。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>View 的事件体系</title>
    <link href="/posts/38fdb1d1c50f/"/>
    <url>/posts/38fdb1d1c50f/</url>
    
    <content type="html"><![CDATA[<h1 id="View基础知识"><a href="#View基础知识" class="headerlink" title="View基础知识"></a>View基础知识</h1><h2 id="一、View的相关坐标和位置"><a href="#一、View的相关坐标和位置" class="headerlink" title="一、View的相关坐标和位置"></a>一、<code>View</code>的相关坐标和位置</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20180802114150486.jpg" style="zoom:80%;" /><p><strong>先来了解一个概念：</strong></p><p><code>view动画</code>不改变<code>view</code>的真实位置，就是肉眼看上去，<code>view</code>位置发生了变化，但是它的点击区域还是在原来的位置。</p><p>为了方便描述，下文中的的 <code>真实View</code>，表示真实位置的<code>View</code>，<code>看到的View</code>，表示肉眼看到的<code>View</code>。</p><p>属性动画和 <code>setTranslationX</code> &#x2F; <code>setTranslationY</code> ，会改变显示位置和真实位置。</p><p>上图中<code>view1</code>是初始位置，通过执行<code>setTranslation</code>函数，得到的<code>view2</code>位置，其中<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>这几个值不会改变。</p><h3 id="left，top，right，bottom"><a href="#left，top，right，bottom" class="headerlink" title="left，top，right，bottom"></a><code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code></h3><p><code>View</code>的位置主要由它的四个顶点的位置来决定，分别对应 View 的四个属性：<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>。对应的函数是<code>getLeft</code>，<code>getTop</code>，<code>getRight</code>，<code>getBottom</code>。</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>left</code></td><td><code>View</code> 左上顶点相对于父容器的横坐标</td></tr><tr><td><code>top</code></td><td><code>View</code> 左上顶点相对于父容器的纵坐标</td></tr><tr><td><code>right</code></td><td><code>View</code> 右下顶点相对于父容器的横坐标</td></tr><tr><td><code>bottom</code></td><td><code>View</code> 右下顶点相对于父容器的纵坐标</td></tr></tbody></table><p>这几个值表示的是View的真身位置，它表示哪里，点击区域就在哪里。和肉眼在屏幕上看到的位置可能不一样。</p><h3 id="X，Y"><a href="#X，Y" class="headerlink" title="X，Y"></a><code>X</code>，<code>Y</code></h3><p>上面说到view动画不改变<code>view</code>的真实位置（也就是不改变<code>view</code>的<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>）。</p><p>看到的view相对于真实<code>view</code>，位置发生了变化，但是它的点击区域还是在真实view的位置。</p><p>从 Android 3.0 开始，<code>View</code> 增加了 x，y，<code>translationX</code> 和 <code>translationY</code>。</p><p>x，y 是看到的<code>view</code>的左上角相对父容器的坐标，但不同于 left 和 top ，这两个坐标点的值并一定都是相等的。</p><p>真实<code>view</code> 和 看到<code>view</code>的偏差用 <code>translationX</code> 和 <code>translationY</code> <code>来表示</code>。</p><h3 id="translationX，translationY"><a href="#translationX，translationY" class="headerlink" title="translationX，translationY"></a><code>translationX</code>，<code>translationY</code></h3><p><strong>android开发艺术探索中，关于<code>translationX</code>的讲解是错误的。</strong>真实情况是，<code>translationX</code>是<code>真实view</code> 相对于<code>看到view</code>的 x 方向偏移量。</p><p>从上图可以得知：<code>x</code> &#x3D; <code>left</code> + <code>translationX</code>。</p><h2 id="二、点击事件的XY坐标"><a href="#二、点击事件的XY坐标" class="headerlink" title="二、点击事件的XY坐标"></a>二、点击事件的<code>XY</code>坐标</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20180802143219331.jpg" style="zoom:50%;" /><h2 id="三、MotionEvent"><a href="#三、MotionEvent" class="headerlink" title="三、MotionEvent"></a>三、<code>MotionEvent</code></h2><p>常见的触摸动作一共有三个：</p><ol><li><code>ACTION_DOWN</code>手指按下动作</li><li><code>ACTION_MOVE</code>手指滑动动作</li><li><code>ACTION_UP</code>    手指抬起动作</li></ol><h2 id="四、GestureDetector"><a href="#四、GestureDetector" class="headerlink" title="四、GestureDetector"></a>四、<code>GestureDetector</code></h2><p>手势检测，检测用户的单击、双击、长按等操作。</p><p>通过创建<code>GestureDetector</code>对象并实现<code>OnGestureListener</code>接口（检测单击相关手势）或者<code>OnDoubleTapListener</code>接口（检测双击相关动作）。</p><h2 id="五、TouchSlop"><a href="#五、TouchSlop" class="headerlink" title="五、TouchSlop"></a>五、<code>TouchSlop</code></h2><p>不同安卓设备认为的最小的滑动距离，低于此距离，将不认为用户在滑动，开发者可自行更改，默认为<code>8dp</code>。</p><h2 id="六、VelocityTracker"><a href="#六、VelocityTracker" class="headerlink" title="六、VelocityTracker"></a>六、<code>VelocityTracker</code></h2><p>速度检测，可以计算出用户的手势的滑动速度。</p><p>注意，在<code>VelocityTracker#computeCurrentVelocity(int time)</code>中的<code>time</code>参数是我们计算速度的单位时间，相同的速度用不同的单位时间会有不同的表示方法。</p><h2 id="七、Scroller"><a href="#七、Scroller" class="headerlink" title="七、Scroller"></a>七、<code>Scroller</code></h2><p>弹性滑动对象，由于View中的<code>scrollTo/scrollBy</code>都是瞬间完成位移的。对用户的使用体验不太友好，所以引入弹性滑动对象，使得<code>View</code>的滑动变得可视化。</p><h1 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h1><h2 id="一、scrollTo-x2F-scrollBy"><a href="#一、scrollTo-x2F-scrollBy" class="headerlink" title="一、scrollTo&#x2F;scrollBy"></a>一、<code>scrollTo</code>&#x2F;<code>scrollBy</code></h2><p>View有专门的方法实现滑动，即<code>scrollTo()</code>, <code>scrollBy()</code>;</p><p>这两个函数只能将<code>View</code>中间的内容进行位移，但是不能改变<code>View</code>本身的位置。</p><p>可以方便的实现滑动效果并且不影响内部元素的点击事件。</p><p><code>scrollTo(int destX, int destY)</code>直接让View出现在目标位置，无中间动画。</p><p>参数变量的单位都是像素级。</p><h2 id="二、使用动画"><a href="#二、使用动画" class="headerlink" title="二、使用动画"></a>二、使用动画</h2><p>有两种动画的使用方法。</p><ol><li><p><code>View</code>动画</p><p>在<code>XML</code>文件里面通过改变<code>translationX</code>&#x2F;<code>translationY</code>的方式来实现View的移动效果。</p></li><li><p>属性动画</p><p>在<code>Android3.0</code>版本以上，可以使用<code>ObjectAnimator</code>类来实现属性动画的效果。</p><p>在<code>Android3.0</code>以下的版本中，我们需要自己加载开源动画库<code>NineOldAndroids</code>。</p></li></ol><p>在<code>XML</code>文件中，有一个<code>andoird:fillAfter=&quot;true|false&quot;</code>的选项。</p><p>当为<code>true</code>的时候，View在动画结束后，图像将停留在目标位置上。</p><p>当为<code>false</code>的时候，View会在动画结束后，从末位置消失，重新在初位置出现。</p><p>不论是<code>true</code>还是<code>false</code>，View的点击事件的坐标还是在原先的初始位置上，并不会随着<code>View</code>的移动而移动。</p><p>在<code>Android3.0</code>以上使用属性动画可以解决这样的问题。</p><h2 id="三、改变布局参数"><a href="#三、改变布局参数" class="headerlink" title="三、改变布局参数"></a>三、改变布局参数</h2><p>通过修改<code>View</code>的<code>marginLeft</code>等等布局参数，以此来达到<code>View</code>滑动的效果。</p><h1 id="弹性滑动"><a href="#弹性滑动" class="headerlink" title="弹性滑动"></a>弹性滑动</h1><h2 id="一、Scroller"><a href="#一、Scroller" class="headerlink" title="一、Scroller"></a>一、<code>Scroller</code></h2><p><code>Scroller#smoothScrollTo(int destX, int destY)</code>将<strong>目标位置与初始位置的偏移值delta</strong>计算后调用<code>startScroller()</code>方法存储相关参数，并开始使用<code>invalidate()</code>方法重绘<code>View</code>。重绘<code>View</code>时的<code>draw()</code>方法会调用<code>computeScroll()</code>方法，其中又会调用<code>invalidate</code>方法重绘<code>View</code>，不断的循环。由于<code>scrollTo(int destX, int destY)</code>直接让View出现在目标位置，所以我们在<code>computeScroll()</code>方法中采取微分法的做法，即将一段长距离拆分成许多微小的距离。不断通过<code>scrollTo()</code>的直接滑动以及<code>computeScrollOffset()</code>的重新计算下一个短距离的相关参数以及<code>postInvalidate()</code>的重绘View，最终达到弹性滑动的效果。</p><p><code>computeScrollOffset()</code>方法通过计算目前已经位移的百分比来计算下一次的位移目标以及是否已经完成的滑动，不通过计时器等工具。</p><pre><code class=" mermaid">flowchart TDA[startScroll]B[invalidate]C[computeScroll]D[computeScrollOffset : boolean]E[invalidate]A --&gt; B --&gt;|draw| C --&gt; D --&gt;|not finish| E --&gt;|draw| CD --&gt;|finish| F[finish]</code></pre><h2 id="二、通过动画"><a href="#二、通过动画" class="headerlink" title="二、通过动画"></a>二、通过动画</h2><p>通过<code>ObjectAnimator类</code>我们可以直接的通过动画完成<code>View</code>的弹性滑动。</p><p>我们也可以通过<code>onAnimatorUpdate</code>方法还自定义自己想要的动画效果。</p><h2 id="三、使用延时策略"><a href="#三、使用延时策略" class="headerlink" title="三、使用延时策略"></a>三、使用延时策略</h2><p>可以通过<code>Thread#sleep</code>或者<code>Handler#postDelayed</code>方法来达到间隔一定的时间就改变一次微小位置变化的操作。</p><p>在此次的<code>scrollTo</code>方法执行结束后，通过<code>sleep|postDelayed</code>方法暂停一定的时间，然后重复执行<code>scrollTo</code>的方法，以此来达到弹性滑动的效果。</p><p><strong>注意：</strong>无法在精准的时间内移动固定的位移，因为系统的消息调度（<code>sleep|postDelayed</code>）也是需要时间的。</p><h1 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a><code>View</code>的事件分发机制</h1><h2 id="一、点击事件的传递规则"><a href="#一、点击事件的传递规则" class="headerlink" title="一、点击事件的传递规则"></a>一、点击事件的传递规则</h2><p>点击事件分发过程，即将一系列的<code>MotionEvent</code>事件序列（由<code>ACTION_DOWN</code>开始到<code>ACTION_UP</code>结束的一连串操作）交给一个<code>View</code>执行的过程。</p><p>点击事件的分发主要由三个重要方法构成：<code>dispatchTouchEvent</code>, <code>onInterceptTouchEvent</code>,<code>onTouchEvent</code>。</p><p>三个方法的执行顺序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123; <span class="hljs-comment">// 对当前的View进行事件的分发</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">consume</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;                        <span class="hljs-comment">// 判断是否可以消耗这个事件序列</span><br>    <span class="hljs-keyword">if</span> (onInterceptTouchEvent(ev)) &#123;                <span class="hljs-comment">// 如果准备拦截此次事件序列</span><br>        consume = onTouchEvent(ev);                 <span class="hljs-comment">// 事件由该View执行，并返回结果</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        consume = child.dispatchTouchEvent(ev);     <span class="hljs-comment">// 若不准备拦截，则交给子View进行判断</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> consume;                                 <span class="hljs-comment">// 向父级返回结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中执行事件序列的不同方法中同样由优先顺序：<code>onTouchListener &gt; onTouchEvent &gt; onClickListener</code></p><p>当点击事件发生后，它的传递过程会遵循以下的顺序：<code>Activity　-&gt; Window -&gt; DecorView -&gt; View -&gt; ...</code>、</p><p>同时，如果子级发现无法执行这个事件的时候，那么它的父容器的<code>onTouchEvent</code>就会重新调用，直到<code>Activity</code>。</p><p>其中，<code>ViewGroup</code>默认不拦截任何事件，<code>View</code>没有<code>onInterceptTouchEvent</code>方法。</p><h2 id="二、事件分发解析"><a href="#二、事件分发解析" class="headerlink" title="二、事件分发解析"></a>二、事件分发解析</h2><h3 id="Activity对点击事件的分发"><a href="#Activity对点击事件的分发" class="headerlink" title="Activity对点击事件的分发"></a><code>Activity</code>对点击事件的分发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>    <span class="hljs-keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) <span class="hljs-comment">// 如果Window可以处理点击事件</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> onTouchEvent(ev); <span class="hljs-comment">// 返回Activity自己处理点击事件的结果(true|false)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Window对点击事件的分发"><a href="#Window对点击事件的分发" class="headerlink" title="Window对点击事件的分发"></a><code>Window</code>对点击事件的分发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> PhoneWindow#superDispatchTouchEvent(MotionEvent ev) &#123;<br>  <span class="hljs-keyword">return</span> mDecor.superDispatchTouchEvent(ev); <span class="hljs-comment">// 返回DecorView的处理结果</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="顶级View对点击事件的分发"><a href="#顶级View对点击事件的分发" class="headerlink" title="顶级View对点击事件的分发"></a><code>顶级View</code>对点击事件的分发</h3><p>由此开始，将执行（一）所讲述的事件传递规则。其主要的部分是<code>ViewGroup</code>的事件传递。<code>顶级View</code>一般来说都是<code>ViewGroup</code>。</p><h4 id="判断当前ViewGroup是否拦截点击事件"><a href="#判断当前ViewGroup是否拦截点击事件" class="headerlink" title="判断当前ViewGroup是否拦截点击事件"></a>判断当前<code>ViewGroup</code>是否拦截点击事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> intercepted;<br><span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION.DOWN || mFirstTouchTarget != NULL) &#123; <span class="hljs-comment">// 意思见下方文字</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">disallowIntercept</span> <span class="hljs-operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>; <span class="hljs-comment">// 判断是否允许屏蔽自身的onInterceptTouchEvent方法</span><br>    <span class="hljs-keyword">if</span> (!disallowIntercept) &#123; <span class="hljs-comment">// 如果允许拦截</span><br>        intercepted = onInterceptTouchEvent(ev); <span class="hljs-comment">// 询问能否拦截并赋值</span><br>        ev.setAction(action); <span class="hljs-comment">// 防止事件被修改，存储事件的动作</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        intercepted = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 由于不允许拦截，则直接赋值</span><br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    intercepted = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 由于直接拦截，则不用询问</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码中的几个变量的作用：</p><ol><li><p>当事件由<code>ViewGroup</code>的子元素处理成功时，<code>mFirstTouchTarget</code>就会被赋值并指向子元素，此时的<code>mFirstTouchTarget != NULL</code>。</p></li><li><p><code>FLAG_DISALLOW_INTERCEPT</code>一旦被设置后，那么当前的<code>ViewGroup</code>就无法拦截<code>ACTION_MOVE</code>以及<code>ACTION_UP</code>。</p><p>由于事件为<code>ACTION_DOWN</code>的时候，<code>ViewGroup</code>会重置<code>FLAG_DISALLOW_INTERCEPT</code>，所以每次事件为<code>ACTION_DOWN</code>的时候，都会执行一次<code>onInterceptTouchEvent</code>方法。</p></li></ol><p>第3行的判断语句的意思为：</p><ol><li>如果当前的事件为<code>ACTION_DOWN</code>时，作为一个点击事件的开始，需要向子元素传递，返回<code>true</code>。允许向子元素传递。</li><li>如果当前的事件为<code>ACTION_MOVE</code>或者<code>ACTION_UP</code>的时候，如果<code>ACTION_DOWN</code>已经被子元素处理了（<code>mFirstTouchTarget != NULL</code>），那么由于一系列的点击事件都要有同一个<code>View</code>处理，则不能在此拦截，故返回<code>true</code>。反之，如果<code>mFirstTouchTarget == NULL</code>，则代表<code>ACTION_DOWN</code>是由<code>ViewGroup</code>自身处理的，则不能向下传递，返回<code>false</code>。</li></ol><h4 id="ViewGroup在ACTION-DOWN到来时的重置操作"><a href="#ViewGroup在ACTION-DOWN到来时的重置操作" class="headerlink" title="ViewGroup在ACTION_DOWN到来时的重置操作"></a><code>ViewGroup</code>在<code>ACTION_DOWN</code>到来时的重置操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Handle an initial down.</span><br><span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;<br>    <span class="hljs-comment">// Throw away all previous state when starting a new touch gesture.</span><br>cancelAndClearTouchTargets(ev);<br>resetTouchState();<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>resetTouchState</code>方法中会对<code>FLAG_DISALLOW_INTERCEPT</code>进行重置。</p><p>因此<code>子View</code>的<code>requestDisallowInterceptTouchEvent</code>方法并不能影响<code>ViewGroup</code>对<code>ACTION_DOWN</code>事件的处理。</p><h4 id="ViewGroup不拦截事件时，对点击事件的分发"><a href="#ViewGroup不拦截事件时，对点击事件的分发" class="headerlink" title="ViewGroup不拦截事件时，对点击事件的分发"></a><code>ViewGroup</code>不拦截事件时，对点击事件的分发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> View[] = mChildren;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> childrenCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-comment">// 获取每一个子View的位置以及其他信息</span><br>    <span class="hljs-keyword">if</span> (子元素正在播放动画 || 点击事件的坐标落在当前子元素的区域外) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    newTouchTarget = getTouchTarget(child); <br>    <span class="hljs-keyword">if</span> (newTouchTarget != NULL) &#123; <span class="hljs-comment">// 如果不是NULL的话(该child之前初始化过)，就直接向其中添加元素就行了</span><br>        newTouchTarget.pointerIdBits |= idBitsToAssign;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果 newTouchTarget == NULL, 那么就初始化 + 添加第一个可用子元素</span><br>    resetCancelNextUpFlag(child);<br>    <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="hljs-literal">false</span>, child, idBitsToAssign)) &#123;<br>        ...<br>        newTouchTarget = addTouchTarget(child, idBitsToAssign);<br>        alreadyDispatchedToNewTouchTarget = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不断的遍历当前<code>ViewGroup</code>的所有子元素，如果<strong>子元素不在播放动画</strong>以及<strong>点击事件的坐标落在当前子元素的区域内</strong>，那么这个子元素就是一个可以传递的。</p><blockquote><p>  由<code>TouchTarget</code>源码可知：</p><p>  <code>TouchTarget</code>保存了响应触摸事件的子<code>view</code>和该子view上的触摸点ID集合，表示一个触摸事件派发目标。通过<code>next</code>成员可以看出，它支持作为一个链表节点储存。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TouchTarget</span> &#123;<br>    <span class="hljs-comment">// ···</span><br><br>    <span class="hljs-comment">// The touched child view.</span><br>    <span class="hljs-comment">// 被触摸的子元素</span><br>    <span class="hljs-meta">@UnsupportedAppUsage</span><br>    <span class="hljs-keyword">public</span> View child;<br><br>    <span class="hljs-comment">// The combined bit mask of pointer ids for all pointers captured by the target.</span><br>    <span class="hljs-comment">// 指针 id 的位的掩码组合，用于目标捕获的所有指针</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> pointerIdBits;<br><br>    <span class="hljs-comment">// The next target in the target list.</span><br>    <span class="hljs-comment">// 目标列表中的下一个目标</span><br>    <span class="hljs-keyword">public</span> TouchTarget next;<br>    <br>    <span class="hljs-comment">// ···</span><br>&#125;<br>————————————————<br>版权声明：本文为CSDN博主「分则能成」的原创文章，遵循CC <span class="hljs-number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：https:<span class="hljs-comment">//blog.csdn.net/dehang0/article/details/104317611</span><br></code></pre></td></tr></table></figure></blockquote><p>如果是第一个可传递元素，那么就会进入初始化部分，其中的<code>dispatchTransformedTouchEvent</code>方法实际上就是调用的子元素的<code>dispatchTouchEvent</code>方法。在该方法中有如下的一段内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (child == NULL) &#123;<br>    handled = <span class="hljs-built_in">super</span>.dispatchTouchTarget(event);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    handled = child.dispatchTouchTarget(event);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于前面的代码中<code>dispatchTransformedTouchEvent</code>方法的第三个参数为<code>child</code>，所以会执行子元素的<code>dispatchTouchEvent</code>方法，点击事件交由子元素处理，从而完成了一轮事件的分发。</p><p>当子元素的<code>dispatchTouchEvent</code>方法返回<code>true</code>时，<code>dispatchTransformedTouchEvent</code>方法同样也会返回<code>true</code>，接着便执行<code>if语句</code>的代码块部分了。如果<code>dispatchTouchEvent</code>方法返回<code>false</code>的话，<code>ViewGroup</code>就会把事件向后遍历，寻找新的可传递的子元素。在<code>if语句</code>的代码块中，<code>mFirstTouchTarget</code>会被赋值同时跳出<code>for循环</code>。</p><p>其中<code>mFirstTouchTarget</code>的赋值由<code>addTouchTarget</code>方法完成，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TouchTarget <span class="hljs-title function_">addTouchTarget</span><span class="hljs-params">(View child, <span class="hljs-type">int</span> pointerIdBits)</span> &#123;<br>    <span class="hljs-type">TouchTarget</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> TouchTarget.obtain(child, pointerIdBits);<br>   target.next = mFirstTouchTarget;<br>    mFirstTouchTarget = target;<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以很容易的看出，<code>mFirstTouchTarget</code>其实是一个<strong>单链表结构</strong>，<code>mFirstTouchTarget</code>是否被赋值，将直接影响<code>ViewGroup</code>对事件的拦截策略。</p><h4 id="ViewGroup中没有合适的子元素"><a href="#ViewGroup中没有合适的子元素" class="headerlink" title="ViewGroup中没有合适的子元素"></a><code>ViewGroup</code>中没有合适的子元素</h4><p>有两种情况，<code>ViewGroup</code>中会没有合适的子元素可以传递：</p><ol><li><code>ViewGroup</code>没有子元素</li><li>子元素处理了点击事件，但是<code>dispatchTouchEvent</code>方法返回了<code>false</code>，这一般是因为子元素在<code>onTouchEvent</code>中返回了<code>false</code>。</li></ol><p>在这两种情况中，<code>ViewGroup</code>都会自己处理点击事件。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (mFirstTouchTarget == NULL) &#123;<br><span class="hljs-comment">// 没有可分发子元素，就当其是一个普通的View</span><br>handled = dispatchTransformedTouchEvent(ev, canceled, <span class="hljs-literal">null</span>, TouchTarget.ALL_POINTER_IDS);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，代码中的<code>dispatchTransformedTouchEvent</code>方法的第三个参数将其设置为<code>null</code>，此时它就会调用<code>super.dispatchTouchTarget</code>方法了。</p><h3 id="View对点击事件的处理过程"><a href="#View对点击事件的处理过程" class="headerlink" title="View对点击事件的处理过程"></a><code>View</code>对点击事件的处理过程</h3><p>这里的<code>View</code>不包含<code>ViewGroup</code>，因为没有子元素，所以不用向下分发事件，只能自己处理事件。</p><p>先看它的<code>dispatchTouchEvent</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    ...<br>    <span class="hljs-keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;<br>        <span class="hljs-type">ListenerInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> mListenerInfo;<br>        <span class="hljs-keyword">if</span> (li != <span class="hljs-literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="hljs-literal">null</span> &amp;&amp; li.mOnTouchListener.onTouch(<span class="hljs-built_in">this</span>, event) &amp;&amp; ...) &#123;<br>            result = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;<br>            result = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上面的代码可以看出，<code>View</code>对点击事件的处理流程中，首先会判断有没有设置<code>onTouchListener</code>，如果有且其中的<code>onTouch</code>方法返回<code>true</code>，则<code>onTouchEvent</code>方法就不会被调用。</p><p>从其他的代码中也可以得出的一些结论：</p><ol><li>如果<code>View</code>的<code>CLICKABLE</code>以及<code>LONG_CLICKABLE</code>中有一个为<code>true</code>，不论<code>View</code>是否为<code>DISABLE</code>，都会消耗事件（也就是即使<code>View</code>看起来没有任何的反应，但是也消耗了点击事件）。</li><li><code>View</code>的<code>LONG_CLICKABLE</code>默认为<code>false</code>，而<code>CLICKABLE</code>是否为<code>false</code>与其<code>View</code>有关，如<code>button</code>的默认为<code>true</code>、<code>textview</code>的默认为<code>false</code>。</li><li>当<code>ACTION_UP</code>事件发生时，会触发<code>performClick</code>方法，如果<code>View</code>设置了<code>OnClickListener</code>，那么<code>performClick</code>方法就会调用它的<code>onClick</code>方法。（即<code>onClick</code>的触发前提时<code>View</code>是可点击的，且收到了<code>DOWN</code>和<code>UP</code>的点击事件。）</li><li><code>setOnClickListener</code>方法会自动将<code>CLICKABLE</code>设置为<code>true</code>，<code>setOnLongClickListener</code>方法会自动将<code>LONG_CLICKABLE</code>设置为<code>true</code>。</li></ol><h1 id="View的滑动冲突"><a href="#View的滑动冲突" class="headerlink" title="View的滑动冲突"></a><code>View</code>的滑动冲突</h1><p>总共会出现三种滑动冲突的情况：</p><ol><li><code>内部View</code>与<code>外部View</code>的滑动方向相反。</li><li><code>内部View</code>与<code>外部View</code>的滑动方向相同。</li><li>前两种情况的嵌套。</li></ol><p>三种情况的处理思路：</p><ol><li>通过手势滑动的角度判断滑动的方向。</li><li>通过当前处于的不同的页面状态来判断应该滑动的<code>View</code>。</li><li>通过前两种的综合使用。</li></ol><h2 id="滑动冲突的解决方式"><a href="#滑动冲突的解决方式" class="headerlink" title="滑动冲突的解决方式"></a>滑动冲突的解决方式</h2><h3 id="外部拦截法"><a href="#外部拦截法" class="headerlink" title="外部拦截法"></a>外部拦截法</h3><p>通过重写<strong>父容器的</strong><code>onInterceptTouchEvent</code>方法，所有的事件都先经过父容器的筛选，对其中父容器需要的事件进行拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">intercepted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getX();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getY();<br>    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN : &#123;<br>            intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE : &#123;<br>            <span class="hljs-keyword">if</span> (父容器需要当前的点击事件)<br>                intercepted = <span class="hljs-literal">true</span>;<br>           <span class="hljs-keyword">else</span> <br>                intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP : &#123;<br>            intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span> :<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    mLastXIntercept = x;<br>    mLastYIntercept = y;<br>    <span class="hljs-keyword">return</span> intercepted;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内部拦截法"><a href="#内部拦截法" class="headerlink" title="内部拦截法"></a>内部拦截法</h3><p>父元素拦截除<code>ACTION_DOWN</code>以外的其他事件，当事件到达子元素后，由子元素判断是否需要这些事件，不需要的事件将重新交由父容器来处理。这种方法和Android的事件分发机制不一致，需要配合<code>requestDisallowInterceptTouchEvent</code>方法才能正常的工作。</p><p>相关阅读链接：<a href="https://www.jianshu.com/p/fe3d109eb27e">Android TouchEvent之requestDisallowInterceptTouchEvent - 简书 (jianshu.com)</a></p><h4 id="子元素的dispatchTouchEvent方法"><a href="#子元素的dispatchTouchEvent方法" class="headerlink" title="子元素的dispatchTouchEvent方法"></a>子元素的<code>dispatchTouchEvent</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getX();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getY();<br>    <br>    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN : &#123;<br>            parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 此子View的所有父ViewGroup会跳过onInterceptTouchEvent回调</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE : &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">deltaX</span> <span class="hljs-operator">=</span> x - mLastX;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">deltaY</span> <span class="hljs-operator">=</span> y - mLastY;<br>            <span class="hljs-keyword">if</span> (父容器需要当前的点击事件) &#123;<br>                parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">false</span>);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP : &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span> : <br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    mLastX = x;<br>    mLastY = y;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.dispatchTouchEvent(event);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="父容器的onInterceptTouchEvent方法："><a href="#父容器的onInterceptTouchEvent方法：" class="headerlink" title="父容器的onInterceptTouchEvent方法："></a>父容器的<code>onInterceptTouchEvent</code>方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> event.getAction();<br>    <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 垃圾回收机制</title>
    <link href="/posts/95a5ab043507/"/>
    <url>/posts/95a5ab043507/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="http://www.cyc2018.xyz/">Java 虚拟机 | CS-Notes</a></li><li><a href="https://blog.csdn.net/jisuanjiguoba/article/details/80156781">JVM中的新生代和老年代（Eden空间、两个Survior空间）</a></li></ul></blockquote><hr><h1 id="判断一个对象是否可以被回收"><a href="#判断一个对象是否可以被回收" class="headerlink" title="判断一个对象是否可以被回收"></a>判断一个对象是否可以被回收</h1><ol><li>引用计数算法</li><li>可达性分析算法</li><li>方法区的回收</li><li><code>finalize</code> 方法</li></ol><hr><h1 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h1><ol><li>强引用：被强引用关联的对象不会被回收。</li><li>软引用：被软引用关联的对象只会在内存不足的情况下被回收。</li><li>弱引用：被弱引用关联的对象一定会被回收，只能活到下次垃圾回收之前。</li><li>虚引用：无法通过虚引用创建一个对象。为对象创建虚引用的唯一目的是在这个对象在被回收时受到一个系统消息。</li></ol><hr><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><ol><li>标记-清除算法</li><li>标记-复制算法</li><li>复制算法</li><li>分代收集算法</li></ol><hr><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>并行与串行</li><li>单线程与多线程</li></ol><h2 id="主要收集器"><a href="#主要收集器" class="headerlink" title="主要收集器"></a>主要收集器</h2><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS(Concurrent Mark Sweep，即多线程的标记-清除算法)</p><p>分为四个流程：</p><ol><li><strong>初始标记</strong><br> 仅仅是标记一下 GC Roots 能直接关联到的对象。</li><li><strong>并发标记</strong><br> 进行 GC Roots Trancing 的过程。</li><li><strong>重新标记</strong><br> 为了修正并发标记期间因用户线程继续运作而产生变动的那一部分的对象的标记记录。</li><li><strong>并发清除</strong><br> 对标记出来的垃圾进行清除操作。</li></ol><p>具有以下的缺点：</p><ol><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不高。</li><li>标记-清除算法导致的空间碎片，导致往往出现老年代空间剩余，但是无法找到一段连续的空间用于存储对象，而不得不进行一次 Full GC。</li><li>无法处理浮动垃圾，而导致 Concurrent Mode Failure。其中，浮动垃圾是指在并发清除阶段由于用户线程的继续运行而产生的垃圾。</li></ol><h3 id="G1-Garbage-First"><a href="#G1-Garbage-First" class="headerlink" title="G1(Garbage First)"></a>G1(Garbage First)</h3><p>G1 垃圾收集器是面向客户端的垃圾收集器，在多 CPU 和大内存场景下有很好的性能。</p><p>堆被分为新生代和老年代，G1 收集器可以直接对新生代和老年代一起回收。</p><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p>G1 收集器的运作大致分为以下的几个部分：</p><ol><li><strong>初始标记</strong><br> 仅仅是标记 GC Roots 能够直接标记到的对象。</li><li><strong>并发标记</strong><br> 进行 GC Roots Tracing 的过程。</li><li><strong>最终标记</strong><br> 为了修正在并发标记期间因用户线程继续运行而导致标记产生变动的那一部分标记记录。</li><li><strong>筛选回收</strong><br> 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ol><p>具备如下的特点：</p><ol><li>空间整合：从整体上看是基于标记-整理算法实现的收集器，从局部上看是居于复制算法实现的，这就意味着运行期间不会产生内存空闲碎片。</li><li>可预测的停顿：能够有用户自定义 GC收集器 上所消耗的时间。</li></ol><h2 id="其他收集器"><a href="#其他收集器" class="headerlink" title="其他收集器"></a>其他收集器</h2><pre><code class="mermaid" >graph TBsubgraph 新生代     Serial    ParNew    Parallel_Scaevnge[Parallel Scavenge]endsubgraph 老年代    Serial_Old[Serial Old]    Parallel_Old[Parallel Old]end</code></pre><hr><h1 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h1><h2 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h2><ol><li>Minor GC</li><li>Full GC</li></ol><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><ol><li><p>一个人（对象）出来（new 出来）后会在Eden Space（伊甸园）无忧无虑的生活，直到GC到来打破了他们平静的生活。GC会逐一问清楚每个对象的情况，有没有钱（此对象的引用）啊，因为GC想赚钱呀，有钱的才可以敲诈嘛。然后富人就会进入Survivor Space（幸存者区），穷人的就直接kill掉。</p></li><li><p>并不是进入Survivor Space（幸存者区）后就保证人身是安全的，但至少可以活段时间。GC会定期（可以自定义）会对这些人进行敲诈，亿万富翁每次都给钱，GC很满意，就让其进入了Genured Gen(养老区)。万元户经不住几次敲诈就没钱了，GC看没有啥价值啦，就直接kill掉了。</p></li><li><p>进入到养老区的人基本就可以保证人身安全啦，但是亿万富豪有的也会挥霍成穷光蛋，只要钱没了，GC还是kill掉。</p></li></ol><p><strong>总结</strong></p><ol><li>对象优先在 Eden 分配</li><li>大对象直接进入老年代</li><li>长期存活的对象直接进入老年代</li><li>动态对象年龄判定</li><li>空间分配担保</li></ol><h2 id="Full-GC-出触发条件"><a href="#Full-GC-出触发条件" class="headerlink" title="Full GC 出触发条件"></a>Full GC 出触发条件</h2><ol><li>调用 <code>System.gc()</code></li><li>老年代空间不足</li><li>空间分配担保失败</li><li>JDK 1.8 之前的永久代空间不足</li><li>Concurrent Mode Failure</li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM Garbage Collection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>View 的绘制原理</title>
    <link href="/posts/19429a22b2b2/"/>
    <url>/posts/19429a22b2b2/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="ViewRoot"><a href="#ViewRoot" class="headerlink" title="ViewRoot"></a><code>ViewRoot</code></h2><p><code>ViewRoot</code>对应于<code>ViewRootImpl</code>类，它是连接<code>WindowManager</code>和<code>DecorView</code>的纽带。<code>View</code>的三大流程都是通过<code>ViewRoot</code>来完成的。</p><p>在<code>ActivityThread</code>中，当<code>Activity</code>对象被创建完毕后，会将<code>DecorView</code>添加到<code>Window</code>中，同时也会创建<code>ViewRootImpl</code>对象，并将<code>ViewRootImpl</code>对象与<code>DecorView</code>建立关联。</p><h2 id="View的三大绘制流程"><a href="#View的三大绘制流程" class="headerlink" title="View的三大绘制流程"></a><code>View</code>的三大绘制流程</h2><p><code>View</code>的绘制流程主要有<code>measure</code>、<code>layout</code>和<code>draw</code>过程。</p><ol><li><code>measure</code>：用来确定<code>View</code>的测量宽高。</li><li><code>layout</code>：用来确定<code>View</code>的最终宽高以及四个顶点的位置。</li><li><code>draw</code>：将<code>View</code>绘制在屏幕上。</li></ol><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-d165daed428c4a5312c1ce1af6a9693a_720w.jpg"></p><p><code>View</code>的绘制流程由<code>ViewRoot</code>的<code>performTraversals</code>方法开始。</p><p><code>performTraversals</code>方法会依次调用<code>performMeasure</code>、<code>performLayout</code>、<code>performDraw</code>方法。<strong>这三个方法会分别完成<code>顶层View</code>的<code>measure</code>、<code>layout</code>、<code>draw</code>过程。</strong></p><p>其中、<code>performMeasure</code>方法会调用其中的<code>measure</code>方法，在<code>measure</code>方法中又会调用<code>onMeasure</code>方法，在<code>onMeasure</code>方法中会对所有的子元素进行<code>measure</code>过程，这个时候<code>measure</code>的流程就从父容器传递到了子元素中，这样就完成了一轮<code>measure</code>过程。不断的对子元素进行<code>measure</code>过程。如此反复便完成了对<code>View</code>树的遍历。</p><p>其中，<code>performMeasure</code>方法位于<code>ViewRootImpl</code>中的<code>measureHierarchy</code>方法中(<code>hierarchy</code>：<code>n.</code>层次结构)。</p><p><code>performLayout</code>方法、<code>performDraw</code>方法的流程与之同理，需要注意一点的是，<code>draw</code>流程的传递是通过<code>draw</code>方法中的<code>dispatchDraw</code>实现的，不过并无本质的区别。</p><h2 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a><code>DecorView</code></h2><p><code>DecorView</code>作为<code>顶层View</code>，继承自<code>FrameLayout</code>。一般情况下它的内部都会包含一个<code>LinearLayout</code>。而<code>LinearLayout</code>中有上下两个部分，分别为标题栏和内容栏。我们平时设置指定布局文件的方法<code>setContentView</code>，就是指的是内容栏中的布局。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-8f887429daf00df80319901f69cd1d35_720w.jpg" alt="img" style="zoom:67%;" /><p>通过源码，我们可以得知，**<code>DecorView</code> 其实是一个 <code>LinearLayout</code>**，<code>View</code> 层的事件都先通过 <code>DecorView</code>，然后才传递给我们的 <code>View</code>。</p><h2 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a><code>MeasureSpec</code></h2><blockquote><p>  <code>spec</code> <strong><code>英[spek]</code></strong><code>n.</code>规格 <code>vt.</code>按特定标准设计并制造</p></blockquote><p><code>MeasureSpec</code>参与了<code>View</code>的<code>measure</code>过程。在测量过程中，系统将<code>View</code>的<code>LayoutParams</code>根据父容器所施加的规则转换成对应的<code>MeasureSpec</code>，然后再根据这个<code>MeasureSpec</code>来测量出<code>View</code>的测量宽&#x2F;高。</p><p><code>MeasureSpec</code>代表一个32位的<code>int</code>值，高两位代表 测量模式<code>SpecMode</code>，低30位代表 该测量模式下的规格大小<code>SpecSize</code>。</p><p><code>MeasureSpec</code>与<code>SpecMode</code>、<code>SpecSize</code>之间可以通过位运算互相求出。</p><p>每个<code>View</code>的<code>measure</code>过程之前都会先计算其<code>MeasureSpec</code>的值，然后再对其进行<code>measure</code>。</p><p><strong>注意</strong>：<code>View</code>的宽和高各有一个<code>MeasureSpec</code>值，分别为<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>。</p><h3 id="SpecMode的三种状态"><a href="#SpecMode的三种状态" class="headerlink" title="SpecMode的三种状态"></a><code>SpecMode</code>的三种状态</h3><ol><li><p><code>UNSPECIFIED</code></p><p>父容器不对<code>View</code>做任何的限制，要多大给多大。<strong>这种情况一般用于系统的内部</strong>，表示一种测量方式的状态。</p></li><li><p><code>EXACTLY</code></p><p>父容器已经测出了<code>View</code>所需要的精确大小，此时的大小就是<code>View</code>的最终大小。</p><p>它对应于<code>LayoutParams</code>的<code>match_parent</code>和具体的数值这两种模式。</p></li><li><p><code>AT_MOST</code></p><p>父容器指定了一个可用的大小，<code>View</code>的大小不能大于这个值。</p><p>它对应于<code>LayoutParams</code>中的<code>wrap_content</code>。</p></li></ol><h3 id="MeasureSpec和LayoutParams的对应关系"><a href="#MeasureSpec和LayoutParams的对应关系" class="headerlink" title="MeasureSpec和LayoutParams的对应关系"></a><code>MeasureSpec</code>和<code>LayoutParams</code>的对应关系</h3><p>对于<code>DecorView</code>和普通<code>View</code>来说，<code>MeasureSpec</code>的转化过程略有不同。</p><p><strong>对于<code>DecorView</code>：</strong></p><p><strong><code>DecorView</code>的<code>MeasureSpec</code>由窗口的大小和<code>DecorView</code>自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在<code>ViewRootImpl</code>中的<code>measureHierarchy</code>方法中，调用<code>getRootMeasureSpec</code>方法，获得<code>DecorView</code>的<code>MeasureSpec</code>。</p><p>其中<code>getRootMeasureSpec</code>方法中，根据自身<code>LayoutParams</code>的不同大小，共有三种情况：</p><ol><li><code>LayoutParams.MATCH_PARENT</code>：精确模式，大小就是窗口的大小。</li><li><code>LayoutParams.WRAP_CONTENT</code>：最大模式，大小不定，但是不能超过窗口的大小。</li><li>固定大小(比如100dp)：精确模式，大小为<code>LayoutParams</code>中指定的大小。</li></ol><p><strong>对于普通<code>View</code>：</strong></p><p><strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在父容器的<code>measureChildWithMargins</code>中的<code>getChildMeasureSpec</code>方法获得<code>View</code>的<code>MeasureSpec</code>。</p><p>其中<code>getChildMeasureSpec</code>方法的参数中使用到了父容器的<code>MeasureSpec</code>。在这个方法中通过<code>switch</code>和<code>if</code>语句，对<code>View</code>的<code>MeasureSpec</code>进行了决定。结果如下：</p><table><thead><tr><th><code>childLayoutParams</code> \ <code>parentMeasureSpec</code></th><th><code>EXACTLY</code></th><th><code>AT_MOST</code></th><th><code>UNSPECIFIED</code></th></tr></thead><tbody><tr><td><code>dp</code>&#x2F;<code>px</code></td><td><code>EXACTLY</code><br>childSize</td><td><code>EXACTLY</code><br/>childSize</td><td><code>EXACTLY</code><br/>childSize</td></tr><tr><td><code>match_parent</code></td><td><code>EXACTLY</code><br/>parentSize</td><td><code>AT_MOST</code><br>parentSize</td><td><code>UNSPECIFIED</code><br>0</td></tr><tr><td><code>wrap_content</code></td><td><code>AT_MOST</code><br>parentSize</td><td><code>AT_MOST</code><br/>parentSize</td><td><code>UNSPECIFIED</code><br/>0</td></tr></tbody></table><p>上图可以简单记为：除了<code>dp</code>&#x2F;<code>px</code>的精确模式情况外，三种<code>MeasureSpec</code>的级别为：<code>EXACTLY</code> &lt; <code>AT_MOST</code> &lt; <code>UNSPECIFIED</code> 且<code>childMeasureSpec</code> &#x3D; max(<code>childLayoutParams</code> , <code>parentMeasureSpec</code>)。（<strong>实际上并无级别之分</strong>）</p><p>通过上面的表格，可以更加直观的看出：<strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><h1 id="View的工作流程"><a href="#View的工作流程" class="headerlink" title="View的工作流程"></a><code>View</code>的工作流程</h1><h2 id="measure过程"><a href="#measure过程" class="headerlink" title="measure过程"></a><code>measure</code>过程</h2><p><code>measure</code>过程分为两种情况：</p><ol><li><code>View</code>的<code>measure</code>过程：只需要测量自身即可。</li><li><code>ViewGroup</code>的<code>measure</code>过程：则除了完成自己的测量外，还需要遍历去调用所有子元素的<code>measure</code>过程。</li></ol><p>以下对这两种情况分别讨论。</p><h3 id="View的measure过程"><a href="#View的measure过程" class="headerlink" title="View的measure过程"></a><code>View</code>的<code>measure</code>过程</h3><p><code>View</code>的<code>measure</code>方法是<code>final</code>类型的方法，不可以重写，<code>measure</code>方法里面调用了<code>onMeasure</code>方法。</p><p>在<code>onMeasure</code>方法里面也只调用了一个<code>setMeasuredDimension</code>方法来设置<code>View</code>的宽&#x2F;高的测量值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMeasure</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSpec, <span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br>    setMeasuredDimension(getDefaultSize(getSuggestedMininumWidth(), <br>                                        widthMeasureSpec), <br>                         getDefaultSize(getSuggestedMininumHeight(), <br>                                        heightMeasureSpec));<br>&#125;<br></code></pre></td></tr></table></figure><p>而在<code>setMeasureDimension</code>方法的参数中，则使用了<code>getDefaultSize</code>的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDefaultSize</span><span class="hljs-params">(<span class="hljs-type">int</span> size, <span class="hljs-type">int</span> measureSpec)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> size;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">specMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(measureSpec);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">specSize</span> <span class="hljs-operator">=</span> Measurespec.getSize(measureSpec);<br><br>    <span class="hljs-keyword">switch</span> (specMode) &#123;<br>        <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:<br>            result = size;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:<br>        <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:<br>            result = specsize;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对于AT-MOST和EXACTLY的情况"><a href="#对于AT-MOST和EXACTLY的情况" class="headerlink" title="对于AT_MOST和EXACTLY的情况"></a>对于<code>AT_MOST</code>和<code>EXACTLY</code>的情况</h4><p>通过代码可以看出，最终返回的值就是传入的<code>MeasureSpec</code>的中<code>View</code><strong>测量后</strong>的大小（<code>View</code>的<strong>最终的</strong>大小是在<code>layout</code>阶段确定的，但是几乎所有情况下，<code>View</code>的测量大小和最终大小都是相同的）。</p><h4 id="对于UNSPECIFIED的情况"><a href="#对于UNSPECIFIED的情况" class="headerlink" title="对于UNSPECIFIED的情况"></a>对于<code>UNSPECIFIED</code>的情况</h4><p><code>getDefaultSize</code>方法返回的值是<code>getsuggestedMininumWidth</code>方法和<code>getsuggestedMininumHeight</code>方法决定的。</p><p>这里只讨论<code>getsuggestedMininumWidth</code>方法的逻辑，另一个方法同理：</p><ol><li>如果<code>View</code>没有设置背景，那么此方法的返回值就是<code>android:minWidth</code>这个属性所指定的值，这个值默认为0。</li><li>如果<code>View</code>设置了背景，则返回<code>android:minWidth</code>和背景的最小宽度这两者中的最大值。</li></ol><h4 id="对于自定义View的情况"><a href="#对于自定义View的情况" class="headerlink" title="对于自定义View的情况"></a>对于自定义<code>View</code>的情况</h4><p>对于直接继承<code>View</code>的自定义<code>View</code>来说，<strong>需要重写<code>onMeasure</code>方法并设置在<code>wrap_content</code>情况时的自身大小</strong>，否则在布局中使用<code>wrap_content</code>就相当于使用<code>match_parent</code>。</p><p>因为当自定义<code>View</code>处于<code>wrap_content</code>时，它的<code>SpecMode</code>为<code>AT_MOST</code>模式，由前文可知，当父容器无论为<code>AT_MOST</code>还是<code>ECACTLY</code>模式时，自定义<code>View</code>都为<code>AT_MOST</code>模式且尺寸大小为<code>parentSize</code>，也就是父容器的剩余空间，即自定义<code>View</code>的大小变得与父容器的剩余空间大小一致，显然不是我们需要的。</p><p><strong>解决方法：</strong></p><p>解决方法也是非常简单的。我们只需要在<code>onMeasure</code>方法中对</p><ol><li>仅<code>width</code>方向为<code>AT_MOST</code>模式</li><li>仅<code>height</code>方向为<code>AT_MOST</code>模式</li><li><code>width</code>方向以及<code>height</code>方向都为<code>AT_MOST</code>模式</li><li>其他的情况</li></ol><p>这四个状态单独判断，分别使用<code>setMeasuredDimension</code>方法直接为自定义<code>View</code>设置我们需要的值即可。</p><p>源码中对于<code>TextView</code>、<code>ImageView</code>等控件的<code>wrap_content</code>也做了特殊的处理。</p><h3 id="ViewGroup的measure过程"><a href="#ViewGroup的measure过程" class="headerlink" title="ViewGroup的measure过程"></a><code>ViewGroup</code>的<code>measure</code>过程</h3><p>对于<code>ViewGroup</code>来说，处理要完成它自己的<code>measure</code>过程，还需要遍历去调用所有子元素的<code>measure</code>方法，对子元素也进行<code>measure</code>过程。</p><p>由于<code>ViewGroup</code>是一个抽象类，不能重写<code>View</code>的<code>onMeasure</code>方法，但是他提供了一个<code>measureChildren</code>的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measureChildren</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSepc, <span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> mChildrenCount;<br>    <span class="hljs-keyword">final</span> View[] children = mChildren;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> children[i];<br>        <span class="hljs-keyword">if</span> (...) &#123;<br>            measureChild(child, widthMeasureSpec, heightMeasureSpec);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中，可以清晰的看出，<code>measureChildren</code>方法遍历了所有的子元素，并对他们使用了<code>measureChild</code>方法。</p><p>在<code>measureChild</code>方法中，通过</p><ol><li>参数<code>child</code>获得了<code>child.LayoutParams</code>；</li><li><code>measureChild</code>方法中的<code>getChildMeasureSpec</code>方法配合参数中父容器的两个<code>MeasureSpec</code>值，得到子元素的两个<code>MeasureSpec</code>值。</li></ol><p>接着将子元素的两个<code>MeasureSpec</code>值传递给<code>child.measure</code>方法来进行测量，到此便结束了一轮的<code>measure</code>过程。</p><p><strong>注意</strong>：不同的<code>ViewGroup</code>有着不同的布局特性，不易写出通用的供<code>ViewGroup</code>使用的<code>onMeasure</code>方法。故设置成抽象类，需要测量过程中的各个子类（如<code>LinearLayout</code>、<code>RelativeLayout</code>等）自己去具体实现<code>onMeasure</code>方法。</p><h3 id="在Activity启动时获得一个View的宽-x2F-高信息的方法"><a href="#在Activity启动时获得一个View的宽-x2F-高信息的方法" class="headerlink" title="在Activity启动时获得一个View的宽&#x2F;高信息的方法"></a>在<code>Activity</code>启动时获得一个<code>View</code>的宽&#x2F;高信息的方法</h3><p>由于<code>Activity</code>的启动和<code>View</code>的测量过程并不是同步进行的，因此无法保证在<code>Activity</code>启动时某个<code>View</code>已经测量完毕了。所以我们在<code>Activity</code>启动的时候，如果直接通过<code>getMeasuredWidth</code>&#x2F;<code>getMeasuredHeight</code>方法获得的值可能为0。</p><p>以下有四种方法可以解决这个问题（详细代码见《Android开发艺术探索》190页）。</p><ol><li><p><code>Activity/View#onWindowFocusChanged</code></p><p>在<code>Activity</code>的<code>onResume</code>和<code>onPause</code>方法启动时，<code>onWindowFocusChanged</code>方法也会同时被调用，可以重写里面的内容，使之计算<code>View</code>的宽高。</p><p><strong>注意</strong>：<code>onWindowFocusChanged</code>方法会在<code>View</code>已经初始化完毕后才开始调用。</p></li><li><p><code>view.post(runnable)</code></p><p>通过<code>post</code>可以将一个<code>runnable</code>投递都消息队列的尾部，然后等待<code>Looper</code>调用此<code>runnable</code>的时候，<code>View</code>也已经初始化好了。</p></li><li><p><code>ViewTreeObserver</code></p><p><code>ViewTreeObserver</code>中的众多回调可以完成这个功能。</p><p>比如<code>OnGlobalLayoutListener</code>接口，当<code>View</code>树的状态发生改变或者<code>View</code>树内部的<code>View</code>的可见性发生改变的时候，<code>onGlobalLayout</code>方法将被回调，此时就可以获取<code>View</code>的宽高了。</p></li><li><p><code>view.measure(int widthMeasureSpec, int heightMeasureSpec)</code></p><p>可以主动调用该方法开始计算<code>view</code>的宽高。</p><ol><li><p><strong><code>match_parent</code></strong></p><p>由于正常的<code>measure</code>过程中，我们需要父容器的<code>MeasureSpec</code>的值，而此时父容器并没开始计算，我们无从得知这两个值的大小。故我们无法对<code>match_parent</code>的<code>view</code>计算其宽高。</p></li><li><p><strong><code>dp</code>&#x2F;<code>px</code></strong></p><p>因为有精确的数值了，所以我们可以直接使用这个精确的数值通过<code>MeasureSpec.makeMeasureSpec</code>方法构建<code>view</code>的<code>MeasureSpec</code>。</p></li><li><p><strong><code>wrap_content</code></strong></p><p>直接将<code>MeasureSpec.makeMeasureSpec</code>方法中参数的值设置为<code>(1&lt;&lt;30)-1</code>即可，这是<code>View</code>理论上可以支持的最大值，所以这样构建<code>MeasureSpec</code>是合理的。</p></li></ol></li></ol><h2 id="layout过程"><a href="#layout过程" class="headerlink" title="layout过程"></a><code>layout</code>过程</h2><p><code>layout</code>的作用是<code>ViewGroup</code>用来确定子元素的位置。当调用一个<code>View</code>的<code>layout</code>方法时，它会在<code>layout</code>方法中通过<code>setFrame</code>方法确定自身的位置，然后调用<code>onLayout</code>方法确定子元素的位置。</p><p>在<code>onLayout</code>方法中，会遍历所有子元素，对它们计算各自的位置后，调用子元素的<code>layout</code>方法，完成一轮<code>layout</code>过程。</p><p><code>View</code>中实现了<code>layout</code>方法，但是由于<code>onLayout</code>的实现与不同<code>View</code>各自的布局有关，所以源码中仅给出了一个空<code>onLayout</code>方法。需要每个<code>View</code>和<code>ViewGroup</code>自己去重写。</p><p><strong>注意</strong>：单一<code>View</code>一般不需要重写<code>onLayout</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Assign a size and position to a view and all of its</span><br><span class="hljs-comment"> * descendants</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;This is the second phase of the layout mechanism.</span><br><span class="hljs-comment"> * (The first is measuring). In this phase, each parent calls</span><br><span class="hljs-comment"> * layout on all of its children to position them.</span><br><span class="hljs-comment"> * This is typically done using the child measurements</span><br><span class="hljs-comment"> * that were stored in the measure pass().&lt;/p&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Derived classes should not override this method.</span><br><span class="hljs-comment"> * Derived classes with children should override</span><br><span class="hljs-comment"> * onLayout. In that method, they should</span><br><span class="hljs-comment"> * call layout on each of their children.&lt;/p&gt;</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> * 为视图及其所有子体指定大小和位置</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 这是布局机制的第二阶段。</span><br><span class="hljs-comment"> * （第一个是测量）。在此阶段中，每个父级调用其所有子级上的layout来定位它们。</span><br><span class="hljs-comment"> * 这通常使用存储在方法pass()中的子测量值来完成。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 派生类不应重写此方法。</span><br><span class="hljs-comment"> * 具有子级的派生类应重写onLayout。在该方法中，他们应该对每个子对象调用布局。  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLayout</span><span class="hljs-params">(<span class="hljs-type">boolean</span> changed, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> top, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> bottom)</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="draw过程"><a href="#draw过程" class="headerlink" title="draw过程"></a><code>draw</code>过程</h2><p><code>draw</code>过程就比较简单，它的作用是将<code>View</code>绘制到屏幕上面。</p><p><code>View</code>的绘制过程遵循以下的4步：</p><ol><li>绘制背景：<code>background.draw(canvas)</code></li><li>绘制自己：<code>onDraw</code>方法</li><li>绘制children：<code>dispatchDraw</code>方法</li><li>绘制装饰：<code>onDrawScrollBars</code>方法</li></ol><p>所有的绘制过程都在<code>draw</code>方法中进行。</p><p>其中，<code>View</code>绘制过程的传递是通过<code>dispatchDraw</code>方法实现的，<code>dispatchDraw</code>方法会遍历所有的子元素并调用他们的<code>draw</code>方法，完成一轮的<code>draw</code>过程。</p><p><strong>注意</strong>：</p><ol><li>单一<code>View</code>需要重写<code>onDraw</code>方法绘制自身。</li><li><code>ViewGroup</code>需要重写<code>onDraw</code>方法绘制自身以及遍历子元素对它们进行绘制。</li></ol><h2 id="View的工作流程图"><a href="#View的工作流程图" class="headerlink" title="View的工作流程图"></a>View的工作流程图</h2><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-3d1255a5093de81fd5bdc27a300d2f0d_720w.jpg"></p><h1 id="TODO：自定义View"><a href="#TODO：自定义View" class="headerlink" title="TODO：自定义View"></a><em>TODO</em>：自定义<code>View</code></h1>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 动画深入分析</title>
    <link href="/posts/89ece43bd0a9/"/>
    <url>/posts/89ece43bd0a9/</url>
    
    <content type="html"><![CDATA[<h1 id="动画的三个分类"><a href="#动画的三个分类" class="headerlink" title="动画的三个分类"></a>动画的三个分类</h1><ol><li><code>View</code> 动画</li><li>帧动画</li><li>属性动画</li></ol><span id="more"></span><hr><h1 id="View动画"><a href="#View动画" class="headerlink" title="View动画"></a><code>View</code>动画</h1><h2 id="四个动画效果"><a href="#四个动画效果" class="headerlink" title="四个动画效果"></a>四个动画效果</h2><p><code>View</code>动画的作用对象是<code>View</code>，它有四个动画效果：平移动画、缩放动画、旋转动画、透明度动画。</p><p><code>View</code>动画的四个变化效果对应着<code>Animation</code>的四个子类：</p><ol><li>平移动画：<code>TranslateAnimation</code>，<code>XML</code>中对应的标签为<code>&lt;translate&gt;</code></li><li>缩放动画：<code>ScaleAnimation</code>，<code>XML</code>中对应的标签为<code>&lt;scale&gt;</code></li><li>旋转动画：<code>RotateAnimation</code>，<code>XML</code>中对应的标签为<code>&lt;rotate&gt;</code></li><li>透明度动画：<code>AlphaAnimation</code>，<code>XML</code>中对应的标签为<code>&lt;alpha&gt;</code></li></ol><h2 id="lt-set-gt-标签"><a href="#lt-set-gt-标签" class="headerlink" title="&lt;set&gt;标签"></a><code>&lt;set&gt;</code>标签</h2><p><code>&lt;set&gt;</code>标签表示动画的集合，对应着<code>AnimationSet</code>类，其中可以包含着若干的动画，也可以有子动画。</p><p>标签有两个属性：</p><ol><li><code>android:interpolator=&quot;@anim/...&quot;</code>：选定集合所使用的插值器。</li><li><code>android:shareInterpolator=[&quot;true&quot;|&quot;false&quot;]</code>：是否让集合中的动画和集合使用相同的插值器，如果为<code>false</code>，则需要为每一个动画指定一个插值器。</li></ol><h2 id="自定义View动画"><a href="#自定义View动画" class="headerlink" title="自定义View动画"></a>自定义<code>View</code>动画</h2><p>通过继承抽象类<code>Animation</code>，并重写其中的<code>intialize</code>和<code>applyTransformation</code>方法。</p><p><code>intialize</code>方法做初始化工作。</p><p><code>applyTransformation</code>方法中进行相应的矩阵变换，很多时候需要采用<code>Camera</code>类来简化矩阵变换的过程。</p><h2 id="View动画的特殊使用场景"><a href="#View动画的特殊使用场景" class="headerlink" title="View动画的特殊使用场景"></a><code>View</code>动画的特殊使用场景</h2><h3 id="LayoutAnimation"><a href="#LayoutAnimation" class="headerlink" title="LayoutAnimation"></a><code>LayoutAnimation</code></h3><p><code>LayoutAnimation</code>作用于<code>ViewGroup</code>，为<code>ViewGroup</code>指定一个动画，这样当这个<code>ViewGroup</code>的子元素出场时都会具有这个动画效果。</p><p>常常被用在<code>ListView</code>中，让其中的<code>item</code>在出场时都具有动画效果。</p><p><strong>使用步骤：</strong></p><ol><li><p>在<code>XML</code>中定义<code>LayoutAnimation</code>，标签为<code>&lt;layoutAnimation&gt;</code>。其中有两个参数：<code>android:delay</code>和<code>android:animationOrder</code>。两者的作用如下：</p><ol><li><code>android:delay</code>：使子元素的出场时间向后延迟指定的时间，单位为毫秒。</li><li><code>android:animationOrder</code>：指定子元素的出场顺序。有三种选项：<code>normal</code>顺序出场、<code>reverse</code>逆序出场、<code>random</code>随机出场。</li></ol></li><li><p>在<code>XML</code>中指定出场时的动画。</p></li><li><p>在<code>XML</code>中的<code>ViewGroup</code>部分使用<code>android:layoutAnimation</code>参数指定第1步中的<code>LayoutAnimation</code>文件，便可以为<code>ViewGroup</code>中的子元素指定出场动画。</p><p>除了可以在<code>XML</code>中指定<code>ViewGroup</code>的<code>android:layoutAnimation</code>属性，也可以在代码中通过<code>LayoutAnimationController</code>来实现。</p></li></ol><h3 id="Activity的切换效果"><a href="#Activity的切换效果" class="headerlink" title="Activity的切换效果"></a><code>Activity</code>的切换效果</h3><p><code>View</code>动画也可以对<code>Activity</code>的切换效果进行设置，效果如<code>Navigation</code>的<code>Fragment</code>切换效果。</p><p>这个效果是可以自定义的，我们可以通过<code>overridePendingTransition(int enterAnim, int exitAnim)</code>方法，这个方法<code>startActivity(Intent intent)</code>函数或者<code>finish()</code>函数之后被调用才能生效，否则动画效果将不起作用。</p><p>两个参数分别是设置的<strong>入场动画</strong>和<strong>退场动画</strong>的资源Id。</p><p>使用方法例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(...);<br>startActivity(intent);<br>overridePendingTransition(R.anim.enter_anim, R.anim.exit_anim);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finish</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>.finish();<br>    overridePendingTransition(R.anim.enter_anim, R.anim.exit_anim);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Fragment的切换效果"><a href="#Fragment的切换效果" class="headerlink" title="Fragment的切换效果"></a><code>Fragment</code>的切换效果</h3><p>由于<code>Fragment</code>类是在<code>API11</code>中才被新加入的，所以我们使用<code>support-v4</code>这个兼容包。</p><p>我们使用<code>FragmentTransaction</code>类中的<code>setCustomAnimation()</code>方法来添加切换动画，该处的动画<strong>需要是<code>View</code>动画</strong>，而<strong>不能是属性动画</strong>。</p><hr><h1 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h1><p>通过<code>&lt;animation-list&gt;</code>标签，并在其中预设好一组图片，类似于电影的播放，按顺序依次播放。</p><p>系统中提供<code>AnimationDrawable</code>类来使用帧动画。</p><p>应避免使用尺寸较大的图片，以防止<code>OOM</code>的发生。</p><hr><h1 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h1><p>属性动画<strong>可以对任意对象的属性进行动画</strong>而不仅仅是<code>View</code>。</p><p>动画的默认时间间隔为<code>300ms</code>，默认的帧率为<code>10ms/帧</code>。</p><p>达到的效果是：在一个时间间隔内完成对象从一个属性值到另一个属性值的改变。</p><p>常用的几个动画类是：<code>ValueAnimator</code>、<code>ObjectAnimator</code>和<code>AnimatorSet</code>。</p><p>其中，<code>ObjectAnimator</code>继承自<code>ValueAnimator</code>，<code>AnimatorSet</code>是动画集合，可以定义一组动画。</p><h2 id="Nineoldandroids"><a href="#Nineoldandroids" class="headerlink" title="Nineoldandroids"></a><code>Nineoldandroids</code></h2><p><code>API11</code>前，可以使用<code>nineoldandroids</code>开源动画库完成类似属性动画的效果，其使用的语法与<code>API11</code>后属性动画的语法完全一致，不同的是，<code>nineoldandroids</code>通过<code>View</code>动画来完成属性动画的效果。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>属性动画可以通过代码的方式完成，也可以在<code>XML</code>文件中定义。属性动画需要定义在<code>res/animator</code>中。</p><p>上述三个动画类在<code>XML</code>文件中的表示方式如下：</p><h3 id="AnimatorSet"><a href="#AnimatorSet" class="headerlink" title="AnimatorSet"></a><code>AnimatorSet</code></h3><p>对应的标签为<code>&lt;set&gt;</code>。</p><p>其中的属性<code>android:ordering=[&quot;together&quot;|&quot;sequentially&quot;]</code>有两个可选值：</p><ol><li><code>together</code>表示集合中所有的子动画同时播放。</li><li><code>sequentially</code>表示集合中的子动画依次播放。</li></ol><h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a><code>ObjectAnimator</code></h3><p>对应的标签为<code>&lt;objectAnimator&gt;</code>。</p><p>部分属性即解释如下：</p><ul><li><p><code>android:propertyName=&quot;string&quot;</code>：表示属性动画的作用对象的属性的名称。</p></li><li><p><code>android:startOffset=&quot;int&quot;</code>：表示动画的延迟时间，当动画开始后，需要延迟多少毫秒才会真正播放此动画。</p></li><li><p><code>android:repeatCount=&quot;int&quot;</code>：表示动画的重复次数，默认值为<code>0</code>，<code>-1</code>表示无限循环。</p></li><li><p><code>android:repearMode=[&quot;restart&quot;|&quot;reverse&quot;]</code>：表示动画的重复模式。</p><ul><li><code>&quot;restart&quot;</code>表示连续重复，即每次都重新开始播放。</li><li><code>&quot;reverse&quot;</code>表示逆向重复，即第一次正放动画，第二次倒放动画，第三次正放动画，第四次倒放动画，如此反复。</li></ul></li><li><p><code>&quot;android:valueType=[&quot;intType&quot;|&quot;floatType&quot;]</code>：表示<code>android:perpertyName</code>所指定的属性的类型，如果指定的属性为颜色，那么不需要指定该属性，系统会自动对颜色类型的属性做处理。</p></li></ul><h3 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a><code>ValueAnimator</code></h3><p>对应的标签为<code>&lt;animator&gt;</code></p><p>其属性比<code>ObjectAnimator</code>少了一个<code>android:perpertyName</code>，其余的属性都是一样的，故不多介绍。</p><h2 id="理解插值器和估值器"><a href="#理解插值器和估值器" class="headerlink" title="理解插值器和估值器"></a>理解插值器和估值器</h2><p>插值器和估值器是实现非匀速动画的重要手段。</p><h3 id="TimeInterpolator"><a href="#TimeInterpolator" class="headerlink" title="TimeInterpolator"></a><code>TimeInterpolator</code></h3><p>时间插值器。作用为<strong>根据时间的流逝的百分比计算当前属性值改变的百分比</strong>。</p><p>预设的有多种插值器，常见的三种如下：</p><ol><li><code>LinearInterpolator</code>——线性插值器：匀速动画</li><li><code>AccelerateDecelerateInterpolator</code>——加速减速插值器：动画两头慢中间快</li><li><code>DecelerateInterpolator</code>——减速插值器：动画越来越慢</li></ol><p>三个类都实现了<code>Interpolator</code>接口，接口内部只有一个用来计算属性值的改变的百分比的<code>getInterpolation</code>方法需要实现。</p><h3 id="TypeEvaluator"><a href="#TypeEvaluator" class="headerlink" title="TypeEvaluator"></a><code>TypeEvaluator</code></h3><p>类型估值算法，也叫估值器。作用是<strong>根据属性值改变的百分比来计算改变后的属性值</strong>。</p><p>系统预置的有3种：</p><ol><li><code>IntEvaluator</code>：针对整形属性</li><li><code>FloatEvaluator</code>：针对浮点型属性</li><li><code>ArgbEvaluator</code>：针对Color属性</li></ol><p>三个类都实现了<code>TypeEvalator</code>接口，接口内部只有一个用来计算改变后的属性值的<code>evaluate</code>方法需要实现。</p><h3 id="计算顺序"><a href="#计算顺序" class="headerlink" title="计算顺序"></a>计算顺序</h3><p>系统会根据当前的帧所在时刻与动画播放的总时间求出时间的流逝的百分比，再通过插值器计算出当前属性值改变的百分比，后用此值通过估值器计算出当前的属性改变后的确定的值是多少并通过<code>set</code>方法对属性赋值。</p><p>故属性动画要求对象的该属性有<code>set</code>方法（必须有）和<code>get</code>方法（可选）。</p><h3 id="自定义插值器和估值器"><a href="#自定义插值器和估值器" class="headerlink" title="自定义插值器和估值器"></a>自定义插值器和估值器</h3><p>我们可以自定义插值器和估值器，来实现自己想要的动画效果。实现方式也很简单。</p><p>因为插值器和估值器都是一个接口，且内部都只有一个方法，所以我们只需要派生一个类并实现接口就可以了，然后就可以做出千奇百怪的动画效果了。即：</p><ul><li>自定义插值器需要实现<code>Interpolator</code>或者<code>TimeInterpolator</code>接口</li><li>自定义估值器需要实现<code>TypeEvaluator</code>接口。</li></ul><h2 id="属性动画的监听器"><a href="#属性动画的监听器" class="headerlink" title="属性动画的监听器"></a>属性动画的监听器</h2><p>监听器用于监听动画的播放过程，主要有两个接口：<code>AnimatorUpdateListener</code>和<code>AnimatorListener</code>。</p><h3 id="AnimatorUpdateListener"><a href="#AnimatorUpdateListener" class="headerlink" title="AnimatorUpdateListener"></a><code>AnimatorUpdateListener</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AnimatorUpdateListener</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimationUpdate</span><span class="hljs-params">(ValueAnimator animation)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该接口会监听整个动画过程，即每播放一帧，<code>onAnimationUpdate</code>就会被调用一次。</p><h3 id="AnimatorListener"><a href="#AnimatorListener" class="headerlink" title="AnimatorListener"></a><code>AnimatorListener</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AnimatiorListener</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimatorStart</span><span class="hljs-params">(Animator animation)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimatorEnd</span><span class="hljs-params">(Animator animation)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimatorCancel</span><span class="hljs-params">(Animator animation)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimatorRepeat</span><span class="hljs-params">(Animator animation)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该接口会监听动画的开始、结束、取消以及重复播放。同时为了方便开发，系统还提供了<code>AnimatorListenerAdapter</code>这个类，它是<code>AnimatorListener</code>的适配器类，这样我们就可以有选择地实现上面的4个方法了。</p><h2 id="对任意属性做动画"><a href="#对任意属性做动画" class="headerlink" title="对任意属性做动画"></a>对任意属性做动画</h2><p>属性动画<strong>可以对任意对象的属性进行动画</strong>而不仅仅是<code>View</code>。</p><h3 id="属性动画的工作流程"><a href="#属性动画的工作流程" class="headerlink" title="属性动画的工作流程"></a>属性动画的工作流程</h3><p>属性动画要求动画作用的对象提供该属性的<code>set</code>方法，属性动画根据你传递的该属性的初始值和最终值，以动画的效果多次去调用<code>set</code>方法。每次传递给<code>set</code>方法的值都不一样，确切来说是随着时间的推移，所传递的值越来越接近最终值。如果动画的时候没有传递初始值，那么还要提供<code>get</code>方法，因为系统要去获取属性的初始值。即：</p><ul><li><p>必须要有该属性的<code>set</code>方法（如果这条不满足则会无效果）</p></li><li><p>如果没有传递初始值，那么必须要有该属性的<code>get</code>方法（如果这条不满足则程序直接Crash）</p></li></ul><h3 id="动画不生效时的解决方法"><a href="#动画不生效时的解决方法" class="headerlink" title="动画不生效时的解决方法"></a>动画不生效时的解决方法</h3><p>当有些对象的内部并没有该属性的<code>set</code>方法时，动画会无效果，那么我们有三个方法去解决这个问题：</p><ol><li><p><strong>如果有权限的话，直接给对象加上<code>get</code>和<code>set</code>方法</strong></p><p>很多时候，我们是没有权限的去添加方法的，比如我们给<code>Button</code>或者<code>TextView</code>等等，因为这些都是Android SDK内部实现的，我们无法更改。</p></li><li><p><strong>用一个类来包装原始对象，间隔为其提供<code>get</code>和<code>set</code>方法</strong></p><p>因为属性动画可以对任意对象进行动画，所以我们可以用一个类来包装原始对象，并在该类中为原始对象提供<code>get</code>和<code>set</code>方法。</p><p>然后对该类进行属性动画，即可修改原始对象的属性值。</p></li><li><p><strong>利用<code>ValueAnimator</code>，监听动画过程，自己实现属性的改变</strong></p><p>使用<code>AnimatorUpdateListener</code>接口监听整个动画过程，在其中的<code>onAnimationUpdate</code>方法中，对每一帧通过调用插值器和估值器计算当前的属性值，并通过<code>set</code>方法直接为该属性赋值，实现属性的改变。</p></li></ol><p><strong>注：自己写的<code>set</code>方法中，在对属性值进行修改后，需要调用<code>view.requestLayout()</code>方法重绘界面，否则无法显示更改后的界面。</strong></p><h2 id="属性动画的工作原理"><a href="#属性动画的工作原理" class="headerlink" title="属性动画的工作原理"></a>属性动画的工作原理</h2><p><code>ObjectAnimatior#start</code>方法会调用其父类<code>ValueAnimator#start</code>方法，在父类的<code>start</code>方法中会调用<code>AnimationHandler#start</code>方法，<code>AnimationHandler</code>是一个<code>Runnable</code>，我已属性动画需要运行在有<code>Looper</code>的线程中。</p><p>中间通过一系列的方法调用，然后会使用<code>ValueAnimator#doAnimationFrame</code>方法，在此方法中又调用了<code>animationFrame</code>方法，内部又调用了<code>animateValue</code>方法，其中的<code>calculateValue</code>方法就是计算每帧动画所对应的属性的值，其中的<code>setupValue</code>方法通过反射调用对象的<code>get</code>方法，<code>setAnimationValue</code>方法通过反射的方式调用了对象的<code>set</code>方法。</p><hr><h1 id="使用动画的注意事项"><a href="#使用动画的注意事项" class="headerlink" title="使用动画的注意事项"></a>使用动画的注意事项</h1><p><strong>来源：《Android开发艺术探索》</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/Android动画深入分析.png" style="zoom:75%;" />]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Animation</tag>
      
      <tag>属性动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Drawable 解析</title>
    <link href="/posts/da60d3fddfed/"/>
    <url>/posts/da60d3fddfed/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><code>Drawable</code>是一个抽象类，表示的是一个图像的概念。每一个具体的<code>Drawable</code>都是其子类。</p><p><strong>优点：</strong></p><ol><li>使用简单，比自定义<code>View</code>的成本要低。</li><li>非图片类型的<code>Drawable</code>占用空间较小，可以有效的减少<code>apk</code>的大小。</li></ol><p> <strong>内部宽&#x2F;高：</strong></p><p><code>Drawable</code>有个参数比较重要，就是<strong>内部宽&#x2F;高</strong>，通过<code>getIntrinsicWidth</code>和<code>getIntrinsicHeight</code>方法获得。</p><p>但是并不是所有的<code>Drawable</code>都有这两个参数，比如纯颜色的<code>Drawable</code>就没有内部宽&#x2F;高的概念，它的两个值都为<code>-1</code>，它的大小就是<code>View</code>的大小，而图片类型的<code>Drawable</code>的内部宽&#x2F;高决定了这个图片的固定大小。</p><h1 id="Drawable的分类"><a href="#Drawable的分类" class="headerlink" title="Drawable的分类"></a><code>Drawable</code>的分类</h1><p><code>Drawable</code>的子类有许多，这里简单的说几个，具体的参数参考《Android开发艺术探索》Page 244。</p><ul><li><p><code>BitmapDrawable</code></p><p>表示一张图片。</p></li><li><p><code>NinePatchDrawable</code></p><p>表示一个.9格式的图片。</p></li><li><p><code>ShapeDrawable</code></p><p>表示通过颜色（纯色、渐变色）来表示的图形。</p></li><li><p><code>LayerDrawable</code></p><p><code>XML</code>中的标签为<code>&lt;layer-list&gt;</code>，表示的是一组层次化的<code>Drawable</code>集合，最终的效果是由上到下的<code>Drawable</code>的效果依次叠加。</p></li><li><p><code>StateListDrawable</code></p><p><code>XML</code>中的标签为<code>&lt;selector&gt;</code>，表示一个<code>Drawable</code>集合，每个<code>Drawable</code>对应着<code>View</code>的一种状态，系统会根据<code>View</code>的不同状态更换不同的<code>Drawable</code>。常见的使用场景为<code>Button</code>的按下与弹起。</p></li><li><p><code>LevelListDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;level-list&gt;</code>，表示的是一个<code>Drawable</code>集合，其中的每一个<code>Drawable</code>都有一个等级(<code>level</code>)的概念，系统在不同的<code>level</code>下自动更换为不同的<code>Drawable</code>。</p></li><li><p><code>TransitionDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;transition&gt;</code>，其作用是实现两个<code>Drawable</code>之间的淡入淡出效果。</p></li><li><p><code>InsetDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;inset&gt;</code>，可以将其他的<code>Drawable</code>内嵌到自己的<code>Drawable</code>中，并在四周留出一定的空间。其最终显示效果为内嵌的<code>Drawable</code>的显示范围相较于不使用<code>InsetDrawable</code>时变小。</p></li><li><p><code>ScaleDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;scale&gt;</code>，其可以根据自身<code>Drawable</code>所设置的等级(<code>level</code>)对其内部的<code>Drawable</code>实现缩放的效果。</p><p>当其<code>level</code>为<code>0</code>时，其内部的<code>Drawable</code>为不可见状态；为非<code>0</code>的值时，按照<code>XML</code>中的写入的缩放比例进行显示。</p><p><code>level</code>的值默认为<code>0</code>，需要在代码中自行赋值，**系统内部约定<code>Drawable</code>的等级范围为<code>0</code>-<code>10000</code>**。</p></li><li><p><code>ClipDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;clip&gt;</code>，可以根据自己当前的等级(<code>level</code>)来裁剪另一个<code>Drawable</code>，裁剪的方向可以通过<code>android:clipOrientation</code>和<code>android:gravity</code>共同限制。</p><p>当其<code>level</code>的值为<code>0</code>时，表示完全裁剪，即整个<code>Drawable</code>变为不可见的状态；当<code>level</code>的值设置为<code>10000</code>时，表示不裁剪；</p><p>当<code>level</code>的值设置为<code>8000</code>时，表示裁剪了2000的区域，即裁剪<code>20%</code>。 m</p></li></ul><h1 id="自定义Drawable"><a href="#自定义Drawable" class="headerlink" title="自定义Drawable"></a>自定义<code>Drawable</code></h1><p><code>Drawable</code>的使用场景很少，通常用在<code>View</code>的背景和作为<code>ImageView</code>中的图片两个场景。</p><p>由于自定义的<code>Drawable</code>无法在<code>XML</code>中使用，但是我们可以有其他轻便的方法来自定义<code>Drawable</code>。</p><p>通过<code>View</code>的工作原理可以知道，系统通过<code>Drawable</code>的<code>draw</code>方法来绘制<code>View</code>的背景，所以我们可以继承<code>Drawable</code>并重写<code>Drawable</code>的<code>draw</code>方法来实现自定义<code>Drawable</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Drawable</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal 解析 [转载]</title>
    <link href="/posts/03160a3be19b/"/>
    <url>/posts/03160a3be19b/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/61652864">Android进阶知识：ThreadLocal - Android架构</a></li></ul></blockquote><hr><h3 id="ThreadLocal是什么？"><a href="#ThreadLocal是什么？" class="headerlink" title="ThreadLocal是什么？"></a><code>ThreadLocal</code>是什么？</h3><p><code>ThreadLocal</code> 是一个线程内部数据存储类，通过它可以在指定的线程中存储数据。存储后，只能在指定的线程中获取到存储的数据，对其他线程来说无法获取到数据。</p><h3 id="ThreadLocal的使用场景"><a href="#ThreadLocal的使用场景" class="headerlink" title="ThreadLocal的使用场景"></a><code>ThreadLocal</code>的使用场景</h3><p>日常使用场景不多，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，可以考虑使用<code>ThreadLocal</code>。 <code>Android</code>源码的<code>Lopper</code>、<code>ActivityThread</code>以及<code>AMS</code>中都用到了<code>ThreadLocal</code>。</p><h3 id="ThreadLocal的使用示例"><a href="#ThreadLocal的使用示例" class="headerlink" title="ThreadLocal的使用示例"></a><code>ThreadLocal</code>的使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>    <span class="hljs-keyword">private</span> ThreadLocal&lt;String&gt; name = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_thread_local);<br>        name.set(<span class="hljs-string">&quot;小明&quot;</span>);<br>        Log.d(<span class="hljs-string">&quot;ThreadLocalActivity&quot;</span>, <span class="hljs-string">&quot;Thread:&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; name:&quot;</span> + name.get());<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;thread1&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                name.set(<span class="hljs-string">&quot;小红&quot;</span>);<br>                Log.d(<span class="hljs-string">&quot;ThreadLocalActivity&quot;</span>, <span class="hljs-string">&quot;Thread:&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; name:&quot;</span> + name.get());<br>            &#125;<br>        &#125;.start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;thread2&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                Log.d(<span class="hljs-string">&quot;ThreadLocalActivity&quot;</span>, <span class="hljs-string">&quot;Thread:&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; name:&quot;</span> + name.get());<br>            &#125;<br>        &#125;.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">D</span><span class="hljs-operator">/</span><span class="hljs-variable">ThreadLocalActivity</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span><span class="hljs-variable">main</span> <span class="hljs-variable">name</span><span class="hljs-operator">:</span>小明  <br><span class="hljs-built_in">D</span><span class="hljs-operator">/</span><span class="hljs-variable">ThreadLocalActivity</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span><span class="hljs-variable">thread1</span> <span class="hljs-variable">name</span><span class="hljs-operator">:</span>小红  <br><span class="hljs-built_in">D</span><span class="hljs-operator">/</span><span class="hljs-variable">ThreadLocalActivity</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span><span class="hljs-variable">thread2</span> <span class="hljs-variable">name</span><span class="hljs-operator">:</span><span class="hljs-variable">null</span><br></code></pre></td></tr></table></figure><p>可以看到虽然访问的是同一个<code>ThreadLocal</code>对象，但是获取到的值却是不一样的。</p><h3 id="ThreadLocal的源码阅读"><a href="#ThreadLocal的源码阅读" class="headerlink" title="ThreadLocal的源码阅读"></a><code>ThreadLocal</code>的源码阅读</h3><p>那么为什么会造成这样的结果呢？这就需要去看看<code>ThreadLocal</code>的源码实现，这里的源码版本为<code>API28</code>。主要看它的<code>get</code>和<code>set</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>set</code>方法中首先获取了当前线程对象，然后通过<code>getMap</code>方法传入当前线程<code>t</code>获取到一个<code>ThreadLocalMap</code>，接下来判断这个<code>map</code>是否为空，不为空就直接将当前<code>ThreadLocal</code>作为<code>key</code>，<code>set</code>方法中传入要保存的值最为<code>value</code>，存放到<code>map</code>中；如果<code>map</code>为空就调用<code>createMap</code>方法创建一个<code>map</code>并同样将当前<code>ThreadLocal</code>和要保存的值作为<code>key</code>和<code>value</code>加入到<code>map</code>中。<br> 接下先看<code>getMap</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getMap</code>方法比较简单，就是返回从传入的当前线程对象的成员变量<code>threadLocals</code>。 接着是<code>createMap</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>createMap</code>方法也很简单就是<code>new</code>了一个<code>ThreadLocalMap</code>并赋给当前线程对象<code>t</code>中的<code>threadLocals</code>。 原来这个<code>Map</code>是存放在<code>Thread</code>类中的。于是进入<code>Thread</code>类中查看。<br> <code>Thread.java</code>第188-190行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="hljs-comment"> * by the ThreadLocal class. */</span><br>ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>根据这里的注释可以得知，每个线程<code>Thread</code>中都有一个<code>ThreadLocalMap</code>类型的<code>threadLocals</code>成员变量来保存数据，通过<code>ThreadLocal</code>类来进行维护。这样看来我们每次在不同线程调用<code>ThreadLocal</code>的<code>set</code>方法<code>set</code>的数据是存在不同线程的<code>ThreadLocalMap</code>中的，就像注释说的<code>ThreadLocal</code>只是起了个维护<code>ThreadLocalMap</code>的功能。想到是<code>get</code>方法同样也是到不同线程的<code>ThreadLocalMap</code>去取数据。<br> <code>get</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>果然，<code>get</code>方法中同样是先获取当前线程对象，然后在拿着这个对象<code>t</code>去获取到<code>t</code>中的<code>ThreadLocalMap</code>，只要<code>map</code>不等于<code>null</code>就调用<code>map.getEntry(this)</code>方法来获取数据，因为<code>ThreadLocalMap</code>里使用一个内部类<code>Entry</code>来存储数据的，所以调用<code>getEntry(this)</code>方法，传入的<code>key</code>是当前的<code>ThreadLocal</code>。这样获取到<code>Entry</code>类型数据<code>e</code>，只要<code>e</code>不为<code>null</code>，返回<code>e.value</code>即先前存储的数据。如果获取到的<code>map</code>为<code>null</code>又或者根据<code>key</code>获取<code>Entry</code>为<code>null</code>，就调用<code>setInitialValue</code>方法初始化一个<code>value</code>返回。<br> <code>setInitialValue</code>和<code>initialValue</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>setInitialValue</code>方法中首先调用<code>initialValue</code>方法初始化了一个空<code>value</code>，之后的操作和<code>set</code>方法相同，将这个空的<code>value</code>加入到当前线程的<code>ThreadLocalMap</code>中去，<code>ThreadLocalMap</code>为空就创建个<code>Map</code>，最后返回这个空值。<br> 至此，<code>ThreadLocal</code>的<code>get</code>、<code>set</code>方法就都看过了，也理解了<code>ThreadLocal</code>可以在多个线程中操作而互不干扰的原因。但是<code>ThreadLocal</code>还有一个要注意的地方就是<code>ThreadLocal</code>使用不当会造成内存泄漏。</p><h3 id="ThreadLocal内存泄漏的原因"><a href="#ThreadLocal内存泄漏的原因" class="headerlink" title="ThreadLocal内存泄漏的原因"></a><code>ThreadLocal</code>内存泄漏的原因</h3><p>内存泄漏的根本原因是当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，导致本该被回收的对象不能被回收而停留在堆内存中。那么<code>ThreadLocal</code>中是在哪里发生的呢？这就要看到<code>ThreadLocalMap</code>中存储数据的内部类<code>Entry</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-built_in">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/91ef76c6a7efce1b563edc5501a900dbb58f6512.jpeg" alt="img"></p><p>可以看到这个<code>Entry</code>类，这里的<code>key</code>是使用了个弱引用，所以因为使用弱引用这里的<code>key</code>，<code>ThreadLocal</code>会在<code>JVM</code>下次<code>GC</code>回收时候被回收，而造成了个<code>key</code>为<code>null</code>的情况，而外部<code>ThreadLocalMap</code>是没办法通过<code>null</code> <code>key</code>来找到对应<code>value</code>的。如果当前线程一直在运行，那么线程中的<code>ThreadLocalMap</code>也就一直存在，而<code>map</code>中却存在<code>key</code>已经被回收为<code>null</code>对应的<code>Entry</code>和<code>value</code>却一直存在不会被回收，造成内存的泄漏。<br> 不过，这一点设计者也考虑到了，在<code>get()</code>、<code>set()</code>、<code>remove()</code>方法调用的时候会清除掉线程<code>ThreadLocalMap</code>中所有<code>Entry</code>中<code>Key</code>为<code>null</code>的<code>Value</code>，并将整个<code>Entry</code>设置为<code>null</code>，这样在下次回收时就能将<code>Entry</code>和<code>value</code>回收。<br> 这样看上去好像是因为<code>key</code>使用了弱引用才导致的内存泄漏，为了解决还特意添加了清除<code>null key</code>的功能，那么是不是不用弱引用就可以了呢？<br> 很显然不是这样的。设计者使用弱引用是由原因的。</p><ul><li>如果使用强引用，那么如果在运行的线程中<code>ThreadLocal</code>对象已经被回收了但是<code>ThreadLocalMap</code>还持有<code>ThreadLocal</code>的强引用，若是没有手动删除，<code>ThreadLocal</code>不会被回收，同样导致内存泄漏。</li><li>如果使用弱引用<code>ThreadLocal</code>的对象被回收了，因为<code>ThreadLocalMap</code>持有的是<code>ThreadLocal</code>的弱引用，即使没有手动删除，<code>ThreadLocal</code>也会被回收。<code>nullkey</code>的<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set</code>、<code>get</code>、<code>remove</code>的时候会被清除。</li></ul><p>所以，由于<code>ThreadLocalMap</code>和线程<code>Thread</code>的生命周期一样长，如果没有手动删除<code>Map</code>的中的<code>key</code>，无论使用强引用还是弱引用实际上都会出现内存泄漏，但是使用弱引用可以多一层保护，<code>null key</code>在下一次<code>ThreadLocalMap</code>调用<code>set</code>、<code>get</code>、<code>remove</code>的时候就会被清除。 因此，<code>ThreadLocal</code>的内存内泄漏的真正原因并不能说是因为<code>ThreadLocalMap的key</code>使用了弱引用，而是因为<code>ThreadLocalMap</code>和线程<code>Thread</code>的生命周期一样长，没有手动删除<code>Map</code>的中的<code>key</code>才会导致内存泄漏。所以解决<code>ThreadLocal</code>的内存泄漏问题就要每次使用完<code>ThreadLocal</code>，都要记得调用它的<code>remove()</code>方法来清除。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20191223161153316.png" alt="在这里插入图片描述" style="zoom:67%;" /><p>总结一波：</p><p>（1）每个Thread维护着一个<code>ThreadLocalMap</code>的引用</p><p>（2）<code>ThreadLocalMap</code>是<code>ThreadLocal</code>的内部类，用Entry来进行存储</p><p>（3）<code>ThreadLocal</code>创建的副本是存储在自己的<code>threadLocals</code>中的，也就是自己的<code>ThreadLocalMap</code>。</p><p>（4）<code>ThreadLocalMap</code>的键值为<code>ThreadLocal</code>对象，而且可以有多个<code>threadLocal</code>变量，因此保存在<code>map</code>中</p><p>（5）在进行<code>get</code>之前，必须先<code>set</code>，否则会报空指针异常，当然也可以初始化一个，但是必须重写<code>initialValue</code>()方法。</p><p>（6）<code>ThreadLocal</code>本身并不存储值，它只是作为一个<code>key</code>来让线程从<code>ThreadLocalMap</code>获取<code>value</code>。</p><p>OK，现在从源码的角度上不知道你能理解不，对于<code>ThreadLocal</code>来说关键就是内部的<code>ThreadLocalMap</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ThreadLocal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/51f783f2dca4/"/>
    <url>/posts/51f783f2dca4/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
