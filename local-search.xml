<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第八章</title>
    <link href="/posts/cecb127ec7d7/"/>
    <url>/posts/cecb127ec7d7/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第八章学习笔记</b></font></center><br><span id="more"></span><h1 id="堆栈帧"><a href="#堆栈帧" class="headerlink" title="堆栈帧"></a>堆栈帧</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 227</p></blockquote><p>堆栈帧 (stack frame)（或活动记录 (activation record)）是一块堆栈保留区域，用于存放<strong>被传递的实际参数</strong>、<strong>子程序的返回值</strong>、<strong>局部变量</strong>以及<strong>被保存的寄存器</strong>。堆栈帧的创建步骤如下所示：</p><ol><li>被传递的实际参数。如果有，则压入堆栈。</li><li>当子程序被调用时，使该子程序的返回值压入堆栈。</li><li>子程序开始执行时，EBP 被压入堆栈。</li><li>设置 EBP 等于 ESP。从这时开始，EBP 就变成了该子程序所有参数的引用基址。</li><li>如果有局部变量，修改 ESP 以便在堆栈中为这些变量预留空间。</li><li>如果需要保存寄存器，就将它们压入堆栈。</li></ol><blockquote><ul><li><code>ESP</code> 用于寻址堆栈（一种系统内存结构）数据。它极少用于一般算术运算和数据传输，通常被称为扩展堆栈指针 (extended stack pointer) 寄存器。</li><li>高级语言通过 <code>EBP</code> 来引用堆栈中的函数参数和局部变量。除了高级编程，它不用于一般算术运算和数据传输。它常常被称为扩展帧指针 (extended frame pointer) 寄存器。</li></ul></blockquote><p>程序内存模式和对参数传递规则的选择直接影响到堆栈帧的结构。</p><p>学习用堆栈传递参数有个好理由：几乎所有的高级语言都会用到它们。比如如果想要在 32 位 Windows 应用程序接口（API）中调用函数，就必须用堆栈传递参数。而 64 位程序可以使用另一种不同的参数传递规则。</p><h2 id="访问堆栈参数"><a href="#访问堆栈参数" class="headerlink" title="访问堆栈参数"></a>访问堆栈参数</h2><p>高级语言有多种方式来对函数调用的参数进行初始化和访问。以 C 和 C++ 语言为例，它们以保存 EBP 寄存器并使该寄存器指向栈顶的语句为开始 (prologue)。然后，根据实际情况，它们可以把某些寄存器入栈，以便在函数返回时恢复这些寄存器的值。在函数结尾 (epilogue) 部分，恢复 EBP 寄存器，并用 RET 指令返回调用者。</p><h2 id="ENTER-指令"><a href="#ENTER-指令" class="headerlink" title="ENTER 指令"></a>ENTER 指令</h2><p>ENTER 指令为被调用过程自动创建堆栈帧。它为局部变量保留堆栈空间，把 EBP 入栈。具体来说，它执行三个操作：</p><ul><li>把 EBP 入栈（<code>push EBP</code>）</li><li>把 EBP 设置为堆栈帧的基址（<code>mov EBP, ESP</code>）</li><li>为局部变量保留空间（<code>sub ESP, numbytes</code>）</li></ul><p>ENTER有两个操作数：第一个是常数，定义为局部变量保存的堆栈空间字节数；第二个定义了过程的词法嵌套级。<br>$$<br>ENTER \space \space numbytes, \space nestinglevel<br>$$<br>这两个操作数都是立即数。Numbytes 总是向上舍人为 4 的倍数，以便 ESP 对齐双字边界。Nestinglevel 确定了从主调过程堆栈帧复制到当前帧的堆栈帧指针的个数。</p><p><font size = 4><b>示例</b></font></p><p>ENTER 指令为局部变量保留了 8 个字节的堆栈空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MySub PROC<br>    enter 8, 0<br></code></pre></td></tr></table></figure><p>它与如下指令等效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MySub PROC<br>    push  ebp<br>    mov   ebp, esp<br>    sub   esp, 8<br></code></pre></td></tr></table></figure><p>下图为执行 ENTER 指令前后的堆栈示意图。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230103180554430.png" alt="" style="zoom: 67%;" /><h2 id="LEAVE-指令"><a href="#LEAVE-指令" class="headerlink" title="LEAVE 指令"></a>LEAVE 指令</h2><p>LEAVE 指令结束一个过程的堆栈帧。它反转了之前的 ENTER 指令操作：恢复了过程被调用时 ESP 和 EBP 的值。再次以 MySub 过程为例，现在可以编码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MySub PROC<br>    enter 8,0<br>    .<br>    .<br>    leave<br>    ret<br>MySub ENDP<br></code></pre></td></tr></table></figure><p>下面是与之等效的指令序列，其功能是在堆栈中保存和删除 8 个字节的局部变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MySub PROC<br>    push  ebp<br>    mov   ebp, esp<br>    sub   esp, 8<br>    .<br>    .<br>    mov   esp, ebp<br>    pop   ebp<br>    ret<br>MySub ENDP<br></code></pre></td></tr></table></figure><h2 id="LOCAL-指令"><a href="#LOCAL-指令" class="headerlink" title="LOCAL 指令"></a>LOCAL 指令</h2><p>不难想象，Microsoft 创建 LOCAL 伪指令是作为 ENTER 指令的高级替补。</p><p>LOCAL 声明一个或多个变量名，并定义其大小属性。（另一方面，ENTER 则只为局部变量保留一块未命名的堆栈空间。）如果要使用 LOCAL 伪指令，它必须紧跟在 PROC 伪指令的后面。其语法如下所示：</p><p>$$<br>LOCAL \space \space varlist<br>$$<br>varlist 是变量定义列表，用逗号分隔表项，可选为跨越多行。每个变量定义采用如下格式：<br>$$<br>label: \space type<br>$$<br>其中，标号可以为任意有效标识符，类型既可以是标准类型（WORD、DWORD等），也可以是用户定义类型。</p><p><font size = 4><b>示例</b></font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">BubbleSort PROC<br>    LOCAL temp: DWORD, SwapFlag: BYTE<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第七章</title>
    <link href="/posts/3941df7fa3bf/"/>
    <url>/posts/3941df7fa3bf/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第七章学习笔记</b></font></center><br><span id="more"></span><h1 id="移位和循环移位指令"><a href="#移位和循环移位指令" class="headerlink" title="移位和循环移位指令"></a>移位和循环移位指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 192</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102210528302.png" alt="" style="zoom:80%;" /><p>移动操作数的位有两种方法。</p><ul><li>第一种是<strong>逻辑移位</strong> (logic shift)，<strong>空出来的位用 0 填充</strong>。如下图所示，一个字节的数据向右移动一位。也就是说，每一位都被移动到其旁边的低位上。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102210741593.png" alt="" style="zoom:67%;" /><ul><li>另一种移位的方法是<strong>算术移位</strong> (arithmetic shift)，空出来的位用原数据的符号位填充。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102210824137.png" alt="" style="zoom:70%;" /><h2 id="SHL-指令"><a href="#SHL-指令" class="headerlink" title="SHL 指令"></a>SHL 指令</h2><p>逻辑左移。SHL 的第一个操作数是目的操作数,第二个操作数是移位次数：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102211036985.png" alt="" style="zoom:70%;" />$$SHL \space \space destination,count$$该指令可用的操作数类型如下所示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SHL reg, imm8<br>SHL mem, imm8<br>SHL reg, CL<br>SHL mem, CL<br></code></pre></td></tr></table></figure><p>x86处理器允许 imm8 为 0～255 中的任何整数。另外，CL 寄存器包含的是移位计数。上述格式同样适用于 SHR、SAL、SAR、ROR、ROL、RCR 和  RCL 指令。</p><h2 id="SHR-指令"><a href="#SHR-指令" class="headerlink" title="SHR 指令"></a>SHR 指令</h2><p>逻辑右移。SHR 的指令格式与 SHL 相同。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102210741593.png" alt="" style="zoom:67%;" /><h2 id="SAL-和-SAR-指令"><a href="#SAL-和-SAR-指令" class="headerlink" title="SAL 和 SAR 指令"></a>SAL 和 SAR 指令</h2><p>SAL(算术左移)指令的操作与SHL指令一样。</p><p>每次移动时，SAL 都将目的操作数中的每一位移动到下一个最高位上。<strong>最低位用0填充</strong>；最高位移入进位标志位，该标志位原来的值被丢弃：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102211511996.png" alt="" style="zoom:70%;" /><p>SAR 指令为算术右移，指令格式与 SHL 相同。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102210824137.png" alt="" style="zoom:70%;" /><h2 id="ROL-指令"><a href="#ROL-指令" class="headerlink" title="ROL 指令"></a>ROL 指令</h2><p>以循环方式来移位即为位元循环 (Bitwise Rotation)。一些操作中，从数的一端移出的位立即复制到该数的另一端。还有一种类型则是把进位标志位当作移动位的中间点。</p><p>ROL（循环左移）指令把所有位都向左移。最高位复制到进位标志位和最低位。该指令格式与 SHL 指令相同：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102212019795.png" alt="image-20230102212019795" style="zoom:80%;" /><p>位循环不会丢弃位。从数的一端循环出去的位会出现在该数的另一端。</p><p><font size = 4><b>特点</b></font></p><ol><li>当循环计数值大于 1 时，进位标志位保存的是最后循环移出 MSB 的位。</li><li>位组交换利用 ROL 可以交换一个字节的高四位(位 4～7)和低四位(位 0～3)。例如，26h 向任何方向循环移动 4 位就变为 62h。当多字节整数以四位为单位进行循环移位时，其效果相当于一次向右或向左移动一个十六进制位。例如，将 6A4Bh 反复循环左移四位，最后就会回到初始值。</li></ol><h2 id="ROR-指令"><a href="#ROR-指令" class="headerlink" title="ROR 指令"></a>ROR 指令</h2><p>ROR（循环右移）指令把所有位都向右移，最低位复制到进位标志位和最高位。该指令格式与 SHL 指令相同。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102212338300.png" alt="" style="zoom:70%;" /><p>当循环计数值大于 1 时，进位标志位保存的是最后循环移出 LSB 的位。</p><h2 id="RCL-和-RCR-指令"><a href="#RCL-和-RCR-指令" class="headerlink" title="RCL 和 RCR 指令"></a>RCL 和 RCR 指令</h2><p>RCL（带进位循环左移）指令把每一位都向左移，进位标志位复制到 LSB，而 MSB 复制到进位标志位：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102212630840.png" alt="" style="zoom:70%;" /><p>RCR（带进位循环右移）指令把每一位都向右移，进位标志位复制到 MSB，而 LSB 复制到进位标志位：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102212743503.png" alt="" style="zoom:70%;" /><h2 id="SHLD-和-SHRD-指令"><a href="#SHLD-和-SHRD-指令" class="headerlink" title="SHLD 和 SHRD 指令"></a>SHLD 和 SHRD 指令</h2><p>SHLD（双精度左移）指令将目的操作数向左移动指定位数。移动形成的空位由源操作数的高位填充。源操作数不变，但是符号标志位、零标志位、辅助进位标志位、奇偶标志位和进位标志位会受影响：<br>$$<br>SHLD \space \space dest, source, count<br>$$<br>下图展示的是 SHLD 执行移动一位的过程。源操作数的最高位复制到目的操作数的最低位上。目的操作数的所有位都向左移动：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102213018857.png" alt="" style="zoom:67%;" /><p>SHRD（双精度右移）指令将目的操作数向右移动指定位数。移动形成的空位由源操作数的低位填充：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102213058864.png" alt="" style="zoom:67%;" /><p>SHLD 和 SHRD 的指令格式中，目标操作数可以是寄存器或内存操作数；<strong>源操作数必须是寄存器</strong>；移位次数可以是 CL 寄存器或者 8 位立即数。</p><h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 200</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102213650659.png" alt="" style="zoom:80%;" /><hr><h1 id="乘法和除法指令"><a href="#乘法和除法指令" class="headerlink" title="乘法和除法指令"></a>乘法和除法指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 201</p></blockquote><h2 id="MUL-指令"><a href="#MUL-指令" class="headerlink" title="MUL 指令"></a>MUL 指令</h2><p>32位模式下，MUL（<strong>无符号数</strong>乘法）指令有三种类型：</p><ul><li>第一种执行 8 位操作数与 <strong>AL 寄存器</strong>的乘法</li><li>第二种执行16位操作数与 <strong>AX 寄存器</strong>的乘法</li><li>第三种执行 32 位操作数与 <strong>EAX 寄存器</strong>的乘法</li></ul><p>乘数和被乘数的大小必须保持一致，<strong>乘积的大小则是它们的一倍</strong>。这三种类型都可以使用寄存器和内存操作数，但不能使用立即数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MUL reg/mem8<br>MUL reg/mem16<br>MUL reg/mem32<br></code></pre></td></tr></table></figure><p>MUL 指令中的单操作数是乘数。下图按照乘数的大小，列出了默认的被乘数和乘积。</p><p>由于目的操作数是被乘数和乘数大小的两倍，因此<strong>不会发生溢出</strong>。</p><p>如果乘积的高半部分不为零，则 MUL 会把<strong>进位标志位和溢出标志位</strong>置 1。因为进位标志位常常用于无符号数的算术运算。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102222115899.png" alt="" style="zoom:80%;" /><p>例如，当 AX 乘以一个 16 位操作数时，乘积存放在 DX 和 AX 寄存器对中。其中，乘积的高 16 位存放在 DX，低 16 位存放在 AX。如果 DX 不等于零，则进位标志位置 1，这就意味着隐含的目的操作数的低半部分容纳不了整个乘积。</p><h2 id="IMUL-指令"><a href="#IMUL-指令" class="headerlink" title="IMUL 指令"></a>IMUL 指令</h2><p>IMUL（有符号数乘法）指令执行有符号整数乘法。与 MUL 指令不同，IMUL 会<strong>保留乘积的符号</strong>，实现的方法是，将乘积低半部分的最高位符号扩展到高半部分。x86指令集支持三种格式的 IMUL 指令:单操作数、双操作数和三操作数。</p><p><font size = 4><b>单操作数格式</b></font></p><p>单操作数格式中，乘数和被乘数大小相同，而乘积的大小是它们的两倍。单操作数格式将乘积存放在 AX、DX:AX 或 EDX: EAX 中：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102224014015.png" style="zoom: 71%;" /><p>和 MUL 指令一样，其乘积的存储大小使得<strong>溢出不会发生</strong>。同时，如果乘积的高半部分不是其低半部分的符号扩展，则进位标志位和溢出标志位置1。利用这个特点可以决定是否忽略乘积的高半部分。</p><p><font size = 4><b>双操作数格式（32位模式）</b></font></p><p>32 位模式中的双操作数 IMUL 指令把乘积存放在第一个操作数中，这个操作数必须是寄存器。第二个操作数（乘数）可以是寄存器、内存操作数和立即数。<br>$$<br>IMUL \space \space reg, \space reg&#x2F;mem&#x2F;imm<br>$$<br>双操作数格式会按照目的操作数的大小来截取乘积。如果被丢弃的是有效位则溢出标志位和进位标志位置 1。因此，在执行了有两个操作数的 IMUL 操作后，必须检查这些标志位中的一个。</p><p><font size = 4><b>三操作数格式</b></font></p><p>32 位模式下的三操作数格式将乘积保存在第一个操作数中。第二个操作数可以是16位寄存器或内存操作数，它与第三个操作数相乘，该操作数是一个8位或16位立即数。<br>$$<br>IMUL \space \space reg, \space reg&#x2F;mem, \space imm<br>$$<br>IMUL 执行时，若乘积有效位被丢弃，则溢出标志位和进位标志位置 1。因此，在执行了有三个操作数的 IMUL 操作后,必须检查这些标志位中的一个。</p><h2 id="DIV-指令"><a href="#DIV-指令" class="headerlink" title="DIV 指令"></a>DIV 指令</h2><p>32 位模式下，DIV（无符号除法）指令执行 8 位、16 位和 32 位无符号数除法。其中，单寄存器或内存操作数是除数。格式如下:<br>$$<br>DIV\space\space reg&#x2F;mem<br>$$<br>下图给出了被除数、除数、商和余数之间的关系：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102234944257.png" style="zoom: 67%;" /><p>64 位模式下，DIV 指令用 RDX:RAX 作被除数，用 64 位寄存器和内存操作数作除数商存放到 RAX，余数存放在 RDX 中。</p><h2 id="IDIV-指令"><a href="#IDIV-指令" class="headerlink" title="IDIV 指令"></a>IDIV 指令</h2><p>IDIV（有符号除法）指令执行有符号整数除法，其操作数与 DIV 指令相同。执行 8 位除法之前，被除数 (AX) 必须完成符号扩展。余数的符号总是与被除数相同。</p><hr><h1 id="扩展加减法"><a href="#扩展加减法" class="headerlink" title="扩展加减法"></a>扩展加减法</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 212</p></blockquote><h2 id="ADC-指令"><a href="#ADC-指令" class="headerlink" title="ADC 指令"></a>ADC 指令</h2><p>ADC（带进位加法）指令将源操作数和进位标志位的值都与目的操作数相加。该指令格式与 ADD 指令一样,且操作数大小必须相同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ADC reg, reg<br>ADC mem, reg<br>ADC reg, mem<br>ADC mem, imm<br>ADC reg, imm<br></code></pre></td></tr></table></figure><h2 id="程序示例-1"><a href="#程序示例-1" class="headerlink" title="程序示例"></a>程序示例</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102235908443.png" style="zoom:60%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102235932603.png" style="zoom:60%;" /><p>下面的代码示例调用 Extended_Add，并向其传递两个 8 字节的整数。要注意为和数多分配一个字节：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230103000107626.png" style="zoom:60%;" /><p>上述程序的输出，加法产生了一个进位：<code>0122C32B0674BB5736</code></p><h2 id="SBB-指令"><a href="#SBB-指令" class="headerlink" title="SBB 指令"></a>SBB 指令</h2><p>SBB（带借位减法）指令从目的操作数中减去源操作数和进位标志位的值。允许使用的操作数与 ADC 指令相同。</p>]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第六章</title>
    <link href="/posts/049b6e9dd143/"/>
    <url>/posts/049b6e9dd143/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第六章学习笔记</b></font></center><br><span id="more"></span><h1 id="布尔和比较指令"><a href="#布尔和比较指令" class="headerlink" title="布尔和比较指令"></a>布尔和比较指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 148</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102144806527.png" alt="" style="zoom:80%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102144839025.png" style="zoom:80%;" /><h2 id="CPU的状态标志"><a href="#CPU的状态标志" class="headerlink" title="CPU的状态标志"></a>CPU的状态标志</h2><p>布尔指令影响零标志、进位标志、符号标志、溢出标志和奇偶标志。</p><ul><li>操作结果等于 0 时，零标志位置 1。</li><li>操作使得目标操作数的最高位有进位时，进位标志位置 1。</li><li>符号标志位是目标操作数高位的副本，如果标志位置 1，表示是负数；标志位清 0，表示是正数。(假设 0 为正)</li><li>指令产生的结果超出了有符号目的操作数范围时，溢出标志位置 1。</li><li>指令使得目标操作数低字节中有偶数个 1 时，奇偶标志位置 1。</li></ul><h2 id="AND-指令"><a href="#AND-指令" class="headerlink" title="AND 指令"></a>AND 指令</h2><p>AND 指令在两个操作数的对应位之间进行（按位）逻辑与 (AND) 操作，<strong>并将结果存放在目标操作数中</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">AND dest, source<br></code></pre></td></tr></table></figure><p>下列是被允许的操作数组合，但是<strong>立即操作数不能超过 32 位</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">AND reg, reg<br>AND reg, mem<br>AND reg, imm<br>AND mem, reg<br>AND mem, imm<br></code></pre></td></tr></table></figure><p>AND 指令总是<strong>清除溢出和进位标志位</strong>，并根据目标操作数的值来修改符号标志位、零标志位和奇偶标志位。</p><h2 id="OR-指令"><a href="#OR-指令" class="headerlink" title="OR 指令"></a>OR 指令</h2><p>OR指令在两个操作数的对应位之间进行（按位）逻辑或 (OR) 操作，并将结果存放在目标操作数中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">OR dest, source<br></code></pre></td></tr></table></figure><p>操作数组合与 AND 指令相同。</p><p>OR 指令总是<strong>清除溢出标志和进位标志</strong>。它根据目的操作数的值修改符号标志、零标志、奇偶标志。</p><h2 id="XOR-指令"><a href="#XOR-指令" class="headerlink" title="XOR 指令"></a>XOR 指令</h2><p>指令在每对操作数的对应数据之间执行异或 (XOR) 操作，格式与 AND 指令相同。</p><p>XOR 指令总是<strong>清除溢出标志和进位标志</strong>，它依据目的操作数的值修改符号标志、零标志和奇偶标志。</p><h2 id="NOT-指令"><a href="#NOT-指令" class="headerlink" title="NOT 指令"></a>NOT 指令</h2><p>NOT 指令将一个操作数中的所有数据位取反，得到的结果成为该操作数的反码。该指令允许下面的操作数据类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">NOT reg<br>NOT mem<br></code></pre></td></tr></table></figure><p><strong>NOT 指令不影响任何状态标志。</strong></p><h2 id="TEST-指令"><a href="#TEST-指令" class="headerlink" title="TEST 指令"></a>TEST 指令</h2><p>TEST 指令在两个操作数的对应数据位之间执行隐式的 AND 操作，并相应设置标志位。</p><p>TEST 指令和 AND 指令之间的<strong>唯一区别</strong>在于 TEST 指令<strong>不会修改目的操作数</strong>。</p><p>TEST 指令的操作数格式与 AND 相同。</p><p>该指令在测试操作数某些位是否被设置时特别有用。</p><p>TEST 指令总是<strong>清除溢出和进位标志位</strong>，其修改符号标志位、零标志位和奇偶标志位的方法与 AND 指令相同。</p><p>从下面的数据集例子中，可以推断只有当所有测试位都清 0 时,零标志位才置 1（本例中的0000 1001称为位掩码。）：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102154417565.png" alt="image" style="zoom:85%;" /><h2 id="CMP-指令"><a href="#CMP-指令" class="headerlink" title="CMP 指令"></a>CMP 指令</h2><p>CMP（比较）指令执行<strong>从目的操作数中减去源操作数</strong>的隐含减法操作，并且不修改任何操作数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">CMP dest, source<br></code></pre></td></tr></table></figure><p>当实际的减法发生时，CMP指令按照计算结果修改溢出、符号、零、进位、辅助进位和奇偶标志位。</p><p>如果比较的是两个<strong>无符号数</strong>，则零标志位和进位标志位表示的两个操作数之间的关系如下图所示：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102154711457.png" style="zoom:80%;" /><p>如果比较的是两个<strong>有符号数</strong>，则符号标志位、零标志位和溢出标志位表示的两个操作数之间的关系如下图所示：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102154729952.png" style="zoom:80%;" /><p>CMP 指令是创建条件逻辑结构的有效工具。<strong>IF 语句在汇编语言中等价于在 CMP 指令后跟一条条件跳转指令。</strong></p><h2 id="设置和清除单个-CPU-状态标志"><a href="#设置和清除单个-CPU-状态标志" class="headerlink" title="设置和清除单个 CPU 状态标志"></a>设置和清除单个 CPU 状态标志</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs assembly">test al, 0     ; 零标志位置 1<br>and  al, 0     ; 零标志位置 1<br>or   al, 1     ; 零标志位清零<br><br>or   al, 80h   ; 符号标志位置 1<br>and  al, 7Fh   ; 符号标志位清零<br><br>stc            ; 进位标志位置 1<br>clc            ; 进位标志位清零<br><br>mov  al, 7Fh   ; AL = +127<br>inc  al        ; AL = 80h (-128), OF = 1, 溢出标志位置 1<br><br>or   eax, 0    ; 溢出标志位清零<br></code></pre></td></tr></table></figure><h2 id="习题整理"><a href="#习题整理" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  下列语句中，有语法错误的是：（C）<br>  A. mov eax, arrayD[esi*4]<br>  B. popfd<br>  C. cmp val1, val2<br>  D. rep stosb</p></blockquote><p>CMP 指令两个操作数不能都为立即数。</p><hr><h1 id="条件跳转"><a href="#条件跳转" class="headerlink" title="条件跳转"></a>条件跳转</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 156</p></blockquote><h2 id="Jcond-指令"><a href="#Jcond-指令" class="headerlink" title="Jcond 指令"></a>J<i>cond</i> 指令</h2><p> 条件跳转指令在标志条件为真时分支跳转到新的目的标号处，如果条件标志为假，那么执行紧跟在跳转跳转指令之后的指令。格式如下：<br>$$<br>Jcond\space\space destination<br>$$<br> 格式中的 <em>cond</em> 指的是一个标志条件，用来表示一个或多个标志的状态。例如：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102163745683.png" alt="" style="zoom:80%;" /><p>CPU 状态标志位最常见的设置方法是通过算术运算、比较和布尔运算指令。条件跳转指令评估标志位状态，利用它们来决定是否发生跳转。</p><p>限制：MASM 在默认情况下要求跳转的目的地址在当前的过程之内，为了突破这种限制，可以声明一个全局标号（标号后面跟 <code>::</code>）。</p><h2 id="基于特定的标志值的跳转指令"><a href="#基于特定的标志值的跳转指令" class="headerlink" title="基于特定的标志值的跳转指令"></a>基于特定的标志值的跳转指令</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102164214600.png" style="zoom:80%;" /><h2 id="基于恒等性比较的跳转指令"><a href="#基于恒等性比较的跳转指令" class="headerlink" title="基于恒等性比较的跳转指令"></a>基于恒等性比较的跳转指令</h2><p>$$<br>CMP \space\space leftOp,\space rightOp<br>$$</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102164334615.png" style="zoom:80%;" /><p>JE 指令和 JZ 指令是等价的，JNZ 指令和 JNE 指令是等价的。</p><h2 id="基于无符号数比较的跳转指令"><a href="#基于无符号数比较的跳转指令" class="headerlink" title="基于无符号数比较的跳转指令"></a>基于无符号数比较的跳转指令</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102164428457.png" alt="" style="zoom:80%;" /><h2 id="基于有符号数比较的跳转指令"><a href="#基于有符号数比较的跳转指令" class="headerlink" title="基于有符号数比较的跳转指令"></a>基于有符号数比较的跳转指令</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102164453778.png" style="zoom:80%;" /><h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 160</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102192924734.png" alt="" style="zoom:80%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102193006278.png" style="zoom:80%;" /><h2 id="习题整理-1"><a href="#习题整理-1" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  条件转移指令中相等跳转的指令是：（C）<br>  A. JZ<br>  B. JNZ<br>  C. JE<br>  D. JNE</p></blockquote><p>JE 指令和 JZ 指令是等价的。</p><hr><h1 id="条件循环指令"><a href="#条件循环指令" class="headerlink" title="条件循环指令"></a>条件循环指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 163</p></blockquote><h2 id="LOOPZ-和-LOOPE-指令"><a href="#LOOPZ-和-LOOPE-指令" class="headerlink" title="LOOPZ 和 LOOPE 指令"></a>LOOPZ 和 LOOPE 指令</h2><p>ECX 大于 0，并且零标志位置 1 则循环。<br>$$<br>LOOPZ\space\space destination<br>$$</p><p>$$<br>LOOPE\space\space destination<br>$$</p><h2 id="LOOPNZ-和-LOOPNE-指令"><a href="#LOOPNZ-和-LOOPNE-指令" class="headerlink" title="LOOPNZ 和 LOOPNE 指令"></a>LOOPNZ 和 LOOPNE 指令</h2><p>ECX 大于 0，并且零标志位为 0 则循环。<br>$$<br>LOOPNZ\space\space distination<br>$$</p><p>$$<br>LOOPNE\space\space distination<br>$$</p><hr><h1 id="条件结构"><a href="#条件结构" class="headerlink" title="条件结构"></a>条件结构</h1><h2 id="IF-语句"><a href="#IF-语句" class="headerlink" title="IF 语句"></a>IF 语句</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 165</p></blockquote><p>C++ 代码翻译为汇编代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (op1 == op2)<br>&#123;<br>    X = <span class="hljs-number">1</span>;<br>    Y = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">    mov eax, op1<br>    cmp eax, op2      ; op1 == op2 ?<br>    jne L1            ; False : Skip To L1<br>    mov X, 1          ; True : X = 1<br>    mov Y, 2          ; Y = 1<br>L1: .<br>    .<br></code></pre></td></tr></table></figure><h2 id="WHILE-语句"><a href="#WHILE-语句" class="headerlink" title="WHILE 语句"></a>WHILE 语句</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 168</p></blockquote><p>C++ 代码翻译为汇编代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (val &lt; val2)<br>&#123;<br>    val1++;<br>    val2--;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">    mov eax, val1       ; eax = val1<br>beginWhile:<br>    cmp eax, val2       ; if not (val1 &lt; val2)<br>    jnl endWhile        ; 退出循环<br>    inc eax             ; val1++<br>    dec val2            ; val2--<br>    jmp beginWhile      ; 重复循环<br>endWhile:<br>    mov val1, eax       ; val1 = eax<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第五章</title>
    <link href="/posts/eddefec83d75/"/>
    <url>/posts/eddefec83d75/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第五章学习笔记</b></font></center><br><span id="more"></span><h1 id="堆栈操作"><a href="#堆栈操作" class="headerlink" title="堆栈操作"></a>堆栈操作</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 108</p></blockquote><p>堆栈数据结构 (stack data structure) 的原理与盘子堆栈相同：新值添加到栈顶，删除值也在栈顶移除。堆栈也被称为 LIFO 结构 (后进先出，Last-In First-Out)，其原因是，最后进入堆栈的值也是第一个出堆栈的值。</p><h2 id="运行时堆栈（32位模式）"><a href="#运行时堆栈（32位模式）" class="headerlink" title="运行时堆栈（32位模式）"></a>运行时堆栈（32位模式）</h2><p>运行时堆栈是内存数组，CPU 用 ESP (扩展堆栈指针，extended stack pointer) 寄存器对其进行直接管理，该寄存器被称为堆栈指针寄存器 (stack pointer register)。</p><p>32位模式下，ESP寄存器存放的是堆栈中某个位置的 32 位偏移量。ESP 基本上不会直接被程序员控制，反之，它是用 CALL、RET、PUSH 和 POP 等指令间接进行修改。</p><p><font size = 4><b>入栈操作</b></font></p><p>32位入栈操作把栈顶指针减 4，再将数值复制到栈顶指针指向的堆栈位置。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101231844357.png" alt="入栈操作" style="zoom:67%;" /><p><font size = 4><b>出栈操作</b></font></p><p>出栈操作从堆栈删除数据。数值弹出堆栈后，栈顶指针增加(按堆栈元素大小)，指向堆栈中下一个最高位置。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101231955497.png" alt="出栈操作" style="zoom:67%;" /><p><font size = 4><b>堆栈应用</b></font></p><p>运行时堆栈在程序中有一些重要用途：</p><ul><li>当寄存器用于多个目的时，堆栈可以作为寄存器的一个方便的临时保存区。在寄存器被修改后，还可以恢复其初始值。</li><li>执行 CALL 指令时，CPU 在堆栈中保存当前过程的返回地址。</li><li>调用过程时,输入数值也被称为<strong>参数</strong>，通过将其压入堆栈实现参数传递。</li><li>堆栈也为过程局部变量提供了临时存储区域。</li></ul><h2 id="PUSH-和-POP-指令"><a href="#PUSH-和-POP-指令" class="headerlink" title="PUSH 和 POP 指令"></a>PUSH 和 POP 指令</h2><h3 id="PUSH-指令"><a href="#PUSH-指令" class="headerlink" title="PUSH 指令"></a>PUSH 指令</h3><p>使用 PUSH 指令将数据压入栈内。</p><p>PUSH 指令首先减少 ESP 的值，再将源操作数复制到堆栈。操作数是 16 位的，则 ESP 减 2，操作数是 32 位的,则 ESP 减 4。</p><p>例如 <code>push eax</code> 指令执行的过程可以分为两步：</p><ol><li>指向栈顶的寄存器 <code>esp</code> 进行一个减法操作 <code>sub esp, 4 </code>。</li><li>将需要保存的元素复制到新的栈顶位置 <code>mov [esp], %eax </code>。</li></ol><h3 id="POP-指令"><a href="#POP-指令" class="headerlink" title="POP 指令"></a>POP 指令</h3><p>使用 POP 指令从内存中读取数据，并且修改栈顶指针。</p><p>POP 指令首先把 ESP 指向的堆栈元素内容复制到一个 16 位或 32 位目的操作数中，再增加 ESP  的值。如果操作数是 16 位的，ESP 加 2，如果操作数是 32 位的，ESP 加 4。</p><p>例如 <code>pop ebx</code> 指令就是将栈顶保存的数据复制到寄存器 <code>ebx</code> 中，该指令同样也可以分解成两步：</p><ol><li>从栈顶的位置读出数据，复制到寄存器 <code>ebx</code>：<code>mov ebx, [esp] </code>。</li><li>将栈顶的指针加8（因为 <code>q</code> 表示的是8个字节）：<code>add esp, 4</code>。</li></ol><h3 id="PUSHFD-和-POPFD-指令"><a href="#PUSHFD-和-POPFD-指令" class="headerlink" title="PUSHFD 和 POPFD 指令"></a>PUSHFD 和 POPFD 指令</h3><p>PUSHFD 指令把 32 位 EFLAGS 寄存器内容压入堆栈。</p><p>POPFD 指令则把栈顶单元内容弹出到 EFLAGS 寄存器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pushfd<br>popfd<br></code></pre></td></tr></table></figure><h3 id="PUSHAD-和-POPAD-指令"><a href="#PUSHAD-和-POPAD-指令" class="headerlink" title="PUSHAD 和 POPAD 指令"></a>PUSHAD 和 POPAD 指令</h3><p>PUSHAD 指令按照 EAX、ECX、EDX、EBX、ESP(执行 PUSHAD 之前的值)、EBP、ESI 和 EDI 的顺序，将所有 32 位通用寄存器压入堆栈。</p><p>POPAD 指令按照相反顺序将同样的寄存器弹出堆栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pushad<br>popad<br></code></pre></td></tr></table></figure><p>如果编写的过程会修改 32 位寄存器的值，则在过程开始时使用 PUSHAD 指令，在结束时使用 POPAD 指令，以此保存和恢复寄存器的内容。</p><h3 id="PUSHA-和-POPA-指令"><a href="#PUSHA-和-POPA-指令" class="headerlink" title="PUSHA 和 POPA 指令"></a>PUSHA 和 POPA 指令</h3><p>与之相似，PUSHA 指令按序（AX、CX、DX、BX、SP、BP、SI 和 DI) 将 16 位通用寄存器压入堆栈。</p><p>POPA 指令按照相反顺序将同样的寄存器弹出堆栈。在 16 位模式下,只能使用 PUSHA 和 POPA 指令。</p><hr><h1 id="定义并使用过程"><a href="#定义并使用过程" class="headerlink" title="定义并使用过程"></a>定义并使用过程</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 112</p></blockquote><p>在汇编语言中，通常用术语过程 (procedure) 来指代子程序。在其他语言中，子程序也被称为方法或函数。</p><h2 id="PROC-伪指令"><a href="#PROC-伪指令" class="headerlink" title="PROC 伪指令"></a>PROC 伪指令</h2><p>可以把过程非正式地定义为：以返回语句结束的命令语句块。</p><p>过程使用 PROC 伪指令和 ENDP 伪指令来声明，另外还必须给过程定义一个名字。</p><p>程序启动过程之外的其他过程以 RET 指令结束，以强制 CPU 返回到过程被调用的地方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Function PROC<br>    .<br>    .<br>    .<br>    RET<br>Function ENDP<br></code></pre></td></tr></table></figure><p>但是启动过程（main）是个特例，它以 exit 语句结束。如果程序中使用了 <code>INCLUDE Irvine32.inc</code> 语句的话，exit 语句实际上就是对 ExitProcess 函数的调用，ExitProcess 是用来终止程序的系统函数：<code>INVOKE ExitProcess, 0</code>。</p><h2 id="CALL-和-RET-指令"><a href="#CALL-和-RET-指令" class="headerlink" title="CALL 和 RET 指令"></a>CALL 和 RET 指令</h2><p>CALL 指令指挥处理器在新的内存地址执行指令，以实现过程的调用。过程使用 RET（从过程返回）指令使处理器返回到程序过程被调用的地方继续执行。</p><p>从底层细节角度来讲，CALL 指令把返回地址压入堆栈并把被调用过程的地址复制到指令指针寄存器 (EIP &#x2F; IP) 中。当程序返回时，RET 指令从堆栈中弹出返回地址并送到指令指针寄存器中。</p><p>在 32 位模式下，CPU 总是执行 EIP（指令指针寄存器）所指向的内存出的指令；在 16 位模式下，CPU 总是执行 IP 寄存器指向的指令。</p><p>需要注意的是，进入过程后如果在没有 PUSH 操作的情况下直接 POP，会将之前存入的 CALL 指令后一条指令的地址弹出，从而导致 RET 指令无法正确的返回调用该过程的地址。</p><h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><p>下面的程序通过传递一个 32 位整数数组的偏移量和长度来测试 ArraySum 过程。调用 ArraySum 之后，程序将过程的返回值保存在变量 theSum 中。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102012440040.png" alt="" style="zoom:67%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102012631839.png" style="zoom:67%;" />]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第四章</title>
    <link href="/posts/a23aca48ee77/"/>
    <url>/posts/a23aca48ee77/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第四章学习笔记</b></font></center><br><span id="more"></span><h1 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h1><h2 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 73</p></blockquote><p>x86 指令格式：<code>[label:] mnemonic [operands] [; comment]</code>。其中，指令包含的操作数个数可以是 0个，1个，2个或3个。</p><p>操作数有 3 种基本类型：</p><ul><li><strong>立即数</strong> (<code>imm</code>) ——使用数字文本表达式</li><li><strong>寄存器操作数</strong> (<code>reg</code>) ——使用 CPU 内已命名的寄存器</li><li><strong>内存操作数</strong> (<code>mem</code>) ——引用内存位置</li></ul><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101130934870.png" style="zoom: 50%;" /></center><h2 id="直接内存操作数"><a href="#直接内存操作数" class="headerlink" title="直接内存操作数"></a>直接内存操作数</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 74</p></blockquote><p>变量名引用的是数据段内的偏移量。</p><p>例如，如下变量 var1 的声明表示，该变量的大小类型为字节，值为十六进制的 10：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>var1 BYTE 10h<br></code></pre></td></tr></table></figure><p>可以编写指令，通过内存操作数的地址来解析（查找）这些操作数。</p><p>假设 var1 的地址偏移量为 10400h。如下指令将该变量的值复制到 AL 寄存器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov al var1<br></code></pre></td></tr></table></figure><p>指令会被汇编为下面的机器指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">A0 00010400<br></code></pre></td></tr></table></figure><p>这条机器指令的第一个字节是操作代码（即操作码 (opcode) ）。剩余部分是 var1 的 32 位十六进制地址。虽然编程时有可能只使用数字地址，但是如同 var1 一样的符号标号会让使用内存更加容易。</p><h2 id="直接-偏移量操作数"><a href="#直接-偏移量操作数" class="headerlink" title="直接-偏移量操作数"></a>直接-偏移量操作数</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 78</p></blockquote><p>在变量名称后加上一个偏移值，可以创建直接偏移 (direct-offset) 操作数，可以通过它来访问没有显示标号的内存地址。我们以一个名为 arrayB 的<strong>字节数组</strong>开始枚举：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>arrayB BYTE 10h, 20h, 30h, 40h, 50h ; 注意此处为 BYTE(一个字节)<br><br>.code<br>mov al, arrayB        ; AL = 10h<br>mov al, [arrayB + 1]  ; AL = 20h<br>mov al, [arrayB + 2]  ; AL = 30h<br></code></pre></td></tr></table></figure><p>如果是双字节或者双字（四个字节）或者是其他，注意偏移的时候地址分别是 2、4 或者其他等。</p><hr><h1 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 75</p></blockquote><h2 id="MOV-指令"><a href="#MOV-指令" class="headerlink" title="MOV 指令"></a>MOV 指令</h2><p>MOV指令将源操作数复制到目的操作数。</p><p>在它的基本格式中，<strong>第一个操作数是目的操作数</strong>，<strong>第二个操作数是源操作数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV destination, source<br></code></pre></td></tr></table></figure><p>其中，目的操作数的内容会发生改变，而源操作数不会改变。</p><p>下面是 MOV 指令的标准格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV reg, reg<br>MOV mem, reg<br>MOV reg, mem<br>MOV mem, imm<br>MOV reg, imm<br></code></pre></td></tr></table></figure><p><strong>需要特别注意以下的原则</strong>：</p><ul><li>两个操作数必须是同样的大小。</li><li>两个操作数不能同时为内存操作数。</li><li>指令指针寄存器 (<code>IP</code>、<code>EIP</code>、<code>RIP</code>) 不能作为目标寄存器。</li></ul><p><font size = 4><b>内存到内存</b></font></p><p>单条 MOV 指令不能用于直接将数据从一个内存位置传送到另一个内存位置。相反，在将源操作数的值赋给内存操作数之前，必须先将该数值传送给一个寄存器。在将整型常数复制到一个变量或寄存器时，必须考虑该常量需要的最少字节数。</p><p><font size = 4><b>覆盖值</b></font></p><p>下述代码示例演示了怎样通过使用不同大小的数据来修改同一个32位寄存器。</p><ul><li><p>当 oneWord 字传送到 AX 时，它就覆盖了 AL 中已有的值。</p></li><li><p>当 oneDword 传送到 EAX 时，它就覆盖了 AX 的值。</p></li><li><p>最后，当 0 被传送到 AX 时，它就<strong>覆盖了 EAX 的低半部分</strong>。</p></li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101134153188.png" alt="image" style="zoom:60%;" /><h2 id="整数的全零-x2F-符号扩展"><a href="#整数的全零-x2F-符号扩展" class="headerlink" title="整数的全零&#x2F;符号扩展"></a>整数的全零&#x2F;符号扩展</h2><p><font size = 4><b>把一个较小的值复制到一个较大的操作数</b></font></p><p>尽管 MOV 指令不能直接将较小的操作数复制到较大的操作数中，但是程序员可以想办法解决这个问题。</p><p>假设要将count (无符号，16位) 传送到ECX (32位)，可以先将 ECX 设置为 0，然后将 count 传送到 CX：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>count WORD 1<br>.code<br>mov ecx, 0<br>mov cx, count<br></code></pre></td></tr></table></figure><p>如果对一个有符号整数 -16 进行同样的操作会发生什么呢?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>signedVal SWORD -16    ; FFF0h(-16)<br>.code<br>mov ecx, 0<br>mov cx, signedVal      ; ECX = 0000FFF0h (+65520)<br></code></pre></td></tr></table></figure><p>ECX中的值 (+65520) 与 -16 完全不同。</p><p>但是，如果先将 ECX 设置为 FFFFFFFFh，然后再把 signedVal 复制到 CX，那么最后的值就是完全正确的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ecx，0FFFFFFFFh<br>mov cx, signedVal      ; ECX = FFFFFFF0h (-16)<br></code></pre></td></tr></table></figure><p>本例的有效结果是用源操作数的最高位（1）来填充目的操作数ECX的高16位，这种技术称为符号扩展( sign extension)。</p><p>当然，不能总是假设源操作数的最高位是1。</p><p>幸运的是，Intel 的工程师在设计指令集时已经预见到了这个问题，因此，设置了 <strong>MOVZX</strong> 和 <strong>MOVSX</strong> 指令来分别处理<strong>无符号整数</strong>和<strong>有符号整数</strong>。</p><h3 id="MOVZX-指令"><a href="#MOVZX-指令" class="headerlink" title="MOVZX 指令"></a>MOVZX 指令</h3><p>MOVZX 指令（进行全零扩展并传送）将源操作数复制到目的操作数，<strong>并把目的操作数<mark>0扩展</mark>到 16 位或 32 位</strong>。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101154536720.png" alt="image-20230101154536720" style="zoom:53%;" /><p>这条指令<strong>只用于无符号整数</strong>，有三种不同的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOVZX reg32, reg/mem8<br>MOVZX reg32, reg/mem16<br>MOVZX reg16, reg/mem8<br></code></pre></td></tr></table></figure><p>在三种形式中，第一个操作数（寄存器）是目的操作数，第二个操作数是源操作数。<strong>注意，源操作数不能是常数。</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101154801107.png" alt="image" style="zoom: 60%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101154848550.png" alt="" style="zoom:60%;" /><h3 id="MOVSX-指令"><a href="#MOVSX-指令" class="headerlink" title="MOVSX 指令"></a>MOVSX 指令</h3><p>MOVSX 指令（进行符号扩展并传送）将源操作数内容复制到目的操作数，<strong>并把目的操作数<mark>符号扩展</mark>到 16 位或 32 位。</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101155132150.png" alt="image-20230101155132150" style="zoom:53%;" /><p>这条指令只用于有符号整数，有三种不同的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOVSX reg32, reg/mem8<br>MOVSX reg32, reg/mem16<br>MOVSX reg16, reg/mem8<br></code></pre></td></tr></table></figure><p>操作数进行符号扩展时，在目的操作数的全部扩展位上重复(复制)长度较小操作数的最高位。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101160019171.png" style="zoom:60%;" /><h2 id="LAHF-和-SAHF-指令"><a href="#LAHF-和-SAHF-指令" class="headerlink" title="LAHF 和 SAHF 指令"></a>LAHF 和 SAHF 指令</h2><p>LAHF（<em>load</em> status <em>flags</em> into <em>AH</em>，加载状态标志位<strong>到 AH</strong>）指令将 EFLAGS 寄存器的<strong>低字节复制到 AH</strong>。被复制的标志位包括：符号标志位、零标志位、辅助进位标志位、奇偶标志位和进位标志位。使用这条指令，可以方便地把标志位副本保管在变量中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>saveflags BYTE ?<br>.code<br>lahf                ; 将标志位加载到 AH<br>mov saveflags, ah   ; 用变量保存这些标志位<br></code></pre></td></tr></table></figure><p>SAHF（<em>store</em> <em>AH</em> into status <em>flags</em>，保存 AH 内容到状态标志位）指令将 <strong>AH 内容复制到</strong> EFLAGS（或 RFLAGS）寄存器低字节。例如，可以检索之前保存到变量中的标志位数值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ah, saveflags   ; 加载被保存标志位到 AH<br>sahf                ; 复制到 FLAGS 寄存器<br></code></pre></td></tr></table></figure><h2 id="XCHG-指令"><a href="#XCHG-指令" class="headerlink" title="XCHG 指令"></a>XCHG 指令</h2><p>XCHG（<em>exchange</em> data，交换数据）指令交换两个操作数内容。该指令有三种形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">XCHG reg, reg<br>XCHG reg, mem<br>XCHG mem, reg<br></code></pre></td></tr></table></figure><p>除了 <strong>XCHG 指令不使用立即数作操作数</strong>之外，XCHG 指令操作数的要求与 MOV 指令操作数要求是一样的。即：</p><ol><li>两个操作数不能同时都为内存操作数。</li><li>任何一个操作数都不能为立即数。</li><li>指令指针寄存器 (<code>IP</code>、<code>EIP</code>、<code>RIP</code>) 不能作为目标寄存器。</li><li>两个操作数必须是同样的大小。</li></ol><p>以下是一些使用 XCHG 指令的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">xchg ax, bx      ; 交换两个 16 位寄存器的内同<br>xchg ah, al      ; 交换两个 8 位寄存器的内容<br>xchg var1, bx    ; 交换 16 位的内存操作数和 BX 寄存器内容<br>xchg eax, ebx    ; 交换两个 32 位寄存器的内同<br></code></pre></td></tr></table></figure><p>若要交换两个内存操作数，需要使用一个寄存器作为临时存储容器，并把 MOV 指令和 XCHG 指令结合起来使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov  ax, val1<br>xchg ax, val2<br>mov  val1, ax  <br></code></pre></td></tr></table></figure><h2 id="习题整理"><a href="#习题整理" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  下列语句中，有语法错误的是：（D）<br>  A. add esi, TYPE DWORD<br>  B. pop eax<br>  C. repe cmpsd<br>  D. mov val1, val2</p></blockquote><p>MOV 指令两个操作数不能同时为内存操作数。</p><hr><h1 id="程序示例1"><a href="#程序示例1" class="headerlink" title="程序示例1"></a>程序示例1</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 79</p></blockquote><p>该程序中包含了本文之前介绍的所有指令，包括：MOV、XCHG、MOVSX 和 MOVZX，展示了字节、字和双字是如何受到它们的影响。同时，程序中还包括了一些直接-偏移量操作数。</p><center><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101164424148.png" alt="" style="zoom:67%;" /><br><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101164502334.png" alt="" style="zoom:67%;" /></p></center><hr><h1 id="加法和减法"><a href="#加法和减法" class="headerlink" title="加法和减法"></a>加法和减法</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 81</p></blockquote><h2 id="INC-和-DEC-指令"><a href="#INC-和-DEC-指令" class="headerlink" title="INC 和 DEC 指令"></a>INC 和 DEC 指令</h2><p>INC (increment) 和 DEC (decrement) 指令从操作数中加 1 或减 1，格式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">INC  reg/mem<br>DEC  reg/mem<br></code></pre></td></tr></table></figure><p>根据目标操作数的值，溢出标志位、符号标志位、零标志位、辅助进位标志位、进位标志位和奇偶标志位会发生变化。</p><p>INC和 DEC指令<strong>不会影响进位标志位</strong>。</p><h2 id="ADD-指令"><a href="#ADD-指令" class="headerlink" title="ADD 指令"></a>ADD 指令</h2><p>ADD 指令将同尺寸的源操作数和目的操作数相加，格式是：<code>ADD dest, source</code>。</p><p>在操作中，源操作数不能改变，相加之<strong>和存放在目的操作数中</strong>。</p><p>该指令可以使用的操作数与 MOV 指令相同。</p><p>进位标志位、零标志位、符号标志位、溢出标志位、辅助进位标志位和奇偶标志位根据<strong>存入目标操作数的数值</strong>进行变化。</p><h2 id="SUB-指令"><a href="#SUB-指令" class="headerlink" title="SUB 指令"></a>SUB 指令</h2><p>SUB 指令<strong>将源操作数从目的操作数中减掉</strong>，操作数格式与 ADD 和 MOV 指令操作数相同。</p><p>格式是：<code>SUB dest, source</code>。</p><p>进位标志位、零标志位、符号标志位、溢出标志位、辅助进位标志位和奇偶标志位根据<strong>存入目标操作数的数值</strong>进行变化。</p><p>有一种执行减法而无需使用额外的数字电路单元的简单方法：对源操作数求补，然后把源操作数和目的操作数相加。</p><h2 id="NEG-指令"><a href="#NEG-指令" class="headerlink" title="NEG 指令"></a>NEG 指令</h2><p>NEG (negate) 指令通过将数字转换为对应的补码而求得其相反数（将目标操作数按位取反再加1，就可以得到这个数的二进制补码)。</p><p>格式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">NEG reg<br>NEG mem<br></code></pre></td></tr></table></figure><p>进位标志位、零标志位、符号标志位、溢出标志位、辅助进位标志位和奇偶标志位根据<strong>存入目标操作数的数值</strong>进行变化。</p><h2 id="加减法影响的标志位"><a href="#加减法影响的标志位" class="headerlink" title="加减法影响的标志位"></a>加减法影响的标志位</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 83</p></blockquote><ul><li>进位标志位意味着<strong>无符号整数</strong>溢出。<br>比如，如果指令目的操作数为 8 位，而指令产生的结果大于二进制的 1111 1111，那么进位标志位置 1。</li><li>溢出标志位意味着<strong>有符号整数</strong>溢出。<br>比如，指令目的操作数为 16 位，但其产生的负数结果小于十进制的 -32768，那么溢出标志位置 1。</li><li>零标志位意味着<strong>操作结果为 0</strong>。<br>比如，如果两个值相等的操作数相减，则零标志位置 1。</li><li>符号标志位意味着操作<strong>产生的结果为负数</strong>。如果目的操作数的最高有效位（MSB）置 1，则符号标志位置 1。</li><li>奇偶标志位是指，在一条算术或布尔运算指令执行后，立即判断目的操作数最低有效字节中1的个数是否为偶数。</li><li>辅助进位标志位置1，意味着目的操作数最低有效字节中位 3 有进位。</li></ul><h2 id="习题整理-1"><a href="#习题整理-1" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  下列语句中，有语法错误的是：（B）<br>  A. mov ax, WORD PTR value<br>  B. inc [esi]<br>  C. movzx cx,bl<br>  D. movsx edx,bl</p></blockquote><p>INC 指令只能对寄存器操作数和内存操作数使用。</p><hr><h1 id="和数据相关的操作符和伪指令"><a href="#和数据相关的操作符和伪指令" class="headerlink" title="和数据相关的操作符和伪指令"></a>和数据相关的操作符和伪指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 87</p></blockquote><p>MASM 操作符或伪指令<strong>获取数据的地址以及大小等特征信息</strong>：</p><ul><li><p>OFFSET 操作符返回一个变量相对于其所在段开始的偏移。</p></li><li><p>PTR 操作符允许重载变量的默认尺寸。</p></li><li><p>TYPE 操作符返回数组中每个元素的大小（以字节计算）。</p></li><li><p>LENGTHOF 操作符返回数组内元素的数目。</p></li><li><p>SIZEOF 操作符返回数组初始化时占用的字节数。</p></li></ul><p>除此之外，LABEL 伪指令可以用不同的大小类型来重新定义同一个变量。</p><h2 id="OFFSET-运算符"><a href="#OFFSET-运算符" class="headerlink" title="OFFSET 运算符"></a>OFFSET 运算符</h2><p>OFFSET 操作符返回数据标号的偏移地址。偏移地址代表标号距离数据段开始的距离，单位是以字节计算的。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101174947466.png" alt="" style="zoom:60%;" /><p>在下面的例子中，将用到如下三种类型的变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>bVal  BYTE  ?<br>wVal  WORD  ?<br>dval  DWORD ?<br>dVal2 DWORD ?<br></code></pre></td></tr></table></figure><p>假设 bVal 在偏移量为 0040 4000 (十六进制) 的位置，则 OFFSET 运算符返回值如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov esi, OFFSET bval   ; ESI = 00404000h<br>mov esi, OFFSET wval   ; ESI = 00404001h<br>mov esi, OFFSET dVal   ; ESI = 00404003h<br>mov esi ,OFFSET dval2  ; ESI = 00404007h<br></code></pre></td></tr></table></figure><p>OFFSET 也可以应用于直接-偏移量操作数。</p><p>设 myArray 包含 5 个 16 位的字。下面的 MOV 指令首先得到 myArray 的偏移量，然后加 4，再将形成的结果地址直接传送给 ESI。因此，现在可以说 ESI 指向数组中的第 3 个整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>myArray WORD 1, 2, 3, 4, 5<br>.code<br>mov esi, OFFSET myArray + 4   ; 1 WORD = 2 BYTE<br></code></pre></td></tr></table></figure><h2 id="ALIGN-运算符"><a href="#ALIGN-运算符" class="headerlink" title="ALIGN 运算符"></a>ALIGN 运算符</h2><p>ALIGN伪指令将变量的位置按字节、字、双字或段边界对齐，语法是：ALIGN <em>bound</em>。<em>bound</em> 可以取的值有：1、2、4、8、16。指令把地址直接对齐到所指定 <em>bound</em> 的倍数上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">   bVal   BYTE  ?     ;00404000<br>   ALIGN  2<br>   wVa    WORD  ?     ; 00404002<br>   bVal2  BYTE  ?     ; 00404004<br>   ALIGN  4<br>   dVal   DWORD ?     ; 00404008<br>   dVal2  DWORD ?     ; 0040400C<br></code></pre></td></tr></table></figure><p>请注意，dVal 的偏移量原本是 0040 4005，但是 <code>ALIGN 4</code> 伪指令使它的偏移量成为 0040 4008。</p><h2 id="PTR-操作符"><a href="#PTR-操作符" class="headerlink" title="PTR 操作符"></a>PTR 操作符</h2><p>PTR 操作符来重载操作数声明的默认尺寸，这在试图以不同于变量声明时所使用的尺寸属性访问变量的时候非常有用。</p><p>例如，假设要讲双字变量 myDouble 的低 16 位传送给 AX 寄存器，由于操作数大小不匹配，编译器将不允许下面的数据传送指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>myDouble DOWRD 12345678h<br><br>.code<br>MOV ax, myDouble          ; 错误<br></code></pre></td></tr></table></figure><p>但是 <code>WORD PTR</code> 操作符使得将低字（5678）传送给 AX 成为可能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV ax, WORD PTR myDouble<br></code></pre></td></tr></table></figure><p>注意，<strong>PTR 必须与一个标准汇编数据类型一起使用</strong>，这些类型包括：BYTE、SBYTE、WORD、SWORD、DWORD、SDWORD、FWORD、QWORD 或 TBYTE。</p><h2 id="TYPE-运算符"><a href="#TYPE-运算符" class="headerlink" title="TYPE 运算符"></a>TYPE 运算符</h2><p>TYPE运算符返回变量单个元素的大小，这个大小是<strong>以字节为单位</strong>计算的。</p><p>比如，TYPE为字节，返回值是1 ；TYPE为字，返回值是2；TYPE为双字，返回值是4；TYPE为四字,返回值是8。</p><p>示例如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>Var1 BYTE  ?<br>Var2 WORD  ?<br>Var3 DWORD ?<br>Var4 QWORD ?<br></code></pre></td></tr></table></figure><p>下面是每个 TYPE 表达式的值：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101191245030.png" style="zoom: 67%;" /><h2 id="LENGTHOF-运算符"><a href="#LENGTHOF-运算符" class="headerlink" title="LENGTHOF 运算符"></a>LENGTHOF 运算符</h2><p>LENGTHOF 运算符计算数组中元素的个数，元素个数是由数组标号同一行出现的数值来定义的。示例如下：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101191614251.png" style="zoom:80%;" /><p>如果数组定义中出现了嵌套的 DUP 运算符，那么 LENGTHOF 返回的是两个数值的乘积。</p><p>下表列出了每个 LENGTHOF 表达式返回的数值。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101191653807.png" style="zoom:67%;" /><h2 id="SIZEOF-运算符"><a href="#SIZEOF-运算符" class="headerlink" title="SIZEOF 运算符"></a>SIZEOF 运算符</h2><p>SIZEOF 运算符返回值等于 LENGTHOF 与 TYPE 返回值的乘积。</p><p>如下例所示，intArray 数组的 TYPE &#x3D; 2，LENGTHOF  &#x3D; 32，因此，<code>SIZEOF intArray</code> &#x3D; 64：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>intArray WORD 32 DUP(0)<br><br>.code<br>Mov eax, SIZEOF intArray ; 64<br></code></pre></td></tr></table></figure><h2 id="LABEL-伪指令"><a href="#LABEL-伪指令" class="headerlink" title="LABEL 伪指令"></a>LABEL 伪指令</h2><p>LABEL 伪指令允许插入一个标号并赋予其尺寸属性而无需任何实际的存储空间。LABEL 伪指令可以使用 BYTE、WORD、DWORD、QWORD 或 TBYTE 等任意的标准尺寸属性。LABEL 伪指令的一种常见的用法是为数据段内其后定义的变量提供一个别名以及一个不同的尺寸属性。</p><p>下例中在 val32 前面声明了一个名为 val16 的标号并赋予其 WORD 属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>Val16 LABEL WORD<br>Val32 DWORD 12345678h<br><br>.code<br>MOV ax, val16          ; AX = 5678h<br>MOV dx, [val16 + 2]    ; DX = 1234h<br></code></pre></td></tr></table></figure><p>val16 是名为 val32 的存储地址的一个别名。LABEL 伪指令本身并不占用实际存储空间。</p><h2 id="习题整理-2"><a href="#习题整理-2" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr></blockquote><blockquote><p>  下列语句中，有语法错误的是：（A）<br>  A. mov ax, PTR value<br>  B. inc esi<br>  C. xchg ebx, eax<br>  D. add esi, TYPE DWORD</p></blockquote><p><strong>PTR 必须与一个标准汇编数据类型一起使用</strong>，这些类型包括：BYTE、SBYTE、WORD、SWORD、DWORD、SDWORD、FWORD、QWORD 或 TBYTE。</p><hr><h1 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 91</p></blockquote><p>直接寻址很少用于数组处理，因为，用常数偏移量来寻址多个数组元素时，直接寻址不实用。反之，会用寄存器作为指针（称为间接寻址）并控制该寄存器的值。</p><p>如果一个操作数使用的是间接寻址,就称之为<strong>间接操作数</strong>。</p><h2 id="间接操作数"><a href="#间接操作数" class="headerlink" title="间接操作数"></a>间接操作数</h2><p>任何一个 32 位通用寄存器（EAX、EBX、ECX、EDX、ESI、EDI、EBP 和 ESP）加上括号就能构成一个间接操作数。寄存器中存放的是数据的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>val1 BYTE 10h<br><br>.code<br>mov esi, OFFSET val1<br>mov al, [esi]          ; AL = 10h<br></code></pre></td></tr></table></figure><p>如果目的操作数也是间接操作数，那么新值将存入由寄存器提供地址的内存位置。</p><p>在下面的例子中，BL 寄存器的内容复制到 ESI 寻址的内存地址中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV [esi], bl<br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>间接操作数是步进遍历数组的理想工具。</p><p>下例中，arrayB 有 3 个字节。随着 ESI 不断加 1，它就能顺序指向每一个字节：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>arrayB BYTE 10h, 20h, 30h<br><br>.code<br>mov esi, OFFSET arrayB<br>mov al, [esi]      ; AL = 10h<br>inc esi<br>mov al, [esi]      ; AL = 20h<br>inc esi<br>mov al, [esi]      ; AL = 30h<br></code></pre></td></tr></table></figure><p>如果使用 16 位的整数数组，就需要每次给 ESI 加 2 以便寻址后续的各个数组元素。</p><h2 id="变址操作数"><a href="#变址操作数" class="headerlink" title="变址操作数"></a>变址操作数</h2><p>变址操作数是指，在寄存器上加上常数产生一个有效地址。每个 32 位通用寄存器都可以用作变址寄存器。</p><p>MASM 可以用不同的符号来表示变址操作数（括号是表示符号的一部分)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">constant[reg]<br>[constant + reg]<br></code></pre></td></tr></table></figure><p>第一种形式是变量名加上寄存器。变量名由汇编器转换为常数，代表的是该变量的偏移量。</p><p>变址寻址的第二种形式是寄存器加上常数偏移量。变址寄存器保存数组或结构的基址，常数标识各个数组元素的偏移量。</p><p>两种形式的效果是相同的。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101235820435.png" alt="" style="zoom:67%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; example 1<br>.data<br>arrayB BYTE 10h, 20h, 30h<br>.code<br>mov esi, 0<br>mov al, arrayB[esi]       ; AL = 10h<br><br>; example 2<br>.data<br>arrayW WORD 1000h, 2000h, 3000h<br>.code<br>mov esi, OFFSET arrayW<br>mov ax, [esi]             ; AX = 1000h<br>mov ax, [esi + 2]         ; AX = 2000h<br>mov ax, [esi + 4]         ; AX = 3000h<br></code></pre></td></tr></table></figure><hr><h1 id="JMP-和-LOOP-指令"><a href="#JMP-和-LOOP-指令" class="headerlink" title="JMP 和 LOOP 指令"></a>JMP 和 LOOP 指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 95</p></blockquote><p>默认情况下，CPU是顺序加载并执行程序。但是，当前指令有可能是有条件的，也就是说，它按照 CPU 状态标志（零标志、符号标志、进位标志等）的值把控制转向程序中的新位置。汇编语言程序使用条件指令来实现如 IF 语句的高级语句与循环。每条条件指令都包含了一个可能的转向不同内存地址的转移（跳转）。控制转移，或分支，是一种改变语句执行顺序的方法，它有两种基本类型：</p><ul><li><p><strong>无条件转移</strong>：无论什么情况都会转移到新地址。新地址加载到指令指针寄存器，使得程序在新地址进行执行。JMP 指令实现这种转移。</p></li><li><p><strong>条件转移</strong>：满足某种条件，则程序出现分支。各种条件转移指令还可以组合起来，形成条件逻辑结构。CPU 基于 ECX 和标志寄存器的内容来解释真 &#x2F; 假条件。</p></li></ul><h2 id="JMP-指令"><a href="#JMP-指令" class="headerlink" title="JMP 指令"></a>JMP 指令</h2><p>JMP 指令无条件跳转到目标地址，该地址用代码标号来标识，并被汇编器转换为偏移量。语法是：<code>JMP destination</code>。</p><p>当 CPU 执行一个无条件转移时，目标地址的偏移量被送入指令指针寄存器，从而导致从新地址开始继续执行。</p><p>JMP 指令提供了一种简单的方法来创建循环即跳转到循环开始时的标号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">top:<br>    .<br>    .<br>    jmp top ; 不断地循环<br></code></pre></td></tr></table></figure><p>JMP 是无条件的，因此循环会无休止地进行下去，除非找到其他方法退出循环。</p><h2 id="LOOP-指令"><a href="#LOOP-指令" class="headerlink" title="LOOP 指令"></a>LOOP 指令</h2><p>LOOP指令，正式称为<strong>按照 ECX 计数器循环</strong>，将程序块重复特定次数。<strong>ECX 自动成为计数器，每循环一次计数值减 1</strong>。</p><p>语法是：<code>LOOP destination</code>。</p><p>循环目标必须距离当前地址计数器 -128 到 +127 字节范围内。</p><p>LOOP 指令的执行有两个步骤：第一步，ECX 减 1；第二步，将 ECX 与 0 比较。如果 ECX 不等于 0，则跳转到由目标给出的标号。否则如果 ECX 等于 0，则不发生跳转，并将控制传递到循环后面的指令。</p><p>在下例中，每次执行循环时 AX 加 1，当循环结束的时候 AX &#x3D; 5，ECX &#x3D; 0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">    mov ax, 0<br>    mov ecx, 5<br><br>L1:<br>    inc ax<br>    loop L1<br></code></pre></td></tr></table></figure><p>在循环内创建另一个循环的时候，必须考虑 ECX 中的外层循环计数该如何处理。一个较好的解决方案是把外层循环的技术保存在一个变量中。作为一条一般性的规则，应该尽量避免使用嵌套深度超过两层的循环。否则，管理循环计数将很复杂。</p><h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 98</p></blockquote><p><font size = 4><b>整数数组求和</b></font></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101210920217.png" alt="" style="zoom:67%;" /><p><font size = 4><b>复制字符串</b></font></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101211026618.png" style="zoom:67%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101211106805.png" alt="" style="zoom:67%;" /><p>MOV 指令不能同时有两个内存操作数，所以，每个源字符串字符送入 AL，然后再从 AL 送入目标字符串。</p>]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第三章</title>
    <link href="/posts/84d13931adf9/"/>
    <url>/posts/84d13931adf9/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第三章学习笔记</b></font></center><br><span id="more"></span><h1 id="汇编语言部分基本语言元素"><a href="#汇编语言部分基本语言元素" class="headerlink" title="汇编语言部分基本语言元素"></a>汇编语言部分基本语言元素</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 42</p></blockquote><p><font size = 5><b>整数常量</b></font></p><p>以字母开头的十六进制数必须加个前置0，以防汇编器将其解释为标识符。</p><p><font size = 5><b>字符串常量</b></font></p><p>和字符常量以整数形式存放一样，字符串常量在内存中的保存形式为<strong>整数字节数值序列</strong>。</p><p>例如，字符串常量 “ABCD” 就包含四个字节 41h、42h、43h、44h。</p><p><font size = 5><b>伪指令</b></font></p><p>伪指令 (directive) 是嵌入源代码中的命令，由汇编器识别和执行。</p><p>伪指令不在运行时执行，但是它们可以定义变量、宏和子程序；为内存段分配名称，执行许多其他与汇编器相关的日常任务。</p><p>默认情况下，伪指令不区分大小写。例如，<code>.data</code>，<code>.DATA</code> 和 <code>.Data</code> 是相同的。</p><p><font size = 5><b>定义段</b></font></p><p>汇编器伪指令的一个重要功能是定义程序区段，也称为段 (segment)。程序中的段具有不同的作用。</p><ul><li><p>数据段：<code>.DATA</code> 伪指令表示的数据段可以用于定义变量。</p></li><li><p>代码段：<code>.CODE</code> 伪指令标识的程序区段包含了可执行的指令。</p></li><li><p>堆栈段：<code>.STACK</code> 伪指令标识的程序区段定义了运行时堆栈，并设置了其大小。</p></li></ul><p><font size = 5><b>指令</b></font></p><p>指令 (instruction) 是一种语句，它在程序汇编编译时变得可执行。汇编器将指令翻译为机器语言字节，并且在运行时由 <code>CPU</code> 加载和执行。一条指令有四个组成部分：</p><ol><li>标号（可选）：是一种标识符，是指令和数据的位置标记。标号有两种类型：数据标号和代码标号。</li><li>指令助记符（必需）</li><li>操作数（通常是必需的）</li><li>注释（可选）</li></ol><h2 id="习题整理"><a href="#习题整理" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  计算机的 <code>CPU</code> 每执行一个 ( )，就完成一步基本运算。 （D）<br>  A. 软件<br>  B. 算法<br>  C. 程序<br>  D. 指令</p></blockquote><p>解析见上文整理内容。</p><blockquote><hr><p>  在 x86 汇编语言中，汇编程序常用的三个段，分别是（代码段）、（数据段）和（堆栈段）；<br>  对于 <strong>32位 CPU</strong>，用于在循环中控制循环次数的寄存器是（$ECX$），包含下一跳将要执行指令的地址的寄存器是（$EIP</span>$）。</p></blockquote><p>解析见上文整理内容。</p><blockquote><hr><p>  一条指令有四个组成部分，分别是标号、（指令助记符）、（操作数）和（注释）。其中，标号可分为（数据标号）和（代码标号）。</p></blockquote><p>解析见上文整理内容。</p><hr><h1 id="程序模板"><a href="#程序模板" class="headerlink" title="程序模板"></a>程序模板</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 47, 52, 67</p></blockquote><p>汇编语言程序有一个简单的结构，并且变化很小。当开始编写一个新程序时，可以从一个空 shell 程序开始，里面有所有基本的元素。通过填写缺省部分，并在新名字下保存该文件就可以避免键入多余的内容。关键字大小写均可：</p><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20221231195555.png" alt="image" style="zoom:67%;" /></center><hr><h1 id="汇编、连接和运行程序"><a href="#汇编、连接和运行程序" class="headerlink" title="汇编、连接和运行程序"></a>汇编、连接和运行程序</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 53</p></blockquote><p>用汇编语言编写的源程序不能直接在其目标计算机上执行，必须通过翻译或汇编将其转换为可执行代码。汇编器生成包含机器语言的文件，称为目标文件 (object file)。</p><p>这个文件还没有准备好执行，它还需传递给一个被称为链接器 (linker) 的程序，从而生成可执行文件 (executable file)。</p><p>这个文件就准备好在操作系统命令提示符下执行。</p><p><font size = 5><b>汇编-连接-执行周期</b></font></p><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221231174038959.png" alt="汇编-连接-执行周期" style="zoom: 67%;" /></center><p>对上图每一个步骤进行说明：</p><ol><li>编程者用文本编辑器 (text editor) 创建一个 <code>ASCII</code> 文本文件，称之为<strong>源文件</strong>。</li><li><strong>汇编器</strong>读取源文件，并<strong>生成目标文件</strong>，即对程序的机器语言翻译。或者，它也会生成列表文件。只要出现任何错误，编程者就必须返回步骤1，修改程序。</li><li><strong>链接器</strong>读取并<strong>检查目标文件</strong>，以便发现该程序是否包含了任何对链接库中过程的调用。链接器从链接库中复制任何被请求的过程，将它们与目标文件组合，以生成<strong>可执行文件</strong>。</li><li>操作系统<strong>加载</strong>程序将可执行文件读入内存，并使 CPU 分支到该程序起始地址，然后程序开始执行。</li></ol><h2 id="习题整理-1"><a href="#习题整理-1" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  在汇编语言中，能将目标文件生成可执行文件的程序是： （C）<br>  A. 调试程序<br>  B. 汇编程序<br>  C. 链接程序<br>  D. 编译程序</p></blockquote><p>链接器从链接库中复制任何被请求的过程，将它们与目标文件组合，以生成<strong>可执行文件</strong>。</p><hr><h1 id="定义数据"><a href="#定义数据" class="headerlink" title="定义数据"></a>定义数据</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 55</p></blockquote><p><strong>数据定义语句</strong>形如：<code>count DWORD 12345</code>。</p><h2 id="内部数据类型"><a href="#内部数据类型" class="headerlink" title="内部数据类型"></a>内部数据类型</h2><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221231175027618.png" alt="内部数据类型" style="zoom:67%;" /></center><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221231202803655.png" alt="image-20221231202803655" style="zoom: 67%;" /></center><h2 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h2><h3 id="定义整数类型"><a href="#定义整数类型" class="headerlink" title="定义整数类型"></a>定义整数类型</h3><p>初始值数据定义中<strong>至少要有一个初始值</strong>，即使该值为 0。</p><p>其他初始值，如果有的话，用逗号分隔（例如初始化数组：<code>list BYTE 10, 20, 30</code>）。<strong>对整数数据类型而言，初始值 (initializer) 是整数常量或是与变量类型</strong>，如 <code>BTYE</code> 或 <code>WORD</code> 相匹配的整数表达式。</p><p>如果程序员希望不对变量进行初始化（随机分配数值)，可以用符号 <code>?</code> 作为初始值。使用 <code>?</code> 初始值使得变量未初始化，这意味着在运行时分配数值到该变量。</p><p>所有初始值，不论其格式，都由汇编器转换为二进制数据。初始值 00110010b、32h 和 50d 都具有相同的二进制数值。</p><h3 id="定义字符串"><a href="#定义字符串" class="headerlink" title="定义字符串"></a>定义字符串</h3><p>定义一个字符串，要用单引号或双引号将其括起来。</p><p>最常见的字符串类型是用一个空字节(值为 0)作为结束标记，称为<strong>以空字节结束的字符串</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">greeting1 BYTE &quot;Good Afternoon&quot;, 0<br>greeting2 BYTE &#x27;Good Night&#x27;, 0<br></code></pre></td></tr></table></figure><p>十六进制代码 <code>ODh</code> 和 <code>0Ah</code> 也被称为 <code>CR/LF</code> (回车换行符) 或行结束字符。在编写标准输出时，它们将光标移动到当前行的下一行的左侧。</p><h3 id="DUP-操作符"><a href="#DUP-操作符" class="headerlink" title="DUP 操作符"></a>DUP 操作符</h3><p>DUP 操作符使用一个整数表达式作为计数器，<strong>为多个数据项分配存储空间</strong>。在为字符串或数组分配存储空间时，这个操作符非常有用，它可以使用初始化或非初始化数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">BYTE 20 DUP(O)       ; 20个字节，值都为0<br>BYTE 20 DUP(?)       ; 20个字节，非初始化<br>BYTE  4 DUP(&quot;STACK&quot;) ; 20个字节<br></code></pre></td></tr></table></figure><h3 id="定义浮点类型"><a href="#定义浮点类型" class="headerlink" title="定义浮点类型"></a>定义浮点类型</h3><ul><li><p>REAL4 定义 4 字节单精度浮点变量。</p></li><li><p>REAL8 定义 8 字节双精度数值。</p></li><li><p>REAL10 定义 10 字节扩展精度数值。</p></li></ul><p>每个伪指令都需要一个或多个实常数初始值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">rVal1     REAL4   -1.2<br>rVal2     REAL8   3.2E-260<br>rVal3     REAL10  4.6E+4096<br>shortArray  REAL4   20 DUP(0.0)<br></code></pre></td></tr></table></figure><p>下图描述了标准实数类型的最少有效数字个数和近似范围：</p><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221231190349341.png" alt="标准实数类型" style="zoom:67%;" /></center><h2 id="习题整理-2"><a href="#习题整理-2" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  语句“array WORD 6 DUP (4)”分配主存的存储单元个数是：（B）<br>  A. 6<br>  B. 12<br>  C. 24<br>  D. 48</p></blockquote><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/115640956">吐血整理！这篇带你彻底理解主存中存储单元地址的分配 - 知乎 (zhihu.com)</a></p><p>通常都是以8位二进制为一个存储单元，也就是一个字节。一个 <code>WORD</code> 拥有2个字节，<code>DUP</code> 前面的数字为6，表示共创建6个 <code>WORD</code>，即共12个字节。</p><blockquote><hr><p>  语句“array WORD 10 DUP (?)”分配主存的存储单元个数是：（20）</p></blockquote><p>解析无</p><blockquote><hr><p>  语句“array DWORD 10,20,30,40”分配主存的存储单元个数是：（16）</p></blockquote><p>解析无</p><blockquote><hr><p>  语句“array WORD 10,20,30,40”分配主存的存储单元个数是：（8）</p></blockquote><p>解析无</p><blockquote><hr><p>  语句“array DWORD 10,20,30,40,50”分配主存的存储单元个数是：（20）</p></blockquote><p>解析无</p><blockquote><hr><p>  语句“array word 5 dup(1, 2)”分配主存的存储单元个数是：（10）</p></blockquote><p><em><strong>待添加注释</strong></em></p><blockquote><hr><p>  下列哪个数据伪指令定义32位无符号整数变量：（D）<br>  A. WORD<br>  B. SWORD<br>  C. BYTE<br>  D. DWORD</p></blockquote><p><code>WORD</code> 16位无符号整数；<code>SWORD</code> 16位有符号整数；<code>BYTE</code> 8位无符号整数；<code>DWORD</code> 32位无符号整数。</p><blockquote><hr><p>  下列哪个数据伪指令定义16位有符号整数变量：（B）<br>  A. WORD<br>  B. SWORD<br>  C. BYTE<br>  D. SBYTE</p></blockquote><p><code>WORD</code> 16位无符号整数；<code>SWORD</code> 16位有符号整数；<code>BYTE</code> 8位无符号整数；<code>SBYTE</code> 8位有符号整数。</p><blockquote><hr><p>  下列哪个数据伪指令定义16位无符号整数变量？（C）<br>  A. DWORD<br>  B. SWORD<br>  C. WORD<br>  D. SDWORD</p></blockquote><p>解析无</p><blockquote><hr><p>  下列哪个数据伪指令定义32位有符号整数变量？（D）<br>  A. DWORD<br>  B. SWORD<br>  C. FWORD<br>  D. SDWORD</p></blockquote><p>解析无</p><blockquote><hr><p>  下列哪个数据伪指令定义8位有符号整数变量？（SBYTE）</p></blockquote><p>解析无</p><hr><h1 id="小端顺序"><a href="#小端顺序" class="headerlink" title="小端顺序"></a>小端顺序</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 62</p></blockquote><p>x86 处理器在内存中按<strong>小端顺序</strong> (低到高) <strong>存放和检索数据</strong>。</p><p>最低有效字节存放在分配给该数据的第一个内存地址中，剩余字节存放在随后的连续内存位置中。</p><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221231191909818.png" alt="image-20221231191909818" style="zoom:60%;" /></center><p>其他有些计算机系统采用的是大端顺序(高到低)。下图展示了 12345678h 从偏移量 0000 开始的大端顺序存放。</p><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221231192011363.png" alt="image-20221231192011363" style="zoom:63%;" /></center><h2 id="习题整理-3"><a href="#习题整理-3" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  变量保存于字节编址的内存存储器中，每个存储单元保存一个8位、字节量数据。多个字节数据顺序逐个存放在主存相邻单元。<br>  一般采用<strong>小端方式</strong>存储，即高字节数据保存在（<strong>高地址</strong>）存储单元，低字节数据保存在（<strong>低地址</strong>）存储单元。</p></blockquote><p>解析见上文整理内容。</p><hr><h1 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 63</p></blockquote><h2 id="等号伪指令"><a href="#等号伪指令" class="headerlink" title="等号伪指令"></a>等号伪指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">name = expression<br></code></pre></td></tr></table></figure><p>通常，表达式是一个32位的整数值。当程序进行汇编时，在汇编器预处理阶段，所有出现的 name 都会被替换为 expression。类比 C 语言的 <code>#define name expression</code>。</p><h2 id="计算数组大小"><a href="#计算数组大小" class="headerlink" title="计算数组大小"></a>计算数组大小</h2><p><code>$</code> 运算符（当前地址计数器）返回当前程序语句的偏移量。在下例中，从当前地址计数器（<code>$</code>）中减去list的偏移量，计算得到 ListSize。<strong>ListSize 必须紧跟在 list 的后面。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">list BYTE 10, 20, 30, 40<br>ListSize = ($ - list)<br></code></pre></td></tr></table></figure><h2 id="字数组和双字数组"><a href="#字数组和双字数组" class="headerlink" title="字数组和双字数组"></a>字数组和双字数组</h2><p>当要计算元素数量的数组中包含的不是字节时，就应该用数组总的大小（按字节计）除以单个元素的大小。</p><p>比如，在下例中，由于数组中的每个字要占2个字节（16位)，因此，地址范围应该除以2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">list WORD 1000h, 2000h, 3000h, 4000h<br>ListSize = ($ - list) / 2<br></code></pre></td></tr></table></figure><p>同样，双字数组中每个元素长4个字节，因此，其总长度除以4才能产生数组元素的个数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">list DOWRD 10000000h, 20000000h, 30000000h, 40000000h<br>ListSize = ($ - list) / 4<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第一二章</title>
    <link href="/posts/0adefcb064e3/"/>
    <url>/posts/0adefcb064e3/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第一、二章学习笔记</b></font></center><br><span id="more"></span><h1 id="汇编语言基本概念"><a href="#汇编语言基本概念" class="headerlink" title="汇编语言基本概念"></a>汇编语言基本概念</h1><p><font size = 4><b>汇编语言可移植吗?</b></font></p><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 3</p></blockquote><p>一种语言，如果它的源程序能够在各种各样的计算机系统中进行编译和运行，那么这种语言被称为是可移植的 (portable)。</p><p>例如，一个C++程序，除非需要特别引用某种操作系统的库函数，否则它就几乎可以在任何一台计算机上编译和运行。Java语言的一大特点就是，其编译好的程序几乎能在所有计算机系统中运行。</p><p><strong>汇编语言不是可移植的，因为它是为特定处理器系列设计的。</strong> 目前广泛使用的有多种不同的汇编语言，每一种都基于一个处理器系列。对于一些广为人知的处理器系列如 <code>Motorola68x00</code>、<code>x86</code>、<code>SUN Sparc</code>、<code>Vax</code> 和 <code>IBM-370</code>，汇编语言指令会直接与该计算机体系结构相匹配，或者在执行时用一种被称为微代码解释器 (microcode interpreter) 的处理器内置程序来进行转换。</p><p><font size = 4><b>汇编语言与机器语言有什么关系?</b></font></p><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 3</p></blockquote><p>机器语言 (machine language) 是一种数字语言，专门设计成能被计算机处理器（CPU）理解。所有 <code>x86</code> 处理器都理解共同的机器语言。汇编语言 (assembly language) 包含用短助记符如 <code>ADD</code>、<code>MOV</code>、<code>SUB</code> 和 <code>CALL</code> 书写的语句。</p><p><strong>汇编语言与机器语言是一对一 (one-to-one) 的关系：每一条汇编语言指令对应一条机器语言指令。</strong></p><p><font size = 4><b>C++ 和 Java 与汇编语言有什么关系?</b></font></p><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 3</p></blockquote><p><strong>高级语言如 <code>Python</code>、<code>C++</code> 和 <code>Java</code> 与汇编语言和机器语言的关系是一对多 (one-to-many)。</strong></p><p>比如，<code>C++</code> 的一条语句就会扩展为多条汇编指令或机器指令。这种转换需要多条语句，因为每条汇编语句只对应一条机器指令。</p><p><font size = 4><b>汇编语言有规则吗?</b></font></p><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 4</p></blockquote><p><strong>大多数汇编语言规则都是以目标处理器及其机器语言的物理局限性为基础的。</strong> 比如，CPU要求两个指令操作数的大小相同。</p><p>与 C++ 或 Java 相比，汇编语言的规则较少，因为，前者是用语法规则来减少意外的逻辑错误，而这是以限制底层数据访问为代价的。反之，汇编语言可以访问所有的内存地址。</p><p><font size = 4><b>为什么高级语言这么发达还会用汇编语言？</b></font></p><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 3</p></blockquote><ul><li><p>嵌入式程序是指一些存放在专用设备中小容量存储器内的短程序。高级语言可能生成很大的可执行文件，以至于超出设备的内存容量。由于汇编语言占用内存少，因此它是编写嵌入式程序的理想工具。</p></li><li><p>处理仿真和硬件监控的实时应用程序要求精确定时和响应。高级语言不会让程序员对编译器生成的机器代码进行精确控制。汇编语言则允许程序员精确指定程序的可执行代码。</p></li><li><p>电脑游戏要求软件在减少代码大小和加快执行速度方面进行高度优化。游戏程序员经常选择汇编语言作为工具，因为汇编语言允许直接访问计算机硬件，所以，为了提高速度可以对代码进行手工优化。</p></li></ul><p><font size = 4><b>汇编语言与高级语言的比较</b></font></p><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 4</p></blockquote><table><thead><tr><th>应用类型</th><th>高级语言</th><th>汇编语言</th></tr></thead><tbody><tr><td>商业或科学应用程序，为单一的中型或大型平台编写</td><td>规范结构使其易于组织和维护大量代码</td><td>最小规范结构，因此必须由具有不同程度经验的程序员来维护结构。这导致对已有代码的维护困难</td></tr><tr><td>硬件设备驱动程序</td><td>语言不一定提供对硬件的直接访问。即使提供了,可能也需要难以控制的编码技术，这导致维护困难</td><td>对硬件的访问直接且简单。当程序较短且文档良好时易于维护</td></tr><tr><td>为多个平台（不同的操作系统）编写的商业或科学应用程序</td><td>通常可移植。在每个目标操作系统上,源程序只做少量修改就能重新编译</td><td>需要为每个平台单独重新编写代码，每个汇编器都使用不同的语法。维护困难</td></tr><tr><td>需要直接访问硬件的嵌入式系统和电脑游戏</td><td>可能生成很大的可执行文件，以至于超出设备的内存容量</td><td>理想，因为可执行代码小，运行速度快</td></tr></tbody></table><h2 id="习题整理"><a href="#习题整理" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  （机器语言）是一种数字语言，专门设计成能被计算机处理器理解。<br>  （汇编语言）是包含用短助记符如 <code>ADD</code>、<code>MOV</code> 和 <code>CALL</code> 书写的语句，两者是（一对一）的关系。<br>  （高级语言）如 <code>Python</code>、<code>C++</code> 等与汇编语言的是（一对多）的关系。</p></blockquote><p>参考上文整理内容。</p><hr><h1 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h1><h2 id="整数存储大小"><a href="#整数存储大小" class="headerlink" title="整数存储大小"></a>整数存储大小</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 9</p></blockquote><p>在 <code>x86</code> 计算机中，所有数据存储的基本单位都是字节 (<code>byte</code>)，<strong>一个字节有8位</strong>。</p><p>其他的存储单位还有：</p><ul><li>字 (<code>word</code>，2个字节)</li><li>双字 ( <code>doubleword</code>，4个字节) </li><li>四字 (<code>quadword</code>，8个字节)</li></ul><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 12</p></blockquote><ol><li><p><strong>负整数使用补码表示。</strong> </p></li><li><p>将一个二进制整数按位取反(求补)再加 1，就形成了它的补码。将一个十六进制整数按位取反并加1，就生成了该十六进制整数的补码。</p></li><li><p><strong>补码操作是可逆的。</strong> 以 8 位二进制数 $0000 \space 0001$ 为例，其补码为 $1111 \space 1111$ 。同时，$1111 \space 1111$ 的补码也为 $0000 \space 0001$。</p></li></ol><h2 id="习题整理-1"><a href="#习题整理-1" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  对于下列8位有符号数来说，哪个值最大？（A）<br>  A. 81<br>  B. 0010 1100<br>  C. F5H<br>  D. 1101 0110</p></blockquote><p>A 为十进制数，值为 81；<br>B 为二进值数，值为 44；<br>C 为十六进制数，转换成二进值后为 $1111 \space 0101$，所以值为 -11；<br>D 为二进值数，值为 -42。</p><p>综上可得，A 的值最大</p><blockquote><hr><p>  A. 将16位十六进制数 55AAH 转化为二进制数的值为（$0101\space 0101\space 1010\space 1010$）；<br>  B. 将16位二进制数1100 1011 1001 0111B 转化为十六进制数的值为（$CB97$）；<br>  C. 有符号十进制整数-46的8位二进制补码是（$1101\space 0010$）；<br>  D. 十六进制整数A598 + 32A7&#x3D;（$D83F$）</p></blockquote><p>A 易得 $0101\space 0101\space 1010\space 1010$；<br>B 易得 $CB97$；<br>C 将 $46D &#x3D; 0010\space 1110B$，对 $0010\space 1110B$ 进行取反操作后 $+ 1$，可以到最终结果为 $1101\space 0010$；<br>D 通过 16 进制加法，可以计算出结果为 $D83F$。</p><blockquote><hr><p>  A. 将16位十六进制数AAF0H 转化为二进制数的值为（1010 1010 1111 0000）；<br>  B. 将16位二进制数1011 1101 0110 1001B 转化为十六进制数的值为（BD69）；<br>  C. 有符号十进制整数-98的8位二进制补码是（1001 1110）；<br>  D. 十六进制整数3A7+32F6&#x3D;（369D）</p></blockquote><p>解析无</p><blockquote><hr><p>  字长为8位的无符号数，其数值范围为（0）到（255）</p></blockquote><p>数值范围为 $2^0 \sim (2^8-1)$，即 0 ~ 255。</p><blockquote><hr><p>  将16位十六进制数6A8DH 转化为二进制数的值为（0110 1010 1000 1101）；<br>  将16位二进制数1010 0001 1110 1011B 转化为十六进制数的值为（A1EB）；<br>  有符号十进制整数-100的8位二进制补码是（1001 1100）；<br>  十六进制整数068A+7D08&#x3D;（8392）。</p></blockquote><p>解析无</p><blockquote><hr><p>  将16位十六进制数7DF6H 转化为二进制数的值为（0111 1101 1111 0110）；<br>  将16位二进制数1110 1101 0111 1000B 转化为十六进制数的值为（ED78）；<br>  有符号十进制整数-89的8位二进制补码是（1010 0111）；<br>  十六进制整数0F3D+A256&#x3D;（B193）。</p></blockquote><p>解析无</p><blockquote><hr><p>  将16位十六进制数8A5DH 转化为二进制数的值为（1000 1010 0101 1101）；<br>  将16位二进制数1010 0101 0110 1100B 转化为十六进制数的值为（A56C）；<br>  有符号十进制整数-98的8位二进制补码是（1001 1110）；<br>  十六进制整数753A+32F6&#x3D;（A830）。</p></blockquote><p>解析无</p><blockquote><hr><p>  在8位二进制数01101011中，最高有效位(MSB)的值是（0），最低有效位(LSB)的值是（1）。</p></blockquote><p>参考资料：<a href="https://blog.csdn.net/qq_29350001/article/details/51177404">LSB最低有效位和MSB最高有效位_聚优致成的博客-CSDN博客_最低有效位</a></p><p>最低有效位是指一个二进制数字中的即最低位，具有权值为 $2^0$，可以用它来检测数的奇偶性。在大端序中，<code>LSB</code> 指最右边的位。</p><p>最高有效位是指一个n位二进制数字中的最高位，具有最高的权值为 $2^n - 1$。在大端序中，<code>MSB</code> 即指最左端的位。对于有符号二进制数，负数采用反码或补码形式，此时 <code>MSB</code>用来表示符号，<code>MSB</code> 为 1 表示负数，为 0 表示正数。</p><blockquote><hr><p>  对于下列8位有符号数来说，最小的是：（D）<br>  A. 0<br>  B. 00101100B<br>  C. 75H<br>  D. 11010110B</p></blockquote><p>A B C 都为正数。而 D 的符号位为 1，表示负数。</p><blockquote><hr><p>  负数在内存里是以其哪种形式存放？（C）<br>  A. 原码<br>  B. 反码<br>  C. 补码<br>  D. 真值</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  对于下列8位有符号数来说，哪个值最大？（B）<br>  A. FFH<br>  B. 48H<br>  C. 70<br>  D. 11010110</p></blockquote><p>A ：-1；B：72；C：70；D：-42。</p><hr><h1 id="x86-处理器架构"><a href="#x86-处理器架构" class="headerlink" title="x86 处理器架构"></a>x86 处理器架构</h1><h2 id="基本微机设计"><a href="#基本微机设计" class="headerlink" title="基本微机设计"></a>基本微机设计</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 23</p></blockquote><div align="center"><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221230210411168.png" alt="image-20221230210411168" style="zoom:80%;" /></div><p>上图给出了假想机的基本设计。</p><ol><li><p>中央处理单元 (<code>CPU</code>) 是<strong>进行算术和逻辑操作</strong>的部件,包含了：</p><ul><li>寄存器 (register)<br>有限数量的存储位置。</li><li>一个高频时钟<br>时钟 (clock) <strong>对 <code>CPU</code> 内部操作与系统其他组件进行同步</strong>。</li><li>一个控制单元<br>控制单元 (control unit，<code>CU</code>) <strong>协调参与机器指令执行的步骤序列</strong>。</li><li>一个算术逻辑单元<br>算术逻辑单元 (arithmetic logic unit，<code>ALU</code>) <strong>执行算术运算</strong>，如加法和减法，以及逻辑运算，如 <code>AND</code> (与)、<code>OR</code>(或) 和 <code>NOT</code> (非)。</li></ul></li><li><p>内存存储单元 (memory storage unit) 用于<strong>在程序运行时保存指令与数据</strong>。<br> 它接受来自 <code>CPU</code> 的数据请求，<strong>将数据从随机存储器（<code>RAM</code>）传输到 <code>CPU</code>，并从 <code>CPU</code> 传输到内存</strong>。由于所有的数据处理都在 <code>CPU</code> 内进行，因此<strong>保存在内存中的程序在执行前需要被复制到 <code>CPU</code> 中</strong>。程序指令在复制到 <code>CPU</code> 时，可以一次复制一条，也可以一次复制多条。</p></li><li><p>CPU 通过主板上 CPU 插座的引脚与计算机其他部分相连。大部分引脚连接的是<strong>数据总线</strong>、<strong>控制总线</strong>和<strong>地址总线</strong>。</p></li><li><p>总线 (bus) 是一组并行线，用于<strong>将数据从计算机一个部分传送到另一个部分</strong>。<br> 一个计算机系统通常包含<strong>四类总线：数据类，I&#x2F;O类、控制类和地址类</strong>。</p><ul><li>数据总线 (data bus) <strong>在 <code>CPU</code> 和内存之间传输指令和数据</strong>。</li><li>I&#x2F;O总线<strong>在 <code>CPU</code> 和系统输入&#x2F;输出设备之间传输数据</strong>。</li><li>控制总线 (control bus) <strong>用二进制信号对所有连接在系统总线上设备的行为进行同步</strong>。</li><li>当前执行指令在 <code>CPU</code> 和内存之间传输数据时，地址总线 (address bus) <strong>用于保持指令和数据的地址</strong>。</li></ul></li><li><p>时钟︰与 CPU 和系统总线相关的每一个操作都是由一个恒定速率的内部时钟脉冲来进行同步。<br> <strong>机器指令的基本时间单位</strong>是机器周期 (machine cycle) 或<strong>时钟周期</strong> (clock cycle)。<br> 一个时钟周期的时长是一个完整时钟脉冲所需要的时间。<br> <strong>执行一条机器指令最少需要1个时钟周期</strong>，有几个需要的时钟则超过了50个（比如8088处理器中的乘法指令)。<br> 由于在 <code>CPU</code>、系统总线和内存电路之间存在速度差异，因此，<strong>需要访问内存的指令常常需要空时钟周期</strong>，也被称为<strong>等待状态</strong> (wait states )。</p></li></ol><h2 id="指令执行周期"><a href="#指令执行周期" class="headerlink" title="指令执行周期"></a>指令执行周期</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 24</p></blockquote><p>三个步骤：<strong>取指</strong> (Fetch)、<strong>译码</strong> (Decode) 和<strong>执行</strong> (Execute)。</p><p>操作数 (operand) 是指操作过程中输入或输出的值。</p><h2 id="读取内存"><a href="#读取内存" class="headerlink" title="读取内存"></a>读取内存</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 25</p></blockquote><p>作为一个常见现象，计算机<strong>从内存读取数据比从内部寄存器读取速度要慢很多</strong>。</p><p>这是因为从内存读取一个值，需要经过下述步骤：</p><ol><li>将想要读取的值的地址放到地址总线上。</li><li>设置处理器 RD（读取）引脚（改变 RD 的值）。</li><li>等待一个时钟周期给存储器芯片进行响应。</li><li>将数据从数据总线复制到目标操作数。</li></ol><p>上述每一步常常只需要一个时钟周期，虽然一共只需要4个时钟周期。但是，与CPU寄存器相比，这个速度还是慢了，因为访问寄存器一般只需要1个时钟周期。</p><p>CPU 设计者想出了一个可以减少读写内存的时间的方法——<strong>将大部分近期使用过的指令和数据存放在高速存储器 <code>cache</code> 中</strong>。</p><p>其思想是，程序更可能希望反复访问相同的内存和指令。因此，<code>cache</code> 保存这些值就能使它们能被快速访问到。此外，当 <code>CPU</code> 开始执行一个程序时，它会预先将后续（比如）一千条指令加载到 <code>cache</code> 中，这个行为是基一种假设，即这些指令很快就会被用到。如果这种情况重复发生在一个代码块中，则 <code>cache</code> 中就会有相同的指令。</p><p>当处理器能够在 <code>cache</code> 存储器中发现想要的数据，则称为 <strong><code>cache</code> 命中</strong> (cache hit)。反之，如果 <code>CPU</code> 在 <code>cache</code> 中没有找到数据，则称为 <strong><code>cache</code> 未命中</strong> (cache miss)。</p><p>x86 系列中的 <code>cache</code> 存储器有两种类型：</p><ul><li>一级 <code>cache</code> (或主 <code>cache</code>)位于 <code>CPU</code> 上</li><li>二级 <code>cache</code> (或次 <code>cache</code> )速度略慢，通过高速数据总线与 <code>CPU</code> 相连</li></ul><p>这两种 <code>cache</code> 以最佳方式一起工作。</p><p>还有一个原因使得 <code>cache</code> 存储器比传统 <code>RAM</code> 速度快—— <code>cache</code> 存储器是由一种被称为<strong>静态 <code>RAM</code></strong> ( static RAM）的特殊存储器芯片构成的。</p><h2 id="习题整理-2"><a href="#习题整理-2" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  在微型计算机中，微处理器的主要功能是：（A）<br>  A. 算术逻辑运算及全机的控制<br>  B. 逻辑运算<br>  C. 算术逻辑运算<br>  D. 算术运算</p></blockquote><p>解析无</p><blockquote><hr><p>  中央处理单元是进行算术和逻辑操作的部件，包含了（寄存器）、高频时钟、（控制单元）和（算术逻辑单元）。</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  （总线）是一组并行线，用于将数据从计算机的一个部分传到另一部分。<br>  其中，（数据总线）用于在内存和 <code>CPU</code> 之间传递指令和数据；<br>  （控制总线）使用二进制信号对所有连接在总线上的设备的行为进行同步。</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  当处理器能够在 <code>cache</code> 存储器中发现想要的数据，则称为 <code>cache</code>（命中）。<br>  反之，如果 <code>CPU</code> 在 <code>cache</code> 中没有找到数据，则称为 <code>cache</code>（未命中）。</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  CPU可以用来描述计算机的：（A）<br>  A. 运算速度<br>  B. 输入功率<br>  C. 磁盘转速<br>  D. 更新频率</p></blockquote><p><em><strong>解析待添加</strong></em></p><blockquote><hr><p>  一条指令的执行通常可分为(取指)、（编码）和（执行）三个阶段。</p></blockquote><p>解析见上文整理内容。</p><hr><h1 id="x86-处理器"><a href="#x86-处理器" class="headerlink" title="x86 处理器"></a>x86 处理器</h1><h2 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 27</p></blockquote><p>x86处理器有四个主要的操作模式：</p><ul><li>保护模式</li><li>实地址模式</li><li>系统管理模式</li><li>子模式：虚拟8086 (virtual-8086) 模式，这是保护模式的特殊情况。</li></ul><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 27</p></blockquote><p>在32位<strong>保护模式</strong>下，一个任务或程序最大可以寻址 <strong>4GB 的线性地址空间</strong>。</p><p>从 P6 处理器开始，一种被称为<strong>扩展物理寻址</strong> (extended physical addressing) 的技术使得可以被寻址的<strong>物理内存空间增加到 64GB</strong>。</p><p>与之相反，<strong>实地址模式</strong>程序只能<strong>寻址 1MB 空间</strong>。</p><p>如果处理器在<strong>保护模式下运行多个虚拟8086程序</strong>，则<strong>每个程序只能拥有自己的1MB内存空间</strong>。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 28</p></blockquote><p>寄存器是直接位于 <code>CPU</code> 内的高速存储位置，其设计访问速度远高于传统存储器。</p><div align="center"><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221230231001537.png" alt="image-20221230231001537" style="zoom: 67%;" /></div><p>上图展示的是 32位 x86 处理器的基本程序执行寄存器 (basic program execution registers)。8个通用寄存器，6个段寄存器，一个处理器状态标志寄存器 (EFLAGS)，和一个指令指针寄存器 (EIP)。下图为 64为 x86-64 处理器中的寄存器。</p><div align="center"><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-909063cd57cd5b2136ff8ed4d04bc5e6_1440w.jpg" alt="img" style="zoom:57%;" /></div><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>通用寄存器主要用于算术运算和数据传输。其中，存在一些拥有特殊用法的通过寄存器：</p><ul><li>乘除指令默认使用 <code>EAX</code>。它常常被称为扩展累加器 (extended accumulator) 寄存器。</li><li><code>CPU</code> 默认使用 <code>ECX</code> 为循环计数器。</li><li><code>ESP</code> 用于寻址堆栈（一种系统内存结构）数据。它极少用于一般算术运算和数据传输，通常被称为扩展堆栈指针 (extended stack pointer) 寄存器。</li><li><code>ESI</code> 和 <code>EDI</code> 用于高速存储器传输指令，有时也被称为扩展源变址（ extended source index）寄存器和扩展目的变址 (extended destination index) 寄存器。</li><li>高级语言通过 <code>EBP</code> 来引用堆栈中的函数参数和局部变量。除了高级编程，它不用于一般算术运算和数据传输。它常常被称为扩展帧指针 (extended frame pointer) 寄存器。</li></ul><h3 id="指令指针"><a href="#指令指针" class="headerlink" title="指令指针"></a>指令指针</h3><p>指令指针 (<code>EIP</code>) 寄存器中包含下一条将要执行指令的地址。某些机器指令能控制 <code>EIP</code>，使得程序分支转向到一个新位置。</p><h3 id="状态标志位"><a href="#状态标志位" class="headerlink" title="状态标志位"></a>状态标志位</h3><blockquote><p>  设置标志位时，该标识位 &#x3D; 1；</p><p>  清除（或重置）标识位时，该标志位 &#x3D; 0。</p></blockquote><ul><li>进位标志位 (<code>CF</code>)，与目标位置相比，<strong>无符号</strong>算术运算结果太大时，设置该标志位。</li><li>溢出标志位 (<code>OF</code>)，与目标位置相比，<strong>有符号</strong>算术运算结果太大或太小时，设置该标志位。</li><li>符号标志位 (<code>SF</code>)，算术或逻辑操作产生<strong>负结果</strong>时,设置该标志位。</li><li>零标志位 (<code>ZF</code>)，算术或逻辑操作产生的<strong>结果为零</strong>时，设置该标志位。</li><li>辅助进位标志位 (<code>AC</code>)，算术操作在8位操作数中产生了位3向位4的<strong>进位</strong>时，设置该标志位。</li><li>奇偶校验标志位 (<code>PF</code>)，结果的最低有效字节包含偶数个1时，设置该标志位，否则，清除该标志位。一般情况下，如果数据有可能被修改或损坏时，该标志位用于进行错误检测。</li></ul><h2 id="习题整理-3"><a href="#习题整理-3" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  当无符号数算术运算结果超过目标位置大小时，应设置（进位）标志位；<br>  当有符号数算术运算结果对目标位置而言太大或太小时，应设置（溢出）标志位；<br>  当运算产生负数结果时，应设置（符号）标志位；<br>  当运算结果为零时，应设置（零）标志位。</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  算术或逻辑操作产生结果为零时，设置（零）标志位；<br>  与目标位置相比，有符号算术运算结果太大或太小时，设置（溢出）标志位。</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  下列标志位中，可用来判断无符号数运算结果太大的是：（B）<br>  A. OF<br>  B. CF<br>  C. ZF<br>  D. SF</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  下列几种存储器中，存取速度最快的是：（B）<br>  A. Cache<br>  B. 寄存器<br>  C. 内存<br>  D. 光盘</p></blockquote><p>在存储器层次结构中，存储器速度从最快到最慢的排列顺序是：<strong>寄存器 -&gt; <code>cache</code> -&gt; 主存 -&gt; 辅存</strong>。</p><blockquote><hr><p>  在程序执行过程中，EIP 寄存器保存的是？（B）<br>  A. 上一条已执行指令的地址<br>  B. 下一条即将要执行指令的地址<br>  C. 正在执行指令的地址<br>  D. 当前堆栈的栈顶</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  下列标志位中，可用来判断计算结果为零的是？（$ZF$）</p></blockquote><p>零标志位 (<code>ZF</code>)、算术或逻辑操作产生的<strong>结果为零</strong>时，设置该标志位。</p><blockquote><hr><p>  算数或逻辑操作产生负结果时，设置（ 符号）标志位；<br>  与目标位置相比，无符号算术运算结果太大时，设置（进位）标志位。</p></blockquote><p>解析见上文整理内容。</p><blockquote><hr><p>  两个整数相减等于0，则标志位正确的是：（D）<br>  A. ZF&#x3D;0 , PF&#x3D;0 , SF&#x3D;0<br>  B. ZF&#x3D;1 , PF&#x3D;0 , SF&#x3D;1<br>  C. ZF&#x3D;0 , PF&#x3D;1 , SF&#x3D;0<br>  D. ZF&#x3D;1 , PF&#x3D;1 , SF&#x3D;0</p></blockquote><ul><li>零标志位 (<code>ZF</code>)，算术或逻辑操作产生的<strong>结果为零</strong>时，设置该标志位。</li><li>符号标志位 (<code>SF</code>)，算术或逻辑操作产生<strong>负结果</strong>时,设置该标志位。</li><li>奇偶校验标志位 (<code>PF</code>)，结果的最低有效字节包含偶数个1时，设置该标志位，否则，清除该标志位。</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-TCP/IP协议族</title>
    <link href="/posts/6ed3afd2e436/"/>
    <url>/posts/6ed3afd2e436/</url>
    
    <content type="html"><![CDATA[<blockquote><p>   一系列协议所组成的一个网络分层模型。</p></blockquote><hr><h1 id="为什么要分层"><a href="#为什么要分层" class="headerlink" title="为什么要分层"></a>为什么要分层</h1><p>由于现实网络的不稳定性以及不可靠性，所以需要将大数据进行分块传输，才能保障传输效率。但是应用层有许多协议，所有的协议都可能需要分块传输以及稳定传输等众多功能需求，所以为了能够复用一部分相同或者相似的功能，我们使用了分层，方便各个功能模块的解耦和复用。</p><p>如果网络能够稳定的话，那么分成两层也就够了。一层为应用层 HTTP，第二层就直接可以是数据链路层了。</p><hr><h1 id="四层网络模型"><a href="#四层网络模型" class="headerlink" title="四层网络模型"></a>四层网络模型</h1><table><thead><tr><th align="left">层级</th><th>协议</th></tr></thead><tbody><tr><td align="left">应用层</td><td>- <code>HTTP</code><br />- <code>FTP</code><br />- <code>DNS</code></td></tr><tr><td align="left">传输层</td><td>- <code>TCP</code><br />- <code>UDP</code></td></tr><tr><td align="left">网络层</td><td>- <code>IP</code></td></tr><tr><td align="left">数据链路层</td><td>- 以太网<br />- <code>Wi-Fi</code></td></tr></tbody></table><p>应用层负责完成我们所期望的实际的工作的内容。</p><p>但是因为现实网络的不稳定性以及不可靠性，所以有了传输层来用于分块传输。但是由于有些数据在网络不稳定的时候即使丢失了也不需要进行重传，所以在 TCP 之外有了一个 UDP，他们并行存在，都位于传输层。如果所有的协议都不需要重传的话，那么也就不需要这一层了。</p><p>但是为了对他们有一个共同的下位支持，所以分离出来了一个有着 IP 协议的网络层。网络层负责以最小的单位发送和接受上层分块的网络数据以及选址、路由等最下层的网络方面工作。这些工作主要就是 IP 协议做的。</p><p>最下层的数据链路层可以看作是一个物理级别的支持，当然也不止是纯粹的物理设备，比如还有线缆标准，无线网络标准等等用于保障数据的发送和接受不会出现歧义的内容。</p><hr><h1 id="七层网络模型"><a href="#七层网络模型" class="headerlink" title="七层网络模型"></a>七层网络模型</h1><p>由 OSI 制定。较四层模型更加的细致。</p><hr><h1 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a><code>TCP</code> 连接</h1><h2 id="什么是连接"><a href="#什么是连接" class="headerlink" title="什么是连接"></a>什么是连接</h2><p>通信双方建立确认「可以通信」，不会将对方的消息丢弃，即为「建立连接」。</p><p>通过双方建立连接，可以使得双方认识彼此，在以后的通信中可以不用每次确认身份而直接开始交流。</p><p>建立连接后，双方会各自确定一个端口，当使用该端口，发送或接受信息时，就可以直接确认对方的身份了。</p><p>将端口更加具象化后，就成为了 <code>Java</code> 中的 <code>Socket</code>（套接字）类，即 Java 对于 TCP 的端口的一个具体的实现。</p><blockquote><p>  Socket <code>n. 插口</code></p></blockquote><h2 id="TCP-连接的建立与关闭"><a href="#TCP-连接的建立与关闭" class="headerlink" title="TCP 连接的建立与关闭"></a><code>TCP</code> 连接的建立与关闭</h2><p><font size = 4><b>建立：三次握手</b></font></p><ul><li><p>开启双方的认识和交流。</p></li><li><p>开启端口。</p></li></ul><p><font size = 4><b>关闭：四次挥手</b></font></p><ul><li><p>忘记对方，结束双方的交流。</p></li><li><p>释放资源，关闭端口。</p></li></ul><h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><h3 id="为什么要长连接"><a href="#为什么要长连接" class="headerlink" title="为什么要长连接"></a>为什么要长连接</h3><p>因为移动网络并不在 Internet 中，而是在运营商的内网，并不具有真正的公网 IP， 因此当某个 TCP 连接在一段时间不通信之后，网关会出于网络性能考虑而关闭这条 TCP 连接和公网的连接通道，导致这个 TCP 端口不再能收到外部通信消息，即 TCP 连接被动关闭。</p><h3 id="长连接的实现方式：心跳"><a href="#长连接的实现方式：心跳" class="headerlink" title="长连接的实现方式：心跳"></a>长连接的实现方式：心跳</h3><p>在一定的时间间隔之内，不断的使用 TCP 的连接去发送一些超级短的且没有意义的消息到对方。目的是确认双方之间的连接是通畅的，让网关不能将自己定义为「空闲连接」，从而防止网关将自己的连接关闭。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP/IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-登录和授权</title>
    <link href="/posts/e26999fccebc/"/>
    <url>/posts/e26999fccebc/</url>
    
    <content type="html"><![CDATA[<h1 id="登录和授权的区别"><a href="#登录和授权的区别" class="headerlink" title="登录和授权的区别"></a><font size = 5><b>登录和授权的区别</b></font></h1><ul><li>登录：身份认证，即确认「你是你」的过程。 </li><li>授权：由身份或持有的令牌确认享有某些权限（例如获取用户信息）。而登录过程实质上的⽬的也是为了确认权限。</li></ul><hr><h1 id="登录和授权的两种方式"><a href="#登录和授权的两种方式" class="headerlink" title="登录和授权的两种方式"></a><font size = 5><b>登录和授权的两种方式</b></font></h1><ul><li><code>Cookie Header</code></li><li><code>Authorization Header</code></li></ul><hr><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><code>Cookie</code></h1><blockquote><ul><li><p>可以把任何服务器希望存在用户本地的数据都存在用户本地。</p></li><li><p>可以认为是浏览器的缓存。</p></li><li><p>是一个 <code>Header</code>，也是一种信息存储机制。</p></li><li><p>同一个服务器可以用多个 <code>Cookie</code>，只要每个 <code>Cookie</code> 的名字不一样就行了。</p></li></ul></blockquote><h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><ol><li><p>服务器需要客户端保存的内容，放在 <code>Set-Cookie</code> headers 里返回，客户端会<strong>自动</strong>保存。</p></li><li><p>客户端保存的 Cookies，会在之后的所有请求里都 <strong>自动</strong> 携带进 <code>Cookie</code> header 里发回给服务器。</p></li><li><p>客户端保存 <code>Cookie</code> 是按照 <strong>服务器域名</strong> 来分类的，例如 shop.com 发回的 <code>Cookie</code> 保存下来以后，在之后向 games.com 的请求中并不会携带。</p></li><li><p>客户端保存的 <code>Cookie</code> 在超时后会被删除、没有设置超时时间的 <code>Cookie</code> （称作 <code>Session Cookie</code>）在浏览器关闭后就会自动删除；另外，服务器也可以主动删除还未过期的客户端 Cookies。</p></li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>出现 <code>Cookie</code> 的时候还没有 <code>JavaScript</code> 语言，所以不能对 <code>Cookie</code> 进行浏览器本地计算，必须要将 <code>Cookie</code> 传到服务器处理。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li><p>会话管理：登录状态、购物车等</p><p>移动开发通常也只将 Cookie 用于登录状态管理，且现在也越来越少的进行使用了。</p><blockquote><p>  <strong>使用 <code>Cookie</code> 管理登录状态</strong></p><p>  客户端向服务器发送用户名和密码后，当服务器验证用户登录成功后，会通过 <code>Set-Cookie</code> 向客户端传输一个 <code>SessionId</code> 的字段。<code>SessionId</code> 可以是记录了用户此次登录的会话编号。</p><p>  此后客户端每次发送请求的时候通过携带该 <code>Cookie</code> 便可将 <code>HTTP</code> 从无状态变为有状态。</p><p>  当服务器从数据库中发现存在一样的 <code>SessionId</code> 后，便可确认用户的身份信息了。</p></blockquote></li><li><p>个性化：用户篇好、主题等</p><p>如果由服务器网页有多个主题以及其他个性化内容的话，可以通过存储 <code>client_id</code> 等相似字段记录用户的选择，从而记录并显示用户的偏好。</p></li><li><p>Tracking：分析用户行为，追踪用户行为。</p><p>通过记录用户访问的网站信息或者其他信息，可以更加方便得向用户推广广告。</p></li></ol><h2 id="XSS-Cross-site-scripting"><a href="#XSS-Cross-site-scripting" class="headerlink" title="XSS(Cross-site scripting)"></a><code>XSS(Cross-site scripting)</code></h2><p><strong>跨站脚本攻击。</strong>通过 <code>JavaScript</code> 获取客户端浏览器中的 <code>Cookie</code> 并利用其中的信息，如网站登录信息等。</p><p>可以通过 <code>HttpOnly</code> 进行防护，作用是让 <code>Cookie</code> 只能用于发送请求时自动携带，而无法通过 <code>JavaScript</code> 主动获取。添加方法形如 <code>Set-Cookie:session_id=123;HttpOnly</code> 即可。</p><h2 id="XSRF-Cross-site-request-forgery"><a href="#XSRF-Cross-site-request-forgery" class="headerlink" title="XSRF(Cross-site request forgery)"></a><code>XSRF(Cross-site request forgery)</code></h2><p><strong>跨站请求伪造。</strong>在用户不知情的情况下访问了一个用户保存了 <code>Cookie</code> 的网站，以此来进行一些越权操作。</p><p>例如，私自访问用户保存了 <code>Cookie</code> 的银行网站并通过添加 <code>url</code> 参数来进行转账操作等等。</p><p>可以通过 <code>Referer</code> 校验解决，通过在发送请求的时候 <strong>自动且强制</strong> 在 Header 中添加 <code>Referer</code> 参数，其中保存了从哪一个网址跳转进入了该网址。服务器只需要校验 <code>Referer</code> 参数是否在白名单中即可保证访问安全。</p><hr><h1 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a><code>Authorization</code></h1><blockquote><p>  目前较 <code>Cookie</code> 更加流行。</p></blockquote><p><font size = 5><b>两种用法</b></font></p><h2 id="Basic-token"><a href="#Basic-token" class="headerlink" title="Basic token"></a><code>Basic token</code></h2><p>格式：<code>Authorization: Basic &lt;username:password(Base64ed)&gt;</code>。其中，<code>&lt;username:password(Base64ed)&gt;</code> 部分是将 <code>username:password</code> 格式的字符串进行 <code>Base64</code> 处理后重新替换到 <code>Basic</code> 后面。</p><p>服务器对 token 进行校验，如果校验通过，那么授权验证通过，客户端就可以获取到用户信息。如果数据不对，那么就获取不到用户信息，服务器对报 401 错误，即权限不足。</p><h2 id="Bearer-token"><a href="#Bearer-token" class="headerlink" title="Bearer token"></a><code>Bearer token</code></h2><blockquote><p>  Bearer : n. 拿着的人，持票人</p></blockquote><p>格式：<code>Authorization: Bearer &lt;bearer token&gt;</code>。<code>&lt;bearer token&gt;</code> 是授权方发给我们的 <code>access token</code>。</p><h3 id="access-token-获取方法"><a href="#access-token-获取方法" class="headerlink" title="access token 获取方法"></a><code>access token</code> 获取方法</h3><h4 id="OAuth2-流程"><a href="#OAuth2-流程" class="headerlink" title="OAuth2 流程"></a><code>OAuth2</code> 流程</h4><ol start="0"><li><p>第三方网站向授权方网站申请第三方授权合作，拿到 <code>client_id</code> 和 <code>client_secret</code></p><blockquote><p>  <code>client_id</code>：申请授权的 app 的 id。</p><p>  <code>client_secret</code>：需要严格保密，保存在第三方网站服务器中，作为密码的作用，证明是第三方网站自己申请的授权。</p></blockquote></li><li><p>用户在使用第三方网站时，点击「通过 XX (如 <code>GitHub</code>) 授权」按钮，第三方网站将页面跳转到授权方网站，并传入 <code>client_id</code> 作为自己的身份标识。</p></li><li><p>授权方网站根据  <code>client_id</code>  ，将第三方网站的信息和第三方网站需要的用户权限展示给用户，并询问用户是否同意授权</p></li><li><p>用户点击「同意授权」按钮后，授权方网站将页面跳转回第三方网站，并传入 <code>Authorization code</code> 作为用户认可的凭证。</p></li><li><p>第三方网站将 <code>Authorization code</code> 发送回自己的服务器。</p></li><li><p>服务器将 <code>Authorization code</code> 和自己的 <code>client_secret</code> ⼀并发送给授权方的服务器，授权方服务器在验证通过后，返回 <code>access token</code>。OAuth 流程结束。</p></li><li><p>在上面的过程结束之后，第三方网站的服务器（或者有时客户端也会）就可以使用 <code>access token</code> 作为用户授权的令牌，通过 <code>Authorization: Bearer &lt;access token&gt;</code> 向授权方网站发送请求来获取用户信息或操作用户账户。但这已经在 OAuth 流程之外。</p></li></ol><blockquote><p>  为什么 <code>OAuth</code> 要引入 <code>Authorization code</code>，并需要申请授权的第三方将 <code>Authorization code</code> 发送回自己的服务器，再从服务器来获取 <code>access token</code>， 而不是直接返回 <code>access token</code> ？这样复杂的流程意义何在？ </p><p>  为了安全。<code>OAuth</code> 不强制授权流程必须使用 <code>HTTPS</code>，因此需要保证当通信路径中存在窃听者时，依然具有足够高的安全性。</p></blockquote><h4 id="微信登录流程"><a href="#微信登录流程" class="headerlink" title="微信登录流程"></a>微信登录流程</h4><p>第三方 App 通过微信登录的流程，也是一个 <code>OAuth2</code> 流程：</p><ol start="0"><li>第三方 App 向腾讯申请第三方授权合作，拿到 <code>client_id</code> 和 <code>client_secret</code></li><li>用户在使用第三方 App 时，点击「通过微信登录」，第三方 App 将使用微信 SDK 跳转到微信，并传入自己的 <code>client_id</code> 作为自己的身份标识</li><li>微信通过和服务器交互，拿到第三方 App 的信息，并限制在界面中，然后询问用户是否同意授权该 App 使用微信来登录。</li><li>用户点击「使用微信登录」后，微信和服务器交互将授权信息提交，然后跳转回第三方 App，并传入 <code>Authorization code</code> 作为用户认可的凭证。</li><li>第三方 App 调用自己服务器的「微信登录」API，并传入 <code>Authorization code</code>，然后等待服务器的响应。</li><li>服务器在收到登录请求后，拿收到的 <code>Authorization code</code> 去向微信的第三方授权接口发送请求，将 <code>Authorization code</code> 和自己的 <code>client_secret</code> 一起作为参数发送，微信在验证通过后，返回 <code>access token</code>。</li><li>服务器在收到 <code>access token</code> 后，立即拿着 <code>access token</code> 去向微信的用户信息接口发送请求，微信验证通过后，返回用户信息。</li><li>服务器在收到用户信息后，在自己的数据库中为用户创建一个账户，并使用从微信服务器拿来的用户信息填入自己的数据库，以及将用户的 ID 和用户的微信 ID 做关联。</li><li>用户创建完成后，服务器向客户端的请求发送响应，传送回刚创建好的用户信息。</li><li>客户端收到服务器响应，用户登录成功。</li></ol><h4 id="在自家-App-中使用-Bearer-token-登录"><a href="#在自家-App-中使用-Bearer-token-登录" class="headerlink" title="在自家 App 中使用 Bearer token 登录"></a>在自家 App 中使用 <code>Bearer token</code> 登录</h4><p>有的 App 会在 API 的设计中，将登录和授权设计成类似 OAuth2 的过程，但简化掉 <code>Authorization code</code> 概念。</p><p>即：登录接口请求成功时，会直接返回 <code>access token</code>，然后客户端在之后的请求中，就可以使用这个 <code>access token</code> 来当做<br><code>bearer token</code> 进⾏用户操作了。</p><blockquote><p>  <strong>Refresh token</strong></p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Bearer&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxxxx&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxxxx&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;expires_time&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxxxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>  用法：</p><ul><li><code>access token</code> 有失效时间，在它失效后，调⽤ <code>refresh_token</code> 接口，传入 <code>refresh_token</code> 来获取新的 <code>access token</code>。</li></ul><p>  目的：</p><ul><li>安全。当 <code>access token</code> 失窃，由于它有失效时间，因此坏人只有较短的时间来「做坏事」。</li><li>同时，由于（在标准的 <code>OAuth2</code> 流程中）<code>refresh token</code> 永远只存在与第三方服务的服务器中，因此 <code>refresh token</code> 几乎没有失窃的风险。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OAuth2</tag>
      
      <tag>Cookie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-HTTPS</title>
    <link href="/posts/0a77f507cef9/"/>
    <url>/posts/0a77f507cef9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>   <code>HTTP Secure</code> &#x2F; <code>HTTP over SSL</code> &#x2F; <code>HTTP over TLS</code></p><p>  即工作在 <code>SSL</code>（或 <code>TLS</code>）上的 <code>HTTP</code>。说白了就是加密通信的 <code>HTTP</code>。</p><ul><li><code>SSL</code> : Secure Socket Layer（安全套接字层）（<code>TLS</code> 前身）</li><li><code>TLS</code> : Transport Layer Security（传输层安全性）</li></ul></blockquote><hr><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在 <code>HTTP</code> 和 <code>TCP</code> 之间增加了一个 <strong>安全层</strong>（安全的加密层），用于保障 <code>HTTP</code> 的加密传输。</p><p>即 <code>HTTP</code> 将数据交给 <code>TCP</code> 之前，先把数据交给 <code>TLS</code>，由 <code>TLS</code> 将数据进行加密后，再往下交给 <code>TCP</code> 进行数据去传输。</p><p>以及对面的接受方在 <code>TCP</code> 层收到数据且拼接好之后，不直接交给 <code>HTTP</code> 层，而是先交给 <code>TCP</code> 层进行解密，解密完后再由 <code>TLS</code> 交给 <code>HTTP</code>。</p><hr><h1 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h1><p>在客户端和服务器之间用 <strong>非对称加密</strong> 协商出一套 <strong>对称密钥</strong> ，每次发送信息之前将内容加密，收到之后解密，达到内容的加密传输。</p><h2 id="为什么不直接用非对称加密"><a href="#为什么不直接用非对称加密" class="headerlink" title="为什么不直接用非对称加密"></a>为什么不直接用非对称加密</h2><p>非对称加密由于使用了复杂了数学原理，因此计算相当复杂，如果完全使用非对称 加密来加密通信内容，会严重影响用络通信的性能</p><hr><h1 id="HTTPS-TLS-的连接"><a href="#HTTPS-TLS-的连接" class="headerlink" title="HTTPS (TLS) 的连接"></a>HTTPS (TLS) 的连接</h1><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><ol><li>客户端请求建立 <code>TLS</code> 连接</li><li>服务器发挥证书</li><li>客户端验证服务器证书</li><li>客户端信任服务器后，和服务器协商对称密钥（此时通过非对称加密的方式协商对称密钥）</li><li>使用对称密码开始通信</li></ol><h2 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h2><blockquote><p>  可以通过 WireShark 进行更加详细的查看。</p></blockquote><ol><li><p>客户端和服务器第一次打招呼。</p><p>客户端向服务器发送 Client Hello（大小为1字节的数据，值为1，这个数据的名字叫做 Client Hello）。</p><p>同时，也会再附加信息中发送服务器可选的 <code>TLS</code> 版本、可选的加密套件（对称加密算法、非对称加密算法、哈希算法）、客户端生成的随机数。</p></li><li><p>服务器收到 Client Hello 后，确定双方可以共同使用的 <code>TLS</code> 版本、加密套件 ，以及服务端自己生成的以及随机数，并将这些信息发回给客户端，称为 Server Hello。Server Hello 也是一个单字节数据，值为2。</p><p>如果没有可以共同使用的内容，那么 <code>HTTPS</code> 就直接建立失败。</p></li><li><p>服务器发送自己的证书。</p><blockquote><p>   <strong>证书中主要包含了</strong>：</p><ol><li>服务器的公钥（其实是个数据）</li><li>服务器的证书的签名（由证书签发机构的私钥对服务器证书的签名）</li><li>证书签发机构的公钥（用户验证这个“公钥签名”的另一个公钥）</li><li>证书签发机构的证书的签名</li><li>证书签发机构的签发机构（根证书机构）的公钥</li><li>服务器主机名</li></ol></blockquote><p>可以让客户端进行信息加密。客户端通过服务器的公钥进行信息加密，服务器可以通过自己的密钥进行信息的解密。</p><blockquote><p>   <strong>服务器公钥的签名</strong></p><p>   用私钥对服务器公钥的 Hash 值版进行一次非对称加密的计算得到的结果数据。这个数据可以被该私钥对应的公钥所解开。</p><p>   如果解开签名之后的值正好等于服务器公钥经过一次 Hash 计算后的结果值，那么就证明这个源数据是没有问题的。</p><p>   注意：用于解开的公钥和被签名的公钥不是同一个，它是由私钥生成的另一个公钥。</p></blockquote></li><li><p>客户端验证公钥的正确性。</p><p>证书签发机构的签发机构的证书，在所有的操作系统中都默认带有一份，被认为是最可信的证书，被称为“根证书”。</p><p>当需要查询这些证书的时候，会从设备中进行查询，如果能够查询的到的话，那么第5个文件内容就是可信的了。</p><p>当证书签发机构的签发机构的公钥是可信的话，我们就可以使用这个公钥去验证第4个内容的正确性。再使用第3个内容的公钥去验证第2个内容的正确性了。</p><p>如果第2个内容是正确的话，那么说明服务器的公钥就是正确的了。</p><blockquote><p>  除了操作系统自带的根证书，我们也可以自行往自己的设备中安装自己需要的根证书。</p></blockquote><p><strong>注：客户端除了验证公钥是否正确，还需要验证服务器主机名是否是我们所需要到达的地址。</strong></p></li><li><p>客户端发送 <code>Pre-master Secret</code> 的数据</p><p>使用的服务器的公钥加密发过去的，也是一个客户端生成的随机数。</p></li><li><p>客户端和服务器都通过上述三个随机数生成一个 <code>Master Secret</code> 的值</p><p>通过 <code>Master Secret</code> 就可以算出双方进行对称加密的密钥等相关的一些信息了。然后双方就可以进行加密通信了。</p><p><code>Master Secret</code> 会生成四个内容：</p><ol><li>客户端加密密钥</li><li>服务端加密密钥</li><li>客户端 <code>MAC Secret</code></li><li>服务端 <code>MAC Secret</code></li></ol><blockquote><p>  <strong>为什么使用三个随机数生成数据，而不是仅使用 <code>Pre-master Secret</code> 来生成数据？</strong></p><p>  为了防止<strong>重放攻击</strong>。通过多个随机数，防止攻击者使用一个以前收到的随机数就可以获取用户的身份认证。</p><blockquote><p>  <strong>重放攻击(Replay Attacks)</strong></p><p>  又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行。</p></blockquote></blockquote><blockquote><p>  为什么客户端和服务器要使用两个加密密钥呢？</p><p>  为了防止出现攻击人将客户端发送的消息重新发送给客户端，使用相同的密钥会使客户端能够解密并认为这个服务器发送的数据，从而导致数据错误。而通过两个不同的密钥，便可以防止客户端和服务器双方无法分辨数据的来源了。</p></blockquote><p>注意：</p><ol><li>客户端向服务端发送对称加密数据时，双方使用客户端加密密钥进行加解密操作。服务端向客户端发送对称加密数据时，双方使用服务端加密密钥进行加解密操作。</li><li><code>MAC Secret</code>。其中 <code>MAC</code> 也即 <code>HMAC</code> (Hash-based Message Authentication Code 哈希运算消息认证码)，可以使数据进行带密码的哈希计算。仅仅只是无密码的哈希算法容易被攻击者碰撞，但是使用带特定的密码的哈希算法就是极大的增加难度。当接收方也使用带该密码的，相同的哈希算法进行计算后，与发送过来的哈希值进行比较，如果两者一样的话，那么就可以证明数据使对方发的且是安全的。</li></ol></li><li><p>客户端向服务器发送1个字节的数据（值为20，名称为 Change Cipher Spec），通知自己将使用加密通信。</p></li><li><p>客户端将前7步得到的数据通过客户端加密密钥以及客户端 <code>MAC Secret</code> 加密，然后发送给服务器。服务器对获得的结果进行验证。</p><p>消息名称为 Encrypted Handshake Message。</p><p><strong>此步之后，客户端就可以通过对称加密发送信息了。</strong></p></li><li><p>服务器向客户端发送1个字节的数据（值为20，名称为 Change Cipher Spec），通知自己将使用加密通信。</p></li><li><p>服务器将前9步得到的数据通过服务器加密密钥以及服务器 <code>MAC Secret</code> 加密，然后发送给客户端。客户端对获得的结果进行验证。</p><p>消息名称为 Encrypted Handshake Message。</p><p><strong>此步之后，服务器也可以通过对称加密发送信息了。</strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>View事件分发 - Android校招面试整理2022</title>
    <link href="/posts/0557737935e1/"/>
    <url>/posts/0557737935e1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/qq_40959750/article/details/119218780">View事件分发相关面试题_打架不行的二哈的博客-CSDN博客_事件分发机制面试题</a></li></ul></blockquote><hr><h1 id="View事件分发机制"><a href="#View事件分发机制" class="headerlink" title="View事件分发机制"></a><code>View</code>事件分发机制</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://luoyu-ying.github.io/posts/38fdb1d1c50f/">View 的事件体系 | 洛语 の Blog (luoyu-ying.github.io)</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/22046c435b7d49f29b7ad04214c4c2fb.png"></p><h1 id="事件是先到-DecorView-还是先到-Window"><a href="#事件是先到-DecorView-还是先到-Window" class="headerlink" title="事件是先到 DecorView 还是先到 Window"></a>事件是先到 <code>DecorView</code> 还是先到 <code>Window</code></h1><p>由上述流程图中可以得知，事件的分发顺序为 </p><p><code>Activity -&gt; Window -&gt; DecorView -&gt; ViewGroup -&gt; View</code></p><h1 id="View的onTouchEvent、OnClickListerner和OnTouchListener的onTouch方法的三者优先级"><a href="#View的onTouchEvent、OnClickListerner和OnTouchListener的onTouch方法的三者优先级" class="headerlink" title="View的onTouchEvent、OnClickListerner和OnTouchListener的onTouch方法的三者优先级"></a><code>View</code>的<code>onTouchEvent</code>、<code>OnClickListerner</code>和<code>OnTouchListener</code>的<code>onTouch</code>方法的三者优先级</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://cloud.tencent.com/developer/article/1333422">Android View的Touch事件分发</a></li></ul></blockquote><p>点击事件的执行顺序为</p><p><code>OnTouchListener.DOWN -&gt; OnTouchEvent.DOWN -&gt; OnTouchListener.MOVE -&gt; OnTouchEvent.MOVE -&gt; OnTouchListener.UP -&gt; OnTouchEvent.UP -&gt; OnClickListener</code></p><p>所以三者的优先级为</p><p><code>OnTouchListener &gt; onTouchEvent &gt; onClick</code></p><h1 id="onTouch-和-onTouchEvent-的区别"><a href="#onTouch-和-onTouchEvent-的区别" class="headerlink" title="onTouch 和 onTouchEvent 的区别"></a><code>onTouch</code> 和 <code>onTouchEvent</code> 的区别</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/huiguixian/article/details/22193977">Android View的onTouchEvent和OnTouch区别_小小攻城师的博客-CSDN博客_ontouch和ontouchevent区别</a></li></ul></blockquote><ol><li><p><code>onTouchListener</code>的<code>onTouch</code>方法优先级比<code>onTouchEvent</code>高，会先触发。</p></li><li><p>假如<code>onTouch</code>方法返回false会接着触发<code>onTouchEvent</code>，反之<code>onTouchEvent</code>方法不会被调用。</p></li><li><p>内置诸如<code>click</code>事件的实现等等都基于<code>onTouchEvent</code>，假如<code>onTouch</code>返回<code>true</code>，这些事件将不会被触发。</p></li></ol><h1 id="Activity-、ViewGroup和View都不消费ACTION-DOWN-那么ACTION-UP事件是怎么传递的"><a href="#Activity-、ViewGroup和View都不消费ACTION-DOWN-那么ACTION-UP事件是怎么传递的" class="headerlink" title="Activity 、ViewGroup和View都不消费ACTION_DOWN,那么ACTION_UP事件是怎么传递的"></a><code>Activity</code> 、<code>ViewGroup</code>和<code>View</code>都不消费<code>ACTION_DOWN</code>,那么<code>ACTION_UP</code>事件是怎么传递的</h1><p>首先，如果大家都不消费 ACTION_DOWN，那么 ACTION_DOWN 的事件传递流程是这样的：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">-&gt; Activity.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.onInterceptTouchEvent<span class="hljs-function"><span class="hljs-params">()</span></span><br><span class="hljs-function">-&gt;</span> view1.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> view1.onTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.onTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> Activity.onTouchEvent();<br></code></pre></td></tr></table></figure><p>接着，由于大家都不消费 ACTION_DOWN，对于 ACTION_MOVE 和 ACTION_UP 的事件传递是这样的</p><p>接着，由于大家都不消费 ACTION_DOWN，对于 ACTION_MOVE 和 ACTION_UP 的事件传递是这样的</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">-&gt; Activity.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span></span><br><span class="hljs-function">-&gt;</span> Activity.onTouchEvent();<br>-&gt; 消费<br></code></pre></td></tr></table></figure><h1 id="点击事件被拦截，但是想传到下面的View，如何操作"><a href="#点击事件被拦截，但是想传到下面的View，如何操作" class="headerlink" title="点击事件被拦截，但是想传到下面的View，如何操作"></a>点击事件被拦截，但是想传到下面的<code>View</code>，如何操作</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">getParent().requestDisallowInterceptTouchEvent(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>可将点击事件传到下面的<code>View</code>, 剥夺了父<code>View</code> 对除了<code>ACTION_DOWN</code>以外的事件的处理权。</p><h1 id="如何解决View的事件冲突"><a href="#如何解决View的事件冲突" class="headerlink" title="如何解决View的事件冲突"></a>如何解决<code>View</code>的事件冲突</h1><h2 id="三种出现滑动冲突的情况"><a href="#三种出现滑动冲突的情况" class="headerlink" title="三种出现滑动冲突的情况"></a>三种出现滑动冲突的情况</h2><ol><li><code>内部View</code>与<code>外部View</code>的滑动方向相反。</li><li><code>内部View</code>与<code>外部View</code>的滑动方向相同。</li><li>前两种情况的嵌套。</li></ol><p>三种情况的处理思路：</p><ol><li>通过手势滑动的角度判断滑动的方向。</li><li>通过当前处于的不同的页面状态来判断应该滑动的<code>View</code>。</li><li>通过前两种的综合使用。</li></ol><h2 id="滑动冲突的解决方式"><a href="#滑动冲突的解决方式" class="headerlink" title="滑动冲突的解决方式"></a>滑动冲突的解决方式</h2><h3 id="外部拦截法"><a href="#外部拦截法" class="headerlink" title="外部拦截法"></a>外部拦截法</h3><p>通过重写<strong>父容器的</strong><code>onInterceptTouchEvent</code>方法，所有的事件都先经过父容器的筛选，对其中父容器需要的事件进行拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">intercepted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getX();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getY();<br>    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN : &#123;<br>            intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE : &#123;<br>            <span class="hljs-keyword">if</span> (父容器需要当前的点击事件)<br>                intercepted = <span class="hljs-literal">true</span>;<br>           <span class="hljs-keyword">else</span> <br>                intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP : &#123;<br>            intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span> :<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    mLastXIntercept = x;<br>    mLastYIntercept = y;<br>    <span class="hljs-keyword">return</span> intercepted;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内部拦截法"><a href="#内部拦截法" class="headerlink" title="内部拦截法"></a>内部拦截法</h3><p>父元素拦截除<code>ACTION_DOWN</code>以外的其他事件，当事件到达子元素后，由子元素判断是否需要这些事件，不需要的事件将重新交由父容器来处理。这种方法和Android的事件分发机制不一致，需要配合<code>requestDisallowInterceptTouchEvent</code>方法才能正常的工作。</p><p>相关阅读链接：<a href="https://www.jianshu.com/p/fe3d109eb27e">Android TouchEvent之requestDisallowInterceptTouchEvent - 简书 (jianshu.com)</a></p><p><strong>子元素的<code>dispatchTouchEvent</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getX();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getY();<br>    <br>    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN : &#123;<br>            parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 此子View的所有父ViewGroup会跳过onInterceptTouchEvent回调</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE : &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">deltaX</span> <span class="hljs-operator">=</span> x - mLastX;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">deltaY</span> <span class="hljs-operator">=</span> y - mLastY;<br>            <span class="hljs-keyword">if</span> (父容器需要当前的点击事件) &#123;<br>                parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">false</span>);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP : &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span> : <br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    mLastX = x;<br>    mLastY = y;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.dispatchTouchEvent(event);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>父容器的<code>onInterceptTouchEvent</code>方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> event.getAction();<br>    <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="requestDisallowInterceptTouchEvent的调用时机"><a href="#requestDisallowInterceptTouchEvent的调用时机" class="headerlink" title="requestDisallowInterceptTouchEvent的调用时机"></a><code>requestDisallowInterceptTouchEvent</code>的调用时机</h1><p><strong><code>parent.requestDisallowInterceptTouchEvent</code>的调用需要写在<code>onTouchEvent</code>方法中</strong></p><p>我们一个手势的操作，会经历<code>ACTION_DOWN</code>、<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等操作。</p><p>子<code>view</code>调用<code>requestDisallowInterceptTouchEvent(true)</code>的时间，是必须在能拿到点击事件的时候。</p><p>比如我们在<code>ACTION_DOWN</code>的时候调用了方法，接下来的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>都会直接传递到子<code>view</code>上了；如果是在子<code>view</code>的<code>ACTION_MOVE</code>方法中调用的话，那么要确认父<code>view</code>在<code>ACTION_MOVE</code>的过程中，能否将事件传递给子<code>view</code>就好了。</p><h1 id="同时对父-View-和子-View-设置点击方法，优先响应哪个"><a href="#同时对父-View-和子-View-设置点击方法，优先响应哪个" class="headerlink" title="同时对父 View 和子 View 设置点击方法，优先响应哪个"></a>同时对父 <code>View</code> 和子 <code>View</code> 设置点击方法，优先响应哪个</h1><p>优先响应子 view。</p><p>如果先响应父 view，那么子 view 将永远无法响应。父 view 要优先响应事件，必须先调用 onInterceptTouchEvent 对事件进行拦截，那么事件不会再往下传递，直接交给父 view 的 onTouchEvent 处理。</p><p>Android系统中ViewGroup的拦截事件默认不拦截。</p><h1 id="ACTION-CANCEL什么时候触发"><a href="#ACTION-CANCEL什么时候触发" class="headerlink" title="ACTION_CANCEL什么时候触发"></a><code>ACTION_CANCEL</code>什么时候触发</h1><ol><li><p>如果在父<code>View</code>中拦截<code>ACTION_UP</code>或<code>ACTION_MOVE</code>，在第一次父视图拦截消息的瞬间，父视图指定子视图不接受后续消息了，同时子视图会收到<code>ACTION_CANCEL</code>事件。一般是系统自己处理</p></li><li><p>如果触摸某个控件，但是又不是在这个控件的区域上抬起（移动到别的地方了），就会出现<code>ACTION_CANCEL</code>。</p></li></ol><h1 id="为什么子-View-不消费-ACTION-DOWN-之后的所有事件都不会向下传递了"><a href="#为什么子-View-不消费-ACTION-DOWN-之后的所有事件都不会向下传递了" class="headerlink" title="为什么子 View 不消费 ACTION_DOWN,之后的所有事件都不会向下传递了"></a>为什么子 <code>View</code> 不消费 <code>ACTION_DOWN</code>,之后的所有事件都不会向下传递了</h1><p>答案是：<code>mFirstTouchTarget</code>。</p><p>当子 view 对事件进行处理的时，那么 <code>mFirstTouchTarget</code> 就会被赋值，若是子 <code>view</code> 不对事件进行处理，那么 <code>mFirstTouchTarget</code> 就为 <code>null</code>，之后 <code>VIewGroup</code> 就会默认拦截所有的事件。</p><p>我们可以从 <code>dispatchTouchEvent</code> 中找到如下代码，可以看出来，若是子 <code>View</code> 不处理 <code>ACTION_DOWN</code>,那么之后的事件也不会给到它了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 检查是否拦截</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> intercepted;<br><span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 省略和问题无关代码</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 默认拦截</span><br>    intercepted = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="在-ViewGroup-中的-onTouchEvent-中消费-ACTION-DOWN-事件（onInterceptTouch-默认设置），那么-ACTION-MOVE-和-ACTION-UP-事件是怎么传递的？"><a href="#在-ViewGroup-中的-onTouchEvent-中消费-ACTION-DOWN-事件（onInterceptTouch-默认设置），那么-ACTION-MOVE-和-ACTION-UP-事件是怎么传递的？" class="headerlink" title="在 ViewGroup 中的 onTouchEvent 中消费 ACTION_DOWN 事件（onInterceptTouch 默认设置），那么 ACTION_MOVE 和 ACTION_UP 事件是怎么传递的？"></a>在 <code>ViewGroup</code> 中的 <code>onTouchEvent</code> 中消费 <code>ACTION_DOWN</code> 事件（<code>onInterceptTouch</code> 默认设置），那么 <code>ACTION_MOVE</code> 和 <code>ACTION_UP</code> 事件是怎么传递的？</h1><p>首先，我们先分析一下 ACTION_DOWN 的事件走向，由于 ViewGroup 中的 onInterceptTouch 是默认设置的，那么 ACTION_DOWN 的事件最终在 ViewGroup 中的 onTouchEvent 方法中停止了，事件走向是这样的：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">-&gt; Activity.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.onInterceptTouchEvent<span class="hljs-function"><span class="hljs-params">()</span></span><br><span class="hljs-function">-&gt;</span> view1.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> view1.onTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.onTouchEvent() <br></code></pre></td></tr></table></figure><p>接着 ACTION_MOVE 和 ACTION_UP 的事件分发流程，之后 onInterceptTouch 和 View 中的方法都不会被调用了，事件分发如下：</p><p>接着 ACTION_MOVE 和 ACTION_UP 的事件分发流程，之后 onInterceptTouch 和 View 中的方法都不会被调用了，事件分发如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">-&gt; Activity.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.onTouchEvent() <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>2022校招面试整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>View</tag>
      
      <tag>2022校招面试整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>View绘制 - Android校招面试整理2022</title>
    <link href="/posts/76aedbc4e682/"/>
    <url>/posts/76aedbc4e682/</url>
    
    <content type="html"><![CDATA[<h1 id="View-的绘制流程"><a href="#View-的绘制流程" class="headerlink" title="View 的绘制流程"></a>View 的绘制流程</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://luoyu-ying.github.io/posts/19429a22b2b2/">View 的绘制原理 | 洛语 の Blog (luoyu-ying.github.io)</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-3d1255a5093de81fd5bdc27a300d2f0d_720w.jpg"></p><h1 id="MeasureSpec-是什么"><a href="#MeasureSpec-是什么" class="headerlink" title="MeasureSpec 是什么"></a><code>MeasureSpec</code> 是什么</h1><blockquote><p>  <code>spec</code> <strong><code>英[spek]</code></strong><code>n.</code>规格 <code>vt.</code>按特定标准设计并制造</p></blockquote><p><code>MeasureSpec</code>参与了<code>View</code>的<code>measure</code>过程。在测量过程中，系统将<code>View</code>的<code>LayoutParams</code>根据父容器所施加的规则转换成对应的<code>MeasureSpec</code>，然后再根据这个<code>MeasureSpec</code>来测量出<code>View</code>的测量宽&#x2F;高。</p><p><code>MeasureSpec</code>代表一个32位的<code>int</code>值，高两位代表 测量模式<code>SpecMode</code>，低30位代表 该测量模式下的规格大小<code>SpecSize</code>。</p><p><code>MeasureSpec</code>与<code>SpecMode</code>、<code>SpecSize</code>之间可以通过位运算互相求出。</p><p>每个<code>View</code>的<code>measure</code>过程之前都会先计算其<code>MeasureSpec</code>的值，然后再对其进行<code>measure</code>。</p><p><strong>注意</strong>：<code>View</code>的宽和高各有一个<code>MeasureSpec</code>值，分别为<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>。</p><p><strong><code>SpecMode</code>的三种状态</strong></p><ol><li><p><code>UNSPECIFIED</code></p><p>父容器不对<code>View</code>做任何的限制，要多大给多大。<strong>这种情况一般用于系统的内部</strong>，表示一种测量方式的状态。</p></li><li><p><code>EXACTLY</code></p><p>父容器已经测出了<code>View</code>所需要的精确大小，此时的大小就是<code>View</code>的最终大小。</p><p>它对应于<code>LayoutParams</code>的<code>match_parent</code>和具体的数值这两种模式。</p></li><li><p><code>AT_MOST</code></p><p>父容器指定了一个可用的大小，<code>View</code>的大小不能大于这个值。</p><p>它对应于<code>LayoutParams</code>中的<code>wrap_content</code>。</p></li></ol><h1 id="子View创建MeasureSpec创建规则是什么"><a href="#子View创建MeasureSpec创建规则是什么" class="headerlink" title="子View创建MeasureSpec创建规则是什么"></a>子View创建<code>MeasureSpec</code>创建规则是什么</h1><p><strong><code>MeasureSpec</code>和<code>LayoutParams</code>的对应关系</strong></p><p>对于<code>DecorView</code>和普通<code>View</code>来说，<code>MeasureSpec</code>的转化过程略有不同。</p><p><strong>对于<code>DecorView</code>：</strong></p><p><strong><code>DecorView</code>的<code>MeasureSpec</code>由窗口的大小和<code>DecorView</code>自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在<code>ViewRootImpl</code>中的<code>measureHierarchy</code>方法中，调用<code>getRootMeasureSpec</code>方法，获得<code>DecorView</code>的<code>MeasureSpec</code>。</p><p>其中<code>getRootMeasureSpec</code>方法中，根据自身<code>LayoutParams</code>的不同大小，共有三种情况：</p><ol><li><code>LayoutParams.MATCH_PARENT</code>：精确模式，大小就是窗口的大小。</li><li><code>LayoutParams.WRAP_CONTENT</code>：最大模式，大小不定，但是不能超过窗口的大小。</li><li>固定大小(比如100dp)：精确模式，大小为<code>LayoutParams</code>中指定的大小。</li></ol><p><strong>对于普通<code>View</code>：</strong></p><p><strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在父容器的<code>measureChildWithMargins</code>中的<code>getChildMeasureSpec</code>方法获得<code>View</code>的<code>MeasureSpec</code>。</p><p>其中<code>getChildMeasureSpec</code>方法的参数中使用到了父容器的<code>MeasureSpec</code>。在这个方法中通过<code>switch</code>和<code>if</code>语句，对<code>View</code>的<code>MeasureSpec</code>进行了决定。结果如下：</p><table><thead><tr><th><code>↓childLayoutParams</code> \ <code>parentMeasureSpec→</code></th><th><code>EXACTLY</code></th><th><code>AT_MOST</code></th><th><code>UNSPECIFIED</code></th></tr></thead><tbody><tr><td><code>dp</code>&#x2F;<code>px</code></td><td><code>EXACTLY</code><br>childSize</td><td><code>EXACTLY</code><br/>childSize</td><td><code>EXACTLY</code><br/>childSize</td></tr><tr><td><code>match_parent</code></td><td><code>EXACTLY</code><br/>parentSize</td><td><code>AT_MOST</code><br>parentSize</td><td><code>UNSPECIFIED</code><br>0</td></tr><tr><td><code>wrap_content</code></td><td><code>AT_MOST</code><br>parentSize</td><td><code>AT_MOST</code><br/>parentSize</td><td><code>UNSPECIFIED</code><br/>0</td></tr></tbody></table><p>上图可以简单记为：除了<code>dp</code>&#x2F;<code>px</code>的精确模式情况外，三种<code>MeasureSpec</code>的级别为：<code>EXACTLY</code> &lt; <code>AT_MOST</code> &lt; <code>UNSPECIFIED</code> 且<code>childMeasureSpec</code> &#x3D; max(<code>childLayoutParams</code> , <code>parentMeasureSpec</code>)。（<strong>实际上并无级别之分</strong>）</p><p>通过上面的表格，可以更加直观的看出：<strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><h1 id="自定义View-wrap-content不起作用的原因"><a href="#自定义View-wrap-content不起作用的原因" class="headerlink" title="自定义View wrap_content不起作用的原因"></a>自定义View <code>wrap_content</code>不起作用的原因</h1><p>对于直接继承<code>View</code>的自定义<code>View</code>来说，<strong>需要重写<code>onMeasure</code>方法并设置在<code>wrap_content</code>情况时的自身大小</strong>，否则在布局中使用<code>wrap_content</code>就相当于使用<code>match_parent</code>。</p><p>因为当自定义<code>View</code>处于<code>wrap_content</code>时，它的<code>SpecMode</code>为<code>AT_MOST</code>模式，由前文可知，当父容器无论为<code>AT_MOST</code>还是<code>ECACTLY</code>模式时，自定义<code>View</code>都为<code>AT_MOST</code>模式且尺寸大小为<code>parentSize</code>，也就是父容器的剩余空间，即自定义<code>View</code>的大小变得与父容器的剩余空间大小一致，显然不是我们需要的。</p><p><strong>解决方法：</strong></p><p>解决方法也是非常简单的。我们只需要在<code>onMeasure</code>方法中对</p><ol><li>仅<code>width</code>方向为<code>AT_MOST</code>模式</li><li>仅<code>height</code>方向为<code>AT_MOST</code>模式</li><li><code>width</code>方向以及<code>height</code>方向都为<code>AT_MOST</code>模式</li><li>其他的情况</li></ol><p>这四个状态单独判断，分别使用<code>setMeasuredDimension</code>方法直接为自定义<code>View</code>设置我们需要的值即可。</p><p>源码中对于<code>TextView</code>、<code>ImageView</code>等控件的<code>wrap_content</code>也做了特殊的处理。</p><h1 id="在Activity中获取某个View的宽高有几种方法"><a href="#在Activity中获取某个View的宽高有几种方法" class="headerlink" title="在Activity中获取某个View的宽高有几种方法"></a>在Activity中获取某个View的宽高有几种方法</h1><p>由于<code>Activity</code>的启动和<code>View</code>的测量过程并不是同步进行的，因此无法保证在<code>Activity</code>启动时某个<code>View</code>已经测量完毕了。所以我们在<code>Activity</code>启动的时候，如果直接通过<code>getMeasuredWidth</code>&#x2F;<code>getMeasuredHeight</code>方法获得的值可能为0。</p><p>以下有四种方法可以解决这个问题（详细代码见《Android开发艺术探索》190页）。</p><ol><li><p><code>Activity/View#onWindowFocusChanged</code></p><p>在<code>Activity</code>的<code>onResume</code>和<code>onPause</code>方法启动时，<code>onWindowFocusChanged</code>方法也会同时被调用，可以重写里面的内容，使之计算<code>View</code>的宽高。</p><p><strong>注意</strong>：<code>onWindowFocusChanged</code>方法会在<code>View</code>已经初始化完毕后才开始调用。</p></li><li><p><code>view.post(runnable)</code></p><p>通过<code>post</code>可以将一个<code>runnable</code>投递都消息队列的尾部，然后等待<code>Looper</code>调用此<code>runnable</code>的时候，<code>View</code>也已经初始化好了。</p></li><li><p><code>ViewTreeObserver</code></p><p><code>ViewTreeObserver</code>中的众多回调可以完成这个功能。</p><p>比如<code>OnGlobalLayoutListener</code>接口，当<code>View</code>树的状态发生改变或者<code>View</code>树内部的<code>View</code>的可见性发生改变的时候，<code>onGlobalLayout</code>方法将被回调，此时就可以获取<code>View</code>的宽高了。</p></li><li><p><code>view.measure(int widthMeasureSpec, int heightMeasureSpec)</code></p><p>可以主动调用该方法开始计算<code>view</code>的宽高。</p><ol><li><p><strong><code>match_parent</code></strong></p><p>由于正常的<code>measure</code>过程中，我们需要父容器的<code>MeasureSpec</code>的值，而此时父容器并没开始计算，我们无从得知这两个值的大小。故我们无法对<code>match_parent</code>的<code>view</code>计算其宽高。</p></li><li><p><strong><code>dp</code>&#x2F;<code>px</code></strong></p><p>因为有精确的数值了，所以我们可以直接使用这个精确的数值通过<code>MeasureSpec.makeMeasureSpec</code>方法构建<code>view</code>的<code>MeasureSpec</code>。</p></li><li><p><strong><code>wrap_content</code></strong></p><p>直接将<code>MeasureSpec.makeMeasureSpec</code>方法中参数的值设置为<code>(1&lt;&lt;30)-1</code>即可，这是<code>View</code>理论上可以支持的最大值，所以这样构建<code>MeasureSpec</code>是合理的。</p></li></ol></li></ol><h1 id="onCreate、onResume中可以获取View的宽高吗？怎么做？View-post-为什么可以获取？"><a href="#onCreate、onResume中可以获取View的宽高吗？怎么做？View-post-为什么可以获取？" class="headerlink" title="onCreate、onResume中可以获取View的宽高吗？怎么做？View#post 为什么可以获取？"></a><code>onCreate</code>、<code>onResume</code>中可以获取View的宽高吗？怎么做？<br><code>View#post</code> 为什么可以获取？</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/qq_40714317/article/details/117666277">onCreate()、onResume() 中可以获取View的宽高吗？怎么做？ View.post{} 为什么可以获取？_qq_40714317的博客</a></li><li><a href="https://github.com/Moosphan/Android-Daily-Interview/issues/126">2019-08-21：View.post()为什么可以获取到宽高信息？ · Issue #126 · Moosphan&#x2F;Android-Daily-Interview </a></li></ul></blockquote><p><strong><code>onCreate</code>、<code>onResume</code>中可以获取View的宽高吗？怎么做？</strong></p><p>View 的测绘绘制流程就是从 ViewRootImpl#performTraversals() 开始的，而这个方法的调用是在 onResume() 方法之后，所以在 onCreate() 和 onResume() 方法中拿不到 View 的测量值。</p><p> View的宽高是在onLayout阶段才能最终确定的，而在Activity#onCreate中并不能保证View已经执行到了onLayout方法，也就是说Activity的声明周期与View的绘制流程并不是一一绑定。所以onCreate() 和 onResume() 中获取不到View的宽高值。以Handler为基础，View.post() 将传入任务的执行时机调整到View 绘制完成之后。</p><p><strong><code>View#post</code> 为什么可以获取？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">view.post(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> view.getWidth();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> view.getHeight();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这样写一般是在 Activity 的 onResume 方法中，因为 onResume 执行在 View 初始化之前，如果在 onResume 中直接获取 View 宽高是获取不到的。</p><p>使用 view.post 就能获取到，因为 view.post 是向 主 Handler 的 MessageQueue 中插入一条待执行消息，但是因为系统在 ViewRoot 中初始化 View 时也是利用 Handler 机制，平且为了优先执行 View 的初始化设置了同步屏障，导致 view.post 插入的消息会在 View 初始化之后执行，那么肯定就能获取到 View 的宽高啦！</p><p><strong><code>Runnable</code>的执行时机具体是什么</strong></p><p> 在 <strong>Android 7.0</strong> 之后，view.post()中的runnbale 能确定被执执行。具体来说：</p><p>Android 7.0之后，除了<code>performTraversal</code>中会调用外，在View的<code>dispatchAttachedToWindow</code>中也会调用，但Android 7.0之后不管在主线程还是在子线程都可以成功执行<code>view.post</code>内部逻辑，并不是因为增加了调用时机，而是取消了<code>ThreadLocal</code>机制，使得 <strong>不管在主线程还是子线程调用view.post方法，都会将runnable对象丢到主线程的任务队列中，更新UI或者获取view的信息</strong>。</p><h1 id="View-post与Handler-post的区别"><a href="#View-post与Handler-post的区别" class="headerlink" title="View#post与Handler#post的区别"></a><code>View#post</code>与<code>Handler#post</code>的区别</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/7280b2d3b4d1">Handler.post和View.post的区别 - 简书 (jianshu.com)</a></li></ul></blockquote><ol><li><p><code>Handler.post</code>，它的执行时间基本是等同于<code>onCreate</code>里那行代码触达的时间；</p></li><li><p>View.post，则不同，它说白了执行时间一定是在<code>Activity#onResume</code>发生后才开始算的；或者换句话说它的效果相当于你上面的<code>View.post</code>方法是写在<code>Activity#onResume</code>里面的（但只执行一次，因为<code>onCreate</code>不像onResume会被多次触发）；</p></li><li><p>当然，虽然这里说的是<code>post</code>方法，但对应的<code>postDelayed</code>方法区别也是类似的。</p></li></ol><h1 id="getWidth-方法和getMeasureWidth-方法的区别"><a href="#getWidth-方法和getMeasureWidth-方法的区别" class="headerlink" title="getWidth()方法和getMeasureWidth()方法的区别"></a><code>getWidth()</code>方法和<code>getMeasureWidth()</code>方法的区别</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/7d8a54dd692f">getMeasureWidth和getWidth的区别 - 简书 (jianshu.com)</a></li><li><a href="https://www.cnblogs.com/yongdaimi/p/13612622.html">android: View的getWidth() 和 getMeasureWidth()方法的区别 - 夜行过客 - 博客园 (cnblogs.com)</a></li></ul></blockquote><ol><li><p><code>getMeasureWidth()</code>方法在<code>measure()</code>过程结束后就可以获取到了，而<code>getWidth()</code>方法要在<code>layout()</code>过程结束后才能获取到。<code>getMeasuredWidth()</code>获取的是<code>View</code>原始的大小，也就是这个<code>View</code>在<code>XML</code>文件中配置或者是代码中设置的大小。<code>getWidth()</code>获取的是这个<code>View</code>最终显示的大小，这个大小有可能等于原始的大小，也有可能不相等。只要在代码里重新修改了子控件的摆放位置，<code>getWidth()</code>和<code>getMeasureWidth()</code>的值就会不同。</p></li><li><p><code>getMeasureWidth()</code>方法中的值是通过<code>setMeasuredDimension()</code>方法来进行设置的，而<code>getWidth()</code>方法中的值则是通过视图右边的坐标减去左边的坐标计算出来的。</p></li></ol><h1 id="View加载流程（setContentView）"><a href="#View加载流程（setContentView）" class="headerlink" title="View加载流程（setContentView）"></a>View加载流程（setContentView）</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/pgg_cold/article/details/79481301"> Android面试题（28）-android的view加载和绘制流程_胖哥哥飘过的博客-CSDN博客_android view加载流程</a></li></ul></blockquote><ol><li><p>通过Activity的setContentView方法间接调用PhoneWindow的setContentView()，在PhoneWindow中通过getLayoutInflate()得到LayoutInflate对象。</p></li><li><p>通过LayoutInflate对象去加载View，主要步骤是：</p><ol><li>通过xml的Pull方式去解析xml布局文件，获取xml信息，并保存缓存信息，因为这些数据是静态不变的。</li><li>根据xml的tag标签通过反射创建View逐层构建View。</li><li>递归构建其中的子View，并将子View添加到父ViewGroup中。</li></ol></li></ol><p>其中，有四种加载XML文件的常用方法：</p><ol><li><p>使用view的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> View.inflate(context, R.layout.child, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure></li><li><p>通过系统获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LayoutInflater</span> <span class="hljs-variable">inflater</span> <span class="hljs-operator">=</span> (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);<br><span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> inflater.inflate(R.layout.child, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure></li><li><p>通过LayoutInflater</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LayoutInflater</span> <span class="hljs-variable">inflater</span> <span class="hljs-operator">=</span> LayoutInflater.from(context);<br><span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> inflater.inflate(R.layout.child, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure></li><li><p>通过getLayoutInflater</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> getLayoutInflater().inflate(R.layout.child, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure></li></ol><p>View 加载过程结束后，便会开始 View 的绘制流程了。</p><h1 id="invalidate-和-postInvalidate-的区别"><a href="#invalidate-和-postInvalidate-的区别" class="headerlink" title="invalidate() 和 postInvalidate() 的区别"></a><code>invalidate()</code> 和 <code>postInvalidate()</code> 的区别</h1><p>这两个方法都是在<strong>重绘当前控件</strong>的时候调用的。</p><p><strong>invalidate在UI线程中调用，postInvalidate在非UI线程中调用。</strong> 因为android的UI线程是非线程安全的，所以在非UI线程中，需要使用postInvalidate来使View重绘。</p><p>view调用invalidate将导致当前view的重绘（draw调用），view的父类将不会执行draw方法；viewGroup调用invalidate会使viewGroup的子view调用draw，也就是viewGroup内部的子view进行重绘。</p><h1 id="requestLayout-和-onLayout-的区别"><a href="#requestLayout-和-onLayout-的区别" class="headerlink" title="requestLayout() 和 onLayout() 的区别"></a><code>requestLayout()</code> 和 <code>onLayout()</code> 的区别</h1><p><strong>requestLayout()</strong></p><p><code>requestLayout</code>方法只会**导致当前<code>view</code>的<code>measure</code>和<code>layout</code>**，而<code>draw</code>不一定被执行，只有当<code>view</code>的位置发生改变才会执行<code>draw</code>方法，因此如果要使当前<code>view</code>重绘需要调用<code>invalidate</code>。</p><p><strong>onLayout()</strong></p><p>在很多情况下requestLayout是不需要被调用的。</p><p>例如，我们把一个AbsoluteLayout里面的childView挪动一下位置。我们仅仅需要调用的可能就是重新布局当前AbsoluteLayout，然后调用invalidate方法进行重绘。而不是从当前View向上的整个View树形结构都要重新layout，onLayout，measure，onMeasure一次。在这种情况下可以直接调用onLayout。然后调用invalidate进行重绘。很明显可以提升绘制效率。</p><p>由于父View的layout实现了会通知布局的listener。但是由于无法得到listener，因此调用onlayout的时候无法对其进行通知，这也是这种实现的缺陷。</p><h1 id="自定义-View-的流程和注意事项"><a href="#自定义-View-的流程和注意事项" class="headerlink" title="自定义 View 的流程和注意事项"></a>自定义 View 的流程和注意事项</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/b0f0d5462d16">自定义View学习–定义View流程和注意事项 - 简书 (jianshu.com)</a></li><li><a href="https://blog.csdn.net/lmj623565791/article/details/38339817"> Android 手把手教您自定义ViewGroup（一）_鸿洋_的博客-CSDN博客_自定义viewgroup</a></li></ul></blockquote><hr><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ol><li>invalidate怎么局部刷新</li><li>Android绘制和屏幕刷新机制原理&#96;</li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>2022校招面试整理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>View</tag>
      
      <tag>2022校招面试整理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>View 的事件体系</title>
    <link href="/posts/38fdb1d1c50f/"/>
    <url>/posts/38fdb1d1c50f/</url>
    
    <content type="html"><![CDATA[<h1 id="View基础知识"><a href="#View基础知识" class="headerlink" title="View基础知识"></a>View基础知识</h1><h2 id="一、View的相关坐标和位置"><a href="#一、View的相关坐标和位置" class="headerlink" title="一、View的相关坐标和位置"></a>一、<code>View</code>的相关坐标和位置</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20180802114150486.jpg" style="zoom:80%;" /><p><strong>先来了解一个概念：</strong></p><p><code>view动画</code>不改变<code>view</code>的真实位置，就是肉眼看上去，<code>view</code>位置发生了变化，但是它的点击区域还是在原来的位置。</p><p>为了方便描述，下文中的的 <code>真实View</code>，表示真实位置的<code>View</code>，<code>看到的View</code>，表示肉眼看到的<code>View</code>。</p><p>属性动画和 <code>setTranslationX</code> &#x2F; <code>setTranslationY</code> ，会改变显示位置和真实位置。</p><p>上图中<code>view1</code>是初始位置，通过执行<code>setTranslation</code>函数，得到的<code>view2</code>位置，其中<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>这几个值不会改变。</p><h3 id="left，top，right，bottom"><a href="#left，top，right，bottom" class="headerlink" title="left，top，right，bottom"></a><code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code></h3><p><code>View</code>的位置主要由它的四个顶点的位置来决定，分别对应 View 的四个属性：<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>。对应的函数是<code>getLeft</code>，<code>getTop</code>，<code>getRight</code>，<code>getBottom</code>。</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>left</code></td><td><code>View</code> 左上顶点相对于父容器的横坐标</td></tr><tr><td><code>top</code></td><td><code>View</code> 左上顶点相对于父容器的纵坐标</td></tr><tr><td><code>right</code></td><td><code>View</code> 右下顶点相对于父容器的横坐标</td></tr><tr><td><code>bottom</code></td><td><code>View</code> 右下顶点相对于父容器的纵坐标</td></tr></tbody></table><p>这几个值表示的是View的真身位置，它表示哪里，点击区域就在哪里。和肉眼在屏幕上看到的位置可能不一样。</p><h3 id="X，Y"><a href="#X，Y" class="headerlink" title="X，Y"></a><code>X</code>，<code>Y</code></h3><p>上面说到view动画不改变<code>view</code>的真实位置（也就是不改变<code>view</code>的<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>）。</p><p>看到的view相对于真实<code>view</code>，位置发生了变化，但是它的点击区域还是在真实view的位置。</p><p>从 Android 3.0 开始，<code>View</code> 增加了 x，y，<code>translationX</code> 和 <code>translationY</code>。</p><p>x，y 是看到的<code>view</code>的左上角相对父容器的坐标，但不同于 left 和 top ，这两个坐标点的值并一定都是相等的。</p><p>真实<code>view</code> 和 看到<code>view</code>的偏差用 <code>translationX</code> 和 <code>translationY</code> <code>来表示</code>。</p><h3 id="translationX，translationY"><a href="#translationX，translationY" class="headerlink" title="translationX，translationY"></a><code>translationX</code>，<code>translationY</code></h3><p><strong>android开发艺术探索中，关于<code>translationX</code>的讲解是错误的。</strong>真实情况是，<code>translationX</code>是<code>真实view</code> 相对于<code>看到view</code>的 x 方向偏移量。</p><p>从上图可以得知：<code>x</code> &#x3D; <code>left</code> + <code>translationX</code>。</p><h2 id="二、点击事件的XY坐标"><a href="#二、点击事件的XY坐标" class="headerlink" title="二、点击事件的XY坐标"></a>二、点击事件的<code>XY</code>坐标</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20180802143219331.jpg" style="zoom:50%;" /><h2 id="三、MotionEvent"><a href="#三、MotionEvent" class="headerlink" title="三、MotionEvent"></a>三、<code>MotionEvent</code></h2><p>常见的触摸动作一共有三个：</p><ol><li><code>ACTION_DOWN</code>手指按下动作</li><li><code>ACTION_MOVE</code>手指滑动动作</li><li><code>ACTION_UP</code>    手指抬起动作</li></ol><h2 id="四、GestureDetector"><a href="#四、GestureDetector" class="headerlink" title="四、GestureDetector"></a>四、<code>GestureDetector</code></h2><p>手势检测，检测用户的单击、双击、长按等操作。</p><p>通过创建<code>GestureDetector</code>对象并实现<code>OnGestureListener</code>接口（检测单击相关手势）或者<code>OnDoubleTapListener</code>接口（检测双击相关动作）。</p><h2 id="五、TouchSlop"><a href="#五、TouchSlop" class="headerlink" title="五、TouchSlop"></a>五、<code>TouchSlop</code></h2><p>不同安卓设备认为的最小的滑动距离，低于此距离，将不认为用户在滑动，开发者可自行更改，默认为<code>8dp</code>。</p><h2 id="六、VelocityTracker"><a href="#六、VelocityTracker" class="headerlink" title="六、VelocityTracker"></a>六、<code>VelocityTracker</code></h2><p>速度检测，可以计算出用户的手势的滑动速度。</p><p>注意，在<code>VelocityTracker#computeCurrentVelocity(int time)</code>中的<code>time</code>参数是我们计算速度的单位时间，相同的速度用不同的单位时间会有不同的表示方法。</p><h2 id="七、Scroller"><a href="#七、Scroller" class="headerlink" title="七、Scroller"></a>七、<code>Scroller</code></h2><p>弹性滑动对象，由于View中的<code>scrollTo/scrollBy</code>都是瞬间完成位移的。对用户的使用体验不太友好，所以引入弹性滑动对象，使得<code>View</code>的滑动变得可视化。</p><h1 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h1><h2 id="一、scrollTo-x2F-scrollBy"><a href="#一、scrollTo-x2F-scrollBy" class="headerlink" title="一、scrollTo&#x2F;scrollBy"></a>一、<code>scrollTo</code>&#x2F;<code>scrollBy</code></h2><p>View有专门的方法实现滑动，即<code>scrollTo()</code>, <code>scrollBy()</code>;</p><p>这两个函数只能将<code>View</code>中间的内容进行位移，但是不能改变<code>View</code>本身的位置。</p><p>可以方便的实现滑动效果并且不影响内部元素的点击事件。</p><p><code>scrollTo(int destX, int destY)</code>直接让View出现在目标位置，无中间动画。</p><p>参数变量的单位都是像素级。</p><h2 id="二、使用动画"><a href="#二、使用动画" class="headerlink" title="二、使用动画"></a>二、使用动画</h2><p>有两种动画的使用方法。</p><ol><li><p><code>View</code>动画</p><p>在<code>XML</code>文件里面通过改变<code>translationX</code>&#x2F;<code>translationY</code>的方式来实现View的移动效果。</p></li><li><p>属性动画</p><p>在<code>Android3.0</code>版本以上，可以使用<code>ObjectAnimator</code>类来实现属性动画的效果。</p><p>在<code>Android3.0</code>以下的版本中，我们需要自己加载开源动画库<code>NineOldAndroids</code>。</p></li></ol><p>在<code>XML</code>文件中，有一个<code>andoird:fillAfter=&quot;true|false&quot;</code>的选项。</p><p>当为<code>true</code>的时候，View在动画结束后，图像将停留在目标位置上。</p><p>当为<code>false</code>的时候，View会在动画结束后，从末位置消失，重新在初位置出现。</p><p>不论是<code>true</code>还是<code>false</code>，View的点击事件的坐标还是在原先的初始位置上，并不会随着<code>View</code>的移动而移动。</p><p>在<code>Android3.0</code>以上使用属性动画可以解决这样的问题。</p><h2 id="三、改变布局参数"><a href="#三、改变布局参数" class="headerlink" title="三、改变布局参数"></a>三、改变布局参数</h2><p>通过修改<code>View</code>的<code>marginLeft</code>等等布局参数，以此来达到<code>View</code>滑动的效果。</p><h1 id="弹性滑动"><a href="#弹性滑动" class="headerlink" title="弹性滑动"></a>弹性滑动</h1><h2 id="一、Scroller"><a href="#一、Scroller" class="headerlink" title="一、Scroller"></a>一、<code>Scroller</code></h2><p><code>Scroller#smoothScrollTo(int destX, int destY)</code>将<strong>目标位置与初始位置的偏移值delta</strong>计算后调用<code>startScroller()</code>方法存储相关参数，并开始使用<code>invalidate()</code>方法重绘<code>View</code>。重绘<code>View</code>时的<code>draw()</code>方法会调用<code>computeScroll()</code>方法，其中又会调用<code>invalidate</code>方法重绘<code>View</code>，不断的循环。由于<code>scrollTo(int destX, int destY)</code>直接让View出现在目标位置，所以我们在<code>computeScroll()</code>方法中采取微分法的做法，即将一段长距离拆分成许多微小的距离。不断通过<code>scrollTo()</code>的直接滑动以及<code>computeScrollOffset()</code>的重新计算下一个短距离的相关参数以及<code>postInvalidate()</code>的重绘View，最终达到弹性滑动的效果。</p><p><code>computeScrollOffset()</code>方法通过计算目前已经位移的百分比来计算下一次的位移目标以及是否已经完成的滑动，不通过计时器等工具。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coq">&#123;%mermaid %&#125;<br>flowchart TD<br>A[startScroll]<br>B[invalidate]<br>C[computeScroll]<br>D[computeScrollOffset : boolean]<br>E[invalidate]<br><br>A --&gt; B --&gt;|<span class="hljs-type">draw</span>| <span class="hljs-type">C</span> --&gt; D --&gt;|<span class="hljs-type">not</span> finish| <span class="hljs-type">E</span> --&gt;|<span class="hljs-type">draw</span>| <span class="hljs-type">C</span><br>D --&gt;|<span class="hljs-type">finish</span>| <span class="hljs-type">F</span>[finish]<br>&#123;% endmermaid %&#125;<br></code></pre></td></tr></table></figure><h2 id="二、通过动画"><a href="#二、通过动画" class="headerlink" title="二、通过动画"></a>二、通过动画</h2><p>通过<code>ObjectAnimator类</code>我们可以直接的通过动画完成<code>View</code>的弹性滑动。</p><p>我们也可以通过<code>onAnimatorUpdate</code>方法还自定义自己想要的动画效果。</p><h2 id="三、使用延时策略"><a href="#三、使用延时策略" class="headerlink" title="三、使用延时策略"></a>三、使用延时策略</h2><p>可以通过<code>Thread#sleep</code>或者<code>Handler#postDelayed</code>方法来达到间隔一定的时间就改变一次微小位置变化的操作。</p><p>在此次的<code>scrollTo</code>方法执行结束后，通过<code>sleep|postDelayed</code>方法暂停一定的时间，然后重复执行<code>scrollTo</code>的方法，以此来达到弹性滑动的效果。</p><p><strong>注意：</strong>无法在精准的时间内移动固定的位移，因为系统的消息调度（<code>sleep|postDelayed</code>）也是需要时间的。</p><h1 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a><code>View</code>的事件分发机制</h1><h2 id="一、点击事件的传递规则"><a href="#一、点击事件的传递规则" class="headerlink" title="一、点击事件的传递规则"></a>一、点击事件的传递规则</h2><p>点击事件分发过程，即将一系列的<code>MotionEvent</code>事件序列（由<code>ACTION_DOWN</code>开始到<code>ACTION_UP</code>结束的一连串操作）交给一个<code>View</code>执行的过程。</p><p>点击事件的分发主要由三个重要方法构成：<code>dispatchTouchEvent</code>, <code>onInterceptTouchEvent</code>,<code>onTouchEvent</code>。</p><p>三个方法的执行顺序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123; <span class="hljs-comment">// 对当前的View进行事件的分发</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">consume</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;                        <span class="hljs-comment">// 判断是否可以消耗这个事件序列</span><br>    <span class="hljs-keyword">if</span> (onInterceptTouchEvent(ev)) &#123;                <span class="hljs-comment">// 如果准备拦截此次事件序列</span><br>        consume = onTouchEvent(ev);                 <span class="hljs-comment">// 事件由该View执行，并返回结果</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        consume = child.dispatchTouchEvent(ev);     <span class="hljs-comment">// 若不准备拦截，则交给子View进行判断</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> consume;                                 <span class="hljs-comment">// 向父级返回结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中执行事件序列的不同方法中同样由优先顺序：<code>onTouchListener &gt; onTouchEvent &gt; onClickListener</code></p><p>当点击事件发生后，它的传递过程会遵循以下的顺序：<code>Activity　-&gt; Window -&gt; DecorView -&gt; View -&gt; ...</code>、</p><p>同时，如果子级发现无法执行这个事件的时候，那么它的父容器的<code>onTouchEvent</code>就会重新调用，直到<code>Activity</code>。</p><p>其中，<code>ViewGroup</code>默认不拦截任何事件，<code>View</code>没有<code>onInterceptTouchEvent</code>方法。</p><h2 id="二、事件分发解析"><a href="#二、事件分发解析" class="headerlink" title="二、事件分发解析"></a>二、事件分发解析</h2><h3 id="Activity对点击事件的分发"><a href="#Activity对点击事件的分发" class="headerlink" title="Activity对点击事件的分发"></a><code>Activity</code>对点击事件的分发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>    <span class="hljs-keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) <span class="hljs-comment">// 如果Window可以处理点击事件</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> onTouchEvent(ev); <span class="hljs-comment">// 返回Activity自己处理点击事件的结果(true|false)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Window对点击事件的分发"><a href="#Window对点击事件的分发" class="headerlink" title="Window对点击事件的分发"></a><code>Window</code>对点击事件的分发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> PhoneWindow#superDispatchTouchEvent(MotionEvent ev) &#123;<br>  <span class="hljs-keyword">return</span> mDecor.superDispatchTouchEvent(ev); <span class="hljs-comment">// 返回DecorView的处理结果</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="顶级View对点击事件的分发"><a href="#顶级View对点击事件的分发" class="headerlink" title="顶级View对点击事件的分发"></a><code>顶级View</code>对点击事件的分发</h3><p>由此开始，将执行（一）所讲述的事件传递规则。其主要的部分是<code>ViewGroup</code>的事件传递。<code>顶级View</code>一般来说都是<code>ViewGroup</code>。</p><h4 id="判断当前ViewGroup是否拦截点击事件"><a href="#判断当前ViewGroup是否拦截点击事件" class="headerlink" title="判断当前ViewGroup是否拦截点击事件"></a>判断当前<code>ViewGroup</code>是否拦截点击事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> intercepted;<br><span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION.DOWN || mFirstTouchTarget != NULL) &#123; <span class="hljs-comment">// 意思见下方文字</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">disallowIntercept</span> <span class="hljs-operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>; <span class="hljs-comment">// 判断是否允许屏蔽自身的onInterceptTouchEvent方法</span><br>    <span class="hljs-keyword">if</span> (!disallowIntercept) &#123; <span class="hljs-comment">// 如果允许拦截</span><br>        intercepted = onInterceptTouchEvent(ev); <span class="hljs-comment">// 询问能否拦截并赋值</span><br>        ev.setAction(action); <span class="hljs-comment">// 防止事件被修改，存储事件的动作</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        intercepted = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 由于不允许拦截，则直接赋值</span><br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    intercepted = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 由于直接拦截，则不用询问</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码中的几个变量的作用：</p><ol><li><p>当事件由<code>ViewGroup</code>的子元素处理成功时，<code>mFirstTouchTarget</code>就会被赋值并指向子元素，此时的<code>mFirstTouchTarget != NULL</code>。</p></li><li><p><code>FLAG_DISALLOW_INTERCEPT</code>一旦被设置后，那么当前的<code>ViewGroup</code>就无法拦截<code>ACTION_MOVE</code>以及<code>ACTION_UP</code>。</p><p>由于事件为<code>ACTION_DOWN</code>的时候，<code>ViewGroup</code>会重置<code>FLAG_DISALLOW_INTERCEPT</code>，所以每次事件为<code>ACTION_DOWN</code>的时候，都会执行一次<code>onInterceptTouchEvent</code>方法。</p></li></ol><p>第3行的判断语句的意思为：</p><ol><li>如果当前的事件为<code>ACTION_DOWN</code>时，作为一个点击事件的开始，需要向子元素传递，返回<code>true</code>。允许向子元素传递。</li><li>如果当前的事件为<code>ACTION_MOVE</code>或者<code>ACTION_UP</code>的时候，如果<code>ACTION_DOWN</code>已经被子元素处理了（<code>mFirstTouchTarget != NULL</code>），那么由于一系列的点击事件都要有同一个<code>View</code>处理，则不能在此拦截，故返回<code>true</code>。反之，如果<code>mFirstTouchTarget == NULL</code>，则代表<code>ACTION_DOWN</code>是由<code>ViewGroup</code>自身处理的，则不能向下传递，返回<code>false</code>。</li></ol><h4 id="ViewGroup在ACTION-DOWN到来时的重置操作"><a href="#ViewGroup在ACTION-DOWN到来时的重置操作" class="headerlink" title="ViewGroup在ACTION_DOWN到来时的重置操作"></a><code>ViewGroup</code>在<code>ACTION_DOWN</code>到来时的重置操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Handle an initial down.</span><br><span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;<br>    <span class="hljs-comment">// Throw away all previous state when starting a new touch gesture.</span><br>cancelAndClearTouchTargets(ev);<br>resetTouchState();<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>resetTouchState</code>方法中会对<code>FLAG_DISALLOW_INTERCEPT</code>进行重置。</p><p>因此<code>子View</code>的<code>requestDisallowInterceptTouchEvent</code>方法并不能影响<code>ViewGroup</code>对<code>ACTION_DOWN</code>事件的处理。</p><h4 id="ViewGroup不拦截事件时，对点击事件的分发"><a href="#ViewGroup不拦截事件时，对点击事件的分发" class="headerlink" title="ViewGroup不拦截事件时，对点击事件的分发"></a><code>ViewGroup</code>不拦截事件时，对点击事件的分发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> View[] = mChildren;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> childrenCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-comment">// 获取每一个子View的位置以及其他信息</span><br>    <span class="hljs-keyword">if</span> (子元素正在播放动画 || 点击事件的坐标落在当前子元素的区域外) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    newTouchTarget = getTouchTarget(child); <br>    <span class="hljs-keyword">if</span> (newTouchTarget != NULL) &#123; <span class="hljs-comment">// 如果不是NULL的话(该child之前初始化过)，就直接向其中添加元素就行了</span><br>        newTouchTarget.pointerIdBits |= idBitsToAssign;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果 newTouchTarget == NULL, 那么就初始化 + 添加第一个可用子元素</span><br>    resetCancelNextUpFlag(child);<br>    <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="hljs-literal">false</span>, child, idBitsToAssign)) &#123;<br>        ...<br>        newTouchTarget = addTouchTarget(child, idBitsToAssign);<br>        alreadyDispatchedToNewTouchTarget = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不断的遍历当前<code>ViewGroup</code>的所有子元素，如果<strong>子元素不在播放动画</strong>以及<strong>点击事件的坐标落在当前子元素的区域内</strong>，那么这个子元素就是一个可以传递的。</p><blockquote><p>  由<code>TouchTarget</code>源码可知：</p><p>  <code>TouchTarget</code>保存了响应触摸事件的子<code>view</code>和该子view上的触摸点ID集合，表示一个触摸事件派发目标。通过<code>next</code>成员可以看出，它支持作为一个链表节点储存。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TouchTarget</span> &#123;<br>    <span class="hljs-comment">// ···</span><br><br>    <span class="hljs-comment">// The touched child view.</span><br>    <span class="hljs-comment">// 被触摸的子元素</span><br>    <span class="hljs-meta">@UnsupportedAppUsage</span><br>    <span class="hljs-keyword">public</span> View child;<br><br>    <span class="hljs-comment">// The combined bit mask of pointer ids for all pointers captured by the target.</span><br>    <span class="hljs-comment">// 指针 id 的位的掩码组合，用于目标捕获的所有指针</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> pointerIdBits;<br><br>    <span class="hljs-comment">// The next target in the target list.</span><br>    <span class="hljs-comment">// 目标列表中的下一个目标</span><br>    <span class="hljs-keyword">public</span> TouchTarget next;<br>    <br>    <span class="hljs-comment">// ···</span><br>&#125;<br>————————————————<br>版权声明：本文为CSDN博主「分则能成」的原创文章，遵循CC <span class="hljs-number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：https:<span class="hljs-comment">//blog.csdn.net/dehang0/article/details/104317611</span><br></code></pre></td></tr></table></figure></blockquote><p>如果是第一个可传递元素，那么就会进入初始化部分，其中的<code>dispatchTransformedTouchEvent</code>方法实际上就是调用的子元素的<code>dispatchTouchEvent</code>方法。在该方法中有如下的一段内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (child == NULL) &#123;<br>    handled = <span class="hljs-built_in">super</span>.dispatchTouchTarget(event);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    handled = child.dispatchTouchTarget(event);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于前面的代码中<code>dispatchTransformedTouchEvent</code>方法的第三个参数为<code>child</code>，所以会执行子元素的<code>dispatchTouchEvent</code>方法，点击事件交由子元素处理，从而完成了一轮事件的分发。</p><p>当子元素的<code>dispatchTouchEvent</code>方法返回<code>true</code>时，<code>dispatchTransformedTouchEvent</code>方法同样也会返回<code>true</code>，接着便执行<code>if语句</code>的代码块部分了。如果<code>dispatchTouchEvent</code>方法返回<code>false</code>的话，<code>ViewGroup</code>就会把事件向后遍历，寻找新的可传递的子元素。在<code>if语句</code>的代码块中，<code>mFirstTouchTarget</code>会被赋值同时跳出<code>for循环</code>。</p><p>其中<code>mFirstTouchTarget</code>的赋值由<code>addTouchTarget</code>方法完成，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TouchTarget <span class="hljs-title function_">addTouchTarget</span><span class="hljs-params">(View child, <span class="hljs-type">int</span> pointerIdBits)</span> &#123;<br>    <span class="hljs-type">TouchTarget</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> TouchTarget.obtain(child, pointerIdBits);<br>   target.next = mFirstTouchTarget;<br>    mFirstTouchTarget = target;<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以很容易的看出，<code>mFirstTouchTarget</code>其实是一个<strong>单链表结构</strong>，<code>mFirstTouchTarget</code>是否被赋值，将直接影响<code>ViewGroup</code>对事件的拦截策略。</p><h4 id="ViewGroup中没有合适的子元素"><a href="#ViewGroup中没有合适的子元素" class="headerlink" title="ViewGroup中没有合适的子元素"></a><code>ViewGroup</code>中没有合适的子元素</h4><p>有两种情况，<code>ViewGroup</code>中会没有合适的子元素可以传递：</p><ol><li><code>ViewGroup</code>没有子元素</li><li>子元素处理了点击事件，但是<code>dispatchTouchEvent</code>方法返回了<code>false</code>，这一般是因为子元素在<code>onTouchEvent</code>中返回了<code>false</code>。</li></ol><p>在这两种情况中，<code>ViewGroup</code>都会自己处理点击事件。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (mFirstTouchTarget == NULL) &#123;<br><span class="hljs-comment">// 没有可分发子元素，就当其是一个普通的View</span><br>handled = dispatchTransformedTouchEvent(ev, canceled, <span class="hljs-literal">null</span>, TouchTarget.ALL_POINTER_IDS);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，代码中的<code>dispatchTransformedTouchEvent</code>方法的第三个参数将其设置为<code>null</code>，此时它就会调用<code>super.dispatchTouchTarget</code>方法了。</p><h3 id="View对点击事件的处理过程"><a href="#View对点击事件的处理过程" class="headerlink" title="View对点击事件的处理过程"></a><code>View</code>对点击事件的处理过程</h3><p>这里的<code>View</code>不包含<code>ViewGroup</code>，因为没有子元素，所以不用向下分发事件，只能自己处理事件。</p><p>先看它的<code>dispatchTouchEvent</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    ...<br>    <span class="hljs-keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;<br>        <span class="hljs-type">ListenerInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> mListenerInfo;<br>        <span class="hljs-keyword">if</span> (li != <span class="hljs-literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="hljs-literal">null</span> &amp;&amp; li.mOnTouchListener.onTouch(<span class="hljs-built_in">this</span>, event) &amp;&amp; ...) &#123;<br>            result = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;<br>            result = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上面的代码可以看出，<code>View</code>对点击事件的处理流程中，首先会判断有没有设置<code>onTouchListener</code>，如果有且其中的<code>onTouch</code>方法返回<code>true</code>，则<code>onTouchEvent</code>方法就不会被调用。</p><p>从其他的代码中也可以得出的一些结论：</p><ol><li>如果<code>View</code>的<code>CLICKABLE</code>以及<code>LONG_CLICKABLE</code>中有一个为<code>true</code>，不论<code>View</code>是否为<code>DISABLE</code>，都会消耗事件（也就是即使<code>View</code>看起来没有任何的反应，但是也消耗了点击事件）。</li><li><code>View</code>的<code>LONG_CLICKABLE</code>默认为<code>false</code>，而<code>CLICKABLE</code>是否为<code>false</code>与其<code>View</code>有关，如<code>button</code>的默认为<code>true</code>、<code>textview</code>的默认为<code>false</code>。</li><li>当<code>ACTION_UP</code>事件发生时，会触发<code>performClick</code>方法，如果<code>View</code>设置了<code>OnClickListener</code>，那么<code>performClick</code>方法就会调用它的<code>onClick</code>方法。（即<code>onClick</code>的触发前提时<code>View</code>是可点击的，且收到了<code>DOWN</code>和<code>UP</code>的点击事件。）</li><li><code>setOnClickListener</code>方法会自动将<code>CLICKABLE</code>设置为<code>true</code>，<code>setOnLongClickListener</code>方法会自动将<code>LONG_CLICKABLE</code>设置为<code>true</code>。</li></ol><h1 id="View的滑动冲突"><a href="#View的滑动冲突" class="headerlink" title="View的滑动冲突"></a><code>View</code>的滑动冲突</h1><p>总共会出现三种滑动冲突的情况：</p><ol><li><code>内部View</code>与<code>外部View</code>的滑动方向相反。</li><li><code>内部View</code>与<code>外部View</code>的滑动方向相同。</li><li>前两种情况的嵌套。</li></ol><p>三种情况的处理思路：</p><ol><li>通过手势滑动的角度判断滑动的方向。</li><li>通过当前处于的不同的页面状态来判断应该滑动的<code>View</code>。</li><li>通过前两种的综合使用。</li></ol><h2 id="滑动冲突的解决方式"><a href="#滑动冲突的解决方式" class="headerlink" title="滑动冲突的解决方式"></a>滑动冲突的解决方式</h2><h3 id="外部拦截法"><a href="#外部拦截法" class="headerlink" title="外部拦截法"></a>外部拦截法</h3><p>通过重写<strong>父容器的</strong><code>onInterceptTouchEvent</code>方法，所有的事件都先经过父容器的筛选，对其中父容器需要的事件进行拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">intercepted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getX();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getY();<br>    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN : &#123;<br>            intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE : &#123;<br>            <span class="hljs-keyword">if</span> (父容器需要当前的点击事件)<br>                intercepted = <span class="hljs-literal">true</span>;<br>           <span class="hljs-keyword">else</span> <br>                intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP : &#123;<br>            intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span> :<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    mLastXIntercept = x;<br>    mLastYIntercept = y;<br>    <span class="hljs-keyword">return</span> intercepted;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内部拦截法"><a href="#内部拦截法" class="headerlink" title="内部拦截法"></a>内部拦截法</h3><p>父元素拦截除<code>ACTION_DOWN</code>以外的其他事件，当事件到达子元素后，由子元素判断是否需要这些事件，不需要的事件将重新交由父容器来处理。这种方法和Android的事件分发机制不一致，需要配合<code>requestDisallowInterceptTouchEvent</code>方法才能正常的工作。</p><p>相关阅读链接：<a href="https://www.jianshu.com/p/fe3d109eb27e">Android TouchEvent之requestDisallowInterceptTouchEvent - 简书 (jianshu.com)</a></p><h4 id="子元素的dispatchTouchEvent方法"><a href="#子元素的dispatchTouchEvent方法" class="headerlink" title="子元素的dispatchTouchEvent方法"></a>子元素的<code>dispatchTouchEvent</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getX();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getY();<br>    <br>    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN : &#123;<br>            parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 此子View的所有父ViewGroup会跳过onInterceptTouchEvent回调</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE : &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">deltaX</span> <span class="hljs-operator">=</span> x - mLastX;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">deltaY</span> <span class="hljs-operator">=</span> y - mLastY;<br>            <span class="hljs-keyword">if</span> (父容器需要当前的点击事件) &#123;<br>                parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">false</span>);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP : &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span> : <br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    mLastX = x;<br>    mLastY = y;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.dispatchTouchEvent(event);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="父容器的onInterceptTouchEvent方法："><a href="#父容器的onInterceptTouchEvent方法：" class="headerlink" title="父容器的onInterceptTouchEvent方法："></a>父容器的<code>onInterceptTouchEvent</code>方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> event.getAction();<br>    <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>View 的绘制原理</title>
    <link href="/posts/19429a22b2b2/"/>
    <url>/posts/19429a22b2b2/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="ViewRoot"><a href="#ViewRoot" class="headerlink" title="ViewRoot"></a><code>ViewRoot</code></h2><p><code>ViewRoot</code>对应于<code>ViewRootImpl</code>类，它是连接<code>WindowManager</code>和<code>DecorView</code>的纽带。<code>View</code>的三大流程都是通过<code>ViewRoot</code>来完成的。</p><p>在<code>ActivityThread</code>中，当<code>Activity</code>对象被创建完毕后，会将<code>DecorView</code>添加到<code>Window</code>中，同时也会创建<code>ViewRootImpl</code>对象，并将<code>ViewRootImpl</code>对象与<code>DecorView</code>建立关联。</p><h2 id="View的三大绘制流程"><a href="#View的三大绘制流程" class="headerlink" title="View的三大绘制流程"></a><code>View</code>的三大绘制流程</h2><p><code>View</code>的绘制流程主要有<code>measure</code>、<code>layout</code>和<code>draw</code>过程。</p><ol><li><code>measure</code>：用来确定<code>View</code>的测量宽高。</li><li><code>layout</code>：用来确定<code>View</code>的最终宽高以及四个顶点的位置。</li><li><code>draw</code>：将<code>View</code>绘制在屏幕上。</li></ol><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-d165daed428c4a5312c1ce1af6a9693a_720w.jpg"></p><p><code>View</code>的绘制流程由<code>ViewRoot</code>的<code>performTraversals</code>方法开始。</p><p><code>performTraversals</code>方法会依次调用<code>performMeasure</code>、<code>performLayout</code>、<code>performDraw</code>方法。<strong>这三个方法会分别完成<code>顶层View</code>的<code>measure</code>、<code>layout</code>、<code>draw</code>过程。</strong></p><p>其中、<code>performMeasure</code>方法会调用其中的<code>measure</code>方法，在<code>measure</code>方法中又会调用<code>onMeasure</code>方法，在<code>onMeasure</code>方法中会对所有的子元素进行<code>measure</code>过程，这个时候<code>measure</code>的流程就从父容器传递到了子元素中，这样就完成了一轮<code>measure</code>过程。不断的对子元素进行<code>measure</code>过程。如此反复便完成了对<code>View</code>树的遍历。</p><p>其中，<code>performMeasure</code>方法位于<code>ViewRootImpl</code>中的<code>measureHierarchy</code>方法中(<code>hierarchy</code>：<code>n.</code>层次结构)。</p><p><code>performLayout</code>方法、<code>performDraw</code>方法的流程与之同理，需要注意一点的是，<code>draw</code>流程的传递是通过<code>draw</code>方法中的<code>dispatchDraw</code>实现的，不过并无本质的区别。</p><h2 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a><code>DecorView</code></h2><p><code>DecorView</code>作为<code>顶层View</code>，继承自<code>FrameLayout</code>。一般情况下它的内部都会包含一个<code>LinearLayout</code>。而<code>LinearLayout</code>中有上下两个部分，分别为标题栏和内容栏。我们平时设置指定布局文件的方法<code>setContentView</code>，就是指的是内容栏中的布局。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-8f887429daf00df80319901f69cd1d35_720w.jpg" alt="img" style="zoom:67%;" /><p>通过源码，我们可以得知，**<code>DecorView</code> 其实是一个 <code>LinearLayout</code>**，<code>View</code> 层的事件都先通过 <code>DecorView</code>，然后才传递给我们的 <code>View</code>。</p><h2 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a><code>MeasureSpec</code></h2><blockquote><p>  <code>spec</code> <strong><code>英[spek]</code></strong><code>n.</code>规格 <code>vt.</code>按特定标准设计并制造</p></blockquote><p><code>MeasureSpec</code>参与了<code>View</code>的<code>measure</code>过程。在测量过程中，系统将<code>View</code>的<code>LayoutParams</code>根据父容器所施加的规则转换成对应的<code>MeasureSpec</code>，然后再根据这个<code>MeasureSpec</code>来测量出<code>View</code>的测量宽&#x2F;高。</p><p><code>MeasureSpec</code>代表一个32位的<code>int</code>值，高两位代表 测量模式<code>SpecMode</code>，低30位代表 该测量模式下的规格大小<code>SpecSize</code>。</p><p><code>MeasureSpec</code>与<code>SpecMode</code>、<code>SpecSize</code>之间可以通过位运算互相求出。</p><p>每个<code>View</code>的<code>measure</code>过程之前都会先计算其<code>MeasureSpec</code>的值，然后再对其进行<code>measure</code>。</p><p><strong>注意</strong>：<code>View</code>的宽和高各有一个<code>MeasureSpec</code>值，分别为<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>。</p><h3 id="SpecMode的三种状态"><a href="#SpecMode的三种状态" class="headerlink" title="SpecMode的三种状态"></a><code>SpecMode</code>的三种状态</h3><ol><li><p><code>UNSPECIFIED</code></p><p>父容器不对<code>View</code>做任何的限制，要多大给多大。<strong>这种情况一般用于系统的内部</strong>，表示一种测量方式的状态。</p></li><li><p><code>EXACTLY</code></p><p>父容器已经测出了<code>View</code>所需要的精确大小，此时的大小就是<code>View</code>的最终大小。</p><p>它对应于<code>LayoutParams</code>的<code>match_parent</code>和具体的数值这两种模式。</p></li><li><p><code>AT_MOST</code></p><p>父容器指定了一个可用的大小，<code>View</code>的大小不能大于这个值。</p><p>它对应于<code>LayoutParams</code>中的<code>wrap_content</code>。</p></li></ol><h3 id="MeasureSpec和LayoutParams的对应关系"><a href="#MeasureSpec和LayoutParams的对应关系" class="headerlink" title="MeasureSpec和LayoutParams的对应关系"></a><code>MeasureSpec</code>和<code>LayoutParams</code>的对应关系</h3><p>对于<code>DecorView</code>和普通<code>View</code>来说，<code>MeasureSpec</code>的转化过程略有不同。</p><p><strong>对于<code>DecorView</code>：</strong></p><p><strong><code>DecorView</code>的<code>MeasureSpec</code>由窗口的大小和<code>DecorView</code>自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在<code>ViewRootImpl</code>中的<code>measureHierarchy</code>方法中，调用<code>getRootMeasureSpec</code>方法，获得<code>DecorView</code>的<code>MeasureSpec</code>。</p><p>其中<code>getRootMeasureSpec</code>方法中，根据自身<code>LayoutParams</code>的不同大小，共有三种情况：</p><ol><li><code>LayoutParams.MATCH_PARENT</code>：精确模式，大小就是窗口的大小。</li><li><code>LayoutParams.WRAP_CONTENT</code>：最大模式，大小不定，但是不能超过窗口的大小。</li><li>固定大小(比如100dp)：精确模式，大小为<code>LayoutParams</code>中指定的大小。</li></ol><p><strong>对于普通<code>View</code>：</strong></p><p><strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在父容器的<code>measureChildWithMargins</code>中的<code>getChildMeasureSpec</code>方法获得<code>View</code>的<code>MeasureSpec</code>。</p><p>其中<code>getChildMeasureSpec</code>方法的参数中使用到了父容器的<code>MeasureSpec</code>。在这个方法中通过<code>switch</code>和<code>if</code>语句，对<code>View</code>的<code>MeasureSpec</code>进行了决定。结果如下：</p><table><thead><tr><th><code>childLayoutParams</code> \ <code>parentMeasureSpec</code></th><th><code>EXACTLY</code></th><th><code>AT_MOST</code></th><th><code>UNSPECIFIED</code></th></tr></thead><tbody><tr><td><code>dp</code>&#x2F;<code>px</code></td><td><code>EXACTLY</code><br>childSize</td><td><code>EXACTLY</code><br/>childSize</td><td><code>EXACTLY</code><br/>childSize</td></tr><tr><td><code>match_parent</code></td><td><code>EXACTLY</code><br/>parentSize</td><td><code>AT_MOST</code><br>parentSize</td><td><code>UNSPECIFIED</code><br>0</td></tr><tr><td><code>wrap_content</code></td><td><code>AT_MOST</code><br>parentSize</td><td><code>AT_MOST</code><br/>parentSize</td><td><code>UNSPECIFIED</code><br/>0</td></tr></tbody></table><p>上图可以简单记为：除了<code>dp</code>&#x2F;<code>px</code>的精确模式情况外，三种<code>MeasureSpec</code>的级别为：<code>EXACTLY</code> &lt; <code>AT_MOST</code> &lt; <code>UNSPECIFIED</code> 且<code>childMeasureSpec</code> &#x3D; max(<code>childLayoutParams</code> , <code>parentMeasureSpec</code>)。（<strong>实际上并无级别之分</strong>）</p><p>通过上面的表格，可以更加直观的看出：<strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><h1 id="View的工作流程"><a href="#View的工作流程" class="headerlink" title="View的工作流程"></a><code>View</code>的工作流程</h1><h2 id="measure过程"><a href="#measure过程" class="headerlink" title="measure过程"></a><code>measure</code>过程</h2><p><code>measure</code>过程分为两种情况：</p><ol><li><code>View</code>的<code>measure</code>过程：只需要测量自身即可。</li><li><code>ViewGroup</code>的<code>measure</code>过程：则除了完成自己的测量外，还需要遍历去调用所有子元素的<code>measure</code>过程。</li></ol><p>以下对这两种情况分别讨论。</p><h3 id="View的measure过程"><a href="#View的measure过程" class="headerlink" title="View的measure过程"></a><code>View</code>的<code>measure</code>过程</h3><p><code>View</code>的<code>measure</code>方法是<code>final</code>类型的方法，不可以重写，<code>measure</code>方法里面调用了<code>onMeasure</code>方法。</p><p>在<code>onMeasure</code>方法里面也只调用了一个<code>setMeasuredDimension</code>方法来设置<code>View</code>的宽&#x2F;高的测量值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMeasure</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSpec, <span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br>    setMeasuredDimension(getDefaultSize(getSuggestedMininumWidth(), <br>                                        widthMeasureSpec), <br>                         getDefaultSize(getSuggestedMininumHeight(), <br>                                        heightMeasureSpec));<br>&#125;<br></code></pre></td></tr></table></figure><p>而在<code>setMeasureDimension</code>方法的参数中，则使用了<code>getDefaultSize</code>的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDefaultSize</span><span class="hljs-params">(<span class="hljs-type">int</span> size, <span class="hljs-type">int</span> measureSpec)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> size;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">specMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(measureSpec);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">specSize</span> <span class="hljs-operator">=</span> Measurespec.getSize(measureSpec);<br><br>    <span class="hljs-keyword">switch</span> (specMode) &#123;<br>        <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:<br>            result = size;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:<br>        <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:<br>            result = specsize;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对于AT-MOST和EXACTLY的情况"><a href="#对于AT-MOST和EXACTLY的情况" class="headerlink" title="对于AT_MOST和EXACTLY的情况"></a>对于<code>AT_MOST</code>和<code>EXACTLY</code>的情况</h4><p>通过代码可以看出，最终返回的值就是传入的<code>MeasureSpec</code>的中<code>View</code><strong>测量后</strong>的大小（<code>View</code>的<strong>最终的</strong>大小是在<code>layout</code>阶段确定的，但是几乎所有情况下，<code>View</code>的测量大小和最终大小都是相同的）。</p><h4 id="对于UNSPECIFIED的情况"><a href="#对于UNSPECIFIED的情况" class="headerlink" title="对于UNSPECIFIED的情况"></a>对于<code>UNSPECIFIED</code>的情况</h4><p><code>getDefaultSize</code>方法返回的值是<code>getsuggestedMininumWidth</code>方法和<code>getsuggestedMininumHeight</code>方法决定的。</p><p>这里只讨论<code>getsuggestedMininumWidth</code>方法的逻辑，另一个方法同理：</p><ol><li>如果<code>View</code>没有设置背景，那么此方法的返回值就是<code>android:minWidth</code>这个属性所指定的值，这个值默认为0。</li><li>如果<code>View</code>设置了背景，则返回<code>android:minWidth</code>和背景的最小宽度这两者中的最大值。</li></ol><h4 id="对于自定义View的情况"><a href="#对于自定义View的情况" class="headerlink" title="对于自定义View的情况"></a>对于自定义<code>View</code>的情况</h4><p>对于直接继承<code>View</code>的自定义<code>View</code>来说，<strong>需要重写<code>onMeasure</code>方法并设置在<code>wrap_content</code>情况时的自身大小</strong>，否则在布局中使用<code>wrap_content</code>就相当于使用<code>match_parent</code>。</p><p>因为当自定义<code>View</code>处于<code>wrap_content</code>时，它的<code>SpecMode</code>为<code>AT_MOST</code>模式，由前文可知，当父容器无论为<code>AT_MOST</code>还是<code>ECACTLY</code>模式时，自定义<code>View</code>都为<code>AT_MOST</code>模式且尺寸大小为<code>parentSize</code>，也就是父容器的剩余空间，即自定义<code>View</code>的大小变得与父容器的剩余空间大小一致，显然不是我们需要的。</p><p><strong>解决方法：</strong></p><p>解决方法也是非常简单的。我们只需要在<code>onMeasure</code>方法中对</p><ol><li>仅<code>width</code>方向为<code>AT_MOST</code>模式</li><li>仅<code>height</code>方向为<code>AT_MOST</code>模式</li><li><code>width</code>方向以及<code>height</code>方向都为<code>AT_MOST</code>模式</li><li>其他的情况</li></ol><p>这四个状态单独判断，分别使用<code>setMeasuredDimension</code>方法直接为自定义<code>View</code>设置我们需要的值即可。</p><p>源码中对于<code>TextView</code>、<code>ImageView</code>等控件的<code>wrap_content</code>也做了特殊的处理。</p><h3 id="ViewGroup的measure过程"><a href="#ViewGroup的measure过程" class="headerlink" title="ViewGroup的measure过程"></a><code>ViewGroup</code>的<code>measure</code>过程</h3><p>对于<code>ViewGroup</code>来说，处理要完成它自己的<code>measure</code>过程，还需要遍历去调用所有子元素的<code>measure</code>方法，对子元素也进行<code>measure</code>过程。</p><p>由于<code>ViewGroup</code>是一个抽象类，不能重写<code>View</code>的<code>onMeasure</code>方法，但是他提供了一个<code>measureChildren</code>的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measureChildren</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSepc, <span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> mChildrenCount;<br>    <span class="hljs-keyword">final</span> View[] children = mChildren;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> children[i];<br>        <span class="hljs-keyword">if</span> (...) &#123;<br>            measureChild(child, widthMeasureSpec, heightMeasureSpec);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中，可以清晰的看出，<code>measureChildren</code>方法遍历了所有的子元素，并对他们使用了<code>measureChild</code>方法。</p><p>在<code>measureChild</code>方法中，通过</p><ol><li>参数<code>child</code>获得了<code>child.LayoutParams</code>；</li><li><code>measureChild</code>方法中的<code>getChildMeasureSpec</code>方法配合参数中父容器的两个<code>MeasureSpec</code>值，得到子元素的两个<code>MeasureSpec</code>值。</li></ol><p>接着将子元素的两个<code>MeasureSpec</code>值传递给<code>child.measure</code>方法来进行测量，到此便结束了一轮的<code>measure</code>过程。</p><p><strong>注意</strong>：不同的<code>ViewGroup</code>有着不同的布局特性，不易写出通用的供<code>ViewGroup</code>使用的<code>onMeasure</code>方法。故设置成抽象类，需要测量过程中的各个子类（如<code>LinearLayout</code>、<code>RelativeLayout</code>等）自己去具体实现<code>onMeasure</code>方法。</p><h3 id="在Activity启动时获得一个View的宽-x2F-高信息的方法"><a href="#在Activity启动时获得一个View的宽-x2F-高信息的方法" class="headerlink" title="在Activity启动时获得一个View的宽&#x2F;高信息的方法"></a>在<code>Activity</code>启动时获得一个<code>View</code>的宽&#x2F;高信息的方法</h3><p>由于<code>Activity</code>的启动和<code>View</code>的测量过程并不是同步进行的，因此无法保证在<code>Activity</code>启动时某个<code>View</code>已经测量完毕了。所以我们在<code>Activity</code>启动的时候，如果直接通过<code>getMeasuredWidth</code>&#x2F;<code>getMeasuredHeight</code>方法获得的值可能为0。</p><p>以下有四种方法可以解决这个问题（详细代码见《Android开发艺术探索》190页）。</p><ol><li><p><code>Activity/View#onWindowFocusChanged</code></p><p>在<code>Activity</code>的<code>onResume</code>和<code>onPause</code>方法启动时，<code>onWindowFocusChanged</code>方法也会同时被调用，可以重写里面的内容，使之计算<code>View</code>的宽高。</p><p><strong>注意</strong>：<code>onWindowFocusChanged</code>方法会在<code>View</code>已经初始化完毕后才开始调用。</p></li><li><p><code>view.post(runnable)</code></p><p>通过<code>post</code>可以将一个<code>runnable</code>投递都消息队列的尾部，然后等待<code>Looper</code>调用此<code>runnable</code>的时候，<code>View</code>也已经初始化好了。</p></li><li><p><code>ViewTreeObserver</code></p><p><code>ViewTreeObserver</code>中的众多回调可以完成这个功能。</p><p>比如<code>OnGlobalLayoutListener</code>接口，当<code>View</code>树的状态发生改变或者<code>View</code>树内部的<code>View</code>的可见性发生改变的时候，<code>onGlobalLayout</code>方法将被回调，此时就可以获取<code>View</code>的宽高了。</p></li><li><p><code>view.measure(int widthMeasureSpec, int heightMeasureSpec)</code></p><p>可以主动调用该方法开始计算<code>view</code>的宽高。</p><ol><li><p><strong><code>match_parent</code></strong></p><p>由于正常的<code>measure</code>过程中，我们需要父容器的<code>MeasureSpec</code>的值，而此时父容器并没开始计算，我们无从得知这两个值的大小。故我们无法对<code>match_parent</code>的<code>view</code>计算其宽高。</p></li><li><p><strong><code>dp</code>&#x2F;<code>px</code></strong></p><p>因为有精确的数值了，所以我们可以直接使用这个精确的数值通过<code>MeasureSpec.makeMeasureSpec</code>方法构建<code>view</code>的<code>MeasureSpec</code>。</p></li><li><p><strong><code>wrap_content</code></strong></p><p>直接将<code>MeasureSpec.makeMeasureSpec</code>方法中参数的值设置为<code>(1&lt;&lt;30)-1</code>即可，这是<code>View</code>理论上可以支持的最大值，所以这样构建<code>MeasureSpec</code>是合理的。</p></li></ol></li></ol><h2 id="layout过程"><a href="#layout过程" class="headerlink" title="layout过程"></a><code>layout</code>过程</h2><p><code>layout</code>的作用是<code>ViewGroup</code>用来确定子元素的位置。当调用一个<code>View</code>的<code>layout</code>方法时，它会在<code>layout</code>方法中通过<code>setFrame</code>方法确定自身的位置，然后调用<code>onLayout</code>方法确定子元素的位置。</p><p>在<code>onLayout</code>方法中，会遍历所有子元素，对它们计算各自的位置后，调用子元素的<code>layout</code>方法，完成一轮<code>layout</code>过程。</p><p><code>View</code>中实现了<code>layout</code>方法，但是由于<code>onLayout</code>的实现与不同<code>View</code>各自的布局有关，所以源码中仅给出了一个空<code>onLayout</code>方法。需要每个<code>View</code>和<code>ViewGroup</code>自己去重写。</p><p><strong>注意</strong>：单一<code>View</code>一般不需要重写<code>onLayout</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Assign a size and position to a view and all of its</span><br><span class="hljs-comment"> * descendants</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;This is the second phase of the layout mechanism.</span><br><span class="hljs-comment"> * (The first is measuring). In this phase, each parent calls</span><br><span class="hljs-comment"> * layout on all of its children to position them.</span><br><span class="hljs-comment"> * This is typically done using the child measurements</span><br><span class="hljs-comment"> * that were stored in the measure pass().&lt;/p&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Derived classes should not override this method.</span><br><span class="hljs-comment"> * Derived classes with children should override</span><br><span class="hljs-comment"> * onLayout. In that method, they should</span><br><span class="hljs-comment"> * call layout on each of their children.&lt;/p&gt;</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> * 为视图及其所有子体指定大小和位置</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 这是布局机制的第二阶段。</span><br><span class="hljs-comment"> * （第一个是测量）。在此阶段中，每个父级调用其所有子级上的layout来定位它们。</span><br><span class="hljs-comment"> * 这通常使用存储在方法pass()中的子测量值来完成。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 派生类不应重写此方法。</span><br><span class="hljs-comment"> * 具有子级的派生类应重写onLayout。在该方法中，他们应该对每个子对象调用布局。  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLayout</span><span class="hljs-params">(<span class="hljs-type">boolean</span> changed, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> top, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> bottom)</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="draw过程"><a href="#draw过程" class="headerlink" title="draw过程"></a><code>draw</code>过程</h2><p><code>draw</code>过程就比较简单，它的作用是将<code>View</code>绘制到屏幕上面。</p><p><code>View</code>的绘制过程遵循以下的4步：</p><ol><li>绘制背景：<code>background.draw(canvas)</code></li><li>绘制自己：<code>onDraw</code>方法</li><li>绘制children：<code>dispatchDraw</code>方法</li><li>绘制装饰：<code>onDrawScrollBars</code>方法</li></ol><p>所有的绘制过程都在<code>draw</code>方法中进行。</p><p>其中，<code>View</code>绘制过程的传递是通过<code>dispatchDraw</code>方法实现的，<code>dispatchDraw</code>方法会遍历所有的子元素并调用他们的<code>draw</code>方法，完成一轮的<code>draw</code>过程。</p><p><strong>注意</strong>：</p><ol><li>单一<code>View</code>需要重写<code>onDraw</code>方法绘制自身。</li><li><code>ViewGroup</code>需要重写<code>onDraw</code>方法绘制自身以及遍历子元素对它们进行绘制。</li></ol><h2 id="View的工作流程图"><a href="#View的工作流程图" class="headerlink" title="View的工作流程图"></a>View的工作流程图</h2><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-3d1255a5093de81fd5bdc27a300d2f0d_720w.jpg"></p><h1 id="TODO：自定义View"><a href="#TODO：自定义View" class="headerlink" title="TODO：自定义View"></a><em>TODO</em>：自定义<code>View</code></h1>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/51f783f2dca4/"/>
    <url>/posts/51f783f2dca4/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
