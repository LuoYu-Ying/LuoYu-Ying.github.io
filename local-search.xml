<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>详解十大排序算法！</title>
    <link href="/posts/69698757e59a/"/>
    <url>/posts/69698757e59a/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  以下所有排序算法的示例代码皆为：</p><ul><li><a href="https://www.nowcoder.com/practice/2baf799ea0594abd974d37139de27896">排序-牛客题霸_牛客网 (nowcoder.com)</a></li></ul></blockquote><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p><p>常见的内部排序算法有：插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序等。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/sort.png" alt="十个排序算法的特性 - 1" style="zoom: 80%;" /><p>对上面图中的部分参数进行一个讲解：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>$n$</td><td>数据的规模</td></tr><tr><td>$k$</td><td>“桶”的个数</td></tr><tr><td>$in-place$</td><td>占用的常数内存，不占用额外内存</td></tr><tr><td>$out-place$</td><td>占用的额外内存</td></tr><tr><td>稳定性</td><td>排序后的 2 个相等键值的顺序和排序之前它们的顺序相同</td></tr></tbody></table><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/0B319B38-B70E-4118-B897-74EFA7E368F9.png" alt="十个排序算法的特性 - 2"  /><hr><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较相邻的两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p><strong>比较相邻的元素。</strong>如果第一个比第二个大，就交换他们两个。</p><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，<strong>最后的元素会是最大的数。</strong></p><p>针对所有的元素重复以上的步骤，除了最后一个。</p><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/bubbleSort.gif" alt="冒泡排序 动图演示" style="zoom: 80%;" /><h2 id="最坏时间复杂度情况"><a href="#最坏时间复杂度情况" class="headerlink" title="最坏时间复杂度情况"></a>最坏时间复杂度情况</h2><p>输入数据为反序的时候。时间复杂度为 $O(n^2)$（但是和平均时间复杂度一样）。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Bubble Sort</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将给定数组排序</span><br><span class="hljs-comment">     * @param arr int整型vector 待排序的数组</span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MyBubbleSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; len; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[i] &gt; arr[j]) &#123;<br>                    <span class="hljs-built_in">swap</span>(arr[i], arr[j]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序是一种简单直观的排序算法，<strong>无论什么数据</strong>进去都是 $O(n^2)$ 的时间复杂度。所以用到它的时候，<strong>数据规模越小越好</strong>。唯一的好处可能就是不占用额外的内存空间了吧。</p><h2 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><p>重复第二步，直到所有元素均排序完毕。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/selectionSort.gif" alt="选择排序 动图演示" style="zoom:80%;" /><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Selection Sort</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将给定数组排序</span><br><span class="hljs-comment">     * @param arr int整型vector 待排序的数组</span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MySelectionSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = arr.<span class="hljs-built_in">size</span>(), min_value_position = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++) &#123;<br>            min_value_position = i;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; len; j++) &#123;<br>                <span class="hljs-comment">// 寻找未排序部分中最小值所在的位置</span><br>                <span class="hljs-keyword">if</span> (arr[min_value_position] &gt; arr[j]) <br>                    min_value_position = j;<br>            &#125;<br>            <span class="hljs-built_in">swap</span>(arr[i], arr[min_value_position]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。</p><p>插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>插入排序和冒泡排序一样，也有一种优化算法，叫做<strong>拆半插入</strong>。</p><h2 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h2><p><strong>初始状态（即未开始排序的时候）下</strong>，将第一待排序序列第一个元素看做一个有序序列，第二个元素到最后一个元素当成是未排序序列。</p><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置（如果待插入的元素与有序序列中的某个元素相等，则将<strong>待插入元素插入到相等元素的后面</strong>）。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/insertionSort.gif" alt="插入排序 动图演示" style="zoom:80%;" /><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Insertion Sort</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将给定数组排序</span><br><span class="hljs-comment">     * @param arr int整型vector 待排序的数组</span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MyInsertionSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = arr.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>            <span class="hljs-type">int</span> current_value = arr[i], cmp_index = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (cmp_index &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[cmp_index] &gt; current_value) &#123;<br>                arr[cmp_index + <span class="hljs-number">1</span>] = arr[cmp_index];<br>                cmp_index--;<br>            &#125;<br>            arr[cmp_index + <span class="hljs-number">1</span>] = current_value;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序的实质就是分组插入排序，该方法又称递减增量排序算法。希尔排序是非稳定的排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ol><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率。</li><li>插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。</li></ol><h2 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序。</p><p>待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。</p><p>这里需要注意的是，我们是<strong>将所有间隔为一个“增量”的元素归并为一个子序列</strong>，而非是连续长度为“间隔”的数字归并为子序列。</p><p>假设有一组 ${9, 1, 2, 5, 7, 4, 8, 6, 3, 5}$ 无序序列：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-7ef755d2b04f11cb013acb47f10928cc_720w.webp" alt="希尔排序 示例" style="zoom: 80%;" /><p>这里对上面的示例进行一个讲解：</p><ul><li><p><strong>第一趟排序</strong>：</p><p>设 $gap1 &#x3D; N &#x2F; 2 &#x3D; 5$，即相隔距离为 $5$ 的元素组成一组，可以分为 $5$ 组。接下来，按照直接插入排序的方法对每个组进行排序。</p></li><li><p><strong>第二趟排序</strong>：<br>将上次的 $gap$ 缩小一半，即 $gap2 &#x3D; gap1 &#x2F; 2 &#x3D; 2$ （取整数）。这样每相隔距离为 $2$ 的元素组成一组，可以分为 $2$ 组。按照直接插入排序的方法对每个组进行排序。</p></li><li><p><strong>第三趟排序</strong>：<br>再次把 $gap$ 缩小一半，即 $gap3 &#x3D; gap2 &#x2F; 2 &#x3D; 1$。 这样相隔距离为 $1$ 的元素组成一组，即只有一组。按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。</p></li></ul><p><strong>注：需要注意一下的是，图中有两个相等数值的元素 $5$ 和 $5$。我们可以清楚的看到，在排序过程中，两个元素位置交换了。也即希尔排序是不稳定的排序算法。</strong></p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li><strong>平均时间复杂度：</strong>$O(nlog_2n)$</li><li><strong>最坏时间复杂度：</strong>当序列为最终排序结果的反序时，时间复杂度则会是 $O(n^2)$</li></ul><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将给定数组排序</span><br><span class="hljs-comment">     * @param arr int整型vector 待排序的数组</span><br><span class="hljs-comment">     * @return int整型vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">MyShellSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = arr.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 计算 gap，每次都是前一次的 1/2 倍</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> gap = len &gt;&gt; <span class="hljs-number">1</span>; gap &gt; <span class="hljs-number">0</span>; gap &gt;&gt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = gap; i &lt; len; i++) &#123;<br>                <span class="hljs-comment">// 代码参考插入排序，需要注意 cmp_index 的取值变化</span><br>                <span class="hljs-type">int</span> current_value = arr[i], cmp_index = i - gap;<br>                <span class="hljs-keyword">while</span> (cmp_index &gt;= <span class="hljs-number">0</span> &amp;&amp; arr[cmp_index] &gt; current_value) &#123;<br>                    arr[cmp_index + gap] = arr[cmp_index];<br>                    cmp_index -= gap;<br>                &#125;<br>                arr[cmp_index + gap] = current_value;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">十大经典排序算法 | 菜鸟教程 (runoob.com)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/122632213">【算法】排序算法之希尔排序 - 知乎 (zhihu.com)</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sort Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android面试整理-ContentProvider</title>
    <link href="/posts/5b54e4a61c50/"/>
    <url>/posts/5b54e4a61c50/</url>
    
    <content type="html"><![CDATA[<blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/Lwenlong/p/15941998.html">Android面试——ContentProvider篇 - 向着内核前进！ - 博客园 (cnblogs.com)</a></li></ul></blockquote><h1 id="什么是ContentProvider及其使用"><a href="#什么是ContentProvider及其使用" class="headerlink" title="什么是ContentProvider及其使用"></a>什么是<code>ContentProvider</code>及其使用</h1><ol><li><p><code>ContentProvider</code>通过Uri标识其他应用要访问的数据；</p></li><li><p>通过<code>ContentResolver</code>的增删改查方法实现对共享的数据的操作；</p></li><li><p>通过注册<code>ContentObserver</code>来监听数据是否发生了变化来对应的刷新页面</p></li></ol><p> <strong><font size="4">作用</font></strong> </p><p>为不同应用之间的数据共享提供统一的接口</p><h1 id="ContentProvider-ContentResolver-ContentObserver之间的关系"><a href="#ContentProvider-ContentResolver-ContentObserver之间的关系" class="headerlink" title="ContentProvider,ContentResolver,ContentObserver之间的关系"></a><code>ContentProvider</code>,<code>ContentResolver</code>,<code>ContentObserver</code>之间的关系</h1><ol><li><p><code>ContentProvider</code></p><p>内容提供者：管理数据，提供数据的增删改查操作，数据源可以是数据库，文件，<code>xml</code>，网络等。</p></li><li><p><code>ContentResolver</code></p><p>内容解析者：外部进程通过内容解析者与内容提供者进行交互。</p></li><li><p><code>ContentObserver</code></p><p>内容观察者：观察内容提供者的数据变化，并将变化通知给外界。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>面试整理-2022</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ContentProvider</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 自定义 Toast 转载</title>
    <link href="/posts/c584a47cc2bb/"/>
    <url>/posts/c584a47cc2bb/</url>
    
    <content type="html"><![CDATA[<blockquote><p>文章转载自：</p><ul><li><a href="https://blog.csdn.net/liuwan1992/article/details/52710652">Android 自定义Toast，修改Toast样式和显示时长_liuwan1992的博客-CSDN博客</a></li></ul></blockquote><hr><p>Android 中有一个 Toast 控件，可以用来显示提示信息，还是非常好用的，但是样式和显示时长比较局限。所以我们来自定义一个 Toast，让它可以显示我们想要的效果，并能设置显示时长。</p><p>首先，在 <code>res\layout</code> 文件夹下创建自定义 Toast 的布局文件 <code>custom_toast.xml</code>，用来设置 Toast 的样式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/toast_custom_parent&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">              <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/tvToastContent&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;46dp&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">android:layout_marginBottom</span>=<span class="hljs-string">&quot;75dp&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@drawable/toast_customer_style&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;#FFFFFF&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里的自定义 Toast 其实就是一个TextView ，其中引用了 <code>res\drawable</code> 文件夹下的一个 shape 样式文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">shape</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">android:shape</span>=<span class="hljs-string">&quot;rectangle&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 设置背景透明度和颜色 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">solid</span> <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;#99000000&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 设置四个角为弧形 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">corners</span> <span class="hljs-attr">android:radius</span>=<span class="hljs-string">&quot;23dp&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">padding</span></span><br><span class="hljs-tag">             <span class="hljs-attr">android:left</span>=<span class="hljs-string">&quot;23dp&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">android:right</span>=<span class="hljs-string">&quot;23dp&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">shape</span>&gt;</span><br></code></pre></td></tr></table></figure><p>到这里，所有的布局就已经设计好了，也就是实现了自定义样式，接下来就是在代码中实现自定义 Toast 了，以及实现设置显示时长：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomToast</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">canceled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">private</span> Handler handler;<br>    <span class="hljs-keyword">private</span> Toast toast;<br>    <span class="hljs-keyword">private</span> TimeCount time;<br>    <span class="hljs-keyword">private</span> TextView toast_content;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomToast</span><span class="hljs-params">(Context context, ViewGroup viewGroup)</span> &#123;<br>        <span class="hljs-built_in">this</span>(context, viewGroup, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomToast</span><span class="hljs-params">(Context context, ViewGroup viewGroup, Handler handler)</span> &#123;<br>        <span class="hljs-built_in">this</span>.handler = handler;<br><br>        <span class="hljs-type">View</span> <span class="hljs-variable">layout</span> <span class="hljs-operator">=</span> LayoutInflater.from(context).inflate(R.layout.custom_toast, viewGroup);<br>        toast_content = (TextView) layout.findViewById(R.id.tvToastContent);<br>        <span class="hljs-keyword">if</span> (toast == <span class="hljs-literal">null</span>) &#123;<br>            toast = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Toast</span>(context);<br>        &#125;<br>        toast.setGravity(Gravity.BOTTOM, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        toast.setDuration(Toast.LENGTH_LONG);<br>        toast.setView(layout);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> text     要显示的内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> duration 显示的时间长</span><br><span class="hljs-comment">     *                 根据LENGTH_MAX进行判断</span><br><span class="hljs-comment">     *                 如果不匹配，进行系统显示</span><br><span class="hljs-comment">     *                 如果匹配，永久显示，直到调用hide()</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">(String text, <span class="hljs-type">int</span> duration)</span> &#123;<br>        time = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeCount</span>(duration, <span class="hljs-number">1000</span>);<br>        toast_content.setText(text);<br>        <span class="hljs-keyword">if</span> (canceled) &#123;<br>            time.start();<br>            canceled = <span class="hljs-literal">false</span>;<br>            showUntilCancel();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 隐藏Toast</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hide</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (toast != <span class="hljs-literal">null</span>) &#123;<br>            toast.cancel();<br>        &#125;<br>        canceled = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showUntilCancel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (canceled) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        toast.show();<br>        handler.postDelayed(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                showUntilCancel();<br>            &#125;<br>        &#125;, <span class="hljs-number">3000</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计时器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeCount</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CountDownTimer</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TimeCount</span><span class="hljs-params">(<span class="hljs-type">long</span> millisInFuture, <span class="hljs-type">long</span> countDownInterval)</span> &#123;<br>            <span class="hljs-built_in">super</span>(millisInFuture, countDownInterval); <span class="hljs-comment">// 总时长,计时的时间间隔</span><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFinish</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 计时完毕时触发</span><br>            hide();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onTick</span><span class="hljs-params">(<span class="hljs-type">long</span> millisUntilFinished)</span> &#123; <span class="hljs-comment">// 计时过程显示</span><br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里主要通过一个倒计时器和异步线程来实现设置显示时长。<code>TimeCount</code> 有两个参数，第一个是倒计时时长，也就是 Toast 要显示的时长，第二个是间隔时间，在倒计时内每隔一定时间会回调一次 <code>onTick</code> 方法，倒计时结束后回调 <code>onFinish</code> 方法。在倒计时器中我 们要设置的只有倒计时时长，即显示时长，时间到了就 <code>cancel()</code> 掉 Toast。在对 Toast 初始化时，默认设置的显示时长是 <code>LENGTH_LONG</code>，为 2.5s。那么问题来了，3s 以内倒计时器可以控制显示时长，但是超过 3s Toast 就自行结束了，如果我们想要显示超过三秒怎么办，所以这里通过一个异步线程，并设置一个 <code>postDelayed</code> 任务，推迟 3s 执行，在线程中调用自身的方法，实现循环调用。 这样每隔 3s 显示一次 Toast ，达到了一直显示的效果。然后通过 <code>canceled</code> 属性，将倒计时器和异步线程联系到一起，这样就可以通过 Handler 让 Toast 一直显示，再通过 <code>TimeCount</code> 让 Toast 结束显示，达到了自定义显示时长的效果。</p><p>具体调用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> CustomToast toast;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">toastMessage</span><span class="hljs-params">(String content)</span> &#123;<br>    <span class="hljs-keyword">if</span> (toast != <span class="hljs-literal">null</span>) &#123;<br>        toast.hide();<br>    &#125;<br>    toast = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomToast</span>(LoginActivity.<span class="hljs-built_in">this</span>,<br>                            (ViewGroup) <span class="hljs-built_in">this</span>.findViewById(R.id.toast_custom_parent));<br>    toast.show(content, <span class="hljs-number">500</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就可以在 <code>onClick</code> 等事件中通过调用 <code>toastMessage(&quot;自定义 Toast 的显示内容 &quot;);</code> 来显示你想要给用户看到的提示内容了。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Toast</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android面试整理 - Handler</title>
    <link href="/posts/c2b533c1e2de/"/>
    <url>/posts/c2b533c1e2de/</url>
    
    <content type="html"><![CDATA[<h1 id="Handler的实现原理"><a href="#Handler的实现原理" class="headerlink" title="Handler的实现原理"></a><code>Handler</code>的实现原理</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://luoyu-ying.github.io/posts/9435d0391c8a/">Handler 机制解析 | 洛语 の Blog (luoyu-ying.github.io)</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/Handler%E6%9C%BA%E5%88%B6ver2.png" alt="Handler 机制"></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/a3f0101bb9aef02691d45337a906325f.png"></p><h1 id="子线程中能不能直接new一个Handler-为什么主线程可以？主线程的Looper第一次调用loop方法-什么时候-哪个类？"><a href="#子线程中能不能直接new一个Handler-为什么主线程可以？主线程的Looper第一次调用loop方法-什么时候-哪个类？" class="headerlink" title="子线程中能不能直接new一个Handler,为什么主线程可以？主线程的Looper第一次调用loop方法,什么时候,哪个类？"></a>子线程中能不能直接<code>new</code>一个<code>Handler</code>,为什么主线程可以？主线程的<code>Looper</code>第一次调用<code>loop</code>方法,什么时候,哪个类？</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/886b11e233b3">可以在子线程直接new一个Handler吗？怎么做？ - 简书 (jianshu.com)</a></li></ul></blockquote><p><strong>可以在子线程直接<code>new</code>一个<code>Handler</code>，不过需要在子线程里先调用<code>Looper#prepare</code>。<code>new</code>一个<code>Handler</code>后，还需要调用<code>Looper#loop</code>方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        Looper.prepare();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>                <span class="hljs-built_in">super</span>.handleMessage(msg);<br>            &#125;<br>        &#125;;<br>        Looper.loop();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>有人会问，在主线程中为什么没看到<code>Looper.prepare()</code>？其实系统已经给我们调用了，不过调用的是<code>Looper.prepareMainLooper()</code>，如下源码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SystemServer 类</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* The main entry point from zygote.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemServer</span>().run();<br>&#125;<br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    Looper.prepareMainLooper();<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>main</code>方法是整个<code>android</code>应用的入口，在子线程中调用<code>Looper.prepare()</code>是为了创建一个<code>Looper</code>对象，并将该对象存储在当前线程的<code>ThreadLocal</code>中。</p><p>每个线程都会有一个<code>ThreadLocal</code>，它为每个线程提供了一个本地的副本变量机制，实现了和其它线程隔离，并且这种变量只在本线程的生命周期内起作用，可以减少同一个线程内多个方法之间的公共变量传递的复杂度。<code>Looper.loop()</code>方法是为了取出消息队列中的消息并将消息发送给指定的<code>handler</code>,通过<code>msg.target.dispatchMassage()</code>方法。</p><h1 id="Handler导致的内存泄露原因及其解决方案"><a href="#Handler导致的内存泄露原因及其解决方案" class="headerlink" title="Handler导致的内存泄露原因及其解决方案"></a><code>Handler</code>导致的内存泄露原因及其解决方案</h1><blockquote><p>当不再需要某个实例后，这个对象却仍然被引用，阻止被垃圾回收(Prevent from being bargage collected)，这个情况就叫做内存泄露(Memory Leak)。</p></blockquote><p>考虑以下的代码；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">mLeakyHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>        <span class="hljs-comment">// ... </span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然不明显，但是这段代码可能导致内存泄露。Android Lint会提示以下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">In Android, Handler classes should be static or leaks might occur.<br></code></pre></td></tr></table></figure><p><strong>它到底是如何泄露的呢？</strong></p><ol><li><p>当一个<code>Android</code>应用程序启动的时候，<code>Android</code>框架为这个程序的主线程即UI线程创建了一个<code>Looper</code>对象，用于处理<code>Handler</code>中的<code>Message</code>。<br> <code>Looper</code>实现了一个简单的消息队列<code>MessageQueue</code>，不断循环的处理其中的<code>message</code>。<br> 所有的应用程序框架的事件（比如<code>Activity</code>生命周期的调用，按钮的点击等）都被封装在这个<code>Message</code>对象里，然后被加入到<code>Looper</code>的<code>MessageQueue</code>，最后一个一个的处理这些<code>Message</code>。<br> 注意，<code>Looper</code>在整个应用程序的生命周期中一直存在。</p></li><li><p>在主线程中实例化一个<code>Handler</code>对象的时候，就和它关联了主线程<code>Looper</code>的消息队列<code>MessageQueue</code>。<br> 被发送到这个消息队列的<code>Message</code>将保持对这个Handler对象的引用，这样框架就可以在处理这个<code>Message</code>的时候调用<code>Handler.handleMessage(Message)</code>来处理消息了。<br> (也就是说，只要没有处理到这个<code>Message</code>，<code>Handler</code>就一直在队列中被引用)。</p></li><li><p>在<code>Java</code>中，非静态内部类和匿名内部类都隐式的保持了一个对外部类<code>outerclass</code>的引用。<strong>但是静态内部类不会有这个引用。</strong></p></li></ol><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/5238c9d2921c4ba6b78be289b24a7d27.jpg" style="zoom:67%;" /><p><strong>正确的解决方法：</strong></p><ol><li><code>Handler</code>静态内部类 + <code>WeakReference&lt;Activity&gt;</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br>    <br>    <span class="hljs-comment">// 静态内部类不会持有外部类的信用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WeakReference&lt;MainActivity&gt; mActivity;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyHandler</span><span class="hljs-params">(MainActivity activity)</span> &#123;<br>            mActivity = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;MainActivity&gt;(activity);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>            <span class="hljs-type">MainActivity</span> <span class="hljs-variable">activity</span> <span class="hljs-operator">=</span> mActivity.get();<br>            <span class="hljs-keyword">if</span> (activity != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// ...</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">MyHandler</span> <span class="hljs-variable">mHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyHandler</span>(<span class="hljs-built_in">this</span>);<br>&#125;   <br></code></pre></td></tr></table></figure><ol start="2"><li>静态<code>Runnable</code>，避免对外部类的引用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br><br>    <span class="hljs-comment">// 匿名类用static修饰后，不会再持有外部类的引用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">sRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// TODO</span><br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState); <br>        mHandler.postDelayed(sRunnable, <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// Go back to the previous Activity.</span><br>        finish();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态内部类和非静态内部类的区别很微小，但是开发人员必须了解。</p><p>那么底线是什么？</p><p>当内部类可以独立于<code>Activity</code>的生命周期而存在的时候，应该避免使用非静态内部类，应该用静态内部类并且使用<code>WeakReference</code>保持对<code>Activity</code>的引用。</p><p><strong>深入理解</strong></p><p>像下面这样使用handler的时候，其实是将handler定义为了匿名内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br>    <span class="hljs-keyword">private</span> Handler mLeakyHandler=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123; <br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<strong>匿名内部类会默认持有外部类（<code>MainActivity</code>）的引用</strong>。</p><p>学过<code>handler</code>的都知道，<code>handler</code>发送消息后，消息会进行入队操作，在<code>enqueueMessage</code>方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">msg.target = <span class="hljs-built_in">this</span>;<br></code></pre></td></tr></table></figure><p><code>this</code>指的就是handler，所以<code>handler</code>被<code>message</code>持有了，而<code>message</code>放入消息队列后，<code>message</code>又被<code>MessageQueue</code>持有了，而<code>MessageQueue</code>是在创建Looper的时候生成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">Looper</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>    mQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(quitAllowed);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>所以<code>MessageQueue</code>又被<code>looper</code>所持有。如果这个<code>handler</code>是主线程的<code>handler</code>，那么此时的<code>looper</code>就是指的主线程的<code>Looper</code>，它的声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Looper sMainLooper;<br></code></pre></td></tr></table></figure><p>可以看到主线程的<code>looper</code>是<code>static</code>静态变量，而<code>static</code>静态变量在垃圾回收的时候是会被当做<code>GC Root</code>的，静态变量的生命周期与<code>APP</code>的生命周期、与虚拟机的生命周期是一样的，所以正是因为这个持有链的存在，导致了内存泄露。</p><p>引用链大致如下：</p><p><code>(static) Looper --&gt;|持有| MessageQueue --&gt;|持有| Message --&gt;|持有| Handler --&gt;|持有| MainActivity</code></p><p>所以解决 <code>handler</code> 内存泄露的办法就是要破坏这个持有链，比如只要 <code>handler</code> 不被 <code>activity</code> 持有就可以，所以可以把 <code>handler</code> 定义为<code>static</code>，因为 <code>static</code> 不会持有外部类，这样 <code>handler</code> 就不会持有 <code>activity</code> 了。</p><p><strong>怎样判断一个内部类有没有被持有外部类？</strong></p><p>比如上面的<code>handler</code>定义，没有加static的时候，在<code>handleMessage</code>方法里面可以正常使用<code>MainActivity.this</code>，这说明它持有了外部类。而一旦<code>Handler</code>加上static关键字，在<code>handleMessage</code>方法内部就不能再使用<code>MainActivity.this</code>，说明它没有持有外部类。</p><p>（为什么<code>static</code>变量，不会造成内存泄露？<code>static</code> 不会去持有外部类）</p><h1 id="MessageQueue是什么数据结构"><a href="#MessageQueue是什么数据结构" class="headerlink" title="MessageQueue是什么数据结构"></a><code>MessageQueue</code>是什么数据结构</h1><p><code>MessageQueue</code> 是一个基于时间排序的<strong>优先队列</strong>。</p><h1 id="Message对象创建的方式有哪些-amp-区别？"><a href="#Message对象创建的方式有哪些-amp-区别？" class="headerlink" title="Message对象创建的方式有哪些 &amp; 区别？"></a><code>Message</code>对象创建的方式有哪些 &amp; 区别？</h1><p>创建Message对象的时候，<strong>有三种方式</strong>，分别为：</p><ol><li><code>Message msg = new Message();</code></li><li><code>Message msg = Message.obtain();</code></li><li><code>Message msg = handler.obtainMessage();</code></li></ol><p><strong>分析</strong></p><ol><li><p><code>Message msg = new Message();</code></p><p>这种就是直接初始化一个Message对象，没有什么特别的。</p></li><li><p><code>Message msg = Message.obtain();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Return a new Message instance from the global pool. Allows us to</span><br><span class="hljs-comment">* avoid allocating new objects in many cases.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title function_">obtain</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;<br><span class="hljs-keyword">if</span> (sPool != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> sPool;<br>            sPool = m.next;<br>            m.next = <span class="hljs-literal">null</span>;<br>            m.flags = <span class="hljs-number">0</span>; <span class="hljs-comment">// clear in-use flag</span><br>            sPoolSize--;<br>            <span class="hljs-keyword">return</span> m;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>从注释可以得知，从整个<code>Message</code>池中返回一个新的<code>Message</code>实例，通过<code>obtainMessage</code>能避免重复<code>Message</code>创建对象。</p></li><li><p><code>Message msg = handler1.obtainMessage();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Message <span class="hljs-title function_">obtainMessage</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> Message.obtain(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title function_">obtain</span><span class="hljs-params">(Handler h)</span> &#123;<br>    <span class="hljs-type">Message</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> obtain();<br>    m.target = h;<br>    <span class="hljs-keyword">return</span> m;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title function_">obtain</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (sPoolSync) &#123;<br>        <span class="hljs-keyword">if</span> (sPool != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> sPool;<br>            sPool = m.next;<br>            m.next = <span class="hljs-literal">null</span>;<br>            m.flags = <span class="hljs-number">0</span>; <span class="hljs-comment">// clear in-use flag</span><br>            sPoolSize--;<br>            <span class="hljs-keyword">return</span> m;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，第二种跟第三种其实是一样的，都可以避免重复创建Message对象，所以建议用第二种或者第三种任何一个创建Message对象。</p></li></ol><h1 id="Message-obtain-怎么维护消息池的？"><a href="#Message-obtain-怎么维护消息池的？" class="headerlink" title="Message.obtain()怎么维护消息池的？"></a><code>Message.obtain()</code>怎么维护消息池的？</h1><p>使用了<strong>享元设计模式</strong>，当前message执行完后，把message置为空，然后重新给message进行赋值。 通<strong>过链表的形式</strong>，进行了复用和回收</p><h1 id="Handler-有哪些发送消息的方法"><a href="#Handler-有哪些发送消息的方法" class="headerlink" title="Handler 有哪些发送消息的方法"></a><code>Handler</code> 有哪些发送消息的方法</h1><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//版本1</span><br>Message message = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Message()</span>;<br>message.what = <span class="hljs-number">0</span>;<br>message.obj = <span class="hljs-string">&quot;hello&quot;</span>;<br>mHandler.send<span class="hljs-constructor">Message(<span class="hljs-params">message</span>)</span>; <br><br><span class="hljs-comment">//版本2</span><br>Message message = mHandler.obtain<span class="hljs-constructor">Message()</span>;<br>message.what = <span class="hljs-number">0</span>;<br>message.obj = <span class="hljs-string">&quot;hello&quot;</span>;<br>mHandler.send<span class="hljs-constructor">Message(<span class="hljs-params">message</span>)</span>;<br><br><span class="hljs-comment">//版本3</span><br>mHandler.obtain<span class="hljs-constructor">Message(0,<span class="hljs-string">&quot;hello&quot;</span>)</span>.send<span class="hljs-constructor">ToTarget()</span>;<br></code></pre></td></tr></table></figure><p>其中，版本3 使用到的 <code>sendToTarget</code> 方法只适用于有<code>target</code>值的<code>Message</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Sends this Message to the Handler specified by &#123;<span class="hljs-doctag">@link</span> #getTarget&#125;.</span><br><span class="hljs-comment">* Throws a null pointer exception if this field has not been set.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendToTarget</span><span class="hljs-params">()</span> &#123;<br>target.sendMessage(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Handler的post与sendMessage的区别和应用场景"><a href="#Handler的post与sendMessage的区别和应用场景" class="headerlink" title="Handler的post与sendMessage的区别和应用场景"></a><code>Handler</code>的<code>post</code>与<code>sendMessage</code>的区别和应用场景</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/jingerlovexiaojie/article/details/107973310">Handler发送消息的方式_程序员老林的博客-CSDN博客_handler发送消息</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220517154734.png"></p><h1 id="子线程能不能更新UI"><a href="#子线程能不能更新UI" class="headerlink" title="子线程能不能更新UI"></a>子线程能不能更新UI</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/xyh269/article/details/52728861">Android中子线程真的不能更新UI吗？_yinhuanxu的博客-CSDN博客_android非主线程更新ui</a></li></ul></blockquote><p>极端情况下是可以的。</p><ol><li><p>更新UI后会立即通过 <code>ViewRootImpl</code> 类执行里面的 <code>performTraversal</code> 方法。</p></li><li><p>在 <code>performTraversal</code> 方法前，还会先执行一个 <code>checkThread</code> 方法。如果监测到当前的线程不是主线程，就会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">checkThread</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (mThread != Thread.currentThread()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CalledFromWrongThreadException</span>(<br>                <span class="hljs-string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过源码可以发现， <code>ViewRootImpl</code> 类的创建是在回调了 <code>onResume</code> 方法之后。所以我们在 <code>onCreate</code> 方法中通过子线程立即更新UI时，由于该类并没有创建，所以无法检测当前线程是否为主线程，所以程序没有崩溃一样能跑起来，如果修改了程序，让线程休眠了200毫秒后，程序就崩了。很明显200毫秒后<code>ViewRootImpl</code>已经创建了，可以执行<code>checkThread</code>方法检查当前线程。</p></li></ol><h1 id="为什么Android系统不建议子线程访问UI"><a href="#为什么Android系统不建议子线程访问UI" class="headerlink" title="为什么Android系统不建议子线程访问UI"></a>为什么Android系统不建议子线程访问UI</h1><p>Android的UI访问是没有加锁的，这样在多个线程访问UI是不安全的。所以Android中规定只能在UI线程中访问UI。</p><h1 id="postDelay后消息队列有什么变化，假设先-postDelay-10s-再postDelay-1s-怎么处理这2条消息"><a href="#postDelay后消息队列有什么变化，假设先-postDelay-10s-再postDelay-1s-怎么处理这2条消息" class="headerlink" title="postDelay后消息队列有什么变化，假设先 postDelay 10s, 再postDelay 1s, 怎么处理这2条消息"></a><code>postDelay</code>后消息队列有什么变化，假设先 <code>postDelay</code> 10s, 再<code>postDelay</code> 1s, 怎么处理这2条消息</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://juejin.cn/post/7030413030940737549">android 面试题handle系列 - 掘金 (juejin.cn)</a></li></ul></blockquote><p>如果队列中只有这个消息，那么消息不会被发送，而是计算到时唤醒的时间，先将Looper阻塞，到时间就唤醒它。</p><p>但如果此时要加入新消息，该消息队列的对头跟delay时间相比更长，则插入到头部，<strong>按照触发时间进行排序</strong>，队头的时间最小、队尾的时间最大。<strong>（消息队列为优先队列）</strong></p><h1 id="MessageQueue的enqueueMessage-方法如何进行线程同步的"><a href="#MessageQueue的enqueueMessage-方法如何进行线程同步的" class="headerlink" title="MessageQueue的enqueueMessage()方法如何进行线程同步的"></a><code>MessageQueue</code>的<code>enqueueMessage</code>()方法如何进行线程同步的</h1><p>通过源码可以发现，<code>enqueueMessage</code> 方法中，通过了 <code>synchronized</code> 关键字对 <code>MessageQueue</code> 进行了上锁的处理。保证了线程的同步。</p><h1 id="ThreadLocal在Handler机制中的作用"><a href="#ThreadLocal在Handler机制中的作用" class="headerlink" title="ThreadLocal在Handler机制中的作用"></a><code>ThreadLocal</code>在<code>Handler</code>机制中的作用</h1><blockquote><p>  ThreadLocal 更多细节：</p><ul><li>[ThreadLocal 解析 <a href="https://luoyu-ying.github.io/posts/03160a3be19b/">转载] | 洛语 の Blog (luoyu-ying.github.io)</a></li></ul></blockquote><p><code>Threadlocal</code>内部是一个<code>Map</code>实现，以当前线程<code>Threadlocal</code>为键，以<code>Looper</code>为值进行绑定，**保证一个线程对应一个<code>Looper</code>**。</p><h1 id="当Activity有多个Handler的时候，怎么样区分当前消息由哪个Handler处理"><a href="#当Activity有多个Handler的时候，怎么样区分当前消息由哪个Handler处理" class="headerlink" title="当Activity有多个Handler的时候，怎么样区分当前消息由哪个Handler处理"></a>当<code>Activity</code>有多个<code>Handler</code>的时候，怎么样区分当前消息由哪个<code>Handler</code>处理</h1><p>在<code>Looper#loop</code>中，<code>Looper</code>把<code>message</code>直接交给了<code>target</code>即发送这个消息的<code>handler</code>处理。</p><h1 id="Handler-如何与-Looper-关联的"><a href="#Handler-如何与-Looper-关联的" class="headerlink" title="Handler 如何与 Looper 关联的"></a><code>Handler</code> 如何与 <code>Looper</code> 关联的</h1><p>通过 ThreadLocal 进行关联。</p><h1 id="Looper-如何与-Thread-关联的"><a href="#Looper-如何与-Thread-关联的" class="headerlink" title="Looper 如何与 Thread 关联的"></a><code>Looper</code> 如何与 <code>Thread</code> 关联的</h1><p>通过 ThreadLocal 进行关联。</p><h1 id="通过Handler如何实现线程的切换"><a href="#通过Handler如何实现线程的切换" class="headerlink" title="通过Handler如何实现线程的切换"></a>通过<code>Handler</code>如何实现线程的切换</h1><p>实际线程间切换，就是通过<strong>线程间共享变量</strong>实现的。</p><p>在A线程new handler()，在b线程调用这个handler发送消息，这个message发送到了，A线程中的 messageQueue里面，又回到了a线程中执行。</p><h1 id="Android中为什么主线程不会因为Looper-loop里的死循环卡死？"><a href="#Android中为什么主线程不会因为Looper-loop里的死循环卡死？" class="headerlink" title="Android中为什么主线程不会因为Looper#loop里的死循环卡死？"></a><code>Android</code>中为什么主线程不会因为<code>Looper#loop</code>里的死循环卡死？</h1><p>主线程确实是阻塞的,不阻塞那<code>APP</code>怎么能一直运行？</p><p>所以说主线程阻塞是一个伪命题,只不过是没有弄明白既然阻塞了,为什么还能调用各种声明周期而已。</p><p> 调用生命周期是因为有<code>Looper</code>,有<code>MessageQueue</code>,还有沟通的桥梁<code>Handler</code>,通过<code>IPC</code>机制调用<code>Handler</code>发送各种消息,保存到<code>MessageQueue</code>中,然后在主线程中的<code>Looper</code>提取了消息,并在主线程中调用<code>Handler</code>的方法去处理消息.最终完成各种声明周期。</p><h1 id="MessageQueue-next-在没有消息的时候会阻塞，如何恢复？"><a href="#MessageQueue-next-在没有消息的时候会阻塞，如何恢复？" class="headerlink" title="MessageQueue#next 在没有消息的时候会阻塞，如何恢复？"></a><code>MessageQueue#next</code> 在没有消息的时候会阻塞，如何恢复？</h1><p>用 <code>MessageQueue#enqueueMessage</code> 时会唤醒 <code>MessageQueue</code>，这个方法会被 <code>Handler#sendMessage</code>、<code>Handler#post</code> 等一系列发送消息的方法调用。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>面试整理-2022</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Handler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Handler 机制解析</title>
    <link href="/posts/6805656561ea/"/>
    <url>/posts/6805656561ea/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理自：</p><ul><li>《Android 开发艺术探索》</li><li><a href="https://blog.csdn.net/zhanglianyu00/article/details/70842494">Handler sendMessageDelayed()&#x2F;postDelayed()机制详解</a></li><li><a href="https://www.cnblogs.com/neo-java/p/6830681.html">主线程中的Looper.loop()为什么不会造成ANR</a></li><li><a href="https://blog.csdn.net/zenmela2011/article/details/123439527">Android Handler引发内存泄露★★★</a></li></ul></blockquote><hr><h1 id="Handler机制组成部分"><a href="#Handler机制组成部分" class="headerlink" title="Handler机制组成部分"></a><code>Handler</code>机制组成部分</h1><p><code>Hanler</code>机制中的几个重要的组成部分：</p><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td><code>ThreadLocal</code></td><td>将消息转存入其他指定的线程中</td></tr><tr><td><code>MessageQueue</code></td><td>消息队列，用于存储当前线程的转存入的消息</td></tr><tr><td><code>Looper</code></td><td>消息循环，不断的监控消息队列并从其中取出消息并处理</td></tr><tr><td><code>Handler</code></td><td>负责发送消息以及处理消息</td></tr></tbody></table><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ul><li><p>常用于在其他线程中处理UI操作。</p></li><li><p>在处理消息的线程中定义一个<code>Handler</code>，若该线程中没有定义<code>Looper</code>，则需要先定义<code>Looper</code>，否则会报错。其中主线程的<code>Looper</code>已在启动的时候默认加载了，所以在主线程中无需先定义<code>Looper</code>。</p></li><li><p>当在其中线程中需要进行UI操作的时候，需要在该线程中使用主线程的<code>Handler</code>变量的<code>sendMessage</code>方法或者<code>post</code>方法。</p></li></ul><h1 id="ThreadLocal注意"><a href="#ThreadLocal注意" class="headerlink" title="ThreadLocal注意"></a><code>ThreadLocal</code>注意</h1><p><code>ThreadLocal</code>在<code>API21</code>以及<code>API28</code>中的代码实现方法不同：</p><ul><li>由<code>localValues</code>数组变为<code>TheadLocalMap</code>类。</li><li><code>ThreadLocalMap</code>为弱引用。</li></ul><h1 id="Looper注意"><a href="#Looper注意" class="headerlink" title="Looper注意"></a><code>Looper</code>注意</h1><ul><li><code>Looper</code>每个线程只有一个，除主线程外的线程默认不自动加载，需要自己主动使用<code>Looper.prepare()</code>方法加载。</li><li>另外需要<code>looper.loop()</code>方法启动<code>Looper</code>。</li><li><code>Looper</code>启动时会同时加载<code>MessageQueue</code>。</li><li>推出<code>Looper</code>是可以使用<code>Looper#quit</code>或者<code>Looper#quitSafely</code>方法。</li></ul><h1 id="机制分析"><a href="#机制分析" class="headerlink" title="机制分析"></a>机制分析</h1><p>从<code>handler.sendMessage(Message msg)</code>出发，分析整个<code>Handler</code>的消息处理机制。</p><h2 id="Handler-sendMessage方法"><a href="#Handler-sendMessage方法" class="headerlink" title="Handler#sendMessage方法"></a><code>Handler#sendMessage</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>    <span class="hljs-keyword">return</span> sendMessageDelayed(msg, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessageDelayed</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-type">long</span> delayMillis)</span> &#123;<br>    <span class="hljs-keyword">if</span> (delayMillis &lt; <span class="hljs-number">0</span>) &#123;<br>        delayMillis = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">sendMessageAtTime</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg, <span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>    <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> mQueue;<br>    <span class="hljs-keyword">if</span> (queue == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">RuntimeException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>            <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot; sendMessageAtTime() called with no mQueue&quot;</span>);<br>        Log.w(<span class="hljs-string">&quot;Looper&quot;</span>, e.getMessage(), e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> MessageQueue queue, <span class="hljs-meta">@NonNull</span> Message msg,</span><br><span class="hljs-params">                               <span class="hljs-type">long</span> uptimeMillis)</span> &#123;<br>    msg.target = <span class="hljs-built_in">this</span>;<br>    msg.workSourceUid = ThreadLocalWorkSource.getUid();<br><br>    <span class="hljs-keyword">if</span> (mAsynchronous) &#123;<br>        msg.setAsynchronous(<span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>sendMessage</code>方法的调用，以及中间的多个方法的调用，最终调用了<code>enqueueMessage</code>方法中的<code>queue.enqueueMessage</code>方法，将消息加入了<code>MessageQueue</code>中。</p><h2 id="MessageQueue-enqueueMessage方法"><a href="#MessageQueue-enqueueMessage方法" class="headerlink" title="MessageQueue#enqueueMessage方法"></a><code>MessageQueue#enqueueMessage</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">enqueueMessage</span><span class="hljs-params">(Message msg, <span class="hljs-type">long</span> when)</span> &#123;<br>    <span class="hljs-keyword">if</span> (msg.target == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Message must have a target.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (msg.isInUse()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(msg + <span class="hljs-string">&quot; This message is already in use.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>            <span class="hljs-type">IllegalStateException</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<br>                msg.target + <span class="hljs-string">&quot; sending message to a Handler on a dead thread&quot;</span>);<br>            Log.w(TAG, e.getMessage(), e);<br>            msg.recycle();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        msg.markInUse();<br>        msg.when = when;<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> mMessages;<br>        <span class="hljs-type">boolean</span> needWake;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when == <span class="hljs-number">0</span> || when &lt; p.when) &#123;<br>            <span class="hljs-comment">// New head, wake up the event queue if blocked.</span><br>            msg.next = p;<br>            mMessages = msg;<br>            needWake = mBlocked;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Inserted within the middle of the queue.  Usually we don&#x27;t have to wake</span><br>            <span class="hljs-comment">// up the event queue unless there is a barrier at the head of the queue</span><br>            <span class="hljs-comment">// and the message is the earliest asynchronous message in the queue.</span><br>            needWake = mBlocked &amp;&amp; p.target == <span class="hljs-literal">null</span> &amp;&amp; msg.isAsynchronous();<br>            Message prev;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                prev = p;<br>                p = p.next;<br>                <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">null</span> || when &lt; p.when) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;<br>                    needWake = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>            msg.next = p; <span class="hljs-comment">// invariant: p == prev.next</span><br>            prev.next = msg;<br>        &#125;<br><br>        <span class="hljs-comment">// We can assume mPtr != 0 because mQuitting is false.</span><br>        <span class="hljs-keyword">if</span> (needWake) &#123;<br>            nativeWake(mPtr);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法比较简单，采用<strong>线程安全</strong>的方式将 <code>Message</code> 插入到消息队列中，插入的新消息有三种可能成为消息队列的 <code>head</code>：</p><ol><li><code>MessageQueue</code> 为空。</li><li>参数 <code>when</code> 为 0，因为此时 <code>when</code> 已经转成绝对时间，所以只有 <code>AtFrontOfQueue</code> 系列的 <code>API</code> 才会满足这个条件。</li><li>当前的 <code>head Message</code> 执行时间在 <code>when</code> 之后，即消息队列中无需要在此 <code>Message</code> 之前执行的 <code>Message</code>。</li></ol><h2 id="Looper-loop方法"><a href="#Looper-loop方法" class="headerlink" title="Looper#loop方法"></a><code>Looper#loop</code>方法</h2><p>同时<code>Looper</code>的<code>loop</code>方法不断监控<code>MessageQueue</code>中是否有待处理的消息，如果有的话，就调用<code>MessageQueue#next</code>方法，该方法将取出单链表第一个消息并返回给<code>looper</code>。</p><blockquote><p>  <code>MessageQueue#next</code>方法链表中没有消息的情况下不返回任何信息，直到中间有了新的消息后才取出，否则将一直等待。</p><p>  <code>Looper#loop</code>方法是会堵塞进程的方法，如果没有消息的话，就会继续永不停止的观测，直到<code>MessageQueue#next</code>能够返回出消息。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Looper</span> <span class="hljs-variable">me</span> <span class="hljs-operator">=</span> myLooper();<br>    <span class="hljs-keyword">if</span> (me == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (me.mInLoop) &#123;<br>        Slog.w(TAG, <span class="hljs-string">&quot;Loop again would have the queued messages be executed&quot;</span><br>               + <span class="hljs-string">&quot; before this one completed.&quot;</span>);<br>    &#125;<br><br>    me.mInLoop = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> me.mQueue;<br><br>    <span class="hljs-comment">// Make sure the identity of this thread is that of the local process,</span><br>    <span class="hljs-comment">// and keep track of what that identity token actually is.</span><br>    Binder.clearCallingIdentity();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ident</span> <span class="hljs-operator">=</span> Binder.clearCallingIdentity();<br><br>    <span class="hljs-comment">// Allow overriding a threshold with a system prop. e.g.</span><br>    <span class="hljs-comment">// adb shell &#x27;setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start&#x27;</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">thresholdOverride</span> <span class="hljs-operator">=</span><br>        SystemProperties.getInt(<span class="hljs-string">&quot;log.looper.&quot;</span><br>                                + Process.myUid() + <span class="hljs-string">&quot;.&quot;</span><br>                                + Thread.currentThread().getName()<br>                                + <span class="hljs-string">&quot;.slow&quot;</span>, <span class="hljs-number">0</span>);<br><br>    ...<br><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> queue.next(); <span class="hljs-comment">// might block</span><br>            <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// No message indicates that the message queue is quitting.</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// This must be in a local variable, in case a UI event sets the logger</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Printer</span> <span class="hljs-variable">logging</span> <span class="hljs-operator">=</span> me.mLogging;<br>            <span class="hljs-keyword">if</span> (logging != <span class="hljs-literal">null</span>) &#123;<br>                logging.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="hljs-string">&quot; &quot;</span> +<br>                                msg.callback + <span class="hljs-string">&quot;: &quot;</span> + msg.what);<br>            &#125;<br>            e.traceBegin(traceTag, msg.target.getTraceName(msg));<br>        &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">dispatchStart</span> <span class="hljs-operator">=</span> needStartTime ? SystemClock.uptimeMillis() : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> dispatchEnd;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>        token = observer.messageDispatchStarting();<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">origWorkSource</span> <span class="hljs-operator">=</span> ThreadLocalWorkSource.setUid(msg.workSourceUid);<br>    <span class="hljs-keyword">try</span> &#123;<br>        msg.target.dispatchMessage(msg);<br>        <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>            observer.messageDispatched(token, msg);<br>        &#125;<br>        dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception exception) &#123;<br>        <span class="hljs-keyword">if</span> (observer != <span class="hljs-literal">null</span>) &#123;<br>            observer.dispatchingThrewException(token, msg, exception);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> exception;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        ThreadLocalWorkSource.restore(origWorkSource);<br>        <span class="hljs-keyword">if</span> (traceTag != <span class="hljs-number">0</span>) &#123;<br>            Trace.traceEnd(traceTag);<br>        &#125;<br>    &#125;<br><br>    ...<br><br>        msg.recycleUnchecked();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在该方法的中间有<code>msg.target.dispatchMessage(msg);</code>这行代码。<code>msg.target</code>就是目标线程的<code>handler</code>对象，对该对象使用<code>Handler#dispatchMessage</code>方法，让其处理消息。</p><p>也就是说，取下一个消息的实际执行时间取决于上一个消息什么时候处理完。</p><h2 id="MessageQueue-next方法"><a href="#MessageQueue-next方法" class="headerlink" title="MessageQueue#next方法"></a><code>MessageQueue#next</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java">Message <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Return here if the message loop has already quit and been disposed.</span><br>    <span class="hljs-comment">// This can happen if the application tries to restart a looper after quit</span><br>    <span class="hljs-comment">// which is not supported.</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ptr</span> <span class="hljs-operator">=</span> mPtr;<br>    <span class="hljs-keyword">if</span> (ptr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">pendingIdleHandlerCount</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// -1 only during first iteration</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextPollTimeoutMillis</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (nextPollTimeoutMillis != <span class="hljs-number">0</span>) &#123;<br>            Binder.flushPendingCommands();<br>        &#125;<br><br>        nativePollOnce(ptr, nextPollTimeoutMillis);<br><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// Try to retrieve the next message.  Return if found.</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> SystemClock.uptimeMillis();<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">prevMsg</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> mMessages;<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; msg.target == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    prevMsg = msg;<br>                    msg = msg.next;<br>                &#125; <span class="hljs-keyword">while</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !msg.isAsynchronous());<br>            &#125;<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>                    <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span><br>                    nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Got a message.</span><br>                    mBlocked = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) &#123;<br>                        prevMsg.next = msg.next;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        mMessages = msg.next;<br>                    &#125;<br>                    msg.next = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">&quot;Returning message: &quot;</span> + msg);<br>                    msg.markInUse();<br>                    <span class="hljs-keyword">return</span> msg;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// No more messages.</span><br>                nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// Process the quit message now that all pending messages have been handled.</span><br>            <span class="hljs-keyword">if</span> (mQuitting) &#123;<br>                dispose();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// If first time idle, then get the number of idlers to run.</span><br>            <span class="hljs-comment">// Idle handles only run if the queue is empty or if the first message</span><br>            <span class="hljs-comment">// in the queue (possibly a barrier) is due to be handled in the future.</span><br>            <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt; <span class="hljs-number">0</span><br>                &amp;&amp; (mMessages == <span class="hljs-literal">null</span> || now &lt; mMessages.when)) &#123;<br>                pendingIdleHandlerCount = mIdleHandlers.size();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// No idle handlers to run.  Loop and wait some more.</span><br>                mBlocked = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (mPendingIdleHandlers == <span class="hljs-literal">null</span>) &#123;<br>                mPendingIdleHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleHandler</span>[Math.max(pendingIdleHandlerCount, <span class="hljs-number">4</span>)];<br>            &#125;<br>            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);<br>        &#125;<br><br>        <span class="hljs-comment">// Run the idle handlers.</span><br>        <span class="hljs-comment">// We only ever reach this code block during the first iteration.</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">IdleHandler</span> <span class="hljs-variable">idler</span> <span class="hljs-operator">=</span> mPendingIdleHandlers[i];<br>            mPendingIdleHandlers[i] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// release the reference to the handler</span><br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">keep</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                keep = idler.queueIdle();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                Log.wtf(TAG, <span class="hljs-string">&quot;IdleHandler threw exception&quot;</span>, t);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (!keep) &#123;<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    mIdleHandlers.remove(idler);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Reset the idle handler count to 0 so we do not run them again.</span><br>        pendingIdleHandlerCount = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// While calling an idle handler, a new message could have been delivered</span><br>        <span class="hljs-comment">// so go back and look again for a pending message without waiting.</span><br>        nextPollTimeoutMillis = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到 <code>next()</code> 实际上也有一个 <code>for(;;)</code>，而出口只有两个：</p><ol><li>消息队列已经退出，返回 null；</li><li>找到了一个合适的消息，将其返回。<br>如果没有合适的消息，或者消息队列为空，会 block 或者由 IdleHandler 处理，不在本文问题范畴，暂不展开。</li></ol><p>主要看找到合适的消息的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (now &lt; msg.when) &#123;<br>        <span class="hljs-comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span><br>        nextPollTimeoutMillis = (<span class="hljs-type">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Got a message.</span><br>        mBlocked = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (prevMsg != <span class="hljs-literal">null</span>) &#123;<br>            prevMsg.next = msg.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mMessages = msg.next;<br>        &#125;<br>        msg.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (DEBUG) Log.v(TAG, <span class="hljs-string">&quot;Returning message: &quot;</span> + msg);<br>        msg.markInUse();<br>        <span class="hljs-keyword">return</span> msg;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// No more messages.</span><br>    nextPollTimeoutMillis = -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到：</p><ol><li>如果在消息队列中顺序找到了一个消息 msg（前文分析过，消息队列的插入是由when顺序排列，所以如果当前的消息没有到执行时间，其后的也一定不会到），当前的系统时间小于 msg.when，那么会计算一个 timeout，以便在到执行时间时wake up；</li><li>如果当前系统时间大于或等于 msg.when，那么会返回msg给Looper.loop()。</li></ol><p>所以这个逻辑只能保证在 when 之前消息不被处理，不能够保证一定在when时被处理。很好理解：</p><ol><li>在 Loop.loop() 中是顺序处理消息，如果前一个消息处理耗时较长，完成之后已经超过了 when，消息不可能在 when 时间点被处理。</li><li>即使 when 的时间点没有被处理其他消息所占用，线程也有可能被调度失去 cpu 时间片。</li><li>在等待时间点 when 的过程中有可能入队处理时间更早的消息，会被优先处理，又增加了（1）的可能性。</li></ol><p><strong>所以由上述三点可知，Handler 提供的指定处理时间的 api 诸如 postDelayed() &#x2F; postAtTime() &#x2F; sendMessageDelayed() &#x2F; sendMessageAtTime() ，只能保证在指定时间之前不被执行，不能保证在指定时间点被执行。</strong></p><h2 id="Handler-dispatchMessage方法"><a href="#Handler-dispatchMessage方法" class="headerlink" title="Handler#dispatchMessage方法"></a><code>Handler#dispatchMessage</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Handle system messages here.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatchMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (msg.callback != <span class="hljs-literal">null</span>) &#123;<br>        handleCallback(msg);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (mCallback != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (mCallback.handleMessage(msg)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        handleMessage(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该方法一共有三个执行等级：</p><ol><li>如果传入的<code>Message</code>自己附带了UI操作的代码，那么就执行该代码。</li><li>如果<code>Message</code>没有附带的话，那么就是看<code>mCallback</code>是否存在，存在的话就执行该回调的<code>handleCallback</code>方法。</li><li>如果都不存在的话，就执行<code>handler</code>对象的<code>handleMessage</code>方法。</li></ol><h2 id="Handler-handleMessage方法"><a href="#Handler-handleMessage方法" class="headerlink" title="Handler#handleMessage方法"></a><code>Handler#handleMessage</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Subclasses must implement this to receive messages.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Message msg)</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，<code>Handler#handleMessage</code>方法是一个空方法，所以需要我们在创建的时候就进行重写。</p><p>之后目标线程就可以执行想要其执行的操作了。</p><hr><h1 id="相关面试问题"><a href="#相关面试问题" class="headerlink" title="相关面试问题"></a>相关面试问题</h1><h2 id="主线程中的-Looper-loop-为什么不会造成-ANR"><a href="#主线程中的-Looper-loop-为什么不会造成-ANR" class="headerlink" title="主线程中的 Looper.loop() 为什么不会造成 ANR"></a>主线程中的 Looper.loop() 为什么不会造成 ANR</h2><p>正如我们所知，在android中如果主线程中进行耗时操作会引发ANR（Application Not Responding）异常。</p><blockquote><p>造成ANR的原因一般有两种：</p><ol><li>当前的事件没有机会得到处理（即主线程正在处理前一个事件，没有及时的完成或者looper被某种原因阻塞住了）。</li><li>当前的事件正在处理，但没有及时完成。</li></ol></blockquote><p>ActivityThread的main方法主要就是做消息循环，一旦退出消息循环，那么你的应用也就退出了。</p><p>我们知道了消息循环的必要性，那为什么这个死循环不会造成ANR异常呢？</p><p>因为Android 的是由事件驱动的，looper.loop() 不断地接收事件、处理事件，每一个点击触摸或者说Activity的生命周期都是运行在 Looper.loop() 的控制之下，如果它停止了，应用也就停止了。只能是某一个消息或者说对消息的处理阻塞了 Looper.loop()，而不是 Looper.loop() 阻塞它。</p><p>也就说我们的代码其实就是在这个循环里面去执行的，当然不会阻塞了。</p><p>Activity的生命周期都是依靠主线程的Looper.loop，当收到不同Message时则采用相应措施。</p><p>如果某个消息处理时间过长，比如你在onCreate(),onResume()里面处理耗时操作，那么下一次的消息比如用户的点击事件不能处理了，整个循环就会产生卡顿，时间一长就成了ANR。</p><p>主线程Looper从消息队列读取消息，当读完所有消息时，主线程阻塞。子线程往消息队列发送消息，并且往管道文件写数据，主线程即被唤醒，从 管道文件读取数据，主线程被唤醒只是为了读取消息，当消息读取完毕，再次睡眠。因此loop的循环并不会对CPU性能有过多的消耗。</p><p><strong>总结：Looer.loop()方法可能会引起主线程的阻塞，但只要它的消息循环没有被阻塞，能一直处理事件就不会产生ANR异常。</strong></p><h2 id="sendMessage与sendMessageDelay如何保证Message放入MessageQueue中的顺序"><a href="#sendMessage与sendMessageDelay如何保证Message放入MessageQueue中的顺序" class="headerlink" title="sendMessage与sendMessageDelay如何保证Message放入MessageQueue中的顺序"></a>sendMessage与sendMessageDelay如何保证Message放入MessageQueue中的顺序</h2><p>通过对 MessageQueue#enqueue() 以及 MessageQueue#next() 源码的阅读，我们可以看到两个方法都是通过synchronized来保证了线程的安全性。</p><p><strong>由于多线程的性能开销，所以我们能够保证 Message 的顺序的正确性，但是无法保证这些 Message 执行的时间的精确性。</strong></p><h2 id="Handler-内存泄漏问题"><a href="#Handler-内存泄漏问题" class="headerlink" title="Handler 内存泄漏问题"></a>Handler 内存泄漏问题</h2><blockquote><p>当不再需要某个实例后，这个对象却仍然被引用，阻止被垃圾回收(Prevent from being bargage collected)，这个情况就叫做内存泄露(Memory Leak)。</p></blockquote><p>考虑以下的代码；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Handler</span> <span class="hljs-variable">mLeakyHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>            <span class="hljs-comment">// ... </span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然不明显，但是这段代码可能导致内存泄露。Android Lint会提示以下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">In Android, Handler classes should be static or leaks might occur.<br></code></pre></td></tr></table></figure><p><strong>它到底是如何泄露的呢？</strong></p><ol><li><p>当一个Android应用程序启动的时候，Android框架为这个程序的主线程即UI线程创建了一个Looper对象，用于处理Handler中的Message。<br>Looper实现了一个简单的消息队列messagequeue，不断循环的处理其中的message。<br>所有的应用程序框架的事件（比如Activity生命周期的调用，按钮的点击等）都被封装在这个Message对象里，然后被加入到Looper的Messagequeue，最后一个一个的处理这些Message。<br>注意，Looper在整个应用程序的生命周期中一直存在。</p></li><li><p>在主线程中实例化一个Handler对象的时候，就和它关联了主线程Looper的消息队列Messagequeue。<br>被发送到这个消息队列的Message将保持对这个Handler对象的引用，这样框架就可以在处理这个Message的时候调用Handler.handleMessage(Message)来处理消息了。<br>(也就是说，只要没有处理到这个Message，Handler就一直在队列中被引用)。</p></li><li><p>在Java中，非静态内部类和匿名内部类都隐式的保持了一个对外部类outerclass的引用。<strong>但是静态内部类不会有这个引用。</strong></p></li></ol><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/5238c9d2921c4ba6b78be289b24a7d27.jpg" style="zoom:67%;" /><p><strong>正确的解决方法：</strong></p><ol><li>静态内部类+WeakReference<Activity></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br><br>    <span class="hljs-comment">// 静态内部类不会持有外部类的信用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Handler</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WeakReference&lt;MainActivity&gt; mActivity;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyHandler</span><span class="hljs-params">(MainActivity activity)</span> &#123;<br>            mActivity = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;MainActivity&gt;(activity);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123;<br>            <span class="hljs-type">MainActivity</span> <span class="hljs-variable">activity</span> <span class="hljs-operator">=</span> mActivity.get();<br>            <span class="hljs-keyword">if</span> (activity != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// ...</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">MyHandler</span> <span class="hljs-variable">mHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyHandler</span>(<span class="hljs-built_in">this</span>);<br>&#125;   <br></code></pre></td></tr></table></figure><ol start="2"><li>静态Runnable，避免对外部类的引用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br><br>    <span class="hljs-comment">// 匿名类用static修饰后，不会再持有外部类的引用</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">sRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// TODO</span><br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState); <br>        mHandler.postDelayed(sRunnable, <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// Go back to the previous Activity.</span><br>        finish();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态内部类和非静态内部类的区别很微小，但是开发人员必须了解。</p><p>那么底线是什么？</p><p>当内部类可以独立于Activity的生命周期而存在的时候，应该避免使用非静态内部类，应该用静态内部类并且使用WeakReference保持对Activity的引用。</p><p><strong>深入理解</strong></p><p>像下面这样使用handler的时候，其实是将handler定义为了匿名内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br>    <span class="hljs-keyword">private</span> Handler mLeakyHandler=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleMessage</span><span class="hljs-params">(Message msg)</span> &#123; <br>            <span class="hljs-comment">// ...</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而<strong>匿名内部类会默认持有外部类（MainActivity）的引用</strong>。</p><p>学过handler的都知道，handler发送消息后，消息会进行入队操作，在enqueueMessage方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">msg.targer = <span class="hljs-built_in">this</span>;<br></code></pre></td></tr></table></figure><p>this指的就是handler，所以handler被message持有了，而message放入消息队列后，message又被MessageQueue持有了，而MessageQueue是在创建Looper的时候生成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">Looper</span><span class="hljs-params">(<span class="hljs-type">boolean</span> quitAllowed)</span> &#123;<br>    mQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(quitAllowed);<br>&#125;<br></code></pre></td></tr></table></figure><p>所以MessageQueue又被looper所持有。如果这个handler是主线程的handler，那么此时的looper就是指的主线程的Looper，它的声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Looper sMainLooper;<br></code></pre></td></tr></table></figure><p>可以看到主线程的looper是static静态变量，而static静态变量在垃圾回收的时候是会被当做GC Root的，静态变量的生命周期与APP的生命周期、与虚拟机的生命周期是一样的，所以正是因为这个持有链的存在，导致了内存泄露。</p><p>引用链大致如下：</p><p><code>(static)Looper --&gt;|持有| MessageQueue --&gt;|持有| Message --&gt;|持有| Handler --&gt;|持有| MainActivity</code></p><p>所以解决 handler 内存泄露的办法就是要破坏这个持有链，比如只要 handler 不被 activity 持有就可以，所以可以把 handler 定义为static，因为 static 不会持有外部类，这样 handler 就不会持有 activity 了。</p><p><strong>怎样判断一个内部类有没有被持有外部类？</strong></p><p>比如上面的handler定义，没有加static的时候，在handleMessage方法里面可以正常使用MainActivity.this，这说明它持有了外部类。而一旦Handler加上static关键字，在handleMessage方法内部就不能再使用MainActivity.this，说明它没有持有外部类。</p><p>（为什么static变量，不会造成内存泄露？static 不会去持有外部类）</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Handler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 序列化的基本概念</title>
    <link href="/posts/376f5d8c1bd7/"/>
    <url>/posts/376f5d8c1bd7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  答案参考自：</p><ul><li><a href="https://www.cnblogs.com/douzi520/p/9497889.html">Java中序列化的好处及意义 - 久孤丶 - 博客园 (cnblogs.com)</a></li><li><a href="https://www.jianshu.com/p/2ed41bb7aa3a">Serializable和Parcelable区别 - 简书 (jianshu.com)</a></li></ul></blockquote><h1 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h1><p><strong>序列化：</strong> 把对象转化为可传输的字节序列过程称为序列化。</p><p><strong>反序列化：</strong> 把字节序列还原为对象的过程称为反序列化。</p><h1 id="为什么需要使用序列化和反序列化？"><a href="#为什么需要使用序列化和反序列化？" class="headerlink" title="为什么需要使用序列化和反序列化？"></a>为什么需要使用序列化和反序列化？</h1><p>目的是为了对象可以<strong>跨平台存储，和进行网络传输</strong>。</p><h1 id="序列化的有哪些好处"><a href="#序列化的有哪些好处" class="headerlink" title="序列化的有哪些好处"></a>序列化的有哪些好处</h1><p>对对象进行序列化操作，可以极大程度的方便传输。</p><h1 id="什么情况下需要序列化"><a href="#什么情况下需要序列化" class="headerlink" title="什么情况下需要序列化"></a>什么情况下需要序列化</h1><ol><li>当你想把的内存中的对象保存到一个文件中或者数据库中时候。</li><li>当你想用序列化在网络上传送对象的时候。</li></ol><h1 id="什么是serialVersionUID"><a href="#什么是serialVersionUID" class="headerlink" title="什么是serialVersionUID"></a>什么是<code>serialVersionUID</code></h1><p><code>serialVersionUID</code>是用来辅助序列化和反序列化的过程。原则上序列化后的数据中的<code>serialVersionUID</code>只有和当前类的<code>serialVersionUID</code>一致才能成功的反序列化。</p><h1 id="为什么还要显示指定serialVersionUID的值"><a href="#为什么还要显示指定serialVersionUID的值" class="headerlink" title="为什么还要显示指定serialVersionUID的值?"></a>为什么还要显示指定<code>serialVersionUID</code>的值?</h1><p><code>serialVersionUID</code>的详细工作机制是这样的：</p><p>序列化的时候系统会把当前类的<code>serialVersionUID</code>写入序列化的文件中(也可能是其他中介)。当反序列化的时候系统会去检测文件中的<code>serialVersionUID</code>，看它是否和当前类的<code>serialVersionUID</code>一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则就说明当前类和序列化的类相比发生了某些变换，比如成员变量的数量、类型可能会发生变化，这时候就无法正常的反序列化。</p><p>以一般来说，我们应该手动去指定<code>serialVersionUID</code>的值，比如”1L”,也可以让IDE根据当前类的结构去生成对应的<code>hash</code>值，这样序列化和反序列化时两者的<code>serialVersionUID</code>是相同的，因此可以正常的进行反序列化。如果不不设置<code>serialVersionUID</code>，系统在序列化的时候默认会根据类的结构在生成对应的<code>serialVersionUID</code>，在反序列化的时候，如果当类有变化，比如增加或者减少字段，这时候当前的类的<code>serialVersionUID</code>和序列化的时候的<code>serialVersionUID</code>就不一样了，就会出现反序列化失败，如果没有捕获异常会导致<code>crash</code>。</p><p><strong>所以当我们手动指定了它之后，就可以很大程度上避免了反序列化过程的失败。</strong></p><p>比如当版本升级以后，我们可能删除了某个成员变量也可能增加一些新的成员变量，这个时候我们的反序列化过程仍然可以成功，程序仍然能够最大限度地恢复数据。相反 如果我们没有指定<code>serialVersionUID</code>的话，程序就会挂掉。</p><p>当然我们也要考虑到另外一种情况，如果类结构发生了非常规性的改变，比如修改了类名，修改了成员变量的类型，这个时候尽管<code>serialVersionUID</code>验证通过了，但是反序列化过程还是会失败，因为类的而结构有了重大改变，根本无法从老版本的数据还原出一个新的类结构对象。</p><p><strong>注意</strong></p><ol><li><p>静态成员变量属于类，不属于对象，所以不会参与序列化的过程</p></li><li><p>用transient关键字编辑的成员变量不参与序列化的过程。</p></li><li><p>可以通过重写<code>writeObject</code>和<code>readObject</code>两个方法来重写系统默认的序列化和反序列化的过程。不过并不推荐。</p></li></ol><h1 id="Serializable-和-Parcelable-的区别"><a href="#Serializable-和-Parcelable-的区别" class="headerlink" title="Serializable 和 Parcelable 的区别"></a><code>Serializable</code> 和 <code>Parcelable</code> 的区别</h1><p><strong>1、平台区别</strong></p><ul><li><code>Serializable</code>是属于 <code>Java</code> 自带的，表示一个对象可以转换成可存储或者可传输的状态，序列化后的对象可以在网络上进行传输，也可以存储到本地。</li><li><code>Parcelable</code> 是属于 <code>Android</code> 专用。不过不同于<code>Serializable</code>，<code>Parcelable</code>实现的原理是将一个完整的对象进行分解。而分解后的每一部分都是 Intent 所支持的数据类型。</li></ul><p><strong>2、编写上的区别</strong></p><ul><li><code>Serializable</code>代码量少，写起来方便</li><li><code>Parcelable</code>代码多一些，略复杂</li></ul><p><strong>3、选择的原则</strong></p><ul><li>如果是仅仅在内存中使用，比如<code>activity</code>、<code>service</code>之间进行对象的传递，强烈推荐使用<code>Parcelable</code>，因为<code>Parcelable</code>比<code>Serializable</code>性能高很多。因为<code>Serializable</code>在序列化的时候会产生大量的临时变量， 从而引起频繁的<code>GC</code>。</li><li>如果是持久化操作，推荐<code>Serializable</code>，虽然<code>Serializable</code>效率比较低，但是还是要选择它，因为在外界有变化的情况下，<code>Parcelable</code>不能很好的保存数据的持续性。</li></ul><p><strong>4、本质的区别</strong></p><ul><li><code>Serializable</code>的本质是使用了反射，序列化的过程比较慢，这种机制在序列化的时候会创建很多临时的对象，比引起频繁的GC、</li><li><code>Parcelable</code>方式的本质是将一个完整的对象进行分解，而分解后的每一部分都是<code>Intent</code>所支持的类型，这样就实现了传递对象的功能了。</li></ul><h1 id="Java-transient-解析"><a href="#Java-transient-解析" class="headerlink" title="Java transient 解析"></a>Java <code>transient</code> 解析</h1><ol><li><code>transient</code> 关键字<strong>只能修饰变量，而不能修饰方法和类</strong>。注意，本地变量是不能被 <code>transient</code> 关键字修饰的。变量如果是用户自定义的类变量，则该类是要实现 <code>Serializable</code> 接口。</li><li>一旦变量被 <code>transient</code> 修饰，变量将不是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li><li>静态变量不管是否被 <code>transient</code> 修饰，都无法被序列化。</li></ol><p><strong>注意： 被 <code>transient</code> 修饰的变量也是可以被序列化的。</strong></p><p>Java 中，对象的序列化可以通过实现两个接口实现：</p><ul><li>若实现的是 <code>Serializable</code> 接口，则所有的序列化都将会自动进行，被 <code>transient</code> 修饰的变量将不会被序列化。</li><li>若实现的是 <code>Externalizable</code> 接口，则任何东西都需要自己在 <code>writeExternal</code> 方法中自己手动指定需要序列化的变量。任何变量都可以序列化，与变量是否被 <code>transient</code> 修饰无关。</li></ul><h1 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h1><ol><li>当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口； </li><li>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化； </li><li>并非所有的对象都可以序列化，,至于为什么不可以，有很多原因了。比如： <ol><li>安全方面的原因，比如一个对象拥有<code>private</code>，<code>public</code>等<code>field</code>，对于一个要传输的对象，比如写到文件，或者进行<code>RMI</code>传输 等等，在序列化进行传输的过程中，这个对象的<code>private</code>等域是不受保护的。 </li><li>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现。</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>面试整理-2022</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Serializable</tag>
      
      <tag>Parcelable</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fragment 简单了解</title>
    <link href="/posts/219a53ef52d7/"/>
    <url>/posts/219a53ef52d7/</url>
    
    <content type="html"><![CDATA[<h1 id="Fragment的生命周期"><a href="#Fragment的生命周期" class="headerlink" title="Fragment的生命周期"></a><code>Fragment</code>的生命周期</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/70d7bfae18f3">Fragment 生命周期和使用 - 简书 (jianshu.com)</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/1688279-0424d62f50035b43.png" alt="img"></p><p>可以看到 Fragment 的生命周期和 Activity 很相似，只是多了一下几个方法：</p><ol><li><p><strong>onAttach()</strong> </p><p>在Fragment 和 Activity 建立关联时调用（Activity 传递到此方法内）。</p></li><li><p><strong>onCreateView()</strong> </p><p>当Fragment 创建视图时调用。</p></li><li><p><strong>onActivityCreated()</strong> </p><p>在相关联的 Activity 的 onCreate() 方法已返回时调用。</p></li><li><p><strong>onDestroyView()</strong> </p><p>当Fragment中的视图被移除时调用。</p></li><li><p><strong>onDetach()</strong> </p><p>当Fragment 和 Activity 取消关联时调用。</p></li></ol><p>几种操作情况下Fragment 的生命周期变化</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/1688279-e34d09c9351c7084.png" alt="img" style="zoom:80%;" /><h1 id="结合Activity的生命周期"><a href="#结合Activity的生命周期" class="headerlink" title="结合Activity的生命周期"></a>结合<code>Activity</code>的生命周期</h1><p>管理 Fragment 生命周期和 Activity 生命周期很相似，同时 Activity 的生命周期对 Fragment 的生命周期也有一定的影响，如下图所示。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/1688279-e513845a80659860.png" alt="img"></p><p>用下图（<a href="https://www.jianshu.com/p/184f0c8857d6">来源</a>）来表示 Activity 和 Fragment 的生命周期变化的先后过程是:</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/1688279-020ad51ed5443cce.png" alt="img" style="zoom:80%;" /><p>Fragment 生命周期与 Activity 生命周期的一个关键区别就在于，Fragment 的生命周期方法是由托管Activity而不是操作系统调用的。Activity 中生命周期方法都是 protected，而 Fragment 都是 public，也能印证了这一点，因为 Activity 需要调用 Fragment 那些方法并管理它。</p><h1 id="Activity和Fragment的通信方式"><a href="#Activity和Fragment的通信方式" class="headerlink" title="Activity和Fragment的通信方式"></a><code>Activity</code>和<code>Fragment</code>的通信方式</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://developer.aliyun.com/article/637559">Fragment与Activity之间的通信-阿里云开发者社区 (aliyun.com)</a></li></ul></blockquote><p><strong>将Fragment添加到Activity之后，Fragment必须与Activity交互信息，这就需要Fragment能获取它所在的Activity，Activity也能获取它所包含的任意的Fragment。</strong></p><ul><li><p><strong><font size="4">Fragment获取它所在的Activtiy</font></strong></p><p>调用Fragment的getActivity()方法即可返回它所在的Activity。</p></li><li><p><strong><font size="4">Activity获取它包含的Fragment</font></strong></p><p>调用Activity关联的FragmentManager的findFragmentById(int id)或findFragmentByTag(String tag)方法即可获取指定的Fragment。</p></li></ul><p><strong>除此之外，Fragment与Activity可能还需要相互传递数据，可按如下方式进行。</strong></p><ul><li><p><strong><font size="4">Activity向Fragment传递数据</font></strong></p><p>在Activity中创建Bundle数据包，并调用Fragment的<strong>setArguments</strong>(Bundle bundle)方法即可将Bundle数据包传给Fragment。</p></li><li><p><strong><font size="4">Fragment向Activity传递数据或Activity需要在Fragment运行中进行实时通信</font></strong></p><p>在Fragment中定义一个<strong>内部回调接口</strong>，再让包含该Fragment的Activity实现该回调接口，这样Fragment即可调用该回调方法将数据传给Activity。</p></li></ul><p><strong>使用 FragmentManager 还可以执行的操作包括：</strong></p><ul><li>通过 findFragmentById 或 findFragmentByTag 获取 activity 中存在的 fragment 的实例</li><li>通过 popBackStack （<em>模拟用户点击返回按钮操作</em>）将 fragment 从返回栈中弹出</li><li>通过 addOnBackStackChangedListener() 注册一个监听返回栈改变的监听器</li><li>像上边生成 fragmentTransaction 的方法，可以使用 fragmentManager 生成一个 fragmentTransaction 来执行某些事务，比如添加、替换、移除、addToBackStack()等。</li></ul><h1 id="Fragment之间如何进行通信"><a href="#Fragment之间如何进行通信" class="headerlink" title="Fragment之间如何进行通信"></a><code>Fragment</code>之间如何进行通信</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh-cn#sharing">ViewModel 概览  | Android 开发者  | Android Developers (google.cn)</a></li></ul></blockquote><p>Activity 中的两个或更多 Fragment 需要相互通信是一种很常见的现象。想象一下拆分视图 (<code>list-detail</code>) Fragment 的常见情况，假设您有一个 Fragment，在该 Fragment 中，用户从列表中选择一项，还有另一个 Fragment，用于显示选定项的内容。这种情况不太容易处理，因为这两个 Fragment 都需要定义某种接口描述，并且所有者 Activity 必须将两者绑定在一起。此外，这两个 Fragment 都必须处理另一个 Fragment 尚未创建或不可见的情况。</p><p>可以使用 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel?hl=zh-cn"><code>ViewModel</code></a> 对象解决这一常见的难点。这两个 fragment 可以使用其 activity 范围共享 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel?hl=zh-cn"><code>ViewModel</code></a> 来处理此类通信，如以下示例代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedViewModel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ViewModel</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MutableLiveData&lt;Item&gt; selected = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutableLiveData</span>&lt;Item&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">select</span><span class="hljs-params">(Item item)</span> &#123;<br>        selected.setValue(item);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> LiveData&lt;Item&gt; <span class="hljs-title function_">getSelected</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> selected;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fragment</span> &#123;<br>    <span class="hljs-keyword">private</span> SharedViewModel model;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onViewCreated</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View view, Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onViewCreated(view, savedInstanceState);<br>        model = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewModelProvider</span>(requireActivity()).get(SharedViewModel.class);<br>        itemSelector.setOnClickListener(item -&gt; &#123;<br>            model.select(item);<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DetailFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fragment</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onViewCreated</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> View view, Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onViewCreated(view, savedInstanceState);<br>        <span class="hljs-type">SharedViewModel</span> <span class="hljs-variable">model</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewModelProvider</span>(requireActivity()).get(SharedViewModel.class);<br>        model.getSelected().observe(getViewLifecycleOwner(), item -&gt; &#123;<br>           <span class="hljs-comment">// Update the UI.</span><br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请注意，这两个 Fragment 都会检索包含它们的 Activity。这样，当这两个 Fragment 各自获取 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModelProvider?hl=zh-cn"><code>ViewModelProvider</code></a> 时，它们会收到相同的 <code>SharedViewModel</code> 实例（其范围限定为该 Activity）。</p><p>此方法具有以下优势：</p><ul><li>Activity 不需要执行任何操作，也不需要对此通信有任何了解。</li><li>除了 <code>SharedViewModel</code> 约定之外，Fragment 不需要相互了解。如果其中一个 Fragment 消失，另一个 Fragment 将继续照常工作。</li><li>每个 Fragment 都有自己的生命周期，而不受另一个 Fragment 的生命周期的影响。如果一个 Fragment 替换另一个 Fragment，界面将继续工作而没有任何问题。</li></ul><h1 id="为什么使用Fragment-setArguments-Bundle-传递参数"><a href="#为什么使用Fragment-setArguments-Bundle-传递参数" class="headerlink" title="为什么使用Fragment.setArguments(Bundle)传递参数"></a>为什么使用<code>Fragment.setArguments(Bundle)</code>传递参数</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/tu_bingbing/article/details/24143249">Android解惑 - 为什么要用Fragment.setArguments(Bundle bundle)来传递参数_pobi的博客-CSDN博客_fragment setarguments</a></li><li><a href="https://www.jianshu.com/p/c06efe090589">为什么要通过Fragment.setArguments(Bundle)传递参数 - 简书 (jianshu.com)</a></li></ul></blockquote><p>当我们实例化自定义Fragment时，为什么官方推荐Fragment.setArguments(Bundle bundle)这种方式来传递参数，而不推荐通过构造方法直接来传递参数呢？ </p><p><strong>方式一：通过构造方法传递参数</strong></p><p>在创建Fragment的时候，使用 MyFragment fragment &#x3D; new MyFragment(parameter) 来传递参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fragment</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyFragment</span><span class="hljs-params">(Parameter p)</span>&#123;<br>        <span class="hljs-comment">//将参数保存起来</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方式二：通过Fragment.setArguments(Bundle)传递参数</strong></p><p>在创建Fragment的时候，使用MyFragment fragment &#x3D; MyFragment.newInstance(paramter) 来传递参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fragment</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyFragment <span class="hljs-title function_">newInstance</span><span class="hljs-params">(Parameter p)</span> &#123;<br>        <span class="hljs-type">MyFragment</span> <span class="hljs-variable">myFragment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFragment</span>();<br>        <span class="hljs-type">Bundle</span> <span class="hljs-variable">args</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();<br>        args.putInt(<span class="hljs-string">&quot;someParameter&quot;</span>, p);<br>        myFragment.setArguments(args);<br>        <span class="hljs-keyword">return</span> myFragment;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结论</strong></p><p>我们可以知道Activity重新创建时，会重新构建它所管理的Fragment，原先的Fragment的字段值将会全部丢失，但是通过 Fragment.setArguments(Bundle bundle)方法设置的bundle会保留下来。所以尽量使用Fragment.setArguments(Bundle bundle)方式来传递参数。</p><h1 id="Fragment嵌套问题"><a href="#Fragment嵌套问题" class="headerlink" title="Fragment嵌套问题"></a><code>Fragment</code>嵌套问题</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/yzwfeng/article/details/123535473">Android开发-Fragment嵌套Fragment的使用及常见错误_有点料的博客-CSDN博客_fragment 嵌套</a></li></ul></blockquote><p>嵌套Fragments (Nested Fragments), 是在Fragment内部又添加Fragment。</p><p><strong>使用时, 主要要依靠宿主Fragment的 getChildFragmentManager() 来获取FragmentManger。</strong> 虽然看起来和在activity中添加fragment差不多, 但因为fragment生命周期及管理恢复模式不同, 其中有一些需要特别注意的地方。</p><p>本文内容还包括了从Fragment迁移到v4.Fragment代码中需要改动的一些地方.</p><p><strong><font size="4">嵌套Fragments</font></strong> </p><p>嵌套Fragments 是Android 4.2 API 17 引入的.</p><p>目的: 进一步增强动态复用。</p><p><strong><font size="4">嵌套Fragment的动态添加</font></strong> </p><p>在宿主fragment里调用getChildFragmentManager()</p><p>即可用它来向这个fragment内部添加fragments。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Fragment</span> <span class="hljs-variable">videoFragment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VideoPlayerFragment</span>();<br><span class="hljs-type">FragmentTransaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> getChildFragmentManager().beginTransaction();<br>transaction.add(R.id.video_fragment, videoFragment).commit();<br></code></pre></td></tr></table></figure><p><strong>同样, 对于内部的fragment来说, getParentFragment() 方法可以获取到fragment的宿主fragment.</strong></p><p><strong><font size="4">getChildFragmentManager() 和 getFragmentManager()</font></strong> </p><p>getChildFragmentManager()是fragment中的方法, 返回的是管理当前fragment内部子fragments的manager.</p><p><strong>getFragmentManager()在activity和fragment中都有。</strong></p><p>在activity中, 如果用的是v4 support库, 方法应该用getSupportFragmentManager(), 返回的是管理activity中fragments的manager.</p><p><strong>在fragment中, 调用getFragmentManager(), 返回的是把自己加进来的那个manager.</strong></p><p>也即, 如果fragment在activity中, fragment.getFragmentManager()得到的是activity中管理fragments的那个manager.<br>如果fragment是嵌套在另一个fragment中, fragment.getFragmentManager()得到的是它的parent的getChildFragmentManager()。</p><p><strong>总结就是: getFragmentManager()是本级别管理者, getChildFragmentManager()是下一级别管理者。这实际上是一个树形管理结构。</strong></p><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ol><li><code>FragmentPageAdapter</code>和<code>FragmentStatePageAdapter</code>区别及使用场景</li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>面试整理-2022</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fragment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快速理解 OkHttp</title>
    <link href="/posts/30e7e50495ee/"/>
    <url>/posts/30e7e50495ee/</url>
    
    <content type="html"><![CDATA[<h1 id="使用-OkHttp-的基本流程"><a href="#使用-OkHttp-的基本流程" class="headerlink" title="使用 OkHttp 的基本流程"></a>使用 OkHttp 的基本流程</h1><ol><li>创建 OkHttpClient 对象</li><li>创建 Request 对象</li><li>创建 Call 对象</li><li>同步请求调用 call.execute()；异步请求调用 call.enqueue()</li></ol><h2 id="同步执行"><a href="#同步执行" class="headerlink" title="同步执行"></a>同步执行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建OkHttpClient对象</span><br><span class="hljs-type">OkHttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>();<br><br>String <span class="hljs-title function_">run</span><span class="hljs-params">(String url)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>   <span class="hljs-comment">//创建Request请求对象</span><br>  <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Builder()<br>      .url(url)<br>      .build();<br><br>   <span class="hljs-comment">//创建Call对象，并执行同步获取网络数据</span><br>  <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> client.newCall(request).execute();<br>  <span class="hljs-keyword">return</span> response.body().string();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="异步执行"><a href="#异步执行" class="headerlink" title="异步执行"></a>异步执行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">runAsync</span><span class="hljs-params">(String url, Callback callback)</span> &#123;<br>    <span class="hljs-type">OkHttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>.Builder().addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Interceptor</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>            <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> chain.request();<br>            Request.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> request.newBuilder().addHeader(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>);<br>            <span class="hljs-keyword">return</span> chain.proceed(builder.build());<br>        &#125;<br>    &#125;).build();<br>    <span class="hljs-comment">//创建Request请求对象</span><br>    <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Request</span>.Builder()<br>        .url(url)<br>        .build();<br><br>    client.newCall(request).enqueue(callback);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="创建-OkHttpClient-对象"><a href="#创建-OkHttpClient-对象" class="headerlink" title="创建 OkHttpClient 对象"></a>创建 OkHttpClient 对象</h1><p>创建 OkHttpClient 一般有两种方法，一种是直接 new OkHttpClient(),另外一种是通过 OkHttpClient.Builder()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">OkhttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span><br>    .Builder()<br>    .connectTimeout(<span class="hljs-number">5</span>, TimeUnit.SECONDS)<br>    .writeTimeout(<span class="hljs-number">10</span>,TimeUnit.SECONDS)<br>    .readTimeout(<span class="hljs-number">10</span>, TimeUnit.SECONDS)<br>    .build();<br></code></pre></td></tr></table></figure><p>第二种创建方式主要是通过建造者模式，来配置一些参数，比如连接超时时间，读写超时时间，超时重试次数等。这样有一个好处，可以对外屏蔽掉构建 client 的细节。</p><p>OkhttpClient 对象主要处理一些基础的配置，比如连接超时，读写超时，添加拦截器。</p><hr><h1 id="创建-Request-对象"><a href="#创建-Request-对象" class="headerlink" title="创建 Request 对象"></a>创建 Request 对象</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Request</span> &#123;<br>    <span class="hljs-keyword">final</span> HttpUrl url;<br>    <span class="hljs-keyword">final</span> String method;<br>    <span class="hljs-keyword">final</span> Headers headers;<br>    <span class="hljs-keyword">final</span> RequestBody body;<br>    <span class="hljs-keyword">final</span> Object tag;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> CacheControl cacheControl; <span class="hljs-comment">// Lazily initialized.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Request 对象主要封装的是一些网络请求的信息，比如请求 url，请求方法，请求头，请求 body 等，也比较简单，这里不再展开阐述。</p><hr><h1 id="创建-Call-对象"><a href="#创建-Call-对象" class="headerlink" title="创建 Call 对象"></a>创建 Call 对象</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> Call <span class="hljs-title function_">newCall</span><span class="hljs-params">(Request request)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealCall</span>(<span class="hljs-built_in">this</span>, request, <span class="hljs-literal">false</span> <span class="hljs-comment">/* for web socket */</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 call 对象实际是 RealCall 的实例化对象。</p><hr><h1 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h1><h2 id="RealCall-execute"><a href="#RealCall-execute" class="headerlink" title="RealCall#execute()"></a>RealCall#execute()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Already Executed&quot;</span>);<br>        executed = <span class="hljs-literal">true</span>;<br>    &#125;<br>    captureCallStackTrace();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 执行 client.dispatcher() 的 executed 方法</span><br>        client.dispatcher().executed(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-type">Response</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> getResponseWithInterceptorChain();<br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Canceled&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 最后再执行 dispatcher 的 finish 方法</span><br>        client.dispatcher().finished(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 execute 方法中：</p><ol><li>首先会调用 client.dispatcher().executed(this) 加入到 runningAsyncCalls 队列当中</li><li>接着执行 getResponseWithInterceptorChain() 获取请求结果</li><li>最终再执行 client.dispatcher().finished(this) 将 realCall 从 runningAsyncCalls 队列中移除</li></ol><hr><h1 id="拦截器-Interceptor"><a href="#拦截器-Interceptor" class="headerlink" title="拦截器 Interceptor"></a>拦截器 Interceptor</h1><h2 id="getResponseWithInterceptorChain"><a href="#getResponseWithInterceptorChain" class="headerlink" title="getResponseWithInterceptorChain()"></a>getResponseWithInterceptorChain()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Response <span class="hljs-title function_">getResponseWithInterceptorChain</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// Build a full stack of interceptors.</span><br>    List&lt;Interceptor&gt; interceptors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    interceptors.addAll(client.interceptors());<br>    interceptors.add(retryAndFollowUpInterceptor);<br>    interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BridgeInterceptor</span>(client.cookieJar()));<br>    interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheInterceptor</span>(client.internalCache()));<br>    interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectInterceptor</span>(client));<br>    <span class="hljs-keyword">if</span> (!forWebSocket) &#123;<br>        interceptors.addAll(client.networkInterceptors());<br>    &#125;<br>    interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CallServerInterceptor</span>(forWebSocket));<br>    Interceptor.<span class="hljs-type">Chain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealInterceptorChain</span>(<br>        interceptors, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, originalRequest);<br>    <span class="hljs-keyword">return</span> chain.proceed(originalRequest);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，首先，他会将客户端的 interceptors 添加到 List 当中，接着，再添加 okhttp 里面的 interceptor，然后构建了一个 RealInterceptorChain 对象，并将我们的 <code>List&lt;Interceptor&gt;</code> 作为成员变量，最后调用 RealInterceptorChain 的 proceed 方法。</p><p>其中，client.interceptors() 为我们自己添加的请求拦截器，通常是做一些添加统一的token之类操作。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/4122684-67fcdd5d7e5f984e.jpg" alt="其余较重要的拦截器"></p><p><strong>RetryAndFollowUpInterceptor 拦截器</strong></p><ul><li>RetryAndFollowUpInterceptor 此拦截器顾名思义就是主要负责失败重连工作，但是并不是所有的网络请求都会进行失败重连的,在此拦截器内部会进行网络请求的异常检测和响应码的判断，如果都在限制范围内，那么就可以进行失败重连。</li></ul><p><strong>CacheInterceptor 拦截器</strong></p><ul><li><p>如果当前未使用网络，并且缓存不可以使用，通过构建者模式创建一个 Response 响应，抛出504错误。</p></li><li><p>如果有缓存但是不能使用网络，直接返回缓存结果。这是在进行网络请求之前所做的事情，当网络请求完成，得到下一个拦截器返回的 response 之后，判断 response 的响应码是否是 HTTP_NOT_MODIFIED &#x3D; 304（未改变），是则从缓存中读取数据。</p></li></ul><h2 id="proceed"><a href="#proceed" class="headerlink" title="proceed()"></a>proceed()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">proceed</span><span class="hljs-params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="hljs-params">                        Connection connection)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>    <span class="hljs-comment">// 省略无关代码</span><br><br><br>    <span class="hljs-comment">//  生成 list 当中下一个 interceptot 的 chain 对象</span><br>    <span class="hljs-type">RealInterceptorChain</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealInterceptorChain</span>(<br>        interceptors, streamAllocation, httpCodec, connection, index + <span class="hljs-number">1</span>, request);<br>    <span class="hljs-comment">// 当前的 interceptor</span><br>    <span class="hljs-type">Interceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> interceptors.get(index);<br>    <span class="hljs-comment">// 当前的 intercept 处理下一个 intercept 包装的 chain 对象</span><br>    <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> interceptor.intercept(next);<br><br>    <span class="hljs-comment">// ----</span><br><br>    <span class="hljs-keyword">return</span> response;<br>&#125;<br></code></pre></td></tr></table></figure><p>proceed 方法也很简单，proceed方法每次从拦截器列表中取出拦截器，并调用 interceptor.intercept(next)。</p><p>熟悉 Okhttp 的应该都知道，我们在 addInterceptor 创建 Interceptor 实例，最终都会调用 chain.proceed(Request request),从而形成一种链式调用。这种便是责任链设计模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">OkHttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>.Builder().addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Interceptor</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> chain.request();<br>        Request.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> request.newBuilder().addHeader(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>);<br>        <span class="hljs-keyword">return</span> chain.proceed(builder.build());<br>    &#125;<br>&#125;).build();<br></code></pre></td></tr></table></figure><p>而 OkHttp 是怎样结束循环调用的，这是因为最后一个拦截器 CallServerInterceptor 并没有调用 chain.proceed(request)，所以能够结束循环调用。</p><hr><h1 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h1><h2 id="dispatcher-分发器"><a href="#dispatcher-分发器" class="headerlink" title="dispatcher 分发器"></a>dispatcher 分发器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dispatcher</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxRequests</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxRequestsPerHost</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">private</span> Runnable idleCallback;<br><br>    <span class="hljs-comment">/** Executes calls. Created lazily. */</span><br>    <span class="hljs-keyword">private</span> ExecutorService executorService;<br><br>    <span class="hljs-comment">// 异步的请求等待队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 异步的正在请求的队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 同步的正在请求的队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>分发器 Dispatcher，里面有三个请求队列，一个是正在请求的队列，一个是等待队列，另外一个是同步的正在请求的队列，当我们执行 enqueue 方法的时候，他会判断正在请求队列数量是否超过允许的最大并发数量（默认是 64）（线程池的原理），如果超过了，会添加到等待队列里面。</p><p><strong>maxRequests</strong>：可以同时运行的最大请求数，也就是说一个 okhttp 的 client 可以同时发 64 个请求。</p><p><strong>maxRequestsPerHost</strong>：对每个域名我们最多同时只能有5个请求。</p><p><strong>这个参数的实际意义是针对每个域名，okhttp 最多可以发起5条 TCP 连接。</strong></p><p>execute 方法是同步执行的，每次执行会添加到同步请求队列当中，执行完毕之后会移除。</p><h2 id="RealCall-enqueue-Callback-responseCallback"><a href="#RealCall-enqueue-Callback-responseCallback" class="headerlink" title="RealCall#enqueue(Callback responseCallback)"></a>RealCall#enqueue(Callback responseCallback)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(Callback responseCallback)</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>        <span class="hljs-keyword">if</span> (executed) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Already Executed&quot;</span>);<br>        executed = <span class="hljs-literal">true</span>;<br>    &#125;<br>    captureCallStackTrace();<br>    client.dispatcher().enqueue(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AsyncCall</span>(responseCallback));<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，AsyncCall 是 Runnable 的子类，实现了 run 方法。</p><h2 id="dispatcher-enqueue-AsyncCall-call"><a href="#dispatcher-enqueue-AsyncCall-call" class="headerlink" title="dispatcher().enqueue(AsyncCall call)"></a>dispatcher().enqueue(AsyncCall call)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(AsyncCall call)</span> &#123;<br>    <span class="hljs-keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;<br>        runningAsyncCalls.add(call);<br>        executorService().execute(call);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        readyAsyncCalls.add(call);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当执行 executorService().execute(call) 的时候，会调用 run 方法， run 方法又会调用到 execute 方法进行网络请求，请求完成之后，会调用 client.dispatcher().finished(this) 从队列里面移除。</p><hr><p>到此， Okhttp 的主要流程已经讲完。</p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol><li><p>有一个分发器 Dispatcher，里面有三个请求队列，一个是正在请求的队列，一个是等待队列，另外一个是同步的正在请求的队列，当我们执行 enqueue 方法的时候，他会判断正在请求队列数量是否超过允许的最大并发数量（默认是 64）（线程池的原理），如果超过了，会添加到等待队列里面。<br> excute 方法是同步执行的，每次执行会添加到同步请求队列当中，执行完毕之后会移除。</p></li><li><p>设计的核心思想责任链模式，当我们需要拦截的时候，可以实现 Interceptor 接口，会按照添加的顺序执行 Chain.proceed 方法。</p></li><li><p>职责分明，OkhttpClient 对象主要处理一些基础的配置，比如连接超时，读写超时，添加拦截器。Request 主要配置请求方法，请求头等。</p></li></ol><hr><p><strong>参考资料：</strong></p><ul><li><a href="https://blog.csdn.net/gdutxiaoxu/article/details/100545600">一步步带你读懂 Okhttp 源码</a></li><li><a href="https://www.jianshu.com/p/8522bc275390">okhttp拦截器Interceptor详解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OkHttp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的 OkHttp</title>
    <link href="/posts/7744c4ecc6a9/"/>
    <url>/posts/7744c4ecc6a9/</url>
    
    <content type="html"><![CDATA[<h1 id="OkHttp源码流程"><a href="#OkHttp源码流程" class="headerlink" title="OkHttp源码流程"></a><code>OkHttp</code>源码流程</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://luoyuy.top/posts/4abbeeb2117b/">快速理解 OkHttp - 洛语 の Blog (luoyuy.top)</a></li></ul></blockquote><p><strong><font size="5">基本流程</font></strong></p><ol><li>创建 OkHttpClient 对象</li><li>创建 Request 对象</li><li>创建 Call 对象</li><li>同步请求调用 call.execute()；异步请求调用 call.enqueue()。</li></ol><h1 id="OkHttp线程池"><a href="#OkHttp线程池" class="headerlink" title="OkHttp线程池"></a><code>OkHttp</code>线程池</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/OneDeveloper/article/details/88381817">okhttp3 读书笔记——默认的线程池，addNetworkInterceptor() 与 addInterceptor() 的区别，复用连接池_OneDeveloper的博客-CSDN博客_okhttp 默认线程数</a></li></ul></blockquote><p><code>OkHttp</code> 的异步请求是基于其内部的默认的线程池实现的。</p><p>而默认的线程池是在 <code>Dispatcher</code> 被实例化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> ExecutorService <span class="hljs-title function_">executorService</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (executorService == <span class="hljs-literal">null</span>) &#123;<br>        executorService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">0</span>, <br>            Integer.MAX_VALUE, <br>            <span class="hljs-number">60</span>, <br>            TimeUnit.SECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;(), <br>            Util.threadFactory(<span class="hljs-string">&quot;OkHttp Dispatcher&quot;</span>, <span class="hljs-literal">false</span>)<br>        );<br>    &#125;<br>    <span class="hljs-keyword">return</span> executorService;<br>&#125;<br></code></pre></td></tr></table></figure><p>该线程池的核心线程数为 0，线程池最有能容纳 <code>Integer.MAX_VALUE</code> 个线程，且线程的空闲存活时间为 60s（可以理解为 OkHttp 随时可以创建新的线程来满足需要。可以保证网络的 I&#x2F;O 任务有线程来处理，不被阻塞）。</p><p>重点是使用的阻塞队列为 SynchronousQueue，参考：<br>[<a href="https://luoming1224.github.io/2018/03/19/[java1.8%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0]SynchronousQueue%E8%AF%A6%E8%A7%A3/">java1.8源码笔记]SynchronousQueue详解 | LuoMing’s Blog (luoming1224.github.io)</a></p><h1 id="OkHttp拦截器"><a href="#OkHttp拦截器" class="headerlink" title="OkHttp拦截器"></a><code>OkHttp</code>拦截器</h1><p><strong><font size="4">getResponseWithInterceptorChain()</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">Response <span class="hljs-title function_">getResponseWithInterceptorChain</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// Build a full stack of interceptors.</span><br>    List&lt;Interceptor&gt; interceptors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    interceptors.addAll(client.interceptors());<br>    interceptors.add(retryAndFollowUpInterceptor);<br>    interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BridgeInterceptor</span>(client.cookieJar()));<br>    interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheInterceptor</span>(client.internalCache()));<br>    interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectInterceptor</span>(client));<br>    <span class="hljs-keyword">if</span> (!forWebSocket) &#123;<br>        interceptors.addAll(client.networkInterceptors());<br>    &#125;<br>    interceptors.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CallServerInterceptor</span>(forWebSocket));<br>    Interceptor.<span class="hljs-type">Chain</span> <span class="hljs-variable">chain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealInterceptorChain</span>(<br>        interceptors, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">0</span>, originalRequest);<br>    <span class="hljs-keyword">return</span> chain.proceed(originalRequest);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，首先，他会将客户端的 <code>interceptors</code> 添加到 <code>List</code> 当中，接着，再添加 okhttp 里面的 <code>interceptor</code>，然后构建了一个 <code>RealInterceptorChain</code> 对象，并将我们的 <code>List&lt;Interceptor&gt;</code> 作为成员变量，最后调用 <code>RealInterceptorChain</code> 的 <code>proceed</code> 方法。</p><p>其中，<code>client.interceptors()</code> 为我们自己添加的请求拦截器，通常是做一些添加统一的 token 之类操作。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/4122684-67fcdd5d7e5f984e.jpg" alt="其余较重要的拦截器"></p><p><strong>RetryAndFollowUpInterceptor 拦截器</strong></p><ul><li>RetryAndFollowUpInterceptor 此拦截器顾名思义就是主要负责失败重连工作，但是并不是所有的网络请求都会进行失败重连的,在此拦截器内部会进行网络请求的异常检测和响应码的判断,如果都在限制范围内,那么就可以进行失败重连。</li><li>一个循环来不停的获取response。每循环一次都会获取下一个request，如果没有，则返回response，退出循环。而获取下一个request的逻辑，是根据上一个response返回的状态码，分别作处理。</li></ul><p><strong>桥接拦截器</strong></p><ol><li>请求从应用层数据类型类型转化为网络调用层的数据类型。</li><li>将网络层返回的数据类型 转化为 应用层数据类型。</li></ol><p><strong>CacheInterceptor 拦截器</strong></p><ul><li>作用：将HTPTP和HTTPS的网络返回数据缓存到文件系统中，以便在服务端数据没发生变化的情况下复用，节省时间和带宽；</li></ul><p><strong>连接拦截器 和 最后的请求服务器的拦截器</strong></p><p>这两个连接器基本上完成了最后发起网络请求的工作。</p><h1 id="addInterceptor-和-addNetworkInterceptor区别"><a href="#addInterceptor-和-addNetworkInterceptor区别" class="headerlink" title="addInterceptor 和 addNetworkInterceptor区别"></a><code>addInterceptor</code> 和 <code>addNetworkInterceptor</code>区别</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/OneDeveloper/article/details/88381817">okhttp3 读书笔记——默认的线程池，addNetworkInterceptor() 与 addInterceptor() 的区别，复用连接池_OneDeveloper的博客-CSDN博客_okhttp 默认线程数</a></li></ul></blockquote><p>从上文构造拦截器链的过程，可以看到，通过 <code>addInterceptor()</code> 方法添加的拦截器是放在最前面的。</p><p>而通过 <code>addNetworkInterceptor()</code> 方法添加的网络拦截器，则是在非 WebSocket 请求时，添加在 <code>ConnectInterceptor</code> 和 <code>CallServerInterceptor</code> 之间的。</p><p><strong><font size="4">addInterceptor（应用拦截器）</font></strong></p><ol><li>不需要担心中间过程的响应,如重定向和重试.</li><li>总是只调用一次，即使 HTTP 响应是从缓存中获取.</li><li>观察应用程序的初衷. 不关心 OkHttp 注入的头信息如： <code>If-None-Match</code>.</li><li>允许短路而不调用 Chain#proceed，即中止调用.</li><li>允许重试,使 Chain#proceed 调用多次.</li></ol><p><strong><font size="4">addNetworkInterceptor（网络拦截器）</font></strong></p><ol><li>能够操作中间过程的响应,如重定向和重试.</li><li>当网络短路而返回缓存响应时不被调用.</li><li>只观察在网络上传输的数据.</li><li>携带请求来访问连接.</li></ol><h1 id="OkHttp责任链模式"><a href="#OkHttp责任链模式" class="headerlink" title="OkHttp责任链模式"></a><code>OkHttp</code>责任链模式</h1><p><strong><font size="4">proceed()</font></strong></p><blockquote><p>  <code>proceed</code> <code>v.</code>继续做（或从事、进行）；接着做；继而做；行进</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">proceed</span><span class="hljs-params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="hljs-params">                        Connection connection)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>    <span class="hljs-comment">// 省略无关代码</span><br><br>    <span class="hljs-comment">//  生成 list 当中下一个 interceptot 的 chain 对象</span><br>    <span class="hljs-type">RealInterceptorChain</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealInterceptorChain</span>(<br>        interceptors, streamAllocation, httpCodec, connection, index + <span class="hljs-number">1</span>, request);<br>    <span class="hljs-comment">// 当前的 interceptor</span><br>    <span class="hljs-type">Interceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> interceptors.get(index);<br>    <span class="hljs-comment">// 当前的 intercept 处理下一个 intercept 包装的 chain 对象</span><br>    <span class="hljs-type">Response</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> interceptor.intercept(next);<br><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">return</span> response;<br>&#125;<br></code></pre></td></tr></table></figure><p>proceed 方法也很简单，proceed方法每次从拦截器列表中取出拦截器，并调用 interceptor.intercept(next)。</p><p>熟悉 Okhttp 的应该都知道，我们在 addInterceptor 创建 Interceptor 实例，最终都会调用 chain.proceed(Request request)，从而形成一种链式调用。这种便是责任链设计模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">OkHttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OkHttpClient</span>.Builder().addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Interceptor</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">intercept</span><span class="hljs-params">(Chain chain)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Request</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> chain.request();<br>        Request.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> request.newBuilder().addHeader(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>);<br>        <span class="hljs-keyword">return</span> chain.proceed(builder.build());<br>    &#125;<br>&#125;).build();<br></code></pre></td></tr></table></figure><p>而 OkHttp 是怎样结束循环调用的，这是因为最后一个拦截器 CallServerInterceptor 并没有调用 chain.proceed(request)，所以能够结束循环调用。</p><h1 id="OkHttp缓存怎么处理"><a href="#OkHttp缓存怎么处理" class="headerlink" title="OkHttp缓存怎么处理"></a><code>OkHttp</code>缓存怎么处理</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/00d281c226f6">Okhttp解析（五）缓存的处理 - 简书 (jianshu.com)</a></li></ul></blockquote><h1 id="更多推荐文章"><a href="#更多推荐文章" class="headerlink" title="更多推荐文章"></a>更多推荐文章</h1><ul><li><a href="https://www.cnblogs.com/jimuzz/p/14040674.html">再也不用担心问RecycleView了——面试真题详解 - jimuzz - 博客园 (cnblogs.com)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>面试整理-2022</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OkHttp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin-扩展函数与扩展属性</title>
    <link href="/posts/edb87b835e81/"/>
    <url>/posts/edb87b835e81/</url>
    
    <content type="html"><![CDATA[<p><code>Kotlin</code> 的扩展（<code>Extension</code>），主要分为两种语法：第一个是扩展函数，第二个是扩展属性。从语法上看，扩展看起来就像是我们从类的外部为它扩展了新的成员。 </p><p>这在实际编程当中是非常有用的功能。我们可以来想象一个场景：我们想修改 <code>JDK</code> 当中的 <code>String</code>，想在它的基础上增加一个方法 <code>lastElement()</code> 来获取末尾元素，如果使用 <code>Java</code>，我们是无法通过常规手段实现的，因为我们没办法修改 <code>JDK</code> 的源代码。<strong>任何第三方提供的 <code>SDK</code>，我们都无权修改。</strong></p><p>不过，借助 <code>Kotlin</code> 的扩展函数，我们就完全可以在语义层面，来为第三方 <code>SDK</code> 的类扩展新的成员方法和成员属性。不管是为 <code>JDK</code> 的 <code>String</code> 增加新的成员方法，还是为 <code>Android SDK</code> 的 <code>View</code> 增加新成员属性，我们都可以实现。</p><hr><h1 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h1><p>扩展函数，就是从类的外部扩展出来的一个函数，这个函数看起来就像是类的成员函数一样。这里，我们就以 <code>JDK</code> 当中的 <code>String</code> 为例，来看看如何通过 <code>Kotlin</code> 的扩展特性，为它新增一个 <code>lastElement()</code> 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Ext.kt</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> ①     ②       ③            ④</span><br><span class="hljs-comment"> ↓     ↓       ↓            ↓      */</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">lastElement</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Char</span>? &#123;<br>    <span class="hljs-comment">//    ⑤</span><br>    <span class="hljs-comment">//    ↓</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[length - <span class="hljs-number">1</span>]<br>&#125;<br><br><span class="hljs-comment">// 使用扩展函数</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> msg = <span class="hljs-string">&quot;Hello Wolrd&quot;</span><br>    <br>    <span class="hljs-comment">// lastElement就像String的成员方法一样可以直接调用</span><br>    <span class="hljs-keyword">val</span> last = msg.lastElement() <span class="hljs-comment">// last = d</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们先是定义了一个 <code>String</code> 的扩展函数 <code>lastElement()</code> ，然后在 <code>main</code> 函数当中调用了这个函数。并且，这个扩展函数是直接定义在 <code>Kotlin</code> 文件里的，而不是定义在某个类当中的。这种扩展函数，我们称之为<strong>“顶层扩展”</strong>，这么叫它是因为它并没有嵌套在任何的类当中，它自身就在最外层。</p><p>现在，我们依次来看看上面的五处注释：</p><ol><li><p>注释①，<code>fun</code> 关键字</p><p>代表我们要定义一个函数。也就是说，不管是定义普通 <code>Kotlin</code> 函数，还是定义扩展函数，我们都需要 <code>fun</code> 关键字。</p></li><li><p>注释②，“<code>String.</code>”</p><p>代表我们的扩展函数是为 <code>String</code> 这个类定义的。在 <code>Kotlin</code> 当中，它有一个名字，叫做接收者（<code>Receiver</code>），也就是扩展函数的接收方。</p></li><li><p>注释③，<code>lastElement()</code></p><p>是我们定义的扩展函数的名称。</p></li><li><p>注释④，“<code>Char?</code>”</p><p>代表扩展函数的返回值是可能为空的 <code>Char</code> 类型。</p></li><li><p>注释⑤，“<code>this.</code>”</p><p>代表“具体的 <code>String</code> 对象”，当我们调用 <code>msg.lastElement()</code> 的时候，<code>this</code> 就代表了 <code>msg</code>。</p></li></ol><p>需要注意的是，<strong>在整个扩展函数的方法体当中，<code>this</code> 都是可以省略的</strong>。这一点，<code>Kotlin</code> 和 <code>Java</code> 是一样的，<code>this</code> 代表当前作用域，它可写可不写。即例如以下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">lastElement</span><span class="hljs-params">()</span></span> : <span class="hljs-built_in">Char</span>? = <span class="hljs-keyword">if</span> (isEmpty()) <span class="hljs-literal">null</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">get</span>(length - <span class="hljs-number">1</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> str = <span class="hljs-string">&quot;Hello World!&quot;</span><br>    println(str.lastElement())<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上，<code>Kotlin</code> 的扩展是允许我们为“<strong>可为空的类型</strong>”进行扩展的。比如说：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 不为空的接收者类型</span><br><span class="hljs-comment">//     ↓</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">lastElement</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Char</span>? &#123;&#125;<br><br><span class="hljs-comment">// 可为空的接收者类型</span><br><span class="hljs-comment">//     ↓</span><br><span class="hljs-function"><span class="hljs-keyword">fun</span> String?.<span class="hljs-title">lastElement</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Char</span>? &#123;&#125;<br></code></pre></td></tr></table></figure><p>接受者可空的扩展在遇到空对象调用时不会抛异常，并且允许可空对象调用。</p><hr><h1 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h1><p>在学习了 <code>Kotlin</code> 的扩展函数以后，扩展属性就很好理解了。</p><p>扩展函数，是在类的外部为它定义一个<strong>新的成员方法</strong>；而扩展属性，则是在类的外部为它定义一个<strong>新的成员属性</strong>。</p><p>那么，在研究了扩展的实现原理后，我们知道，我们从外部定义的成员方法和属性，都只是语法层面的，并没有实际修改那个类的源代码。</p><p>还是以 <code>lastElement</code> 为例，在之前的案例当中，我们是通过扩展函数来实现的，这次我们以扩展属性的方式来实现。扩展函数的定义对比普通函数，其实就只是多了一个“接收者类型”。类似的，扩展属性，也就是在普通属性定义的时候多加一个“接收者类型”即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 接收者类型</span><br><span class="hljs-comment">//     ↓</span><br><span class="hljs-keyword">val</span> String.lastElement: <span class="hljs-built_in">Char</span>?<br>    <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">if</span> (isEmpty()) &#123;<br>            <span class="hljs-literal">null</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">get</span>(length - <span class="hljs-number">1</span>)<br>        &#125;<br><br><span class="hljs-comment">/* 使用 this 关键字也可以写成：</span><br><span class="hljs-comment">val String.lastElement : Char?</span><br><span class="hljs-comment">    get() = if (isEmpty()) null else this[length - 1]</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> msg = <span class="hljs-string">&quot;Hello Wolrd&quot;</span><br>    <br>    <span class="hljs-comment">// lastElement就像String的成员属性一样可以直接调用</span><br>    <span class="hljs-keyword">val</span> last = msg.lastElement <span class="hljs-comment">// last = d</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这段的代码中，我们为 String 类型扩展了一个新的成员属性“<code>lastElement</code>”。然后在 <code>main</code> 函数当中，我们直接通过“<code>msg.lastElement</code>”方式使用了这个扩展属性，就好像它是一个成员一样。</p><hr><h1 id="扩展与其反编译代码"><a href="#扩展与其反编译代码" class="headerlink" title="扩展与其反编译代码"></a>扩展与其反编译代码</h1><p>为了看得更加清晰，我们用一张图来描述它们之间的关系。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/2a38487b61ec06e437c1425b2a69ffed.png"></p><p>上面的两个箭头，说明了扩展函数与扩展属性，它们最终会被 <code>Kotlin</code> 编译器转换成静态方法；下面两个箭头，说明了扩展函数和扩展属性的调用代码，最终会被 <code>Kotlin</code> 编译器转换成静态方法的调用。</p><p>所以也就是说，<code>Kotlin</code> 的扩展表面上看起来是为一个类扩展了新的成员，<strong>但是本质上，它还是静态方法</strong>。而且，不管是扩展函数还是扩展属性，它本质上都会变成一个静态的方法。</p><p><strong>那么，到底什么时候该用扩展函数，什么时候该用扩展属性呢？</strong></p><p>其实，我们只需要看扩展在语义上更适合作为函数还是属性就够了。比如这里的 <code>lastElement</code>，它更适合作为一个扩展属性。这样设计的话，在语义上，<code>lastElement</code> 就像是 <code>String</code> 类当中的属性一样，它代表了字符串里的最后一个字符。</p><hr><h1 id="扩展的优势与局限性"><a href="#扩展的优势与局限性" class="headerlink" title="扩展的优势与局限性"></a>扩展的优势与局限性</h1><h2 id="扩展的优势"><a href="#扩展的优势" class="headerlink" title="扩展的优势"></a>扩展的优势</h2><p>当我们想要从外部为一个类扩展一些方法和属性的时候，我们就可以通过扩展来实现了。<strong>在 <code>Kotlin</code> 当中，几乎所有的类都可以被扩展</strong>，包括普通类、单例类、密封类、枚举类、伴生对象，甚至还包括第三方提供的 <code>Java</code> 类。</p><p>唯有匿名内部类，由于它本身不存在名称，我们无法指定“接收者类型”，所以不能被扩展，当然了，它也没必要被扩展。</p><p>可以说，<code>Kotlin</code> 扩展的应用范围还是非常广的。它最主要的用途，就是用来取代 <code>Java</code> 当中的各种工具类，比如 <code>StringUtils</code>、<code>DateUtils</code> 等等。</p><p>所有 <code>Java</code> 工具类能做的事情，<code>Kotlin</code> 扩展函数都可以做，并且可以做得更好。扩展函数的优势在于，开发工具可以在编写代码的时候智能提示。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/239e540b768560c6cd119b1bb9e1eb9c.gif" alt="" style="zoom: 40%;" /><h2 id="扩展的局限性"><a href="#扩展的局限性" class="headerlink" title="扩展的局限性"></a>扩展的局限性</h2><p><code>Kotlin</code> 的扩展，由于它本质上并没有修改接收类型的源代码，所以它的行为是无法与“类成员”完全一致的。那么它对比普通的类成员，就会有以下几个限制。</p><p><strong>第一个限制，<code>Kotlin</code> 扩展不是真正的类成员，因此它无法被它的子类重写。</strong></p><p>举个例子，我们定义一个这样的 <code>Person</code> 类，并且分别为它扩展了一个 <code>isAdult</code> 属性和 <code>walk()</code> 方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">var</span> name: String = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-keyword">val</span> Person.isAdult: <span class="hljs-built_in">Boolean</span><br>    <span class="hljs-keyword">get</span>() = age &gt;= <span class="hljs-number">18</span><br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> Person.<span class="hljs-title">walk</span><span class="hljs-params">()</span></span> &#123;<br>    println(<span class="hljs-string">&quot;walk&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>由于 <code>Person</code> 类有 <code>open</code> 关键字修饰，所以我们可以继承这个 <code>Person</code> 类。</p><p>不过，当我们尝试去重写它的成员时，会发现 <code>isAdult</code> 和 <code>walk()</code> 是无法被重写的，因为它们压根就不属于 <code>Person</code> 这个类。</p><p><strong>第二个限制，扩展属性无法存储状态。</strong></p><p>就如前面代码当中的 <code>isAdult</code> 属性一般，它的值是由 <code>age</code> 这个成员属性决定的，它本身没有状态，也无法存储状态。背后的根本原因，还是因为它们都是静态方法。</p><p><strong>第三个限制，扩展的<em>访问作用域</em>仅限于两个地方。</strong></p><ol><li><p>如果扩展是顶层的扩展。</p><p>那么扩展的访问域仅限于该 <code>Kotlin</code> 文件当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展是可以被全局使用的。</p></li><li><p>如果扩展是被定义在某个类当中的。</p><p>那么该扩展的访问域仅限于该类当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展仅能在该类当中使用。</p></li></ol><hr><h1 id="扩展的使用场景"><a href="#扩展的使用场景" class="headerlink" title="扩展的使用场景"></a>扩展的使用场景</h1><p><strong><code>Kotlin</code> 扩展的第一个典型使用场景：关注点分离。主动使用扩展，通过它来优化软件架构。</strong></p><p>所谓关注点分离，就是将我们程序的逻辑划分成不同的部分，每一个部分，都只关注自己那部分的职责。以 <code>Kotlin</code> 源码中的 <code>String</code> 类为例，<code>String.kt</code> 这个类，只关注 <code>String</code> 的核心逻辑；而 <code>Strings.kt</code> 则只关注 <code>String</code> 的操作符逻辑。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// String.kt (一共只有 13 行代码)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> : <span class="hljs-type">Comparable</span>&lt;<span class="hljs-type">String</span>&gt;, <span class="hljs-type">CharSequence</span> &#123;<br>    <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> &#123;&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">plus</span><span class="hljs-params">(other: <span class="hljs-type">Any</span>?)</span></span>: String<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> length: <span class="hljs-built_in">Int</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">get</span><span class="hljs-params">(index: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Char</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subSequence</span><span class="hljs-params">(startIndex: <span class="hljs-type">Int</span>, endIndex: <span class="hljs-type">Int</span>)</span></span>: CharSequence<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(other: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Int</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Strings.kt 部分代码</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> CharSequence.<span class="hljs-title">trim</span><span class="hljs-params">()</span></span>: CharSequence = trim(<span class="hljs-built_in">Char</span>::isWhitespace)<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">expect</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">lowercase</span><span class="hljs-params">()</span></span>: String<br></code></pre></td></tr></table></figure><p><strong>扩展的第二个核心使用场景：被动使用扩展，提升可读性与开发效率。</strong></p><p>当我们无法修改外部的 <code>SDK</code> 时，对于重复的代码模式，我们将其以扩展的方式封装起来，提供给对应的接收者类型。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><code>Kotlin</code> 的扩展，从 <strong>语法角度</strong> 来看，分为扩展函数和扩展属性。定义扩展的方式，只是比普通函数、属性多了一个“扩展接收者”而已。</li><li>从 <strong>作用域</strong> 角度来看，分为顶层扩展和类内扩展。</li><li>从 <strong>本质</strong> 上来看，扩展函数和扩展属性，它们都是 <code>Java</code> 静态方法，与 <code>Java</code> 当中的工具类别无二致。对比 <code>Java</code> 工具类，扩展最大的优势就在于，<code>IDE</code> 可以为我们提供代码补全功能。</li><li>从 <strong>能力</strong> 的角度来看，<code>Kotlin</code> 扩展一共有三个限制，分别是：扩展无法被重写；扩展属性无法存储状态；扩展的作用域有限，无法访问私有成员。</li><li>从 <strong>使用场景</strong> 的角度来看，<code>Kotlin</code> 扩展主要有两个使用场景，分别是：关注点分离，优化代码架构；消灭模板代码，提高可读性和开发效率。</li></ol><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/b4a3ce7c3e0b2228161faa4769618a10.jpg"></p><hr><p><strong>参考文章：</strong></p><ul><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>扩展函数</tag>
      
      <tag>扩展属性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>需要了解的计算机操作系统知识！</title>
    <link href="/posts/559f8ebee8fc/"/>
    <url>/posts/559f8ebee8fc/</url>
    
    <content type="html"><![CDATA[<h1 id="四个基本特征"><a href="#四个基本特征" class="headerlink" title="四个基本特征"></a>四个基本特征</h1><ol><li><p><strong>并发</strong></p><p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p><p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p></li><li><p><strong>共享</strong></p><p>共享是指系统中的资源可以被多个并发进程共同使用。</p><p>有两种共享方式：互斥共享和同时共享。</p><p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p></li><li><p><strong>虚拟</strong></p><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p><p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p></li><li><p><strong>异步</strong></p><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p></li></ol><hr><h1 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h1><ol><li><p>进程管理</p><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p></li><li><p>内存管理</p><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p></li><li><p>文件管理</p><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p></li><li><p>设备管理</p><p>完成用户的 I&#x2F;O 请求，方便用户使用各种设备，并提高设备的利用率。</p><p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p></li></ol><hr><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/tGPV0.png"></p><hr><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>进程是资源分配的最小单位。</strong></p><p>进程控制块 (Process Control Block，PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p><p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/a6ac2b08-3861-4e85-baa8-382287bfee9f.png"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p><strong>线程是独立调度的基本单位。</strong></p><p>一个进程中可以有多个线程，它们共享进程资源。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li><p>拥有资源</p><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p></li><li><p>调度</p><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p></li><li><p>系统开销</p><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I&#x2F;O 设备等，所付出的开销远大于创建或撤销线程时的开销。</p></li><li><p>通信方面</p><p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p></li></ol><hr><h1 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h1><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ProcessState.png"></p><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源</li></ul><p>注意：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是由于缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><hr><h1 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h1><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h2 id="交互式系统"><a href="#交互式系统" class="headerlink" title="交互式系统"></a>交互式系统</h2><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><h3 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h3><blockquote><p>  <strong>先来先服务 first-come first-serverd（FCFS）</strong></p><p>  批处理系统中非抢占式的调度算法，按照请求的顺序进行调度。</p><p>  有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p></blockquote><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><h3 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h3><p>为每个进程分配一个优先级，按优先级进行调度。</p><p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><h3 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h3><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/042cf928-3c8e-4815-ae9c-f2780202c68f.png"></p><h2 id="批处理系统、实时系统"><a href="#批处理系统、实时系统" class="headerlink" title="批处理系统、实时系统"></a>批处理系统、实时系统</h2><p>具体内容查看本文上方的参考文章。</p><hr><h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> entry section<br><span class="hljs-regexp">//</span> critical section;<br><span class="hljs-regexp">//</span> <span class="hljs-keyword">exit</span> section<br></code></pre></td></tr></table></figure><h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> semaphore;<br>semaphore mutex = <span class="hljs-number">1</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">P1</span><span class="hljs-params">()</span> &#123;<br>    down(&amp;mutex);<br>    <span class="hljs-comment">// 临界区</span><br>    up(&amp;mutex);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">P2</span><span class="hljs-params">()</span> &#123;<br>    down(&amp;mutex);<br>    <span class="hljs-comment">// 临界区</span><br>    up(&amp;mutex);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p><p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><hr><h1 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h1><h2 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h2><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><p>一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p><p>为了防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul><h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><hr><h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><p>进程同步与进程通信很容易混淆，它们的区别在于：</p><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><h2 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h2><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p><h2 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h2><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p><hr><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h2><ol><li>互斥</li><li>占有且等待</li><li>不可抢占</li><li>循环等待</li></ol><h2 id="已发生死锁后的处理方法"><a href="#已发生死锁后的处理方法" class="headerlink" title="已发生死锁后的处理方法"></a>已发生死锁后的处理方法</h2><p>主要有以下四种方法：</p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防</li><li>死锁避免</li></ul><h3 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h3><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p><h3 id="死锁检测与死锁恢复"><a href="#死锁检测与死锁恢复" class="headerlink" title="死锁检测与死锁恢复"></a>死锁检测与死锁恢复</h3><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><p><strong>死锁检测：</strong></p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><p><strong>死锁恢复：</strong></p><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><h2 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h2><p>我们只要<strong>破坏产生死锁的四个条件中的其中一个就可以了</strong>。</p><ol><li><p><strong>破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p></li><li><p><strong>破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p></li><li><p><strong>破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p></li><li><p><strong>破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p></li></ol><h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><h3 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h3><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ed523051-608f-4c3f-b343-383e2d194470.png"></p><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p><h3 id="单个资源的银行家算法"><a href="#单个资源的银行家算法" class="headerlink" title="单个资源的银行家算法"></a>单个资源的银行家算法</h3><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png"></p><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p><h3 id="多个资源的银行家算法"><a href="#多个资源的银行家算法" class="headerlink" title="多个资源的银行家算法"></a>多个资源的银行家算法</h3><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png"></p><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A&#x3D;(1020)，表示 4 个资源分别还剩下 1&#x2F;0&#x2F;2&#x2F;0。</p><p><strong>检查一个状态是否安全的算法如下：</strong></p><ul><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ul><p>如果一个状态不是安全的，需要拒绝进入这个状态。</p><hr><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><blockquote><p>  参考视频：</p><ul><li><a href="https://www.bilibili.com/video/BV18v411a7Vk">【操作系统】内存管理——虚拟内存 _ 哔哩哔哩_bilibili</a></li></ul></blockquote><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/7b281b1e-0595-402b-ae35-8c91084c33c1.png"></p><hr><h1 id="分页系统地址映射"><a href="#分页系统地址映射" class="headerlink" title="分页系统地址映射"></a>分页系统地址映射</h1><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p><p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p><p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" alt="" style="zoom:67%;" /><hr><h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h2 id="最佳"><a href="#最佳" class="headerlink" title="最佳"></a>最佳</h2><blockquote><p>  OPT, Optimal replacement algorithm</p></blockquote><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p><p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。 </p><h2 id="最近最久未使用"><a href="#最近最久未使用" class="headerlink" title="最近最久未使用"></a>最近最久未使用</h2><blockquote><p>  LRU, Least Recently Used</p></blockquote><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p><p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p><h2 id="先进先出"><a href="#先进先出" class="headerlink" title="先进先出"></a>先进先出</h2><blockquote><p>  FIFO, First In First Out</p></blockquote><p>选择换出的页面是最先进入的页面。</p><p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p><h2 id="第二次机会算法"><a href="#第二次机会算法" class="headerlink" title="第二次机会算法"></a>第二次机会算法</h2><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png"></p><h2 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h2><blockquote><p>  Clock</p></blockquote><p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png"></p><h2 id="最近未使用"><a href="#最近未使用" class="headerlink" title="最近未使用"></a>最近未使用</h2><blockquote><p>  NRU, Not Recently Used</p></blockquote><p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R&#x3D;1，当页面被修改时设置 M&#x3D;1。其中 R 位会定时被清零。可以将页面分成以下四类：</p><ul><li>R&#x3D;0，M&#x3D;0</li><li>R&#x3D;0，M&#x3D;1</li><li>R&#x3D;1，M&#x3D;0</li><li>R&#x3D;1，M&#x3D;1</li></ul><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p><p>NRU 优先换出已经被修改的脏页面（R&#x3D;0，M&#x3D;1），而不是被频繁使用的干净页面（R&#x3D;1，M&#x3D;0）。</p><hr><h1 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h1><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p><p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/22de0538-7c6e-4365-bd3b-8ce3c5900216.png"></p><p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><hr><h1 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h1><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><hr><h1 id="分页与分段的比较"><a href="#分页与分段的比较" class="headerlink" title="分页与分段的比较"></a>分页与分段的比较</h1><ul><li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li><li>地址空间的维度：分页是一维地址空间，分段是二维的。</li><li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li><li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul><hr><p><strong>参考资料：</strong></p><ul><li><a href="http://www.cyc2018.xyz/">CS-Notes (cyc2018.xyz)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试整理-2022</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>虚拟内存</tag>
      
      <tag>进程</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP3e-学习笔记-第八章</title>
    <link href="/posts/68b85099e992/"/>
    <url>/posts/68b85099e992/</url>
    
    <content type="html"><![CDATA[<blockquote><hr><p>  判断题：异常分为四种类别：中断（interrupt）、陷阱（trap）、故障（fault）、终止 （abort），四类异常都是同步异常。（错）</p></blockquote><p><strong>CSAPP3e 8.1.2 异常的类别</strong></p><p>异常可以分为四类：中断 (interrupt) 、陷阱 (trap) 、故障 (fault) 和终止 (abort) 。下面的表对这些类别的属性做了小结。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230220094341408.png" alt="异常的类别" style="zoom:67%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230220094532819.png" style="zoom: 67%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230220094559122.png" style="zoom:67%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230220094623459.png" style="zoom:67%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230220094646899.png" style="zoom:67%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230220094713778.png" style="zoom:67%;" /><blockquote><hr><p>  判断题：进程是一个执行中程序的实例，每个进程都运行在某个进程的上下文（context） 中。（对）</p></blockquote><p><strong>CSAPP3e 8.2 进程</strong></p><p><strong>定义：</strong>一个执行中程序的实例。</p><p>进程提供给应用程序两个关键抽象：</p><ul><li><p>逻辑控制流</p><ul><li>PC（程序计数器）值的序列叫做逻辑控制流。</li><li>每个程序似乎独占地使用 CPU</li><li>通过 OS 内核的<strong>上下文切换</strong>机制提供</li></ul></li><li><p>私有地址空间</p><ul><li>每个程序似乎独占地使用内存系统</li><li>OS 内核的<strong>虚拟内存</strong>机制提供</li></ul></li></ul><blockquote><hr><p>  判断题：上下文（context）是由程序正确运行所需要的状态组成，包括：内存中的程序的代码和数据、栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。（对）</p></blockquote><p><strong>CSAPP3e 8.2.5 上下文切换</strong></p><ul><li><p>进程由常驻内存的操作系统代码块（称为内核）管理，内核不是一个单独的进程，而是作为现有进程的一部分运行。</p></li><li><p>操作系统内核使用<strong>上下文切换</strong>实现多任务。上下文包含进程的状态：通用目的寄存器、浮点寄存器、程序计数器、用户栈、内核栈、各种内核数据结构。</p></li><li><p>调度、调度器、上下文切换过程：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230220124914269.png" alt="上下文切换" style="zoom:67%;" /></li></ul><blockquote><hr><p>  判断题：父进程和新创建的子进程具有相同的 PID 和 PGID。（错） </p><p>  判断题：fork 函数调用一次返回两次，一次返回到父进程，一次返回到新创建的子进程。（对）</p></blockquote><p><strong>CSAPP3e 8.4.2 创建和终止进程</strong></p><p>从程序员的角度，我们可以认为进程总是处于下面三种状态之一</p><ul><li>运行（Running）<br>进程要么在 CPU 上执行，要么在等待被执行且最终会被操作系统内核调度。</li><li>停止&#x2F;暂停&#x2F;挂起（Stopped&#x2F;Paused&#x2F;Hanged）<br>进程的执行被挂起且不会被调度，直到收到新的信号。</li><li>终止（Terminated）<br>进程永远地停止了，但<strong>仍占资源</strong>。</li></ul><p><strong>创建进程</strong></p><p>父进程通过调用 <code>fork</code> 函数创建一个新的运行的子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><ul><li>被调用一次，却返回两次<ul><li>子进程返回 0，父进程返回子进程的 PID</li></ul></li><li>新创建的子进程几乎但不完全与父进程相同<ul><li>子进程得到与父进程虚拟地址空间相同的（但是独立的）一份副本（代码、数据段、堆、共享库以及用户栈）</li><li>子进程获得与父进程任何打开文件描述符相同的副本</li><li>stdout 文件在父、子进程是相同的</li><li>子进程有不同于父进程的 PID</li></ul></li><li>并发执行<ul><li>不能预测父进程与子进程 的执行顺序</li></ul></li></ul><p><strong>CSAPP3e 8.5.2 发送信号: 进程组</strong></p><p>每个进程只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的（PGID）。</p><blockquote><hr><p>  多选题：每个信号类型都有一个预定义的默认行为，分别是（A B C D）<br>  A. 进程终止<br>  B. 进程终止并转储内存<br>  C. 进程停止（挂起）直到被 <code>SIGCONT</code> 信号重启<br>  D. 进程忽略该信号</p></blockquote><p><strong>CSAPP3e 8.5 Linux 信号</strong></p><p>signal 就是一条小消息，它通知进程系统中发生了一个某种类型的事件。</p><ul><li>类似于异常和中断</li><li>从内核发送到（有时是在另一个进程的请求下）一个进程</li><li>信号类型是用小整数 ID 来标识的(1-30)</li><li>信号中唯一的信息是它的 ID 和它的到达</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230220131838747.png" style="zoom: 50%;" /><p><strong>CSAPP3e 8.5.3 接收信号</strong></p><p> 每个信号类型都有一个预定义默认行为， 是下面中的一种：</p><ul><li>进程终止</li><li>进程终止并转储内存</li><li>进程停止（挂起）直到被 <code>SIGCONT</code> 信号重启</li><li>进程忽略该信号</li></ul><p>进程可以通过 <code>signal</code> 函数修改和信号相关联的默认行为，其中 <code>SIGSTOP</code> 和 <code>SIGKILL</code> 的默认行为不能修改。</p><blockquote><hr><p>  多选题：进程调用 <code>int kill(pid_t pid, int sig)</code> 函数发送信号给其他进程，以下说法正确的是（A B C）<br>  A. $pid&gt;0$：<code>kill</code> 函数发送信号号码 sig 给进程 pid。<br>  B. $pid&#x3D;0$：<code>kill</code> 函数发送信号 sig 给调用进程所在进程组中的每个进程。<br>  C. $pid&lt;0$：<code>kill</code> 函数发送信号 sig 给进程组 $| pid |$（pid 的绝对值）中的每个进程。<br>  D. 以上说法都不正确</p></blockquote><p><strong>CSAPP3e 8.5.2 发送信号: 进程组</strong></p><p>进程可以通过调用 <code>kill</code> 函数发送信号给其他进程（包括自己）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> sig)</span> <span class="hljs-comment">// 若成功则返回 0，若错误则返回 -1。</span><br></code></pre></td></tr></table></figure><p>pid 取值有三种情况：</p><table><thead><tr><th>pid</th><th>结果</th></tr></thead><tbody><tr><td>$pid&gt;0$</td><td><code>kill</code> 函数发送信号号码 sig 给进程 pid。</td></tr><tr><td>$pid&#x3D;0$</td><td><code>kill</code> 函数发送信号 sig 给调用进程所在进程组中的每个进程。</td></tr><tr><td>$pid&lt;0$</td><td><code>kill</code> 函数发送信号 sig 给进程组$</td></tr></tbody></table><blockquote><hr><p>  多选题：发送信号的原因：（A B）<br>  A. 内核检测到一个系统事件，比如除零错误或子进程终止。<br>  B. 一个进程调用了 <code>kill</code> 函数，显式地要求内核发送一个信号给目的进程。<br>  C. 进程创建子进程。</p></blockquote><p><strong>CSAPP3e 8.5.1 信号术语：发送信号</strong></p><p> 内核通过更新目的进程上下文中的某个状态，发送 （递送）一个信号给目的进程。</p><p>发送信号可以是如下原因之一：</p><ul><li>内核检测到一个系统事件如除零错误(<code>SIGFPE</code>)或者子进程 终止(<code>SIGCHLD</code>)。</li><li>一个进程调用了 <code>kill</code> 系统调用，显式地请求内核发送一 个信号到目的进程。<ul><li>一个进程可以发送信号给它自己。</li></ul></li></ul><blockquote><hr><p>  多选题：signal 函数接受两个参数：信号值和函数指针，可以通过下列哪些方法（A B C）来改变和信号 signum 相关联的行为。<br>  A. 如果 handler 是 SIG_IGN，那么忽略类型为 signum 的信号。<br>  B. 如果 handler 是 SIG_DFL，那么类型为 signum 的信号行为恢复为默认行为。<br>  C. 如果 hanlder 是用户定义的函数的地址，这个函数就被称为信号处理程序。</p></blockquote><p><strong>CSAPP3e 8.5.3 接收信号</strong></p><p>可以使用 <code>signal</code> 函数修改和信号 signum 相关联的默认行为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br>Typedef <span class="hljs-title function_">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br><br><span class="hljs-type">sighandler_t</span> <span class="hljs-title function_">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum, <span class="hljs-type">sighandler_t</span> handler)</span>;<br><span class="hljs-comment">//返回：若成功则为指向前次处理程序的指针，若出错则为SIG_ERR（不设置errno）。</span><br></code></pre></td></tr></table></figure><p>handler 的不同取值：</p><ul><li><code>SIG_IGN</code>: 忽略类型为 signum 的信号</li><li><code>SIG_DFL</code>: 类型为 signum 的信号行为恢复为默认行为</li><li>否则，handler 就是用户定义的函数的地址，这个函数称为信号处理程序<ul><li>只要进程接收到类型为 signum 的信号就会调用信号处理程序</li><li>将处理程序的地址传递到 <code>signal</code> 函数从而改变默认行为，这叫作设置信号处理程序</li><li>调用信号处理程序称为捕获信号</li><li>执行信号处理程序称为处理信号</li><li>当处理程序执行 <code>return</code> 时，控制会传递到控制流中被信号接收所中断的指令处</li></ul></li></ul><blockquote><hr><p>  单选题：以下对Linux 系统提供的监控和操作进程的工具说法错误的是（C）：<br>  A. $TOP$：打印关于当前进程资源使用的信息。<br>  B. $STRACE$：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。<br>  C. $PS$：列出当前系统中的进程，不包括僵死进程。<br>  D. $&#x2F;proc$：一个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。</p></blockquote><p><strong>CSAPP3e 8.4.3 回收子进程</strong></p><p>为什么回收？–与fork创建相反！</p><ul><li><p>当进程终止时，它仍然消耗系统资源</p><ul><li>Examples: Exit status, various OS tables（占用内存）</li></ul></li><li><p>称为僵死进程（ “僵尸 zombie”进程）</p></li><li><p>僵死进程占用内存资源、打开的 IO 资源</p></li></ul><p>回收 (Reaping)</p><ul><li>父进程执行回收(using <code>wait</code> or <code>waitpid</code>)</li><li>内核删掉僵死子进程、从系统中删除掉它的所有痕迹</li></ul><p>父进程不回收子进程的后果：</p><ul><li>如果父进程没有回收它的僵死子进程就终止了，内核安排 <strong>init-养父</strong> 进程去回收它们（init 进程 PID 为 1，系统启动时创建，不会终止，是所有进程的祖先）</li><li>长时间运行的进程应当主动回收它们的僵死子进程</li></ul><p><strong><code>ps</code> 命令：列出当前系统中的进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">/* ps 命令示例 */<br><br>linux&gt; ps<br>PID   TTY    TIME   CMD<br>6585 ttyp9 00:00:00 tcsh<br>6639 ttyp9 00:00:03 forks<br>6640 ttyp9 00:00:00 forks &lt;defunct&gt;<br>6641 ttyp9 00:00:00 ps<br></code></pre></td></tr></table></figure><p><code>ps</code> 命令显示的子进程标记为 “defunct”，即僵死进程。</p><blockquote><hr><p>  <strong>CSAPP3e 练习题8.4 P520</strong></p><p>  考虑下面的程序：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123; <br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello\n&quot;</span>);<br>    pid = Fork();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, !pid);<br>    <span class="hljs-keyword">if</span> (pid != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (waitpid(<span class="hljs-number">-1</span>, &amp;status, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (WIFEXITED(status) != <span class="hljs-number">0</span>)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, WEXITSTATUS(status));<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Bye\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>  A. 这个程序会产生多少输出行？<br>  B. 这些输出行的一种可能的顺序是什么？</p><hr><p>  A. 打印输出 6 行<br>  B. 可能的输出：Hello, 1, 0, Bye, 2, Bye<br>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/CSAPP3e-homework-8-4.jpg" style="zoom:50%;" /></p></blockquote><p><strong>CSAPP3e 8.4.3 回收子进程 &gt;&gt; 与子进程同步：<code>wait</code>&#x2F;<code>waitpid</code></strong></p><p><em><strong>wait 函数</strong></em></p><p>父进程通过 <code>wait</code>&#x2F;<code>waitpid</code> 函数回收子进程：</p><ul><li>调用 <code>wait(&amp;status)</code>  等价于调用 <code>waitpid(-1, &amp;status, 0)</code> 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *statusp)</span>;<br><span class="hljs-comment">// 返回：如果成功，则为子进程的 PID, 如果出错，则为 -1。</span><br></code></pre></td></tr></table></figure><ul><li><p>挂起当前进程的执行直到它的一个子进程终止。</p></li><li><p>返回已终止子进程（可能很多，是个集合）的 pid。</p></li><li><p>如 <code>child_status != NULL</code>，则在该指针指向的整型量中写入关于终止原因和退出状态的信息。</p><ul><li><p>用 <code>wait.h</code> 头文件中定义的宏来检查（具体作用查看）：</p><ul><li><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230220162935923.png" style="zoom: 60%;" /></li><li><p><code>WEXITSTATUS</code> 是一个检验子进程退出的正常还是非正常和返回值的宏。</p><p><code>WIFEXITED(status)</code> 这个宏用来指出子进程是否为正常退出的，如果是，它会返回一个非零值。</p><p><code>WEXITSTATUS(status)</code> 当 <code>WIFEXITED</code> 返回非零值时，可以用这个宏来提取子进程的返回值，如果子进程调用 <code>exit(5)</code> 退出，<code>WEXITSTATUS(status)</code> 就会返回 5；如果子进程调用 <code>exit(7)</code>，<code>WEXITSTATUS(status)</code> 就会返回 7。</p><p>请注意，如果进程不是正常退出的，也就是说，<code>WIFEXITED</code> 返回 0，这个值就毫无意义。</p></li></ul></li></ul></li><li><p>子进程完成结束的顺序是任意的（没有固定的顺序）。</p></li><li><p>可用宏函数 <code>WIFEXITED</code> 和 <code>WEXITSTATUS</code> 获取进程的退出状态信息。</p></li></ul><p><em><strong>waitpid 函数</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-type">pid_t</span> <span class="hljs-title function_">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *statusp, <span class="hljs-type">int</span> options)</span>;<br><span class="hljs-comment">// 返回：如果成功，则为子进程的 PID, 如果 WNOHANG, 则为 0, 如果其他错误，则为 —1。</span><br></code></pre></td></tr></table></figure><ol><li>默认情况下（当 <code>options</code> &#x3D; 0 时）， <code>waitpid</code> 挂起调用进程的执行，直到它的等待集合(wait set) 中的一个子进程终止。</li><li>如果等待集合中的一个进程在刚调用的时刻就已经终止了，那么 <code>waitpid</code> 就立即返回。</li></ol><p>在上面这两种情况中，<code>waitpid</code> 返回导致 <code>waitpid</code> 返回的已终止子进程的 PID。此时，已终止的子进程已经被回收，内核会从系统中删除掉它的所有痕迹。</p><p><em>参数说明：</em></p><ol><li><p>判定等待集合的成员</p><table><thead><tr><th>pid</th><th>成员</th></tr></thead><tbody><tr><td>$pid&#x3D;-1$</td><td>等待集合是由父进程所有的子进程组成的。</td></tr><tr><td>$pid&gt;0$</td><td>等待集合是一个单独的子进程，它的进程 ID 等于 pid。</td></tr></tbody></table></li><li><p>修改默认行为</p><p>通过设置 <code>Options</code> 来修改默认行为（默认<code>Options</code> &#x3D; 0，等待子进程终止）：      </p><table><thead><tr><th>options</th><th>行为</th></tr></thead><tbody><tr><td><code>WNOHANG</code></td><td>如果等待集合的任何子进程没有终止，就立即返回 0。<br />父进程可继续其他工作。</td></tr><tr><td><code>WUNTRACED</code></td><td>挂起当前进程，直到等待集合中的任一进程终止或停止，则返回其 pid。<br />用于检查。</td></tr><tr><td><code>WCONTINUED</code></td><td>挂起当前进程，直到<em>等待集合中的任一进程从运行到终止</em>或<em>一个停止的进程收到 <code>SIGCONT</code></em> 而恢复运行。</td></tr><tr><td>&#96;WNOHANG</td><td>WUNTRACED&#96;组合</td></tr></tbody></table></li></ol>]]></content>
    
    
    <categories>
      
      <category>深入理解计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进程</tag>
      
      <tag>异常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP3e-学习笔记-第十章</title>
    <link href="/posts/b9e87311a79b/"/>
    <url>/posts/b9e87311a79b/</url>
    
    <content type="html"><![CDATA[<blockquote><hr><p>  Linux 系统下的 I&#x2F;O 进程，其标准输出描述符的值是（B）<br>  A. $0$<br>  B. $1$<br>  C. $2$<br>  D. $-1$</p></blockquote><blockquote><hr><p>  在头文件中，标准输出描述符所对应的预定义常量是（B）<br>  A. <code>STDIN_FILENO</code><br>  B. <code>STDOUT_FILENO</code><br>  C. <code>STDERR_FILENO</code><br>  D. <code>STDFILE_FILENO</code></p></blockquote><p>每个 C 程序开始时都有三个打开的流（在 <code>stdio.h</code> 中定义）</p><ul><li><code>stdin</code> (standard input) 标准输入</li><li><code>stdout</code> (standard output) 标准输出</li><li><code>stderr</code> (standard error) 标准错误</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stdin</span>;  <span class="hljs-comment">/* standard input  (descriptor 0) */</span><br><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stdout</span>; <span class="hljs-comment">/* standard output (descriptor 1) */</span><br><span class="hljs-keyword">extern</span> FILE *<span class="hljs-built_in">stderr</span>; <span class="hljs-comment">/* standard error  (descriptor 2) */</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-built_in">stdout</span>, <span class="hljs-string">&quot;Hello, world\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><hr><p>  Linux系统中文件类型包含下面哪些？（A B C D）<br>  A. 普通文件<br>  B. 目录<br>  C. 套接字<br>  D. 符号链接</p></blockquote><p>每个 Linux 文件都有一个类型来表明它在系统中的角色：</p><table><thead><tr><th>类型</th><th>英语</th><th>作用</th></tr></thead><tbody><tr><td>普通文件</td><td>Regular file</td><td>包含任意数据</td></tr><tr><td>套接字</td><td>Socket</td><td>用来与另一个进程进行跨网络通信的文件</td></tr><tr><td>目录</td><td>Directory</td><td>一组链接文件的索引</td></tr><tr><td>命名通道</td><td>Named pipes (FIFOs)</td><td></td></tr><tr><td>符号链接</td><td>Symbolic links</td><td></td></tr><tr><td>字符和块设备</td><td>Character and block devices</td><td></td></tr></tbody></table><blockquote><hr><p>  要读取某个目录的内容，应该使用函数（A B C）<br>  A. <code>opendir</code><br>  B. <code>readdir</code><br>  C. <code>closedir</code><br>  D. <code>writedir</code></p></blockquote><p><strong>文件描述符</strong></p><p>在 Linux 下一切皆文件，文件描述符是内核为了高效的管理<strong>已经被打开的文件所创建的索引</strong>，它是一个非负整数，用于指代被打开的文件。所有执行 I&#x2F;O 操作的系统调用都是通过文件描述符完成的。而系统调用函数 <code>open</code> 的返回值就是文件描述符 <code>fd</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//  打开文件 -&gt; 返回：若成功则为新文件描述符，若出错为-1。 </span><br><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">char</span> *filename, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br><br><span class="hljs-comment">// 关闭文件 -&gt; 返回：若成功则为0，若出错为-1。</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br><br><span class="hljs-comment">// 读文件 -&gt; 返回：若成功则为读的字节数，若 EOF 则为0，若出错为-1。</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> n)</span>;<br><br><span class="hljs-comment">// 写文件 -&gt; 返回：若成功则为写的字节数，若出错为-1。</span><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> n)</span>;<br></code></pre></td></tr></table></figure><p><strong>普通文件</strong></p><ul><li>普通文件包含任意数据</li><li>应用程序常常要区分文本文件（text files）和二进制文件（binary files）<ul><li>文本文件是只包含 ASCII 或 Unicode 字符的普通文件</li><li>二进制文件是所有其他文件<ul><li>比如目标文件，JPEG 图像文件等等</li></ul></li><li>内核并不知道两者之间的区别</li></ul></li><li>Linux 文本文件是文本行的序列<ul><li>文本行是一个字符序列，以一个新行符 (<code>\n</code>)结束<ul><li>新行符为 <code>0xa</code>，与 ASCII 的换行符 (<code>LF</code>) 是一样的</li></ul></li></ul></li><li>其他系统中的行结束标志<ul><li>Linux 和 Mac 操作系统 :  <code>\n</code> (<code>0xa</code>)<ul><li>换行 (<code>LF</code>)</li></ul></li><li>Windows 和 因特网络协议: <code>\r\n</code> (<code>0xd</code> <code>0xa</code>) <ul><li>Carriage return (<code>CR</code>) followed by line feed (<code>LF</code>)  回车换行</li></ul></li></ul></li></ul><p><strong>目录</strong></p><ul><li>目录是包含一组链接的文件<ul><li>每个链接将一个文件名映射到一个文件</li></ul></li><li>每个目录至少含有两个条目<ul><li><code>.</code> 是到该目录自身的链接</li><li><code>..</code> 是到目录层次结构中父目录的链接</li></ul></li></ul><blockquote><hr><p>  如何使用 <code>dup2</code> 将标准输入重定向到描述符5？（A）<br>  A. <code>dup2(5, 0)</code><br>  B. <code>dup2(0, 5)</code><br>  C. <code>dup2(1, 5)</code><br>  D. <code>dup2(5, 1)</code></p></blockquote><p><strong><code>dup2(oldfd, newfd)</code>函数</strong></p><p>复制描述符表表项 <code>oldfd</code> 到描述符表表项 <code>newfd</code>， 覆盖描述符表表项 <code>newfd</code> 以前的内容。</p><p>调用 <code>dup2(4, 1)</code>：使得 <code>fd =  1 (stdout)</code> 指向 <code>fd = 4</code> 所指向的磁盘文件。</p><blockquote><p>  dup2(A, B) &#x3D;&#x3D; 复制描述符 A 到描述符 B &#x3D;&#x3D; 描述符 B 指向描述符 A</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230219225416875.png" style="zoom: 80%;" />]]></content>
    
    
    <categories>
      
      <category>深入理解计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>I/O</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP3e-学习笔记-第七章</title>
    <link href="/posts/f36f34702e61/"/>
    <url>/posts/f36f34702e61/</url>
    
    <content type="html"><![CDATA[<blockquote><hr><p>  单选题：以下关于强符号和弱符号定义的描述中，错误的是（A）<br>  A. 只有初始化为 0 的全局变量在链接中才为强符号<br>  B. 局部符号没有强、弱符号的概念<br>  C. 没有初始化的全局变量是弱符号<br>  D. 全局使用的函数名都是强符号</p></blockquote><p><strong>CSAPP3e 7.6.1 链接器如何解析多重定义的全局符号</strong></p><ul><li>强符号：函数和已初始化的全局变量</li><li>弱符号：未初始化的全局变量</li></ul><blockquote><hr><p>  判断题：可重定位目标文件中未初始化的全局变量保存在 $.data$ 中（错）</p><p>  判断题：程序的数据和代码不存放在同一个地方，代码在低地址段，数据在高地址段。（对）</p></blockquote><p><strong>CSAPP3e 7.4 可重定位目标文件</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230216124752525.png" alt="典型的 ELF 可重定位目标文件" style="zoom: 50%;" /><p>夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节：</p><ul><li><p>$.text$：已编译程序的机器代码。</p></li><li><p>$.rodata$：只读数据，比如 <code>printf</code> 语句中的格式串和开关语句的跳转表。</p></li><li><p>$.data$：已初始化的全局和静态 C 变量。</p><p>局部 C 变量在运行时被保存在栈中，既不出现在 $.data$ 节中，也不出现在 $.bss$ 节中。</p></li><li><p>$.bss$：未初始化的全局和静态 C 变量，以及所有被初始化为 $0$ 的全局或静态变量。</p><p>用术语 $.bss$ 来表示未初始化的数据是很普遍的。一种记住 $.data$ 和 $.bss$ 节之间区别的简单方法是把 <code>bss</code>​ 看成是 “更好地节省空间（Better Save Space）” 的缩写。</p></li><li><p>$.symtab$：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。</p></li><li><p>$.rel.text$：一个 $.text$ 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。</p></li><li><p>$.rel.data$：被模块引用或定义的所有全局变量的重定位信息。</p></li></ul><p><strong>CSAPP3e 7.5 符号和符号表</strong></p><p>每个符号都被分配到目标文件的某个节，由 section 字段表示，该字段也是一个到节头部表的索引。有三个特殊的伪节，它们在节头部表中是没有条目的：</p><ul><li>$ABS$：代表不该被重定位的符号</li><li>$UNDEF$：代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号</li><li>$COMMON$：表示还未被分配位置的未初始化的数据目标</li></ul><p>注意， 只有可重定位目标文件中才有这些伪节，可执行目标文件中是没有的。</p><p>$COMMON$ 和 $.bss$ 的区别很细微。现代的 GCC 版本根据以下规则来将可重定位目标文件中的符号分配到 $COMMON$ 和 $.bss$ 中：</p><ul><li>$COMMON$：未初始化的全局变量</li><li>$.bss$：未初始化的静态变量，以及初始化为 $0$ 的全局或静态变量</li></ul><p>采用这种看上去很绝对的区分方式的原因来自于链接器执行符号解析的方式。</p><blockquote><hr><p>  单选题：以下关于 ELF 可执行目标文件的程序头表（段头表）的叙述中，错误的是（B）<br>  A. $.txt$ 节和 $.rodata$ 节都包含在只读代码段，而 $.data$ 节和 $.bss$ 节都包含在读写数据段<br>  B. 用于描述可执行文件中的节与主存储器中的存储段之间的映射关系<br>  C. 描述了段的起始虚拟地址、存储长度、存取方式和对齐方式</p></blockquote><p><strong>CSAPP3e 7.4 可重定位目标文件</strong></p><p>ELF 头（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。 </p><p>ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括：</p><ul><li>ELF 头的大小</li><li>目标文件的类型（如可重定位、可执行或者共享的）</li><li>机器类型（如 x86-64）</li><li>节头部表（section header table）的文件偏移</li><li>节头部表中条目的大小和数量</li></ul><p>不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目 。</p><blockquote><hr><p>  单选题：以下关于链接过程中对符号定义的判断中，错误的是（A）<br>  A. 函数内的局部变量声明 <code>short x = 200;</code> 中，<code>x</code> 是符号定义<br>  B. 全局变量声明 <code>int x, y;</code> 中，<code>x</code> 和 <code>y</code> 都是符号的定义<br>  C. 全局变量声明 <code>int xp = &amp;x;</code> 中，<code>xp</code> 和 <code>x</code> 都是符号的定义<br>  D. 静态局部变量声明 <code>static int x = xp;</code> 中，<code>x</code> 是符号的定义</p></blockquote><p><strong>CSAPP3e 7.2 静态链接</strong></p><p><strong>符号</strong>对应于一个函数、一个全局变量或一个静态变量（即 C 语言 中任何以 <code>static</code> 属性声明的变量）。</p><p><strong>CSAPP3e 7.5 符号和符号表</strong></p><p>每个可重定位目标模块 $m$ 都有一个符号表，它包含 $m$ 定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：</p><ul><li>由模块 $m$ 定义并能被其他模块引用的<strong>全局符号</strong>。全局链接器符号对应于非静态的 C 函数和全局变量。</li><li>由其他模块定义并被模块 $m$ 引用的全局符号。这些符号称为<strong>外部符号</strong>，对应于在其他模块中定义的非静态 C 函数和全局变量。</li><li>只被模块 $m$ 定义和引用的局部符号。它们对应于带 <code>static</code> 属性的 C 函数和全局变量。 这些符号在模块 $m$ 中任何位置都可见，但是不能被其他模块引用。</li></ul><p>$.symtab$ 中的符号表不包含对应于本地非静态程序量的任何符号。这些符号在运行时在栈中被管理，链接器对此类符号不感兴趣。</p><p>定义为带有 C <code>static</code> 属性的本地过程变量是不在栈中管理的。相反，编译器在 $.data$ 或 $.bss$ 中为每个定义分配空间 ，并在符号表中创建一个有唯一名字的本地链接器符号。</p><blockquote><hr><p>  单选题：以下是有关静态链接和动态链接比较的描述，其中错误的是（D）<br>  A. 静态库函数更新后需对程序重新编译和链接，而共享库函数更新后程序无需重新编译和链接<br>  B. 静态库函数代码包含在可执行目标文件中，而共享库函数代码不包含在可执行目标文件中<br>  C. 静态链接情况下静态库函数在加载时被链接，动态链接情况下共享库函数可在加载或运行时被链接<br>  D. 静态库函数代码包含在进程代码段中，而共享库函数代码不包含在进程代码段中</p></blockquote><blockquote><hr><p>  单选题：以下是关于链接过程中的符号解析的叙述，错误的是（A）<br>  A. 同一个符号名可能在多个模块中定义，每个定义处的符号都必须分配空间<br>  B. 符号解析的目的是将符号引用与某目标模块中的定义建立关联<br>  C. 本地符号的解析比较简单，只要与本模块内定义的符号关联即可<br>  D. 全局符号和外部符号需将模块内的引用与模块外定义的符号绑定</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>深入理解计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP3e</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin 理解泛型</title>
    <link href="/posts/e071c5b5b514/"/>
    <url>/posts/e071c5b5b514/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>泛型，这个概念在很多编程语言里面都存在。在中大型软件开发当中，我们对泛型的使用也十分频繁，因为它可以让我们<strong>在不同类型之间复用相似的逻辑代码</strong>。</p><p>然而，泛型实在太抽象了。X﹏X</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230212213111539.png" alt="" style="zoom:80%;" /><hr>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP3e-学习笔记-第六章</title>
    <link href="/posts/8ec5b05368b1/"/>
    <url>/posts/8ec5b05368b1/</url>
    
    <content type="html"><![CDATA[<h1 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h1><h2 id="随机访问存储器（RAM）"><a href="#随机访问存储器（RAM）" class="headerlink" title="随机访问存储器（RAM）"></a>随机访问存储器（RAM）</h2><ul><li>最基本的存储单位称为单元，一个单元存储一个 bit。</li><li>RAM 是易失的，意味着如果断电，就会丢失 RAM 中所保存的信息。</li></ul><hr><h1 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h1><p>局部性原理（Principle of Locality）：程序倾向于使用最近一段时间，距离其较近地址的指令和数据。</p><h2 id="时间局部性"><a href="#时间局部性" class="headerlink" title="时间局部性"></a>时间局部性</h2><p>当前被访问的信息近期很可能 还会被再次访问。例如，你读取了一个变量，那么你有可能会再次读取该变量。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230212172010172.png" alt="时间局部性" style="zoom:67%;" /><h2 id="空间局部性"><a href="#空间局部性" class="headerlink" title="空间局部性"></a>空间局部性</h2><p>在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230212172112667.png" alt="空间局部性" style="zoom:67%;" /><h2 id="局部性的定性判断"><a href="#局部性的定性判断" class="headerlink" title="局部性的定性判断"></a>局部性的定性判断</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum_array_cols</span><span class="hljs-params">(<span class="hljs-type">int</span> a[M][N])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; N; j++) <br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; M; i++)<br>            sum += a[i][j]; <br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于上述代码，可以发现 <code>for</code> 循环中的元素的访问顺序是跳跃式的，空间局部性较差，所以这个程序有着较差的局部性。</p><hr><h1 id="存储器层次结构"><a href="#存储器层次结构" class="headerlink" title="存储器层次结构"></a>存储器层次结构</h1><p>软硬件的基本稳定特性：</p><ul><li>高速存储器技术成本高、容量小，且耗电大、易发热。</li><li>CPU 与存储器之间的速度差距越来越大。</li><li>编写良好的程序往往表现出良好的局部性。</li></ul><p>以上特性给出一条设计存储器系统的途径——存储器层次结构（memory hierarchy）。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220626191551044.png" alt="存储器层次结构" style="zoom:75%;" /><hr><h1 id="高速缓存-Cache"><a href="#高速缓存-Cache" class="headerlink" title="高速缓存 Cache"></a>高速缓存 Cache</h1><p><strong>高速缓存（Cache）：</strong></p><ul><li>一种更小、速度更快的存储设备。</li><li>作为更大、更慢存储设备的缓存区。</li></ul><p><strong>存储器层次结构的基本思想：</strong></p><ul><li>对于每个 $k$，位于 $k$ 层的更快更小存储设备作为位于 $k+1$ 层的更大更慢存储设备的缓存。</li></ul><p><strong>为什么存储器层次结构行得通？</strong></p><ul><li>因为局部性原理，程序访问第 $k$ 层的数据比访问第 $k+1$ 层的数据要频繁。</li><li>因为我们不经常访问第 $k+1$ 层的数据，所以第 $k+1$ 层的存储设备可以更慢、容量更大、价格更便宜。</li></ul><p><strong>存储器层次结构构建了一个大容量的存储池：</strong></p><ul><li>其存储容量大小大约等于最底层存储设备的大小、同时也像底层存储器一样廉价。</li><li>却可以以最高层存储设备的速度来访问。</li></ul><h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230212180510791.png" alt="高速缓存工作方式" style="zoom: 60%;" /><p>在任何时间点，高速缓存都保存主缓存器中块的一个子集。所以高速缓存的速度会更快，但是容量也更小、价格也更加的昂贵。</p><h2 id="缓存命中"><a href="#缓存命中" class="headerlink" title="缓存命中"></a>缓存命中</h2><p>当 CPU 请求的数据可以直接在高速缓存中发现的话，那么就可以直接从高速缓存中取出相应的数据块并返回给 CPU。这样会使得获取数据更快。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230212181013609.png" alt="高速缓存缓存命中" style="zoom:60%;" /><h2 id="缓存不命中"><a href="#缓存不命中" class="headerlink" title="缓存不命中"></a>缓存不命中</h2><p>当请求的数据在高速缓存中没有发现的时候，高速缓存会先从内存中取出相应的所需要的数据，将其复制到高速缓存中，然后再从缓存中将所请求的数据返回给 CPU。所以当缓存不命中的时候会需要更长的时间。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230212181126034.png" alt="高速缓存缓存不命中" style="zoom:55%;" /><h3 id="缓存不命中的种类"><a href="#缓存不命中的种类" class="headerlink" title="缓存不命中的种类"></a>缓存不命中的种类</h3><ul><li>冷不命中（强制不命中）<ul><li>最初高速缓存为空时，即没有存储任何块。对任何数据的请求都会不命中，此类不命中称为冷不命中。</li></ul></li><li>冲突不命中<ul><li>大多数缓存将第 $k+1$ 层的某个块限制放置在第 $k$ 层块的一个小的子集中（有时只是一个块）。<br>例如第 $k$ 层复制算法为 $k+1$ 层中第 $i$ 个块会复制到第 $k$ 层中第 $i \space mod\space 3$ 个位置中。那么我们不断循环请求第 0 个、第 3 个、第 6 个……块的数据时，高速缓存就会一直交替复制所请求的块到第 0 个位置，即使其他的位置都是空闲的。这就出现了冲突不命中 。</li><li>冲突不命中发生在缓存足够大，但是这些多个数据对象会映射到同 一个缓存块。</li></ul></li><li>容量不命中<ul><li>发生在当活跃块集合（工作集 working set）的大小比缓存容量大时。<br>例如高速缓存只能存储 4 个块，但是我们需要一次性请求 8 个块时，自然容量仅有 4 个块的高速缓存无法放下整个 8 个块的数组，便会出现容量不命中。</li></ul></li></ul><hr><h1 id="高速缓存存储器-Cache-Memories"><a href="#高速缓存存储器-Cache-Memories" class="headerlink" title="高速缓存存储器 Cache Memories"></a>高速缓存存储器 Cache Memories</h1><p>高速缓存存储器（Cache Memories）是小型的、快速的基于 SRAM 的存储器，是在硬件中自动管理的（非用户程序访问的）。存储器中存储着主存储器中经常访问的块。</p><p>CPU 首先查找该高速缓存存储器中的数据，这只需要花费几个「时钟周期」。</p><p>典型的系统结构如下图所示：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230214004659388.png" alt="典型的系统结构" style="zoom:60%;" /><p>其中现代 CPU 设计如下图所示：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230214004928678.png" alt="现代 CPU 设计" style="zoom:60%;" /><hr><h1 id="高速缓存存储器组织结构"><a href="#高速缓存存储器组织结构" class="headerlink" title="高速缓存存储器组织结构"></a>高速缓存存储器组织结构</h1><h2 id="高速缓存的基本设计思想"><a href="#高速缓存的基本设计思想" class="headerlink" title="高速缓存的基本设计思想"></a>高速缓存的基本设计思想</h2><p><strong>结构模块化：</strong></p><ul><li>CPU 访问 Cache 或主存时，<strong>以字为单位</strong>。 </li><li>Cache 和主存交换信息时，<strong>以块为单位</strong>（Cache 的一块也称为一行），一次读入一块或多块内容；每块由若干个字组成。</li><li>Cache 的每行都设置有标记，CPU 访问程序或数据时，先访问标记。</li></ul><p>此结构<strong>全部由硬件实现</strong>。</p><p>Cache 对程序员是<strong>透明</strong>的，即程序员不必知道是否存在 Cache。</p><h2 id="高速缓存的基本构成"><a href="#高速缓存的基本构成" class="headerlink" title="高速缓存的基本构成"></a>高速缓存的基本构成</h2><ol><li><p><strong>存储体</strong></p><p>基本单位为字，若干个字构成一个数据块。</p></li><li><p><strong>地址映射变换机构</strong></p><p>用于将主存地址变换为 Cache 地址，以利用 CPU 发送的主存地址访问 Cache。</p></li><li><p><strong>替换机构</strong></p><p>若要更新 Cache 中数据时使用的机制。</p></li><li><p><strong>相联存储器</strong></p><p>Cache 的<strong>块表</strong>，快速指示所要访问的信息是否在 Cache 中。</p></li><li><p><strong>读写控制</strong></p></li></ol><h2 id="主存与-Cache-的地址映射"><a href="#主存与-Cache-的地址映射" class="headerlink" title="主存与 Cache 的地址映射"></a>主存与 Cache 的地址映射</h2><p><strong>信息从主存到 Cache 中，如何定位？</strong></p><p>Cache 的容量小于主存，需要采用某种算法确定主存和 Cache 中块的对应关系。</p><p><strong>地址映射</strong></p><p>CPU 访存时，将主存地址按某种映射函数关系变换成 Cache 地址的过程。</p><p><strong>地址映射的方式</strong></p><p>直接映射、组相联映射、全相联映射。</p><h2 id="高速缓存结构图"><a href="#高速缓存结构图" class="headerlink" title="高速缓存结构图"></a>高速缓存结构图</h2><p>高速缓存是一个高速缓存组的数组。每个组包含 一个或多个高速缓存行，每个行包含一个有效位，一些标记位，以及一个数据块。</p><p>有效位（valid bit）指明这个行是否包含有意义的信息。有效位的长度为 1 个 bit。当 valid 等于 1 时，表示数据有效；当 valid 等于 0 时，表示数据无效。</p><p>标记位唯一地标识存储在这个高速缓存行中的块：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230214013032852.png" alt="高速缓存结构图" style="zoom:63%;" /><p>每个存储器地址有 $m$ 位，形成 $M&#x3D;2^m$ 个不同的地址。高速缓存的结构将 $m$ 个地址位划分成了 $t$ 个标记位、 $s$ 个组索引位和 $b$ 个块偏移位：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230214013237057.png" alt="高速缓存的结构" style="zoom:67%;" /><p>一般而言，高速缓存的结构可以用元组 $(S,\space E,\space B,\space m)$ 来描述。高速缓存的大小（或容量）$C$ 指的是所有块的大小的和。标记位和有效位不包括在内。因此， $C &#x3D; S \times E \times B$ 。</p><h2 id="高速缓存的读取方法"><a href="#高速缓存的读取方法" class="headerlink" title="高速缓存的读取方法"></a>高速缓存的读取方法</h2><p>当一条加载指令指示 CPU 从主存地址 A 中读一个字时，它将地址 A 发送到高速缓 存。如果高速缓存正保存着地址 A 处那个字的副本，它就立即将那个字发回给 CPU。</p><p>那么高速缓存如何知道它是否包含地址 A 处那个字的副本的呢？</p><p>参数 $S$ 和 $B$ 将 $m$ 个地址位分为了三个字段。</p><p>地址 A 中的 $s$ 个组索引位是一个到 $S$ 个组的数组的索引。第一个组是组 $0$，第二个组是组 $1$，依此类推。组索引位被解释为一个无符号整数，它告诉我们这个字必须存储在哪个组中。</p><p>一旦我们知道了这个字必须放在哪个组中， A 中的 $t$ 个标记位就告诉我们这个组中的哪一行包含这个字（如果有的话）。当且仅当设置了有效位并且该行的标记位与地址 A 中的标记位相匹配时，组中的这一行才包含这个字。</p><p>一旦我们在由组索引标识的组中定位了由标号所标识的行，那么 $b$ 个块偏移位给出了在 $B$ 个字节的数据块中的字偏移。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E8%AF%BB%E5%8F%96%E6%96%B9%E6%B3%95.jpg" alt="高速缓存的读取方法" style="zoom: 50%;" /><h2 id="直接映射高速缓存"><a href="#直接映射高速缓存" class="headerlink" title="直接映射高速缓存"></a>直接映射高速缓存</h2><p>$E&#x3D;1$。即每个组只有一行。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230214125911666.png" alt="" style="zoom:67%;" /><h3 id="抽取被请求的字的过程"><a href="#抽取被请求的字的过程" class="headerlink" title="抽取被请求的字的过程"></a>抽取被请求的字的过程</h3><ol><li><p><strong>组选择</strong></p><p>高速缓存从 $w$ 的地址中间抽取出 $s$ 个组索引位。这些位被解释成一个对应于一个组号的无符号整数 。换句话来说，如果我们把高速缓存看成是一个关于组的一维数组，那么这些组索引位就是一个到这个数组的索引 。  </p><p>在下图中，组索引位 $00001_2$ 被解释为一个选择组 $1$ 的整数索引。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230214130547741.png" alt="" style="zoom: 60%;" /></li><li><p><strong>行匹配</strong></p><p>在上一步中我们已经选择了某个组 $i$ 接下来的一步就要确定是否有字 $w$ 的一个副本存储在组 $1$ 包含的一个高速缓存行中。</p><p>因为每个组只有一行。所以当且仅当设置了有效位，而且高速缓存行中的标记与 $w$ 的地址中的标记相匹配时，这一行中包含 $w$ 的一个副本。</p></li><li><p><strong>字选择</strong></p><p>一旦命中，我们知道 $w$ 就在这个块中的某个地方。块偏移位提供了所需要的字的第一个字节的偏移。</p><p>在下图中，块偏移位是 $100_2$ 它表明 $w$ 的副本是从块中的字节 $4$ 开始的（我们假设字长为 4 字节）。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230214131025138.png" alt="" style="zoom: 60%;" /></li><li><p><strong>缓存不命中时的行替换</strong></p><p>如果缓存不命中，那么它需要从存储器层次结构中的下一层取出被请求的块 ，然后将新的块存储在组索引位指示的组中的一个高速缓存行中。 </p><p>一般而言，如果组中都是有效高速缓存行了，那么必须要驱逐出一个现存的行 。</p><p>对于直接映射高速缓存来说，每个组只包含有一行，替换策略非常简单：<strong>用新取出的行替换当前的行</strong>。</p></li></ol><h3 id="直接映射高速缓存的优点"><a href="#直接映射高速缓存的优点" class="headerlink" title="直接映射高速缓存的优点"></a>直接映射高速缓存的优点</h3><ul><li>硬件简单</li><li>成本低</li><li>地址变换速度快</li></ul><h3 id="直接映射高速缓存的缺点"><a href="#直接映射高速缓存的缺点" class="headerlink" title="直接映射高速缓存的缺点"></a>直接映射高速缓存的缺点</h3><ul><li>每个主存块只有一个固定的行位置可存放。两个块映射到同一 Cache 行时就会发生冲突。发生冲突会导致频繁的置换，使 Cache 效率下降。</li></ul><h2 id="组相联高速缓存"><a href="#组相联高速缓存" class="headerlink" title="组相联高速缓存"></a>组相联高速缓存</h2><p>满足 $1 &lt; E &lt; C&#x2F;B$ 时，我们可以称该 cache 为 $E$ 路组相联高速缓存。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230214155544592.png" alt="2 路组相联高速缓存" style="zoom:50%;" /><ol><li><p><strong>组选择</strong></p><p>它的组选择与直接映射高速缓存的组选择一样，组索引位标识组。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230214155735302.png" alt="" style="zoom:50%;" /></li><li><p><strong>行匹配和字选择</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230214155800033.png" style="zoom:50%;" /></li><li><p><strong>缓存不命中时的行替换</strong></p><p>如果 CPU 请求的字不在组的任何一行中，那么就是缓存不命中，高速缓存必须从内存中取出包含这个字的块。不过，一旦高速缓存取出了这个块，该替换哪个行呢？</p><p>最简单的替换策略是随机选择要替换的行。其他更复杂的策略利用了局部性原理，以使在比较近的将来引用被替换的行的概率最小。例如：</p><ul><li>最不常使用（Least-Frequently-Used, LFU）策略会替换在过去某个时间窗口内引用次数最少的那一行。</li><li>最近最少使用（Least­ Recently-Used, LRU）策略会替换最后一次访问时间最久远的那一行。</li></ul><p>所有这些策略都需要额外的时间和硬件。</p></li></ol><h3 id="组相联高速缓存的特点"><a href="#组相联高速缓存的特点" class="headerlink" title="组相联高速缓存的特点"></a>组相联高速缓存的特点</h3><ul><li><strong>灵活性：</strong>比直接映射灵活（主存可映射到组内任一块）。</li><li><strong>快速性：</strong>比较次数少，只需组内全部比较，电路也较易于实现。</li></ul><h2 id="全相联高速缓存"><a href="#全相联高速缓存" class="headerlink" title="全相联高速缓存"></a>全相联高速缓存</h2><p>当 $E&#x3D;C&#x2F;B$ 时，称为全相联高速缓存。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230214161911646.png" style="zoom: 55%;" /><ol><li><p><strong>组选择</strong></p><p>全相联高速缓存中的组选择非常简单，因为只有一个组。注意地址中没有组索引位，地址只被划分成了一个标记和一个块偏移。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230214162048800.png" style="zoom:50%;" /></li><li><p><strong>行匹配和字选择</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230214162130551.png" style="zoom:50%;" /></li></ol><h3 id="全相联映射的优点"><a href="#全相联映射的优点" class="headerlink" title="全相联映射的优点"></a>全相联映射的优点</h3><ul><li><p>灵活性好(最理想)</p><p>Cache 中只要有空行，就可以调入所需要的主存数据块。</p></li></ul><h3 id="全相联映射的缺点"><a href="#全相联映射的缺点" class="headerlink" title="全相联映射的缺点"></a>全相联映射的缺点</h3><ul><li><p>成本高</p><p>标记位较长，使 cache 标记容量变大。</p></li><li><p>速度慢</p><p>访问 cache 时，需将所有标记比较一遍，才能最后判出所需主存中的字块是否在 cache 中。</p></li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>深入理解计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>存储器层次结构</tag>
      
      <tag>高速缓存存储器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP3e-学习笔记-第五章</title>
    <link href="/posts/9c6f6c4f5944/"/>
    <url>/posts/9c6f6c4f5944/</url>
    
    <content type="html"><![CDATA[<h1 id="CPE"><a href="#CPE" class="headerlink" title="CPE"></a>CPE</h1><p>引入度量标准<strong>每元素的周期数</strong>（$Cycles \space Per \space Element$，$CPE$），作为一种表示程序性能并指导我们改进代码的方法。</p><ul><li><code>CPE</code> 这种度量标准帮助我们在更细节的级别上理解迭代程序的循环性能。这样的度量标准对执行重复计算的程序来说是很适当的，例如处理图像中的像素，或是计算矩阵乘积中的元素。</li><li>表示向量或列表操作的程序性能的方便方式</li><li>时钟频率为 $4 \space GHz$ 的处理器：<ul><li>处理器时钟运行频率为每秒 $4×10^9$ 个周期。</li><li>每个时钟周期的时间是时钟频率的倒数（$0.25$ 纳秒）。</li><li>用时钟周期来表示度量标准要比用纳秒表示有帮助得多，用时钟周期来表示，度量值表示的是执行了多少条指令， 而不是时钟运行得有多快。</li></ul></li></ul><h2 id="CPE-的图像表示"><a href="#CPE-的图像表示" class="headerlink" title="CPE 的图像表示"></a>CPE 的图像表示</h2><p>$$<br>T &#x3D; CPE \times Length + Overhead<br>$$</p><ul><li>$Length$：循环次数 $n$。</li><li>$CPE$：直线的斜率 $Slope$。$CPE$ 数值越小，程序的性能越好。</li><li>$Overhead$：经常的开销&#x2F;费用。</li><li>$T$：程序在该循环次数的总耗时。</li></ul><p>下面展示了同一个程序的两种优化方式的性能图像（$T&#x3D;368+Slope \times n$）。</p><p>可以发现，下面的直线 $CPE$ 数值较小，其程序性能也更好。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230211175139286.png" style="zoom:50%;" /><hr><h1 id="妨碍优化的因素"><a href="#妨碍优化的因素" class="headerlink" title="妨碍优化的因素"></a>妨碍优化的因素</h1><ol><li>函数调用</li><li>别名引用</li></ol><hr><h1 id="程序优化的方法"><a href="#程序优化的方法" class="headerlink" title="程序优化的方法"></a>程序优化的方法</h1><h2 id="代码移动"><a href="#代码移动" class="headerlink" title="代码移动"></a>代码移动</h2><p>观察下列代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">getLength</span>(); i++) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>将上述代码中的 <code>for</code> 循环进行如下优化的方式叫做<strong>代码移动</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> length = <span class="hljs-built_in">getLength</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过上述的操作，将 <code>getLength()</code> 函数提出到循环之外，由原来需要进行 <code>length</code> 次计算变为只需要一次计算，大大减少的计算量。</p><p>但是由于编译器无法确定 <code>getLength()</code> 函数是否存在副作用，所以不会在代码优化的时候主动进行该类代码移动。 </p><h2 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h2><p>通过减少循环次数以及将数据并行处理以提高程序的性能。</p><hr><h1 id="理解现代处理器"><a href="#理解现代处理器" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h1><h2 id="利用指令级并行"><a href="#利用指令级并行" class="headerlink" title="利用指令级并行"></a>利用指令级并行</h2><ul><li>需要理解现代处理器的设计<ul><li>硬件可以并行执行多个指令</li></ul></li><li>性能受数据依赖的限制</li><li>简单的转换可以带来显著的性能改进<ul><li>编译器通常无法进行这些转换</li><li>浮点运算缺乏结合性和可分配性</li></ul></li></ul><h2 id="整体操作"><a href="#整体操作" class="headerlink" title="整体操作"></a>整体操作</h2><ul><li>指令级并行：在代码级上，看上去似乎是一次执行一条指令，每条指令都包括从寄存器或内存取值，执行一个操作，并把结果存回到一个寄存器或内存位置。在实际的处理器中，是<strong>同时对多条指令求值的</strong>。</li><li>描述程序性能的两个下界：<ul><li>延迟界限：一系列操作必须按照严格顺序执行，因为在下一 条指令开始之前，这条指令必须结束。主要是代码中的数据 相关限制了处理器利用指令级并行的能力。</li><li>吞吐量界限：刻画了处理器功能单元的原始计算能力。这个 界限是程序性能的终极限制。</li></ul></li></ul><h2 id="超标量-Superscalar-处理器"><a href="#超标量-Superscalar-处理器" class="headerlink" title="超标量 Superscalar 处理器"></a>超标量 Superscalar 处理器</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230211180300266.png" style="zoom:67%;" /><ul><li>控制单元 <code>ICU</code>：从内存中读出指令序列，并根据这些指令 序列生成一组针对程序数据的基本操作</li><li>执行单元 <code>EU</code>：执行ICU产生的基本操作</li></ul><h2 id="功能单元"><a href="#功能单元" class="headerlink" title="功能单元"></a>功能单元</h2><p>Intel Core i7 Haswell 参考机有 8 个功能单元，编号为 0~7。下面部分列出了每个单元的功能： </p><table><thead><tr><th align="right">编号</th><th>功能</th></tr></thead><tbody><tr><td align="right">0</td><td>整数运算、浮点乘、整数和浮点数除法、分支</td></tr><tr><td align="right">1</td><td>整数运算、浮点加、整数乘、浮点乘</td></tr><tr><td align="right">2</td><td><strong>加载</strong>、地址计算</td></tr><tr><td align="right">3</td><td><strong>加载</strong>、地址计算</td></tr><tr><td align="right">4</td><td><strong>存储</strong></td></tr><tr><td align="right">5</td><td>整数运算</td></tr><tr><td align="right">6</td><td>整数运算、分支</td></tr><tr><td align="right">7</td><td><strong>存储</strong>、地址计算</td></tr></tbody></table><p>可并行执行多条指令：</p><ul><li>2 个加载，带地址计算</li><li>1个存储 ，带地址计算</li><li>4 个整数运算</li><li>2 个浮点乘法运算 </li><li>1 个浮点加法 </li><li>1 个浮点除法</li></ul><h2 id="功能单元的性能"><a href="#功能单元的性能" class="headerlink" title="功能单元的性能"></a>功能单元的性能</h2><ul><li><p>延迟：表示完成运算所需要的总时间。表明执行实际运算所需要的时钟周期总数</p></li><li><p>发射时间：表示两个连续的同类型的运算之间需要的最小时间。表明两次运算之间间隔的最小周期数</p></li><li><p>容量：表示能够执行该运算的功能单元的数量。表明同时能发射多少个这样的操作</p></li><li><p>最大吞吐量：定义为发射时间的倒数</p></li><li><p>延迟界限：给出了任何必须按照严格顺序完成合并运算的函数所需的最小 CPE 值</p></li><li><p>吞吐量界限：给出了 CPE 的最小界限</p></li></ul><hr><h1 id="优化中的限制因素"><a href="#优化中的限制因素" class="headerlink" title="优化中的限制因素"></a>优化中的限制因素</h1><h2 id="寄存器溢出"><a href="#寄存器溢出" class="headerlink" title="寄存器溢出"></a>寄存器溢出</h2><p>x86-64 有 16 个寄存器，16 个 <code>ymm</code> 寄存器保存浮点数。</p><p>当并行数量大于 16 时，部分数据将存入栈中，此时每次操作数据便会额外从栈中读取数据以及向栈中存入数据。程序整体性能将会减弱。</p><hr><h1 id="应用：性能提高的技术"><a href="#应用：性能提高的技术" class="headerlink" title="应用：性能提高的技术"></a>应用：性能提高的技术</h1><ul><li>高级设计：避免使用那些会渐进地产生糟糕性能的算法或编码技术。</li><li>基本编码原则：避免限制优化的因素，这样编译器就能产生 高效的代码。<ul><li>消除连续的函数调用。在可能时，将计算移到循环外。考虑有选择 地妥协程序的模块性以获得更大的效率。</li><li>消除不必要的内存引用。引人临时变量来保存中间结果。只有在最 后的值计算出来时，才将结果存放到数组或全局变量中。</li></ul></li><li>低级优化<ul><li>展开循环，降低开销，并且使得进一步的优化成为可能。</li><li>通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行。</li><li>用功能性的风格重写条件操作，使得编译采用条件数据传送</li></ul></li></ul><hr><h1 id="习题整理"><a href="#习题整理" class="headerlink" title="习题整理"></a>习题整理</h1><blockquote><hr>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 1</span><br>&#123;<br>   *xp += *yp; <br>   *xp += *yp;<br>&#125; <br><span class="hljs-comment">// 2</span><br>&#123;<br>   *xp += <span class="hljs-number">2</span> * (*yp);<br>&#125;<br></code></pre></td></tr></table></figure><p>  无论何种情况下，以上两个代码块行为相同（ B ）<br>  A. 对<br>  B. 错</p></blockquote><p>当 <code>xp</code> 和 <code>yp</code> 同时指向同一个地址时，第一个代码块的结果为 <code>4(*xp)</code>，而第二个代码块的结果为 <code>3(*xp)</code>。</p><blockquote><hr><p>  <code>f1</code> 和 <code>f2</code> 是两个浮点数，关于下面两条语句，说法正确的是（ D ）</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">f1 = (f1 + f2) + f2; <span class="hljs-comment">// 第一条 </span><br>f1 = f1 + (f2 + f2); <span class="hljs-comment">// 第二条</span><br></code></pre></td></tr></table></figure><p>  A. 第一条执行时间快<br>  B. 第二条执行时间快<br>  C. 两条语句执行结果相同<br>  D. 两条语句执行结果可能不同</p></blockquote><p>具体内容可重新查看《深入理解计算机系统》第一、二章内容。</p><blockquote><hr><p>  关于现代微处理器，下面描述正确的是（ A B C D ）<br>  A. 可以在每个时钟周期执行多个操作。<br>  B. 指令执行的顺序不一定要与他们在机器级程序中的顺序一致。<br>  C. 指令控制单元负责从内存中读出指令序列，并据其生成一组针对程序数据的基本操作。<br>  D. 执行单元执行指令控制单元生成的操作。</p></blockquote><p>《深入理解计算机系统》5.7 理解现代处理器：</p><p>现代微处理器取得的了不起的功绩之一是：它们采用复杂而奇异的微处理器结构，其中，<strong>多条指令可以并行地执行</strong>，同时又呈现出一种简单的顺序执行指令的表象。</p><p>这些处理器在工业界称为超标量 (superscalar) , 意思是 <strong>它可以在每个时钟周期执行多个操作</strong>，而且是乱序的 (out-of-order) , 意思就是<strong>指令执行的顺序不一定要与它们在机器级程序中的顺序一致</strong>。</p><p>整个设计有两个主要部分：<strong>指令控制单元</strong> (Instruction Control Unit, ICU) 和 <strong>执行单元</strong> (Execution Unit, EU) 。<strong>前者负责从内存中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作；而后者执行这些操作。</strong></p><blockquote><hr><p>  下列说法正确的是（ A B D ）<br>  A. 现代处理器有专门的功能单元来执行加载和存储操作。<br>  B. 对于寄存器操作，在指令被译码成操作的时候，处理器就可以确定哪些指令会影响其他哪些指令。<br>  C. 对于内存操作，在指令被译码成操作的时候，处理器就可以确定哪些指令会影响其他哪些指令。<br>  D. 对于内存操作，只有到加载和存储的地址被计算出来以后，处理器才能确定哪些指令会影响其他哪些指令。</p></blockquote><ul><li><p><strong>5.7 理解现代处理器：</strong></p><p>Intel Core i7 Haswell 参考机有 8 个功能单元，编号为 0~7。下面部分列出了每个单元的功能： </p><table><thead><tr><th align="right">编号</th><th>功能</th></tr></thead><tbody><tr><td align="right">0</td><td>整数运算、浮点乘、整数和浮点数除法、分支</td></tr><tr><td align="right">1</td><td>整数运算、浮点加、整数乘、浮点乘</td></tr><tr><td align="right">2</td><td><strong>加载</strong>、地址计算</td></tr><tr><td align="right">3</td><td><strong>加载</strong>、地址计算</td></tr><tr><td align="right">4</td><td><strong>存储</strong></td></tr><tr><td align="right">5</td><td>整数运算</td></tr><tr><td align="right">6</td><td>整数运算、分支</td></tr><tr><td align="right">7</td><td><strong>存储</strong>、地址计算</td></tr></tbody></table></li><li><p><strong>5.12.2 存储的性能</strong></p><p>对于 <strong>寄存器操作</strong>，在指令被译码成操作的时候，处理器就可以确定哪些指令会影响其他哪些指令。</p><p>另一方面，对于 <strong>内存操作</strong>，只有到计算出加载和存储的地址被计算出来以后，处理器才能确定哪些指令会影响其他的哪些。</p></li></ul><blockquote><hr><p>  编写高效程序，下列说法正确的是（ A C ）<br>  A. 程序员必须选择一组适当的算法和数据结构。<br>  B. 大多数编译器会优化程序员给出的算法和数据结构。<br>  C. 程序员必须编写出编译器能够有效优化以转换成高效可执行代码的源代码。<br>  D. 大多数编译器可以轻易优化 C 语言的指针运算。</p></blockquote><p>《深入理解计算机系统》第五章 优化程序性能：</p><p>编写高效程序需要做到以下几点：第一，<strong>我们必须选择一组适当的算法和数据结构</strong>。第二，<strong>我们必须编写出编译器能够有效优化以转换成高效可执行代码的源代码</strong>。C 语言的有些特性，例如<strong>执行指针运算</strong>和强制类型转换的能力，<strong>使得编译器很难对它进行优化</strong>。</p><p>优化编译器会试着进行代码移动。不幸的是，就像前面讨论过的那样，对于会改变在哪里调用函数或调用多少次的变换，编译器通常会非常小心。<strong>它们不能可靠地发现一个函数是否会有副作用</strong>，因而假设函数会有副作用，并保持所有的函数调用不变。</p>]]></content>
    
    
    <categories>
      
      <category>深入理解计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Program Optimization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UML 类图详解</title>
    <link href="/posts/4f89fbcb913c/"/>
    <url>/posts/4f89fbcb913c/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>下文中的示例代码可能不符合实际开发情况，仅作为 UML 类图演示。</p>          </div><hr><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>UML 类图是使用最频繁的 UML 图之一。</p><p>类图是面向对象系统建模中最常用和最重要的图，是定义其它图的基础。类图主要是用来显示系统中的类、接口以及它们之间的静态结构和关系的一种静态模型。类图中最基本的元素是类、接口。软件设计师设计出类图后，程序员就可以用代码实现类图中包含的内容。</p><hr><h1 id="类、接口和包的表示方法"><a href="#类、接口和包的表示方法" class="headerlink" title="类、接口和包的表示方法"></a>类、接口和包的表示方法</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类（具体类和抽象类）在类图中用矩形框表示，矩形框分为三层：第一层是类名字；第二层是类的成员变量；第三层是类的方法。</p><div class="note note-info">            <p>更多具体规范可以查看：<a href="https://www.visual-paradigm.com/guide/uml-unified-modeling-language/what-is-class-diagram/"><em>What is Class Diagram? (visual-paradigm.com)</em></a></p>          </div><p>UML 规定类图中属性的表示方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs uml">可见性 名称 : 类型 [ = 缺省值]<br></code></pre></td></tr></table></figure><p>类图中的方法可以表示为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs uml">可见性 方法名 (参数名 : 参数类型) : 返回值类型<br></code></pre></td></tr></table></figure><p>其中，方法的多个参数间用逗号隔开，无返回值时，其类型为 <code>void</code>。</p><p>成员变量以及方法前的访问修饰符用符号来表示（即表示方法中的<strong>可见性</strong>部分）：</p><ul><li><code>-</code>：表示 <code>private</code></li><li><code>#</code>：表示 <code>protected</code></li><li><code>~</code>：表示 <code>default</code>，也就是包权限</li><li><code>_</code>：表示 <code>static</code></li><li><code>+</code>：表示 <code>public</code></li><li><code>斜体</code>：表示 <code>abstract</code>，<strong>抽象类的类名</strong>以及抽象方法的名字都需要用斜体字表示</li></ul><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> name; &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> age; &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123; <span class="hljs-built_in">this</span>.name = name; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230119220818088.png" alt="" style="zoom:67%;" /></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口在类图中也是用矩形框表示，但是与类的表示法不同的是，接口在类图中的第一层顶端用构造型 <code>«interface»</code> 表示，下面是接口的名字，第二层是方法。</p><p>接口中方法和类中方法的表示形式一样。</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">getCircumference</span><span class="hljs-params">()</span><br>&#125;<br></code></pre></td></tr></table></figure>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230119221447542.png" alt="" style="zoom:67%;" /></blockquote><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>类和接口一般都出现在包中，UML 类图中包的表示形式如下图所示。</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> AAA;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BBB</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230119222716762.png" alt="" style="zoom: 67%;" /></blockquote><hr><h1 id="类图中的关系"><a href="#类图中的关系" class="headerlink" title="类图中的关系"></a>类图中的关系</h1><p>UML 类图中共有 6 种关系，如下图所示：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/UML%E7%B1%BB%E5%9B%BE%E5%85%B3%E7%B3%BB.png" alt="UML-类图关系" style="zoom: 75%;" /><h2 id="实现关系-Realization"><a href="#实现关系-Realization" class="headerlink" title="实现关系 Realization"></a>实现关系 Realization</h2><p>很多面向对象编程语言（如 <code>Java</code>）中都引入了接口的概念。实现关系是指接口及其实现类之间的关系。在 <code>Java</code> 代码中，实现关系可以直接翻译为关键字 <code>implements</code>。</p><p>在 UML 类图中，实现关系用空心三角和虚线组成的箭头来表示，箭头指向方法为从实现类指向接口。</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FileSaveable</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FileSavealbe</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230124220612234.png" alt="" style="zoom:67%;" /></blockquote><h2 id="泛化关系-Generalization"><a href="#泛化关系-Generalization" class="headerlink" title="泛化关系 Generalization"></a>泛化关系 Generalization</h2><p>泛化关系，用于描述父类与子类之间的关系，其中父类又称作超类，子类又称为派生类。注意，父类和子类都可为抽象类或者具体类。</p><p>在 <code>Java</code> 代码中，对象之间的泛化关系可以直接翻译为关键字 <code>extends</code>。</p><p>在 UML 类图中泛化关系使用一条实线空心箭头由子类指向父类。</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Animal</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230125151514457.png" alt="" style="zoom:67%;" /></blockquote><h2 id="关联关系-Association"><a href="#关联关系-Association" class="headerlink" title="关联关系 Association"></a>关联关系 Association</h2><p>关联关系是指对象和对象之间的连接，它使一个对象知道另一个对象的属性和方法。在 <code>Java</code> 中实现关联关系时，通常将一个类的对象作为另一个类的成员变量。</p><p>在 UML 类图中，用实线连接有关联关系的类，并可在关联线上标注角色名或关系名。</p><p>关联关系有双向关联、单向关联、自关联和多重性关联四种，下面将分别介绍。</p><h3 id="双向关联"><a href="#双向关联" class="headerlink" title="双向关联"></a>双向关联</h3><p>如果两个对象都知道（即可以调用）对方的公共属性和操作，那么二者就是双向关联。</p><p>在 UML 图中，双向关联关系用带双箭头的实线或者无箭头的实线表示。</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseAdmin</span> &#123;<br>    <span class="hljs-keyword">private</span> Database database;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Database</span> &#123;<br>    <span class="hljs-keyword">private</span> DatabaseAdmin admin;<br>&#125;<br></code></pre></td></tr></table></figure>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230125155839310.png" alt="" style="zoom:67%;" /></blockquote><h3 id="单向关联"><a href="#单向关联" class="headerlink" title="单向关联"></a>单向关联</h3><p>如果只有一个对象知道（即可以调用）另一个对象的公共属性和操作，那么就是单向关联。大多数关联都是单向关联，单向关联关系更容易建立和维护，有助于寻找可重用的类。</p><p>在 UML 图中，单向关联用一个带箭头的实线表示，箭头指向被关联的对象。</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> BaseInfo info;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseInfo</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230125171648122.png" style="zoom:67%;" /></blockquote><h3 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h3><p>自关联指属性类型为该类本身。例如在链表中，每个节点持有下一个节点的实例。</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">private</span> Node next;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230125174525114.png" alt="" style="zoom:67%;" /></blockquote><h3 id="多重性关联"><a href="#多重性关联" class="headerlink" title="多重性关联"></a>多重性关联</h3><p>一个对象可以持有其它对象的数组或者集合。多重性关联关系，表示两个对象在数量上的对应关系。</p><p>在 UML 类图中，通过放置多重性表达式在关联线的末端来表示。多重性表达式可以是一个数字、一段范围或者是它们的组合。常见的多重性表达式如下所示。</p><table><thead><tr><th>表达式</th><th>含义</th></tr></thead><tbody><tr><td><code>m</code>（数字）</td><td>另一个类的一个对象与该类的 <code>m</code> 个对象有关系</td></tr><tr><td><code>0..*</code></td><td>另一个类的一个对象只与该类的零个或多个对象有关系</td></tr><tr><td><code>0..1</code></td><td>另一个类的一个对象与该类的对象没关系或者只与该类的一个对象有关系</td></tr><tr><td><code>1..*</code></td><td>另一个类的一个对象与该类的一个或多个对象有关系</td></tr><tr><td><code>m..n</code></td><td>另一个类的一个对象与该类最少 <code>m</code>，最多 <code>n</code> 个对象有关系</td></tr></tbody></table><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> Task[] tasks;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>&#125;<br></code></pre></td></tr></table></figure>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230125183225931.png" alt="" style="zoom:67%;" /></blockquote><h2 id="依赖关系-Dependency"><a href="#依赖关系-Dependency" class="headerlink" title="依赖关系 Dependency"></a>依赖关系 Dependency</h2><p>依赖（Dependency）关系是一种弱关联关系。如果对象 A 用到对象 B，但是和 B 的关系不是太明显的时候，就可以把这种关系看作是依赖关系。如果对象 A 依赖于对象 B，则 A “use a” B。</p><p>在 UML 类图中，依赖关系用一个带虚线的箭头表示，由使用方指向被使用方，表示使用方对象持有被使用方对象的引用。</p><p>在 <code>Java</code> 代码中，依赖关系的表现形式体现为以下的 4 个方面：</p><ol><li><p>B 类的实例作为 A 类<strong>构造器或方法的参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// A : class Driver</span><br><span class="hljs-comment">// B : class Car</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">drive</span><span class="hljs-params">(Car car)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>B 类的实例作为 A 类<strong>构造器或方法的局部变量</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// A : class Driver</span><br><span class="hljs-comment">// B : class Car</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>B 类的实例作为 A 类<strong>方法的返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// A : class Driver</span><br><span class="hljs-comment">// B : class Car</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>A 类调用 B 类的<strong>静态方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// B : 被使用方</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// A : 使用方</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        B.method1();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>  B 类的实例作为 A 类构造器或方法的参数的示例</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// A : class Driver</span><br><span class="hljs-comment">// B : class Car</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">drive</span><span class="hljs-params">(Car car)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230125190925502.png" alt="" style="zoom:75%;" /></blockquote><h2 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="聚合关系 Aggregation"></a>聚合关系 Aggregation</h2><p>聚合是关联关系的一种特例，它体现的是整体与部分的拥有关系，即 “has a” 的关系。此时整体与部分之间是可分离的，它们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享，所以聚合关系也常称为共享关系。</p><p>从代码实现上来讲，<strong>部分对象不由整体对象创建</strong>，一般通过<strong>整体类的带参构造方法或者 Setter 方法或者其它业务方法</strong>传入到整体对象，并且有整体对象以外的对象持有部分对象的引用。</p><p>在 UML 类图中，聚合关系用空心菱形加实线箭头表示，空心菱形在整体一方，箭头指向部分一方。</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Department</span> &#123;<br>    <span class="hljs-keyword">private</span> Employee employee;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEmployee</span><span class="hljs-params">(Employee e)</span> &#123;<br>        <span class="hljs-built_in">this</span>.employee = e;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230125195013885.png" alt="" style="zoom:75%;" /></blockquote><p>设计模式装饰模式中，装饰类的对象与被装饰类的对象即为聚合关系。</p><h2 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系 Composition"></a>组合关系 Composition</h2><p>组合也是关联关系的一种特例，它同样体现整体与部分间的包含关系，即 “contains a” 的关系。但此时整体与部分是不可分的，部分也不能给其它整体共享，作为整体的对象负责部分的对象的生命周期，一旦整体对象不存在了，成员对象也即随之消亡。这种关系比聚合更强，也称为强聚合。</p><p>从代码实现上看，一般在整体类的构造方法中<strong>直接实例化成员类</strong>，并且<strong>除整体类对象外，其它类的对象无法获取该对象的引用</strong>。</p><p>在 UML 图中，组合关系用实心菱形加实线箭头表示，实心菱形在整体一方，箭头指向部分一方。</p><blockquote>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230125200949300.png" alt="" style="zoom:75%;" /></blockquote><p>设计模式代理模式中，代理类的对象与被代理类的对象即为组合关系。</p><hr><h1 id="易混淆解析"><a href="#易混淆解析" class="headerlink" title="易混淆解析"></a>易混淆解析</h1><blockquote><p>  依赖关系与关联关系的区别是？</p></blockquote><p>依赖关系是较弱的关系，一般表现为在局部变量中使用被依赖类的对象、以被依赖类的对象作为方法参数或返回值以及使用被依赖类的静态方法。</p><p>而关联关系是相对较强的关系，一般表现为一个类包含一个类型为另外一个类的属性。</p><blockquote><p>  聚合关系、组合关系与关联关系有何区别和联系？</p></blockquote><p>聚合关系、组合关系和关联关系实质上是对象间的关系（继承和实现是类与类和类与接口间的关系）。</p><p>从语意上讲，关联关系中两种对象间一般是平等的，而聚合和组合则代表整体和部分间的关系。聚合与组合的区别主要体现在实现上和生命周期的管理上。</p><blockquote><p>  聚合关系与组合关系都表示整体与部分的关系，有何区别？</p></blockquote><p>聚合关系中，部分对象的生命周期独立于整体对象的生命周期，或者整体对象消亡后部分对象仍然可以独立存在。</p><p>组合关系中，部分类对象的生命周期由整体对象控制，一旦整体对象消亡，部分类的对象随即消亡。</p><p>同时在组合关系中，部分类的对象只属于某一个确定的整体类对象；而在聚合关系中，部分类对象可以属于一个或多个整体类对象。</p><hr><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><p><a href="https://zhuanlan.zhihu.com/p/109655171">30分钟学会UML类图 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1146291">UML(一) 类图详解 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android 设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 设计模式 - 策略模式</title>
    <link href="/posts/37720c1cfb0d/"/>
    <url>/posts/37720c1cfb0d/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>考虑下面的一段没有实际用处的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> animalPrinter = AnimalPrinter()<br>    animalPrinter.printAnimal(<span class="hljs-string">&quot;CAT&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalPrinter</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printAnimal</span><span class="hljs-params">(animal: <span class="hljs-type">String</span>)</span></span> &#123;<br>        <span class="hljs-keyword">when</span> (animal) &#123;<br>            <span class="hljs-string">&quot;CAT&quot;</span> -&gt; printCat()<br>            <span class="hljs-string">&quot;DOG&quot;</span> -&gt; printDog()<br>            <span class="hljs-string">&quot;PARROT&quot;</span> -&gt; printParrot()<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printCat</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;I have a cat.&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printDog</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;I have a dog&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printParrot</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;I have a parrot&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们需要在 <code>main</code> 函数中输出其他的动物时，就需要在 <code>AnimalPrinter#printAnimal</code> 函数中添加新的动物以及对应的实现逻辑，同时在 <code>AnimalPrinter</code> 类中添加对应动物的打印函数，肯定会修改对应的源代码，但是这就违反了单一职责原则。</p><p>那么如果将这些算法或者策略抽象出来，提供一个统一的接口，不同的算法或者策略有不同的实现类，这样在程序客户端就可以通过注入不同的实现对象来实现算法或者策略的动态替换。</p><p>这种模式的可扩展性、可维护性也就更高，也就是我们所说的策略模式。</p><hr><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</p><p>策略模式主要用来分离算法，在相同的行为抽象下有不同的具体实现策略。</p><p>这个模式很好地演示了开闭原则，也就是定义抽象，注入不同的实现，从而达到很好的可扩展性。</p><hr><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul><li><p>针对同一类型问题的多种处理方式，仅仅是具体行为有差别时。</p></li><li><p>需要安全地封装多种同一类型的操作时。</p></li><li><p>出现同一抽象类有多个子类，而又需要使用 <code>if-else</code> 或者 <code>switch-case</code> 来选择具体子类时。</p></li></ul><hr><h1 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h1><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230114222817018.png" alt="Strategy Pattern" style="zoom:80%;" /><p>其中，上图中的类和接口的定义如下：</p><ul><li><strong>Context</strong>：用来操作策略的上下文环境。</li><li><strong>Strategy</strong>：策略的抽象接口。</li><li><strong>Concrete Strategy A</strong>、<strong>Concrete Strategy B</strong>：具体的策略实现。</li></ul><hr><h1 id="引言代码修改"><a href="#引言代码修改" class="headerlink" title="引言代码修改"></a>引言代码修改</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> animalPrinter = AnimalPrinter()<br>    <span class="hljs-comment">// 配置策略</span><br>    animalPrinter.setAnimal(DogPrinter())<br>    <span class="hljs-comment">// 调用接口中的功能</span><br>    animalPrinter.printAnimal()<br>&#125;<br><br><span class="hljs-comment">// UML 类图中 Context 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalPrinter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> animal : IAnimalPrinter<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setAnimal</span><span class="hljs-params">(mIAnimalPrinter: <span class="hljs-type">IAnimalPrinter</span>)</span></span> &#123;<br>        <span class="hljs-keyword">this</span>.animal = mIAnimalPrinter<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">printAnimal</span><span class="hljs-params">()</span></span> = animal.print()<br>&#125;<br><br><span class="hljs-comment">// UML 类图中 Strategy 接口</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IAnimalPrinter</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span><br>&#125;<br><br><span class="hljs-comment">// 实现 Strategy 接口的具体实现类，即 Concrete Strategy 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CatPrinter</span> : <span class="hljs-type">IAnimalPrinter</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;I have a cat.&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DogPrinter</span> : <span class="hljs-type">IAnimalPrinter</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;I have a dog.&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParrotPrinter</span> : <span class="hljs-type">IAnimalPrinter</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;I have a parrot.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过策略模式，当我们需要添加新的动物的时候，通过创建一个实现了 <code>IAnimalPrinter</code> 接口的类并实现其中的方法，便可以直接在 <code>main</code> 函数中使用新动物了而不再需要修改任何已有的、相关的 <code>AnimalPrinter</code> 等类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> animalPrinter = AnimalPrinter()<br>    animalPrinter.setAnimal(RabbitPrinter())<br>    animalPrinter.printAnimal()<br>&#125;<br><br><span class="hljs-comment">// 省略其他代码</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitPrinter</span> : <span class="hljs-type">IAnimalPrinter</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span> = println(<span class="hljs-string">&quot;I have a rabbit.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Android-源码中的应用：属性动画"><a href="#Android-源码中的应用：属性动画" class="headerlink" title="Android 源码中的应用：属性动画"></a>Android 源码中的应用：属性动画</h1><p>属性动画<strong>可以对任意对象的属性进行动画</strong>而不仅仅是 <code>View</code>。达到的效果是：在一个时间间隔内完成对象从一个属性值到另一个属性值的改变。</p><p><strong>在属性动画的源码中，时间插值器（<code>TimeInterpolator</code>）就使用了策略模式。</strong></p><h2 id="插值器和估值器"><a href="#插值器和估值器" class="headerlink" title="插值器和估值器"></a>插值器和估值器</h2><p>插值器和估值器是实现非匀速动画的重要手段。</p><h3 id="TimeInterpolator"><a href="#TimeInterpolator" class="headerlink" title="TimeInterpolator"></a><code>TimeInterpolator</code></h3><p>时间插值器。作用为<strong>根据时间的流逝的百分比计算当前属性值改变的百分比</strong>。</p><p>预设的有多种插值器，常见的三种如下：</p><ol><li><p><code>LinearInterpolator</code></p><p>线性插值器：匀速动画</p></li><li><p><code>AccelerateDecelerateInterpolator</code></p><p>加速减速插值器：动画两头慢中间快</p></li><li><p><code>DecelerateInterpolator</code></p><p>减速插值器：动画越来越慢</p></li></ol><p><strong>三个类都实现了 <code>Interpolator</code> 接口，接口内部只有一个用来计算属性值的改变的百分比的 <code>getInterpolation</code> 方法需要实现。</strong></p><div class="note note-info">            <p>更多插值器即其数值变化方式可以阅读： <a href="https://blog.csdn.net/pzm1993/article/details/77926373"><em>Android动画之Interpolator(插值器)_M-Ellen的博客-CSDN博客</em></a></p>          </div><h3 id="TypeEvaluator"><a href="#TypeEvaluator" class="headerlink" title="TypeEvaluator"></a><code>TypeEvaluator</code></h3><p>类型估值算法，也叫估值器。作用是<strong>根据属性值改变的百分比来计算改变后的属性值</strong>。</p><p>系统预置的有3种：</p><ol><li><code>IntEvaluator</code>：针对整形属性</li><li><code>FloatEvaluator</code>：针对浮点型属性</li><li><code>ArgbEvaluator</code>：针对 Color 属性</li></ol><p>三个类都实现了 <code>TypeEvalator</code> 接口，接口内部只有一个用来计算改变后的属性值的 <code>evaluate</code> 方法需要实现。</p><h3 id="计算顺序"><a href="#计算顺序" class="headerlink" title="计算顺序"></a>计算顺序</h3><p>系统会根据当前的帧所在时刻与动画播放的总时间求出时间的流逝的百分比，再通过插值器计算出当前属性值改变的百分比，后用此值通过估值器计算出当前的属性改变后的确定的值是多少并通过 <code>set</code> 方法对属性赋值。</p><p>故属性动画要求对象的该属性有 <code>set</code> 方法（必须有）和 <code>get</code> 方法（可选）。</p><h3 id="自定义插值器和估值器"><a href="#自定义插值器和估值器" class="headerlink" title="自定义插值器和估值器"></a>自定义插值器和估值器</h3><p>我们可以自定义插值器和估值器，来实现自己想要的动画效果。实现方式也很简单。</p><p>因为插值器和估值器都是一个接口，且内部都只有一个方法，所以我们只需要派生一个类并实现接口就可以了，然后就可以做出千奇百怪的动画效果了。即：</p><ul><li><p>自定义插值器需要实现 <code>Interpolator</code> 或者 <code>TimeInterpolator</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TimeInterpolator</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Maps a value representing the elapsed fraction of an animation to a value that represents</span><br><span class="hljs-comment">     * the interpolated fraction. This interpolated value is then multiplied by the change in</span><br><span class="hljs-comment">     * value of an animation to derive the animated value at the current elapsed animation time.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> input A value between 0 and 1.0 indicating our current point</span><br><span class="hljs-comment">     *        in the animation where 0 represents the start and 1.0 represents</span><br><span class="hljs-comment">     *        the end</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> The interpolation value. This value can be more than 1.0 for</span><br><span class="hljs-comment">     *         interpolators which overshoot their targets, or less than 0 for</span><br><span class="hljs-comment">     *         interpolators that undershoot their targets.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">float</span> <span class="hljs-title function_">getInterpolation</span><span class="hljs-params">(<span class="hljs-type">float</span> input)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * An interpolator defines the rate of change of an animation. This allows</span><br><span class="hljs-comment"> * the basic animation effects (alpha, scale, translate, rotate) to be </span><br><span class="hljs-comment"> * accelerated, decelerated, repeated, etc.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Interpolator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TimeInterpolator</span> &#123;<br>    <span class="hljs-comment">// A new interface, TimeInterpolator, was introduced for the new android.animation</span><br>    <span class="hljs-comment">// package. This older Interpolator interface extends TimeInterpolator so that users of</span><br>    <span class="hljs-comment">// the new Animator-based animations can use either the old Interpolator implementations or</span><br>    <span class="hljs-comment">// new classes that implement TimeInterpolator directly.</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自定义估值器需要实现 <code>TypeEvaluator</code> 接口。</p></li></ul><h2 id="插值器使用方法"><a href="#插值器使用方法" class="headerlink" title="插值器使用方法"></a>插值器使用方法</h2><p>定义一个 <code>Animation</code> 对象后，使用 <code>Animation#setInterpolator</code> 方法进行插值器类型的选择：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">animation.setInterpolator(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AccelerateInterpolator</span>())<br></code></pre></td></tr></table></figure><blockquote><p>  <b><code>Animation#setInterpolator</code></b></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Interpolator mInterpolator; <span class="hljs-comment">// 插值器成员变量</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Sets the acceleration curve for this animation. Defaults to a linear</span><br><span class="hljs-comment"> * interpolation.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> i The interpolator which defines the acceleration curve</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@attr</span> ref android.R.styleable#Animation_interpolator</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setInterpolator</span><span class="hljs-params">(Interpolator i)</span> &#123;<br>    mInterpolator = i;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>查看源码中何时使用了 <code>Interpolator</code> 对象。</p><p>通过查找 <code>View#startAnimation -&gt; View#draw -&gt; View#drawAnimation -&gt; Animation#getTransformation</code>，可以看到插值器的使用。</p><p><b><code>Animation#getTransformation</code></b></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java">Interpolator mInterpolator; <span class="hljs-comment">// 插值器成员变量</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Gets the transformation to apply at a specified point in time. Implementations of this</span><br><span class="hljs-comment"> * method should always replace the specified Transformation or document they are doing</span><br><span class="hljs-comment"> * otherwise.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> currentTime Where we are in the animation. This is wall clock time.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> outTransformation A transformation object that is provided by the</span><br><span class="hljs-comment"> *        caller and will be filled in by the animation.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> True if the animation is still running</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">getTransformation</span><span class="hljs-params">(<span class="hljs-type">long</span> currentTime, Transformation outTransformation)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-type">float</span> normalizedTime;<br>    <span class="hljs-comment">// 1. 计算当前时间的流逝百分比</span><br>    <span class="hljs-keyword">if</span> (duration != <span class="hljs-number">0</span>) &#123;<br>        normalizedTime = ((<span class="hljs-type">float</span>) (currentTime - (mStartTime + startOffset))) /<br>            (<span class="hljs-type">float</span>) duration;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// time is a step-change with a zero duration</span><br>        normalizedTime = currentTime &lt; mStartTime ? <span class="hljs-number">0.0f</span> : <span class="hljs-number">1.0f</span>;<br>    &#125;<br>    <span class="hljs-comment">// 动画是否已经完成</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">expired</span> <span class="hljs-operator">=</span> normalizedTime &gt;= <span class="hljs-number">1.0f</span> || isCanceled();<br>    mMore = !expired;<br><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> ((normalizedTime &gt;= <span class="hljs-number">0.0f</span> || mFillBefore) &amp;&amp; (normalizedTime &lt;= <span class="hljs-number">1.0f</span> || mFillAfter)) &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// 2. 通过插值器获取动画执行百分比</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">interpolatedTime</span> <span class="hljs-operator">=</span> mInterpolator.getInterpolation(normalizedTime);<br>        <span class="hljs-comment">// 3. 应用动画效果</span><br>        applyTransformation(interpolatedTime, outTransformation);<br>    &#125;<br><br>    <span class="hljs-comment">// 4.  如果动画执行完毕，那么出发动画完成的回调或者执行重复动画等操作</span><br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-keyword">if</span> (!mMore &amp;&amp; mOneMoreTime) &#123;<br>        mOneMoreTime = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mMore;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面代码的第 35 行，可以看到使用了 <code>Interpolator</code> 接口的 <code>getInterpolation</code> 方法进行了不同策略的执行。</p><hr><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>结构清晰明了、使用简单直观。</li><li>耦合度相对而言较低，扩展方便。</li><li>操作封装也更为彻底，数据更为安全。</li></ul><hr><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li>随着策略的增加，子类也会变得繁多。</li></ul><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><p>《Android 源码设计模式解析与实战》</p></li><li><p>《Android 开发艺术探索》</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>属性动画</tag>
      
      <tag>策略模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第八章</title>
    <link href="/posts/19271da3fc19/"/>
    <url>/posts/19271da3fc19/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第八章学习笔记</b></font></center><br><span id="more"></span><h1 id="堆栈帧"><a href="#堆栈帧" class="headerlink" title="堆栈帧"></a>堆栈帧</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 227</p></blockquote><p>堆栈帧 (stack frame)（或活动记录 (activation record)）是一块堆栈保留区域，用于存放<strong>被传递的实际参数</strong>、<strong>子程序的返回值</strong>、<strong>局部变量</strong>以及<strong>被保存的寄存器</strong>。堆栈帧的创建步骤如下所示：</p><ol><li>被传递的实际参数。如果有，则压入堆栈。</li><li>当子程序被调用时，使该子程序的返回值压入堆栈。</li><li>子程序开始执行时，EBP 被压入堆栈。</li><li>设置 EBP 等于 ESP。从这时开始，EBP 就变成了该子程序所有参数的引用基址。</li><li>如果有局部变量，修改 ESP 以便在堆栈中为这些变量预留空间。</li><li>如果需要保存寄存器，就将它们压入堆栈。</li></ol><blockquote><ul><li><code>ESP</code> 用于寻址堆栈（一种系统内存结构）数据。它极少用于一般算术运算和数据传输，通常被称为扩展堆栈指针 (extended stack pointer) 寄存器。</li><li>高级语言通过 <code>EBP</code> 来引用堆栈中的函数参数和局部变量。除了高级编程，它不用于一般算术运算和数据传输。它常常被称为扩展帧指针 (extended frame pointer) 寄存器。</li></ul></blockquote><p>程序内存模式和对参数传递规则的选择直接影响到堆栈帧的结构。</p><p>学习用堆栈传递参数有个好理由：几乎所有的高级语言都会用到它们。比如如果想要在 32 位 Windows 应用程序接口（API）中调用函数，就必须用堆栈传递参数。而 64 位程序可以使用另一种不同的参数传递规则。</p><h2 id="访问堆栈参数"><a href="#访问堆栈参数" class="headerlink" title="访问堆栈参数"></a>访问堆栈参数</h2><p>高级语言有多种方式来对函数调用的参数进行初始化和访问。以 C 和 C++ 语言为例，它们以保存 EBP 寄存器并使该寄存器指向栈顶的语句为开始 (prologue)。然后，根据实际情况，它们可以把某些寄存器入栈，以便在函数返回时恢复这些寄存器的值。在函数结尾 (epilogue) 部分，恢复 EBP 寄存器，并用 RET 指令返回调用者。</p><h2 id="ENTER-指令"><a href="#ENTER-指令" class="headerlink" title="ENTER 指令"></a>ENTER 指令</h2><p>ENTER 指令为被调用过程自动创建堆栈帧。它为局部变量保留堆栈空间，把 EBP 入栈。具体来说，它执行三个操作：</p><ul><li>把 EBP 入栈（<code>push EBP</code>）</li><li>把 EBP 设置为堆栈帧的基址（<code>mov EBP, ESP</code>）</li><li>为局部变量保留空间（<code>sub ESP, numbytes</code>）</li></ul><p>ENTER有两个操作数：第一个是常数，定义为局部变量保存的堆栈空间字节数；第二个定义了过程的词法嵌套级。<br>$$<br>ENTER \space \space numbytes, \space nestinglevel<br>$$<br>这两个操作数都是立即数。Numbytes 总是向上舍入为 4 的倍数，以便 ESP 对齐双字边界。Nestinglevel 确定了从主调过程堆栈帧复制到当前帧的堆栈帧指针的个数。</p><p><font size = 4><b>示例</b></font></p><p>ENTER 指令为局部变量保留了 8 个字节的堆栈空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">MySub PROC<br>    enter 8, 0<br></code></pre></td></tr></table></figure><p>它与如下指令等效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">MySub PROC<br>    push  ebp<br>    mov   ebp, esp<br>    sub   esp, 8<br></code></pre></td></tr></table></figure><p>下图为执行 ENTER 指令前后的堆栈示意图。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230103180554430.png" alt="" style="zoom: 67%;" /><h2 id="LEAVE-指令"><a href="#LEAVE-指令" class="headerlink" title="LEAVE 指令"></a>LEAVE 指令</h2><p>LEAVE 指令结束一个过程的堆栈帧。它反转了之前的 ENTER 指令操作：恢复了过程被调用时 ESP 和 EBP 的值。再次以 MySub 过程为例，现在可以编码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">MySub PROC<br>    enter 8,0<br>    .<br>    .<br>    leave<br>    ret<br>MySub ENDP<br></code></pre></td></tr></table></figure><p>下面是与之等效的指令序列，其功能是在堆栈中保存和删除 8 个字节的局部变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">MySub PROC<br>    push  ebp<br>    mov   ebp, esp<br>    sub   esp, 8<br>    .<br>    .<br>    mov   esp, ebp<br>    pop   ebp<br>    ret<br>MySub ENDP<br></code></pre></td></tr></table></figure><h2 id="LOCAL-指令"><a href="#LOCAL-指令" class="headerlink" title="LOCAL 指令"></a>LOCAL 指令</h2><p>不难想象，Microsoft 创建 LOCAL 伪指令是作为 ENTER 指令的高级替补。</p><p>LOCAL 声明一个或多个变量名，并定义其大小属性。（另一方面，ENTER 则只为局部变量保留一块未命名的堆栈空间。）如果要使用 LOCAL 伪指令，它必须紧跟在 PROC 伪指令的后面。其语法如下所示：</p><p>$$<br>LOCAL \space \space varlist<br>$$<br>$varlist$ 是变量定义列表，用逗号分隔表项，可选为跨越多行。每个变量定义采用如下格式：<br>$$<br>label: \space type<br>$$<br>其中，标号可以为任意有效标识符，类型既可以是标准类型（WORD、DWORD等），也可以是用户定义类型。</p><p><font size = 4><b>示例</b></font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Assembly">BubbleSort PROC<br>    LOCAL temp: DWORD, SwapFlag: BYTE<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第七章</title>
    <link href="/posts/68212001d88c/"/>
    <url>/posts/68212001d88c/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第七章学习笔记</b></font></center><br><span id="more"></span><h1 id="移位和循环移位指令"><a href="#移位和循环移位指令" class="headerlink" title="移位和循环移位指令"></a>移位和循环移位指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 192</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102210528302.png" alt="" style="zoom:80%;" /><p>移动操作数的位有两种方法。</p><ul><li>第一种是<strong>逻辑移位</strong> (logic shift)，<strong>空出来的位用 0 填充</strong>。如下图所示，一个字节的数据向右移动一位。也就是说，每一位都被移动到其旁边的低位上。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102210741593.png" alt="" style="zoom:67%;" /><ul><li>另一种移位的方法是<strong>算术移位</strong> (arithmetic shift)，空出来的位用原数据的符号位填充。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102210824137.png" alt="" style="zoom:70%;" /><h2 id="SHL-指令"><a href="#SHL-指令" class="headerlink" title="SHL 指令"></a>SHL 指令</h2><p>逻辑左移。SHL 的第一个操作数是目的操作数,第二个操作数是移位次数：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102211036985.png" alt="" style="zoom:70%;" />$$SHL \space \space destination,count$$该指令可用的操作数类型如下所示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">SHL reg, imm8<br>SHL mem, imm8<br>SHL reg, CL<br>SHL mem, CL<br></code></pre></td></tr></table></figure><p>x86处理器允许 imm8 为 0～255 中的任何整数。另外，CL 寄存器包含的是移位计数。上述格式同样适用于 SHR、SAL、SAR、ROR、ROL、RCR 和  RCL 指令。</p><h2 id="SHR-指令"><a href="#SHR-指令" class="headerlink" title="SHR 指令"></a>SHR 指令</h2><p>逻辑右移。SHR 的指令格式与 SHL 相同。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102210741593.png" alt="" style="zoom:67%;" /><h2 id="SAL-和-SAR-指令"><a href="#SAL-和-SAR-指令" class="headerlink" title="SAL 和 SAR 指令"></a>SAL 和 SAR 指令</h2><p>SAL(算术左移)指令的操作与SHL指令一样。</p><p>每次移动时，SAL 都将目的操作数中的每一位移动到下一个最高位上。<strong>最低位用0填充</strong>；最高位移入进位标志位，该标志位原来的值被丢弃：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102211511996.png" alt="" style="zoom:70%;" /><p>SAR 指令为算术右移，指令格式与 SHL 相同。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102210824137.png" alt="" style="zoom:70%;" /><h2 id="ROL-指令"><a href="#ROL-指令" class="headerlink" title="ROL 指令"></a>ROL 指令</h2><p>以循环方式来移位即为位元循环 (Bitwise Rotation)。一些操作中，从数的一端移出的位立即复制到该数的另一端。还有一种类型则是把进位标志位当作移动位的中间点。</p><p>ROL（循环左移）指令把所有位都向左移。最高位复制到进位标志位和最低位。该指令格式与 SHL 指令相同：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102212019795.png" alt="image-20230102212019795" style="zoom:80%;" /><p>位循环不会丢弃位。从数的一端循环出去的位会出现在该数的另一端。</p><p><font size = 4><b>特点</b></font></p><ol><li>当循环计数值大于 1 时，进位标志位保存的是最后循环移出 MSB 的位。</li><li>位组交换利用 ROL 可以交换一个字节的高四位(位 4～7)和低四位(位 0～3)。例如，26h 向任何方向循环移动 4 位就变为 62h。当多字节整数以四位为单位进行循环移位时，其效果相当于一次向右或向左移动一个十六进制位。例如，将 6A4Bh 反复循环左移四位，最后就会回到初始值。</li></ol><h2 id="ROR-指令"><a href="#ROR-指令" class="headerlink" title="ROR 指令"></a>ROR 指令</h2><p>ROR（循环右移）指令把所有位都向右移，最低位复制到进位标志位和最高位。该指令格式与 SHL 指令相同。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102212338300.png" alt="" style="zoom:70%;" /><p>当循环计数值大于 1 时，进位标志位保存的是最后循环移出 LSB 的位。</p><h2 id="RCL-和-RCR-指令"><a href="#RCL-和-RCR-指令" class="headerlink" title="RCL 和 RCR 指令"></a>RCL 和 RCR 指令</h2><p>RCL（带进位循环左移）指令把每一位都向左移，进位标志位复制到 LSB，而 MSB 复制到进位标志位：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102212630840.png" alt="" style="zoom:70%;" /><p>RCR（带进位循环右移）指令把每一位都向右移，进位标志位复制到 MSB，而 LSB 复制到进位标志位：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102212743503.png" alt="" style="zoom:70%;" /><h2 id="SHLD-和-SHRD-指令"><a href="#SHLD-和-SHRD-指令" class="headerlink" title="SHLD 和 SHRD 指令"></a>SHLD 和 SHRD 指令</h2><p>SHLD（双精度左移）指令将目的操作数向左移动指定位数。移动形成的空位由源操作数的高位填充。源操作数不变，但是符号标志位、零标志位、辅助进位标志位、奇偶标志位和进位标志位会受影响：<br>$$<br>SHLD \space \space dest, source, count<br>$$<br>下图展示的是 SHLD 执行移动一位的过程。源操作数的最高位复制到目的操作数的最低位上。目的操作数的所有位都向左移动：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102213018857.png" alt="" style="zoom:67%;" /><p>SHRD（双精度右移）指令将目的操作数向右移动指定位数。移动形成的空位由源操作数的低位填充：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102213058864.png" alt="" style="zoom:67%;" /><p>SHLD 和 SHRD 的指令格式中，目标操作数可以是寄存器或内存操作数；<strong>源操作数必须是寄存器</strong>；移位次数可以是 CL 寄存器或者 8 位立即数。</p><h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 200</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102213650659.png" alt="" style="zoom:80%;" /><hr><h1 id="乘法和除法指令"><a href="#乘法和除法指令" class="headerlink" title="乘法和除法指令"></a>乘法和除法指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 201</p></blockquote><h2 id="MUL-指令"><a href="#MUL-指令" class="headerlink" title="MUL 指令"></a>MUL 指令</h2><p>32位模式下，MUL（<strong>无符号数</strong>乘法）指令有三种类型：</p><ul><li>第一种执行 8 位操作数与 <strong>AL 寄存器</strong>的乘法</li><li>第二种执行16位操作数与 <strong>AX 寄存器</strong>的乘法</li><li>第三种执行 32 位操作数与 <strong>EAX 寄存器</strong>的乘法</li></ul><p>乘数和被乘数的大小必须保持一致，<strong>乘积的大小则是它们的一倍</strong>。这三种类型都可以使用寄存器和内存操作数，但不能使用立即数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MUL reg/mem8<br>MUL reg/mem16<br>MUL reg/mem32<br></code></pre></td></tr></table></figure><p>MUL 指令中的单操作数是乘数。下图按照乘数的大小，列出了默认的被乘数和乘积。</p><p>由于目的操作数是被乘数和乘数大小的两倍，因此<strong>不会发生溢出</strong>。</p><p>如果乘积的高半部分不为零，则 MUL 会把<strong>进位标志位和溢出标志位</strong>置 1。因为进位标志位常常用于无符号数的算术运算。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102222115899.png" alt="" style="zoom:80%;" /><p>例如，当 AX 乘以一个 16 位操作数时，乘积存放在 DX 和 AX 寄存器对中。其中，乘积的高 16 位存放在 DX，低 16 位存放在 AX。如果 DX 不等于零，则进位标志位置 1，这就意味着隐含的目的操作数的低半部分容纳不了整个乘积。</p><h2 id="IMUL-指令"><a href="#IMUL-指令" class="headerlink" title="IMUL 指令"></a>IMUL 指令</h2><p>IMUL（有符号数乘法）指令执行有符号整数乘法。与 MUL 指令不同，IMUL 会<strong>保留乘积的符号</strong>，实现的方法是，将乘积低半部分的最高位符号扩展到高半部分。x86指令集支持三种格式的 IMUL 指令:单操作数、双操作数和三操作数。</p><p><font size = 4><b>单操作数格式</b></font></p><p>单操作数格式中，乘数和被乘数大小相同，而乘积的大小是它们的两倍。单操作数格式将乘积存放在 AX、DX:AX 或 EDX: EAX 中：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102224014015.png" style="zoom: 71%;" /><p>和 MUL 指令一样，其乘积的存储大小使得<strong>溢出不会发生</strong>。同时，如果乘积的高半部分不是其低半部分的符号扩展，则进位标志位和溢出标志位置1。利用这个特点可以决定是否忽略乘积的高半部分。</p><p><font size = 4><b>双操作数格式（32位模式）</b></font></p><p>32 位模式中的双操作数 IMUL 指令把乘积存放在第一个操作数中，这个操作数必须是寄存器。第二个操作数（乘数）可以是寄存器、内存操作数和立即数。<br>$$<br>IMUL \space \space reg, \space reg&#x2F;mem&#x2F;imm<br>$$<br>双操作数格式会按照目的操作数的大小来截取乘积。如果被丢弃的是有效位则溢出标志位和进位标志位置 1。因此，在执行了有两个操作数的 IMUL 操作后，必须检查这些标志位中的一个。</p><p><font size = 4><b>三操作数格式</b></font></p><p>32 位模式下的三操作数格式将乘积保存在第一个操作数中。第二个操作数可以是16位寄存器或内存操作数，它与第三个操作数相乘，该操作数是一个8位或16位立即数。<br>$$<br>IMUL \space \space reg, \space reg&#x2F;mem, \space imm<br>$$<br>IMUL 执行时，若乘积有效位被丢弃，则溢出标志位和进位标志位置 1。因此，在执行了有三个操作数的 IMUL 操作后,必须检查这些标志位中的一个。</p><h2 id="DIV-指令"><a href="#DIV-指令" class="headerlink" title="DIV 指令"></a>DIV 指令</h2><p>32 位模式下，DIV（无符号除法）指令执行 8 位、16 位和 32 位无符号数除法。其中，单寄存器或内存操作数是除数。格式如下:<br>$$<br>DIV\space\space reg&#x2F;mem<br>$$<br>下图给出了被除数、除数、商和余数之间的关系：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102234944257.png" style="zoom: 67%;" /><p>64 位模式下，DIV 指令用 RDX:RAX 作被除数，用 64 位寄存器和内存操作数作除数商存放到 RAX，余数存放在 RDX 中。</p><h2 id="IDIV-指令"><a href="#IDIV-指令" class="headerlink" title="IDIV 指令"></a>IDIV 指令</h2><p>IDIV（有符号除法）指令执行有符号整数除法，其操作数与 DIV 指令相同。执行 8 位除法之前，被除数 (AX) 必须完成符号扩展。余数的符号总是与被除数相同。</p><hr><h1 id="扩展加减法"><a href="#扩展加减法" class="headerlink" title="扩展加减法"></a>扩展加减法</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 212</p></blockquote><h2 id="ADC-指令"><a href="#ADC-指令" class="headerlink" title="ADC 指令"></a>ADC 指令</h2><p>ADC（带进位加法）指令将源操作数和进位标志位的值都与目的操作数相加。该指令格式与 ADD 指令一样,且操作数大小必须相同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ADC reg, reg<br>ADC mem, reg<br>ADC reg, mem<br>ADC mem, imm<br>ADC reg, imm<br></code></pre></td></tr></table></figure><h2 id="程序示例-1"><a href="#程序示例-1" class="headerlink" title="程序示例"></a>程序示例</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102235908443.png" style="zoom:60%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102235932603.png" style="zoom:60%;" /><p>下面的代码示例调用 Extended_Add，并向其传递两个 8 字节的整数。要注意为和数多分配一个字节：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230103000107626.png" style="zoom:60%;" /><p>上述程序的输出，加法产生了一个进位：<code>0122C32B0674BB5736</code></p><h2 id="SBB-指令"><a href="#SBB-指令" class="headerlink" title="SBB 指令"></a>SBB 指令</h2><p>SBB（带借位减法）指令从目的操作数中减去源操作数和进位标志位的值。允许使用的操作数与 ADC 指令相同。</p>]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第六章</title>
    <link href="/posts/aa0ae44a7053/"/>
    <url>/posts/aa0ae44a7053/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第六章学习笔记</b></font></center><br><span id="more"></span><h1 id="布尔和比较指令"><a href="#布尔和比较指令" class="headerlink" title="布尔和比较指令"></a>布尔和比较指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 148</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102144806527.png" alt="" style="zoom:80%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102144839025.png" style="zoom:80%;" /><h2 id="CPU的状态标志"><a href="#CPU的状态标志" class="headerlink" title="CPU的状态标志"></a>CPU的状态标志</h2><p>布尔指令影响零标志、进位标志、符号标志、溢出标志和奇偶标志。</p><ul><li>操作结果等于 0 时，零标志位置 1。</li><li>操作使得目标操作数的最高位有进位时，进位标志位置 1。</li><li>符号标志位是目标操作数高位的副本，如果标志位置 1，表示是负数；标志位清 0，表示是正数。(假设 0 为正)</li><li>指令产生的结果超出了有符号目的操作数范围时，溢出标志位置 1。</li><li>指令使得目标操作数低字节中有偶数个 1 时，奇偶标志位置 1。</li></ul><h2 id="AND-指令"><a href="#AND-指令" class="headerlink" title="AND 指令"></a>AND 指令</h2><p>AND 指令在两个操作数的对应位之间进行（按位）逻辑与 (AND) 操作，<strong>并将结果存放在目标操作数中</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">AND dest, source<br></code></pre></td></tr></table></figure><p>下列是被允许的操作数组合，但是<strong>立即操作数不能超过 32 位</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">AND reg, reg<br>AND reg, mem<br>AND reg, imm<br>AND mem, reg<br>AND mem, imm<br></code></pre></td></tr></table></figure><p>AND 指令总是<strong>清除溢出和进位标志位</strong>，并根据目标操作数的值来修改符号标志位、零标志位和奇偶标志位。</p><h2 id="OR-指令"><a href="#OR-指令" class="headerlink" title="OR 指令"></a>OR 指令</h2><p>OR指令在两个操作数的对应位之间进行（按位）逻辑或 (OR) 操作，并将结果存放在目标操作数中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">OR dest, source<br></code></pre></td></tr></table></figure><p>操作数组合与 AND 指令相同。</p><p>OR 指令总是<strong>清除溢出标志和进位标志</strong>。它根据目的操作数的值修改符号标志、零标志、奇偶标志。</p><h2 id="XOR-指令"><a href="#XOR-指令" class="headerlink" title="XOR 指令"></a>XOR 指令</h2><p>指令在每对操作数的对应数据之间执行异或 (XOR) 操作，格式与 AND 指令相同。</p><p>XOR 指令总是<strong>清除溢出标志和进位标志</strong>，它依据目的操作数的值修改符号标志、零标志和奇偶标志。</p><h2 id="NOT-指令"><a href="#NOT-指令" class="headerlink" title="NOT 指令"></a>NOT 指令</h2><p>NOT 指令将一个操作数中的所有数据位取反，得到的结果成为该操作数的反码。该指令允许下面的操作数据类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">NOT reg<br>NOT mem<br></code></pre></td></tr></table></figure><p><strong>NOT 指令不影响任何状态标志。</strong></p><h2 id="TEST-指令"><a href="#TEST-指令" class="headerlink" title="TEST 指令"></a>TEST 指令</h2><p>TEST 指令在两个操作数的对应数据位之间执行隐式的 AND 操作，并相应设置标志位。</p><p>TEST 指令和 AND 指令之间的<strong>唯一区别</strong>在于 TEST 指令<strong>不会修改目的操作数</strong>。</p><p>TEST 指令的操作数格式与 AND 相同。</p><p>该指令在测试操作数某些位是否被设置时特别有用。</p><p>TEST 指令总是<strong>清除溢出和进位标志位</strong>，其修改符号标志位、零标志位和奇偶标志位的方法与 AND 指令相同。</p><p>从下面的数据集例子中，可以推断只有当所有测试位都清 0 时,零标志位才置 1（本例中的0000 1001称为位掩码。）：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102154417565.png" alt="image" style="zoom:85%;" /><h2 id="CMP-指令"><a href="#CMP-指令" class="headerlink" title="CMP 指令"></a>CMP 指令</h2><p>CMP（比较）指令执行<strong>从目的操作数中减去源操作数</strong>的隐含减法操作，并且不修改任何操作数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">CMP dest, source<br></code></pre></td></tr></table></figure><p>当实际的减法发生时，CMP指令按照计算结果修改溢出、符号、零、进位、辅助进位和奇偶标志位。</p><p>如果比较的是两个<strong>无符号数</strong>，则零标志位和进位标志位表示的两个操作数之间的关系如下图所示：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102154711457.png" style="zoom:80%;" /><p>如果比较的是两个<strong>有符号数</strong>，则符号标志位、零标志位和溢出标志位表示的两个操作数之间的关系如下图所示：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102154729952.png" style="zoom:80%;" /><p>CMP 指令是创建条件逻辑结构的有效工具。<strong>IF 语句在汇编语言中等价于在 CMP 指令后跟一条条件跳转指令。</strong></p><h2 id="设置和清除单个-CPU-状态标志"><a href="#设置和清除单个-CPU-状态标志" class="headerlink" title="设置和清除单个 CPU 状态标志"></a>设置和清除单个 CPU 状态标志</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs assembly">test al, 0     ; 零标志位置 1<br>and  al, 0     ; 零标志位置 1<br>or   al, 1     ; 零标志位清零<br><br>or   al, 80h   ; 符号标志位置 1<br>and  al, 7Fh   ; 符号标志位清零<br><br>stc            ; 进位标志位置 1<br>clc            ; 进位标志位清零<br><br>mov  al, 7Fh   ; AL = +127<br>inc  al        ; AL = 80h (-128), OF = 1, 溢出标志位置 1<br><br>or   eax, 0    ; 溢出标志位清零<br></code></pre></td></tr></table></figure><h2 id="习题整理"><a href="#习题整理" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  下列语句中，有语法错误的是：（C）<br>  A. mov eax, arrayD[esi*4]<br>  B. popfd<br>  C. cmp val1, val2<br>  D. rep stosb</p></blockquote><p>CMP 指令两个操作数不能都为立即数。</p><hr><h1 id="条件跳转"><a href="#条件跳转" class="headerlink" title="条件跳转"></a>条件跳转</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 156</p></blockquote><h2 id="Jcond-指令"><a href="#Jcond-指令" class="headerlink" title="Jcond 指令"></a>J<i>cond</i> 指令</h2><p> 条件跳转指令在标志条件为真时分支跳转到新的目的标号处，如果条件标志为假，那么执行紧跟在跳转跳转指令之后的指令。格式如下：<br>$$<br>Jcond\space\space destination<br>$$<br> 格式中的 <em>cond</em> 指的是一个标志条件，用来表示一个或多个标志的状态。例如：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102163745683.png" alt="" style="zoom:80%;" /><p>CPU 状态标志位最常见的设置方法是通过算术运算、比较和布尔运算指令。条件跳转指令评估标志位状态，利用它们来决定是否发生跳转。</p><p>限制：MASM 在默认情况下要求跳转的目的地址在当前的过程之内，为了突破这种限制，可以声明一个全局标号（标号后面跟 <code>::</code>）。</p><h2 id="基于特定的标志值的跳转指令"><a href="#基于特定的标志值的跳转指令" class="headerlink" title="基于特定的标志值的跳转指令"></a>基于特定的标志值的跳转指令</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102164214600.png" style="zoom:80%;" /><h2 id="基于恒等性比较的跳转指令"><a href="#基于恒等性比较的跳转指令" class="headerlink" title="基于恒等性比较的跳转指令"></a>基于恒等性比较的跳转指令</h2><p>$$<br>CMP \space\space leftOp,\space rightOp<br>$$</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102164334615.png" style="zoom:80%;" /><p>JE 指令和 JZ 指令是等价的，JNZ 指令和 JNE 指令是等价的。</p><h2 id="基于无符号数比较的跳转指令"><a href="#基于无符号数比较的跳转指令" class="headerlink" title="基于无符号数比较的跳转指令"></a>基于无符号数比较的跳转指令</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102164428457.png" alt="" style="zoom:80%;" /><h2 id="基于有符号数比较的跳转指令"><a href="#基于有符号数比较的跳转指令" class="headerlink" title="基于有符号数比较的跳转指令"></a>基于有符号数比较的跳转指令</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102164453778.png" style="zoom:80%;" /><h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 160</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102192924734.png" alt="" style="zoom:80%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102193006278.png" style="zoom:80%;" /><h2 id="习题整理-1"><a href="#习题整理-1" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  条件转移指令中相等跳转的指令是：（C）<br>  A. JZ<br>  B. JNZ<br>  C. JE<br>  D. JNE</p></blockquote><p>JE 指令和 JZ 指令是等价的。</p><hr><h1 id="条件循环指令"><a href="#条件循环指令" class="headerlink" title="条件循环指令"></a>条件循环指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 163</p></blockquote><h2 id="LOOPZ-和-LOOPE-指令"><a href="#LOOPZ-和-LOOPE-指令" class="headerlink" title="LOOPZ 和 LOOPE 指令"></a>LOOPZ 和 LOOPE 指令</h2><p>ECX 大于 0，并且零标志位置 1 则循环。<br>$$<br>LOOPZ\space\space destination<br>$$</p><p>$$<br>LOOPE\space\space destination<br>$$</p><h2 id="LOOPNZ-和-LOOPNE-指令"><a href="#LOOPNZ-和-LOOPNE-指令" class="headerlink" title="LOOPNZ 和 LOOPNE 指令"></a>LOOPNZ 和 LOOPNE 指令</h2><p>ECX 大于 0，并且零标志位为 0 则循环。<br>$$<br>LOOPNZ\space\space distination<br>$$</p><p>$$<br>LOOPNE\space\space distination<br>$$</p><hr><h1 id="条件结构"><a href="#条件结构" class="headerlink" title="条件结构"></a>条件结构</h1><h2 id="IF-语句"><a href="#IF-语句" class="headerlink" title="IF 语句"></a>IF 语句</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 165</p></blockquote><p>C++ 代码翻译为汇编代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (op1 == op2)<br>&#123;<br>    X = <span class="hljs-number">1</span>;<br>    Y = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">    mov eax, op1<br>    cmp eax, op2      ; op1 == op2 ?<br>    jne L1            ; False : Skip To L1<br>    mov X, 1          ; True : X = 1<br>    mov Y, 2          ; Y = 1<br>L1: .<br>    .<br></code></pre></td></tr></table></figure><h2 id="WHILE-语句"><a href="#WHILE-语句" class="headerlink" title="WHILE 语句"></a>WHILE 语句</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 168</p></blockquote><p>C++ 代码翻译为汇编代码示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (val &lt; val2)<br>&#123;<br>    val1++;<br>    val2--;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">    mov eax, val1       ; eax = val1<br>beginWhile:<br>    cmp eax, val2       ; if not (val1 &lt; val2)<br>    jnl endWhile        ; 退出循环<br>    inc eax             ; val1++<br>    dec val2            ; val2--<br>    jmp beginWhile      ; 重复循环<br>endWhile:<br>    mov val1, eax       ; val1 = eax<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第五章</title>
    <link href="/posts/cdb2a0d3132b/"/>
    <url>/posts/cdb2a0d3132b/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第五章学习笔记</b></font></center><br><span id="more"></span><h1 id="堆栈操作"><a href="#堆栈操作" class="headerlink" title="堆栈操作"></a>堆栈操作</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 108</p></blockquote><p>堆栈数据结构 (stack data structure) 的原理与盘子堆栈相同：新值添加到栈顶，删除值也在栈顶移除。堆栈也被称为 LIFO 结构 (后进先出，Last-In First-Out)，其原因是，最后进入堆栈的值也是第一个出堆栈的值。</p><h2 id="运行时堆栈（32位模式）"><a href="#运行时堆栈（32位模式）" class="headerlink" title="运行时堆栈（32位模式）"></a>运行时堆栈（32位模式）</h2><p>运行时堆栈是内存数组，CPU 用 ESP (扩展堆栈指针，extended stack pointer) 寄存器对其进行直接管理，该寄存器被称为堆栈指针寄存器 (stack pointer register)。</p><p>32位模式下，ESP寄存器存放的是堆栈中某个位置的 32 位偏移量。ESP 基本上不会直接被程序员控制，反之，它是用 CALL、RET、PUSH 和 POP 等指令间接进行修改。</p><p><font size = 4><b>入栈操作</b></font></p><p>32位入栈操作把栈顶指针减 4，再将数值复制到栈顶指针指向的堆栈位置。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101231844357.png" alt="入栈操作" style="zoom:67%;" /><p><font size = 4><b>出栈操作</b></font></p><p>出栈操作从堆栈删除数据。数值弹出堆栈后，栈顶指针增加(按堆栈元素大小)，指向堆栈中下一个最高位置。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101231955497.png" alt="出栈操作" style="zoom:67%;" /><p><font size = 4><b>堆栈应用</b></font></p><p>运行时堆栈在程序中有一些重要用途：</p><ul><li>当寄存器用于多个目的时，堆栈可以作为寄存器的一个方便的临时保存区。在寄存器被修改后，还可以恢复其初始值。</li><li>执行 CALL 指令时，CPU 在堆栈中保存当前过程的返回地址。</li><li>调用过程时,输入数值也被称为<strong>参数</strong>，通过将其压入堆栈实现参数传递。</li><li>堆栈也为过程局部变量提供了临时存储区域。</li></ul><h2 id="PUSH-和-POP-指令"><a href="#PUSH-和-POP-指令" class="headerlink" title="PUSH 和 POP 指令"></a>PUSH 和 POP 指令</h2><h3 id="PUSH-指令"><a href="#PUSH-指令" class="headerlink" title="PUSH 指令"></a>PUSH 指令</h3><p>使用 PUSH 指令将数据压入栈内。</p><p>PUSH 指令首先减少 ESP 的值，再将源操作数复制到堆栈。操作数是 16 位的，则 ESP 减 2，操作数是 32 位的,则 ESP 减 4。</p><p>例如 <code>push eax</code> 指令执行的过程可以分为两步：</p><ol><li>指向栈顶的寄存器 <code>esp</code> 进行一个减法操作 <code>sub esp, 4 </code>。</li><li>将需要保存的元素复制到新的栈顶位置 <code>mov [esp], %eax </code>。</li></ol><h3 id="POP-指令"><a href="#POP-指令" class="headerlink" title="POP 指令"></a>POP 指令</h3><p>使用 POP 指令从内存中读取数据，并且修改栈顶指针。</p><p>POP 指令首先把 ESP 指向的堆栈元素内容复制到一个 16 位或 32 位目的操作数中，再增加 ESP  的值。如果操作数是 16 位的，ESP 加 2，如果操作数是 32 位的，ESP 加 4。</p><p>例如 <code>pop ebx</code> 指令就是将栈顶保存的数据复制到寄存器 <code>ebx</code> 中，该指令同样也可以分解成两步：</p><ol><li>从栈顶的位置读出数据，复制到寄存器 <code>ebx</code>：<code>mov ebx, [esp] </code>。</li><li>将栈顶的指针加8（因为 <code>q</code> 表示的是8个字节）：<code>add esp, 4</code>。</li></ol><h3 id="PUSHFD-和-POPFD-指令"><a href="#PUSHFD-和-POPFD-指令" class="headerlink" title="PUSHFD 和 POPFD 指令"></a>PUSHFD 和 POPFD 指令</h3><p>PUSHFD 指令把 32 位 EFLAGS 寄存器内容压入堆栈。</p><p>POPFD 指令则把栈顶单元内容弹出到 EFLAGS 寄存器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pushfd<br>popfd<br></code></pre></td></tr></table></figure><h3 id="PUSHAD-和-POPAD-指令"><a href="#PUSHAD-和-POPAD-指令" class="headerlink" title="PUSHAD 和 POPAD 指令"></a>PUSHAD 和 POPAD 指令</h3><p>PUSHAD 指令按照 EAX、ECX、EDX、EBX、ESP(执行 PUSHAD 之前的值)、EBP、ESI 和 EDI 的顺序，将所有 32 位通用寄存器压入堆栈。</p><p>POPAD 指令按照相反顺序将同样的寄存器弹出堆栈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">pushad<br>popad<br></code></pre></td></tr></table></figure><p>如果编写的过程会修改 32 位寄存器的值，则在过程开始时使用 PUSHAD 指令，在结束时使用 POPAD 指令，以此保存和恢复寄存器的内容。</p><h3 id="PUSHA-和-POPA-指令"><a href="#PUSHA-和-POPA-指令" class="headerlink" title="PUSHA 和 POPA 指令"></a>PUSHA 和 POPA 指令</h3><p>与之相似，PUSHA 指令按序（AX、CX、DX、BX、SP、BP、SI 和 DI) 将 16 位通用寄存器压入堆栈。</p><p>POPA 指令按照相反顺序将同样的寄存器弹出堆栈。在 16 位模式下,只能使用 PUSHA 和 POPA 指令。</p><hr><h1 id="定义并使用过程"><a href="#定义并使用过程" class="headerlink" title="定义并使用过程"></a>定义并使用过程</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 112</p></blockquote><p>在汇编语言中，通常用术语过程 (procedure) 来指代子程序。在其他语言中，子程序也被称为方法或函数。</p><h2 id="PROC-伪指令"><a href="#PROC-伪指令" class="headerlink" title="PROC 伪指令"></a>PROC 伪指令</h2><p>可以把过程非正式地定义为：以返回语句结束的命令语句块。</p><p>过程使用 PROC 伪指令和 ENDP 伪指令来声明，另外还必须给过程定义一个名字。</p><p>程序启动过程之外的其他过程以 RET 指令结束，以强制 CPU 返回到过程被调用的地方：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">Function PROC<br>    .<br>    .<br>    .<br>    RET<br>Function ENDP<br></code></pre></td></tr></table></figure><p>但是启动过程（main）是个特例，它以 exit 语句结束。如果程序中使用了 <code>INCLUDE Irvine32.inc</code> 语句的话，exit 语句实际上就是对 ExitProcess 函数的调用，ExitProcess 是用来终止程序的系统函数：<code>INVOKE ExitProcess, 0</code>。</p><h2 id="CALL-和-RET-指令"><a href="#CALL-和-RET-指令" class="headerlink" title="CALL 和 RET 指令"></a>CALL 和 RET 指令</h2><p>CALL 指令指挥处理器在新的内存地址执行指令，以实现过程的调用。过程使用 RET（从过程返回）指令使处理器返回到程序过程被调用的地方继续执行。</p><p>从底层细节角度来讲，CALL 指令把返回地址压入堆栈并把被调用过程的地址复制到指令指针寄存器 (EIP &#x2F; IP) 中。当程序返回时，RET 指令从堆栈中弹出返回地址并送到指令指针寄存器中。</p><p>在 32 位模式下，CPU 总是执行 EIP（指令指针寄存器）所指向的内存出的指令；在 16 位模式下，CPU 总是执行 IP 寄存器指向的指令。</p><p>需要注意的是，进入过程后如果在没有 PUSH 操作的情况下直接 POP，会将之前存入的 CALL 指令后一条指令的地址弹出，从而导致 RET 指令无法正确的返回调用该过程的地址。</p><h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><p>下面的程序通过传递一个 32 位整数数组的偏移量和长度来测试 ArraySum 过程。调用 ArraySum 之后，程序将过程的返回值保存在变量 theSum 中。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102012440040.png" alt="" style="zoom:67%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230102012631839.png" style="zoom:67%;" />]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第四章</title>
    <link href="/posts/6950afc4581c/"/>
    <url>/posts/6950afc4581c/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第四章学习笔记</b></font></center><br><span id="more"></span><h1 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h1><h2 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 73</p></blockquote><p>x86 指令格式：<code>[label:] mnemonic [operands] [; comment]</code>。其中，指令包含的操作数个数可以是 0个，1个，2个或3个。</p><p>操作数有 3 种基本类型：</p><ul><li><strong>立即数</strong> (<code>imm</code>) ——使用数字文本表达式</li><li><strong>寄存器操作数</strong> (<code>reg</code>) ——使用 CPU 内已命名的寄存器</li><li><strong>内存操作数</strong> (<code>mem</code>) ——引用内存位置</li></ul><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101130934870.png" style="zoom: 50%;" /></center><h2 id="直接内存操作数"><a href="#直接内存操作数" class="headerlink" title="直接内存操作数"></a>直接内存操作数</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 74</p></blockquote><p>变量名引用的是数据段内的偏移量。</p><p>例如，如下变量 var1 的声明表示，该变量的大小类型为字节，值为十六进制的 10：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>var1 BYTE 10h<br></code></pre></td></tr></table></figure><p>可以编写指令，通过内存操作数的地址来解析（查找）这些操作数。</p><p>假设 var1 的地址偏移量为 10400h。如下指令将该变量的值复制到 AL 寄存器中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov al var1<br></code></pre></td></tr></table></figure><p>指令会被汇编为下面的机器指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">A0 00010400<br></code></pre></td></tr></table></figure><p>这条机器指令的第一个字节是操作代码（即操作码 (opcode) ）。剩余部分是 var1 的 32 位十六进制地址。虽然编程时有可能只使用数字地址，但是如同 var1 一样的符号标号会让使用内存更加容易。</p><h2 id="直接-偏移量操作数"><a href="#直接-偏移量操作数" class="headerlink" title="直接-偏移量操作数"></a>直接-偏移量操作数</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 78</p></blockquote><p>在变量名称后加上一个偏移值，可以创建直接偏移 (direct-offset) 操作数，可以通过它来访问没有显示标号的内存地址。我们以一个名为 arrayB 的<strong>字节数组</strong>开始枚举：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>arrayB BYTE 10h, 20h, 30h, 40h, 50h ; 注意此处为 BYTE(一个字节)<br><br>.code<br>mov al, arrayB        ; AL = 10h<br>mov al, [arrayB + 1]  ; AL = 20h<br>mov al, [arrayB + 2]  ; AL = 30h<br></code></pre></td></tr></table></figure><p>如果是双字节或者双字（四个字节）或者是其他，注意偏移的时候地址分别是 2、4 或者其他等。</p><hr><h1 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 75</p></blockquote><h2 id="MOV-指令"><a href="#MOV-指令" class="headerlink" title="MOV 指令"></a>MOV 指令</h2><p>MOV指令将源操作数复制到目的操作数。</p><p>在它的基本格式中，<strong>第一个操作数是目的操作数</strong>，<strong>第二个操作数是源操作数</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV destination, source<br></code></pre></td></tr></table></figure><p>其中，目的操作数的内容会发生改变，而源操作数不会改变。</p><p>下面是 MOV 指令的标准格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV reg, reg<br>MOV mem, reg<br>MOV reg, mem<br>MOV mem, imm<br>MOV reg, imm<br></code></pre></td></tr></table></figure><p><strong>需要特别注意以下的原则</strong>：</p><ul><li>两个操作数必须是同样的大小。</li><li>两个操作数不能同时为内存操作数。</li><li>指令指针寄存器 (<code>IP</code>、<code>EIP</code>、<code>RIP</code>) 不能作为目标寄存器。</li></ul><p><font size = 4><b>内存到内存</b></font></p><p>单条 MOV 指令不能用于直接将数据从一个内存位置传送到另一个内存位置。相反，在将源操作数的值赋给内存操作数之前，必须先将该数值传送给一个寄存器。在将整型常数复制到一个变量或寄存器时，必须考虑该常量需要的最少字节数。</p><p><font size = 4><b>覆盖值</b></font></p><p>下述代码示例演示了怎样通过使用不同大小的数据来修改同一个32位寄存器。</p><ul><li><p>当 oneWord 字传送到 AX 时，它就覆盖了 AL 中已有的值。</p></li><li><p>当 oneDword 传送到 EAX 时，它就覆盖了 AX 的值。</p></li><li><p>最后，当 0 被传送到 AX 时，它就<strong>覆盖了 EAX 的低半部分</strong>。</p></li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101134153188.png" alt="image" style="zoom:60%;" /><h2 id="整数的全零-x2F-符号扩展"><a href="#整数的全零-x2F-符号扩展" class="headerlink" title="整数的全零&#x2F;符号扩展"></a>整数的全零&#x2F;符号扩展</h2><p><font size = 4><b>把一个较小的值复制到一个较大的操作数</b></font></p><p>尽管 MOV 指令不能直接将较小的操作数复制到较大的操作数中，但是程序员可以想办法解决这个问题。</p><p>假设要将count (无符号，16位) 传送到ECX (32位)，可以先将 ECX 设置为 0，然后将 count 传送到 CX：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>count WORD 1<br>.code<br>mov ecx, 0<br>mov cx, count<br></code></pre></td></tr></table></figure><p>如果对一个有符号整数 -16 进行同样的操作会发生什么呢?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>signedVal SWORD -16    ; FFF0h(-16)<br>.code<br>mov ecx, 0<br>mov cx, signedVal      ; ECX = 0000FFF0h (+65520)<br></code></pre></td></tr></table></figure><p>ECX中的值 (+65520) 与 -16 完全不同。</p><p>但是，如果先将 ECX 设置为 FFFFFFFFh，然后再把 signedVal 复制到 CX，那么最后的值就是完全正确的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ecx，0FFFFFFFFh<br>mov cx, signedVal      ; ECX = FFFFFFF0h (-16)<br></code></pre></td></tr></table></figure><p>本例的有效结果是用源操作数的最高位（1）来填充目的操作数ECX的高16位，这种技术称为符号扩展( sign extension)。</p><p>当然，不能总是假设源操作数的最高位是1。</p><p>幸运的是，Intel 的工程师在设计指令集时已经预见到了这个问题，因此，设置了 <strong>MOVZX</strong> 和 <strong>MOVSX</strong> 指令来分别处理<strong>无符号整数</strong>和<strong>有符号整数</strong>。</p><h3 id="MOVZX-指令"><a href="#MOVZX-指令" class="headerlink" title="MOVZX 指令"></a>MOVZX 指令</h3><p>MOVZX 指令（进行全零扩展并传送）将源操作数复制到目的操作数，<strong>并把目的操作数<mark>0扩展</mark>到 16 位或 32 位</strong>。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101154536720.png" alt="image-20230101154536720" style="zoom:53%;" /><p>这条指令<strong>只用于无符号整数</strong>，有三种不同的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOVZX reg32, reg/mem8<br>MOVZX reg32, reg/mem16<br>MOVZX reg16, reg/mem8<br></code></pre></td></tr></table></figure><p>在三种形式中，第一个操作数（寄存器）是目的操作数，第二个操作数是源操作数。<strong>注意，源操作数不能是常数。</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101154801107.png" alt="image" style="zoom: 60%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101154848550.png" alt="" style="zoom:60%;" /><h3 id="MOVSX-指令"><a href="#MOVSX-指令" class="headerlink" title="MOVSX 指令"></a>MOVSX 指令</h3><p>MOVSX 指令（进行符号扩展并传送）将源操作数内容复制到目的操作数，<strong>并把目的操作数<mark>符号扩展</mark>到 16 位或 32 位。</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101155132150.png" alt="image-20230101155132150" style="zoom:53%;" /><p>这条指令只用于有符号整数，有三种不同的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOVSX reg32, reg/mem8<br>MOVSX reg32, reg/mem16<br>MOVSX reg16, reg/mem8<br></code></pre></td></tr></table></figure><p>操作数进行符号扩展时，在目的操作数的全部扩展位上重复(复制)长度较小操作数的最高位。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101160019171.png" style="zoom:60%;" /><h2 id="LAHF-和-SAHF-指令"><a href="#LAHF-和-SAHF-指令" class="headerlink" title="LAHF 和 SAHF 指令"></a>LAHF 和 SAHF 指令</h2><p>LAHF（<em>load</em> status <em>flags</em> into <em>AH</em>，加载状态标志位<strong>到 AH</strong>）指令将 EFLAGS 寄存器的<strong>低字节复制到 AH</strong>。被复制的标志位包括：符号标志位、零标志位、辅助进位标志位、奇偶标志位和进位标志位。使用这条指令，可以方便地把标志位副本保管在变量中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>saveflags BYTE ?<br>.code<br>lahf                ; 将标志位加载到 AH<br>mov saveflags, ah   ; 用变量保存这些标志位<br></code></pre></td></tr></table></figure><p>SAHF（<em>store</em> <em>AH</em> into status <em>flags</em>，保存 AH 内容到状态标志位）指令将 <strong>AH 内容复制到</strong> EFLAGS（或 RFLAGS）寄存器低字节。例如，可以检索之前保存到变量中的标志位数值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov ah, saveflags   ; 加载被保存标志位到 AH<br>sahf                ; 复制到 FLAGS 寄存器<br></code></pre></td></tr></table></figure><h2 id="XCHG-指令"><a href="#XCHG-指令" class="headerlink" title="XCHG 指令"></a>XCHG 指令</h2><p>XCHG（<em>exchange</em> data，交换数据）指令交换两个操作数内容。该指令有三种形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">XCHG reg, reg<br>XCHG reg, mem<br>XCHG mem, reg<br></code></pre></td></tr></table></figure><p>除了 <strong>XCHG 指令不使用立即数作操作数</strong>之外，XCHG 指令操作数的要求与 MOV 指令操作数要求是一样的。即：</p><ol><li>两个操作数不能同时都为内存操作数。</li><li>任何一个操作数都不能为立即数。</li><li>指令指针寄存器 (<code>IP</code>、<code>EIP</code>、<code>RIP</code>) 不能作为目标寄存器。</li><li>两个操作数必须是同样的大小。</li></ol><p>以下是一些使用 XCHG 指令的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">xchg ax, bx      ; 交换两个 16 位寄存器的内同<br>xchg ah, al      ; 交换两个 8 位寄存器的内容<br>xchg var1, bx    ; 交换 16 位的内存操作数和 BX 寄存器内容<br>xchg eax, ebx    ; 交换两个 32 位寄存器的内同<br></code></pre></td></tr></table></figure><p>若要交换两个内存操作数，需要使用一个寄存器作为临时存储容器，并把 MOV 指令和 XCHG 指令结合起来使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov  ax, val1<br>xchg ax, val2<br>mov  val1, ax  <br></code></pre></td></tr></table></figure><h2 id="习题整理"><a href="#习题整理" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  下列语句中，有语法错误的是：（D）<br>  A. add esi, TYPE DWORD<br>  B. pop eax<br>  C. repe cmpsd<br>  D. mov val1, val2</p></blockquote><p>MOV 指令两个操作数不能同时为内存操作数。</p><hr><h1 id="程序示例1"><a href="#程序示例1" class="headerlink" title="程序示例1"></a>程序示例1</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 79</p></blockquote><p>该程序中包含了本文之前介绍的所有指令，包括：MOV、XCHG、MOVSX 和 MOVZX，展示了字节、字和双字是如何受到它们的影响。同时，程序中还包括了一些直接-偏移量操作数。</p><center><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101164424148.png" alt="" style="zoom:67%;" /><br><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101164502334.png" alt="" style="zoom:67%;" /></p></center><hr><h1 id="加法和减法"><a href="#加法和减法" class="headerlink" title="加法和减法"></a>加法和减法</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 81</p></blockquote><h2 id="INC-和-DEC-指令"><a href="#INC-和-DEC-指令" class="headerlink" title="INC 和 DEC 指令"></a>INC 和 DEC 指令</h2><p>INC (increment) 和 DEC (decrement) 指令从操作数中加 1 或减 1，格式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">INC  reg/mem<br>DEC  reg/mem<br></code></pre></td></tr></table></figure><p>根据目标操作数的值，溢出标志位、符号标志位、零标志位、辅助进位标志位、进位标志位和奇偶标志位会发生变化。</p><p>INC和 DEC指令<strong>不会影响进位标志位</strong>。</p><h2 id="ADD-指令"><a href="#ADD-指令" class="headerlink" title="ADD 指令"></a>ADD 指令</h2><p>ADD 指令将同尺寸的源操作数和目的操作数相加，格式是：<code>ADD dest, source</code>。</p><p>在操作中，源操作数不能改变，相加之<strong>和存放在目的操作数中</strong>。</p><p>该指令可以使用的操作数与 MOV 指令相同。</p><p>进位标志位、零标志位、符号标志位、溢出标志位、辅助进位标志位和奇偶标志位根据<strong>存入目标操作数的数值</strong>进行变化。</p><h2 id="SUB-指令"><a href="#SUB-指令" class="headerlink" title="SUB 指令"></a>SUB 指令</h2><p>SUB 指令<strong>将源操作数从目的操作数中减掉</strong>，操作数格式与 ADD 和 MOV 指令操作数相同。</p><p>格式是：<code>SUB dest, source</code>。</p><p>进位标志位、零标志位、符号标志位、溢出标志位、辅助进位标志位和奇偶标志位根据<strong>存入目标操作数的数值</strong>进行变化。</p><p>有一种执行减法而无需使用额外的数字电路单元的简单方法：对源操作数求补，然后把源操作数和目的操作数相加。</p><h2 id="NEG-指令"><a href="#NEG-指令" class="headerlink" title="NEG 指令"></a>NEG 指令</h2><p>NEG (negate) 指令通过将数字转换为对应的补码而求得其相反数（将目标操作数按位取反再加1，就可以得到这个数的二进制补码)。</p><p>格式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">NEG reg<br>NEG mem<br></code></pre></td></tr></table></figure><p>进位标志位、零标志位、符号标志位、溢出标志位、辅助进位标志位和奇偶标志位根据<strong>存入目标操作数的数值</strong>进行变化。</p><h2 id="加减法影响的标志位"><a href="#加减法影响的标志位" class="headerlink" title="加减法影响的标志位"></a>加减法影响的标志位</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 83</p></blockquote><ul><li>进位标志位意味着<strong>无符号整数</strong>溢出。<br>比如，如果指令目的操作数为 8 位，而指令产生的结果大于二进制的 1111 1111，那么进位标志位置 1。</li><li>溢出标志位意味着<strong>有符号整数</strong>溢出。<br>比如，指令目的操作数为 16 位，但其产生的负数结果小于十进制的 -32768，那么溢出标志位置 1。</li><li>零标志位意味着<strong>操作结果为 0</strong>。<br>比如，如果两个值相等的操作数相减，则零标志位置 1。</li><li>符号标志位意味着操作<strong>产生的结果为负数</strong>。如果目的操作数的最高有效位（MSB）置 1，则符号标志位置 1。</li><li>奇偶标志位是指，在一条算术或布尔运算指令执行后，立即判断目的操作数最低有效字节中1的个数是否为偶数。</li><li>辅助进位标志位置1，意味着目的操作数最低有效字节中位 3 有进位。</li></ul><h2 id="习题整理-1"><a href="#习题整理-1" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  下列语句中，有语法错误的是：（B）<br>  A. mov ax, WORD PTR value<br>  B. inc [esi]<br>  C. movzx cx,bl<br>  D. movsx edx,bl</p></blockquote><p>INC 指令只能对寄存器操作数和内存操作数使用。</p><hr><h1 id="和数据相关的操作符和伪指令"><a href="#和数据相关的操作符和伪指令" class="headerlink" title="和数据相关的操作符和伪指令"></a>和数据相关的操作符和伪指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 87</p></blockquote><p>MASM 操作符或伪指令<strong>获取数据的地址以及大小等特征信息</strong>：</p><ul><li><p>OFFSET 操作符返回一个变量相对于其所在段开始的偏移。</p></li><li><p>PTR 操作符允许重载变量的默认尺寸。</p></li><li><p>TYPE 操作符返回数组中每个元素的大小（以字节计算）。</p></li><li><p>LENGTHOF 操作符返回数组内元素的数目。</p></li><li><p>SIZEOF 操作符返回数组初始化时占用的字节数。</p></li></ul><p>除此之外，LABEL 伪指令可以用不同的大小类型来重新定义同一个变量。</p><h2 id="OFFSET-运算符"><a href="#OFFSET-运算符" class="headerlink" title="OFFSET 运算符"></a>OFFSET 运算符</h2><p>OFFSET 操作符返回数据标号的偏移地址。偏移地址代表标号距离数据段开始的距离，单位是以字节计算的。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101174947466.png" alt="" style="zoom:60%;" /><p>在下面的例子中，将用到如下三种类型的变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>bVal  BYTE  ?<br>wVal  WORD  ?<br>dval  DWORD ?<br>dVal2 DWORD ?<br></code></pre></td></tr></table></figure><p>假设 bVal 在偏移量为 0040 4000 (十六进制) 的位置，则 OFFSET 运算符返回值如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov esi, OFFSET bval   ; ESI = 00404000h<br>mov esi, OFFSET wval   ; ESI = 00404001h<br>mov esi, OFFSET dVal   ; ESI = 00404003h<br>mov esi ,OFFSET dval2  ; ESI = 00404007h<br></code></pre></td></tr></table></figure><p>OFFSET 也可以应用于直接-偏移量操作数。</p><p>设 myArray 包含 5 个 16 位的字。下面的 MOV 指令首先得到 myArray 的偏移量，然后加 4，再将形成的结果地址直接传送给 ESI。因此，现在可以说 ESI 指向数组中的第 3 个整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>myArray WORD 1, 2, 3, 4, 5<br>.code<br>mov esi, OFFSET myArray + 4   ; 1 WORD = 2 BYTE<br></code></pre></td></tr></table></figure><h2 id="ALIGN-运算符"><a href="#ALIGN-运算符" class="headerlink" title="ALIGN 运算符"></a>ALIGN 运算符</h2><p>ALIGN伪指令将变量的位置按字节、字、双字或段边界对齐，语法是：ALIGN <em>bound</em>。<em>bound</em> 可以取的值有：1、2、4、8、16。指令把地址直接对齐到所指定 <em>bound</em> 的倍数上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">   bVal   BYTE  ?     ;00404000<br>   ALIGN  2<br>   wVa    WORD  ?     ; 00404002<br>   bVal2  BYTE  ?     ; 00404004<br>   ALIGN  4<br>   dVal   DWORD ?     ; 00404008<br>   dVal2  DWORD ?     ; 0040400C<br></code></pre></td></tr></table></figure><p>请注意，dVal 的偏移量原本是 0040 4005，但是 <code>ALIGN 4</code> 伪指令使它的偏移量成为 0040 4008。</p><h2 id="PTR-操作符"><a href="#PTR-操作符" class="headerlink" title="PTR 操作符"></a>PTR 操作符</h2><p>PTR 操作符来重载操作数声明的默认尺寸，这在试图以不同于变量声明时所使用的尺寸属性访问变量的时候非常有用。</p><p>例如，假设要讲双字变量 myDouble 的低 16 位传送给 AX 寄存器，由于操作数大小不匹配，编译器将不允许下面的数据传送指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>myDouble DOWRD 12345678h<br><br>.code<br>MOV ax, myDouble          ; 错误<br></code></pre></td></tr></table></figure><p>但是 <code>WORD PTR</code> 操作符使得将低字（5678）传送给 AX 成为可能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV ax, WORD PTR myDouble<br></code></pre></td></tr></table></figure><p>注意，<strong>PTR 必须与一个标准汇编数据类型一起使用</strong>，这些类型包括：BYTE、SBYTE、WORD、SWORD、DWORD、SDWORD、FWORD、QWORD 或 TBYTE。</p><h2 id="TYPE-运算符"><a href="#TYPE-运算符" class="headerlink" title="TYPE 运算符"></a>TYPE 运算符</h2><p>TYPE运算符返回变量单个元素的大小，这个大小是<strong>以字节为单位</strong>计算的。</p><p>比如，TYPE为字节，返回值是1 ；TYPE为字，返回值是2；TYPE为双字，返回值是4；TYPE为四字,返回值是8。</p><p>示例如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>Var1 BYTE  ?<br>Var2 WORD  ?<br>Var3 DWORD ?<br>Var4 QWORD ?<br></code></pre></td></tr></table></figure><p>下面是每个 TYPE 表达式的值：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101191245030.png" style="zoom: 67%;" /><h2 id="LENGTHOF-运算符"><a href="#LENGTHOF-运算符" class="headerlink" title="LENGTHOF 运算符"></a>LENGTHOF 运算符</h2><p>LENGTHOF 运算符计算数组中元素的个数，元素个数是由数组标号同一行出现的数值来定义的。示例如下：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101191614251.png" style="zoom:80%;" /><p>如果数组定义中出现了嵌套的 DUP 运算符，那么 LENGTHOF 返回的是两个数值的乘积。</p><p>下表列出了每个 LENGTHOF 表达式返回的数值。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101191653807.png" style="zoom:67%;" /><h2 id="SIZEOF-运算符"><a href="#SIZEOF-运算符" class="headerlink" title="SIZEOF 运算符"></a>SIZEOF 运算符</h2><p>SIZEOF 运算符返回值等于 LENGTHOF 与 TYPE 返回值的乘积。</p><p>如下例所示，intArray 数组的 TYPE &#x3D; 2，LENGTHOF  &#x3D; 32，因此，<code>SIZEOF intArray</code> &#x3D; 64：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>intArray WORD 32 DUP(0)<br><br>.code<br>Mov eax, SIZEOF intArray ; 64<br></code></pre></td></tr></table></figure><h2 id="LABEL-伪指令"><a href="#LABEL-伪指令" class="headerlink" title="LABEL 伪指令"></a>LABEL 伪指令</h2><p>LABEL 伪指令允许插入一个标号并赋予其尺寸属性而无需任何实际的存储空间。LABEL 伪指令可以使用 BYTE、WORD、DWORD、QWORD 或 TBYTE 等任意的标准尺寸属性。LABEL 伪指令的一种常见的用法是为数据段内其后定义的变量提供一个别名以及一个不同的尺寸属性。</p><p>下例中在 val32 前面声明了一个名为 val16 的标号并赋予其 WORD 属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>Val16 LABEL WORD<br>Val32 DWORD 12345678h<br><br>.code<br>MOV ax, val16          ; AX = 5678h<br>MOV dx, [val16 + 2]    ; DX = 1234h<br></code></pre></td></tr></table></figure><p>val16 是名为 val32 的存储地址的一个别名。LABEL 伪指令本身并不占用实际存储空间。</p><h2 id="习题整理-2"><a href="#习题整理-2" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr></blockquote><blockquote><p>  下列语句中，有语法错误的是：（A）<br>  A. mov ax, PTR value<br>  B. inc esi<br>  C. xchg ebx, eax<br>  D. add esi, TYPE DWORD</p></blockquote><p><strong>PTR 必须与一个标准汇编数据类型一起使用</strong>，这些类型包括：BYTE、SBYTE、WORD、SWORD、DWORD、SDWORD、FWORD、QWORD 或 TBYTE。</p><hr><h1 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 91</p></blockquote><p>直接寻址很少用于数组处理，因为，用常数偏移量来寻址多个数组元素时，直接寻址不实用。反之，会用寄存器作为指针（称为间接寻址）并控制该寄存器的值。</p><p>如果一个操作数使用的是间接寻址,就称之为<strong>间接操作数</strong>。</p><h2 id="间接操作数"><a href="#间接操作数" class="headerlink" title="间接操作数"></a>间接操作数</h2><p>任何一个 32 位通用寄存器（EAX、EBX、ECX、EDX、ESI、EDI、EBP 和 ESP）加上括号就能构成一个间接操作数。寄存器中存放的是数据的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>val1 BYTE 10h<br><br>.code<br>mov esi, OFFSET val1<br>mov al, [esi]          ; AL = 10h<br></code></pre></td></tr></table></figure><p>如果目的操作数也是间接操作数，那么新值将存入由寄存器提供地址的内存位置。</p><p>在下面的例子中，BL 寄存器的内容复制到 ESI 寻址的内存地址中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">MOV [esi], bl<br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>间接操作数是步进遍历数组的理想工具。</p><p>下例中，arrayB 有 3 个字节。随着 ESI 不断加 1，它就能顺序指向每一个字节：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.data<br>arrayB BYTE 10h, 20h, 30h<br><br>.code<br>mov esi, OFFSET arrayB<br>mov al, [esi]      ; AL = 10h<br>inc esi<br>mov al, [esi]      ; AL = 20h<br>inc esi<br>mov al, [esi]      ; AL = 30h<br></code></pre></td></tr></table></figure><p>如果使用 16 位的整数数组，就需要每次给 ESI 加 2 以便寻址后续的各个数组元素。</p><h2 id="变址操作数"><a href="#变址操作数" class="headerlink" title="变址操作数"></a>变址操作数</h2><p>变址操作数是指，在寄存器上加上常数产生一个有效地址。每个 32 位通用寄存器都可以用作变址寄存器。</p><p>MASM 可以用不同的符号来表示变址操作数（括号是表示符号的一部分)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">constant[reg]<br>[constant + reg]<br></code></pre></td></tr></table></figure><p>第一种形式是变量名加上寄存器。变量名由汇编器转换为常数，代表的是该变量的偏移量。</p><p>变址寻址的第二种形式是寄存器加上常数偏移量。变址寄存器保存数组或结构的基址，常数标识各个数组元素的偏移量。</p><p>两种形式的效果是相同的。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101235820435.png" alt="" style="zoom:67%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; example 1<br>.data<br>arrayB BYTE 10h, 20h, 30h<br>.code<br>mov esi, 0<br>mov al, arrayB[esi]       ; AL = 10h<br><br>; example 2<br>.data<br>arrayW WORD 1000h, 2000h, 3000h<br>.code<br>mov esi, OFFSET arrayW<br>mov ax, [esi]             ; AX = 1000h<br>mov ax, [esi + 2]         ; AX = 2000h<br>mov ax, [esi + 4]         ; AX = 3000h<br></code></pre></td></tr></table></figure><hr><h1 id="JMP-和-LOOP-指令"><a href="#JMP-和-LOOP-指令" class="headerlink" title="JMP 和 LOOP 指令"></a>JMP 和 LOOP 指令</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 95</p></blockquote><p>默认情况下，CPU是顺序加载并执行程序。但是，当前指令有可能是有条件的，也就是说，它按照 CPU 状态标志（零标志、符号标志、进位标志等）的值把控制转向程序中的新位置。汇编语言程序使用条件指令来实现如 IF 语句的高级语句与循环。每条条件指令都包含了一个可能的转向不同内存地址的转移（跳转）。控制转移，或分支，是一种改变语句执行顺序的方法，它有两种基本类型：</p><ul><li><p><strong>无条件转移</strong>：无论什么情况都会转移到新地址。新地址加载到指令指针寄存器，使得程序在新地址进行执行。JMP 指令实现这种转移。</p></li><li><p><strong>条件转移</strong>：满足某种条件，则程序出现分支。各种条件转移指令还可以组合起来，形成条件逻辑结构。CPU 基于 ECX 和标志寄存器的内容来解释真 &#x2F; 假条件。</p></li></ul><h2 id="JMP-指令"><a href="#JMP-指令" class="headerlink" title="JMP 指令"></a>JMP 指令</h2><p>JMP 指令无条件跳转到目标地址，该地址用代码标号来标识，并被汇编器转换为偏移量。语法是：<code>JMP destination</code>。</p><p>当 CPU 执行一个无条件转移时，目标地址的偏移量被送入指令指针寄存器，从而导致从新地址开始继续执行。</p><p>JMP 指令提供了一种简单的方法来创建循环即跳转到循环开始时的标号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">top:<br>    .<br>    .<br>    jmp top ; 不断地循环<br></code></pre></td></tr></table></figure><p>JMP 是无条件的，因此循环会无休止地进行下去，除非找到其他方法退出循环。</p><h2 id="LOOP-指令"><a href="#LOOP-指令" class="headerlink" title="LOOP 指令"></a>LOOP 指令</h2><p>LOOP指令，正式称为<strong>按照 ECX 计数器循环</strong>，将程序块重复特定次数。<strong>ECX 自动成为计数器，每循环一次计数值减 1</strong>。</p><p>语法是：<code>LOOP destination</code>。</p><p>循环目标必须距离当前地址计数器 -128 到 +127 字节范围内。</p><p>LOOP 指令的执行有两个步骤：第一步，ECX 减 1；第二步，将 ECX 与 0 比较。如果 ECX 不等于 0，则跳转到由目标给出的标号。否则如果 ECX 等于 0，则不发生跳转，并将控制传递到循环后面的指令。</p><p>在下例中，每次执行循环时 AX 加 1，当循环结束的时候 AX &#x3D; 5，ECX &#x3D; 0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">    mov ax, 0<br>    mov ecx, 5<br><br>L1:<br>    inc ax<br>    loop L1<br></code></pre></td></tr></table></figure><p>在循环内创建另一个循环的时候，必须考虑 ECX 中的外层循环计数该如何处理。一个较好的解决方案是把外层循环的技术保存在一个变量中。作为一条一般性的规则，应该尽量避免使用嵌套深度超过两层的循环。否则，管理循环计数将很复杂。</p><h2 id="程序示例"><a href="#程序示例" class="headerlink" title="程序示例"></a>程序示例</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 98</p></blockquote><p><font size = 4><b>整数数组求和</b></font></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101210920217.png" alt="" style="zoom:67%;" /><p><font size = 4><b>复制字符串</b></font></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101211026618.png" style="zoom:67%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20230101211106805.png" alt="" style="zoom:67%;" /><p>MOV 指令不能同时有两个内存操作数，所以，每个源字符串字符送入 AL，然后再从 AL 送入目标字符串。</p>]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第三章</title>
    <link href="/posts/ae5782ad0d6f/"/>
    <url>/posts/ae5782ad0d6f/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第三章学习笔记</b></font></center><br><span id="more"></span><h1 id="汇编语言部分基本语言元素"><a href="#汇编语言部分基本语言元素" class="headerlink" title="汇编语言部分基本语言元素"></a>汇编语言部分基本语言元素</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 42</p></blockquote><p><font size = 5><b>整数常量</b></font></p><p>以字母开头的十六进制数必须加个前置0，以防汇编器将其解释为标识符。</p><p><font size = 5><b>字符串常量</b></font></p><p>和字符常量以整数形式存放一样，字符串常量在内存中的保存形式为<strong>整数字节数值序列</strong>。</p><p>例如，字符串常量 “ABCD” 就包含四个字节 41h、42h、43h、44h。</p><p><font size = 5><b>伪指令</b></font></p><p>伪指令 (directive) 是嵌入源代码中的命令，由汇编器识别和执行。</p><p>伪指令不在运行时执行，但是它们可以定义变量、宏和子程序；为内存段分配名称，执行许多其他与汇编器相关的日常任务。</p><p>默认情况下，伪指令不区分大小写。例如，<code>.data</code>，<code>.DATA</code> 和 <code>.Data</code> 是相同的。</p><p><font size = 5><b>定义段</b></font></p><p>汇编器伪指令的一个重要功能是定义程序区段，也称为段 (segment)。程序中的段具有不同的作用。</p><ul><li><p>数据段：<code>.DATA</code> 伪指令表示的数据段可以用于定义变量。</p></li><li><p>代码段：<code>.CODE</code> 伪指令标识的程序区段包含了可执行的指令。</p></li><li><p>堆栈段：<code>.STACK</code> 伪指令标识的程序区段定义了运行时堆栈，并设置了其大小。</p></li></ul><p><font size = 5><b>指令</b></font></p><p>指令 (instruction) 是一种语句，它在程序汇编编译时变得可执行。汇编器将指令翻译为机器语言字节，并且在运行时由 <code>CPU</code> 加载和执行。一条指令有四个组成部分：</p><ol><li>标号（可选）：是一种标识符，是指令和数据的位置标记。标号有两种类型：数据标号和代码标号。</li><li>指令助记符（必需）</li><li>操作数（通常是必需的）</li><li>注释（可选）</li></ol><h2 id="习题整理"><a href="#习题整理" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  计算机的 <code>CPU</code> 每执行一个 ( )，就完成一步基本运算。 （D）<br>  A. 软件<br>  B. 算法<br>  C. 程序<br>  D. 指令</p></blockquote><p>解析见上文整理内容。</p><blockquote><hr><p>  在 x86 汇编语言中，汇编程序常用的三个段，分别是（代码段）、（数据段）和（堆栈段）；<br>  对于 <strong>32位 CPU</strong>，用于在循环中控制循环次数的寄存器是（$ECX$），包含下一跳将要执行指令的地址的寄存器是（$EIP$）。</p></blockquote><p>解析见上文整理内容。</p><blockquote><hr><p>  一条指令有四个组成部分，分别是标号、（指令助记符）、（操作数）和（注释）。其中，标号可分为（数据标号）和（代码标号）。</p></blockquote><p>解析见上文整理内容。</p><hr><h1 id="程序模板"><a href="#程序模板" class="headerlink" title="程序模板"></a>程序模板</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 47, 52, 67</p></blockquote><p>汇编语言程序有一个简单的结构，并且变化很小。当开始编写一个新程序时，可以从一个空 shell 程序开始，里面有所有基本的元素。通过填写缺省部分，并在新名字下保存该文件就可以避免键入多余的内容。关键字大小写均可：</p><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20221231195555.png" alt="image" style="zoom:67%;" /></center><hr><h1 id="汇编、连接和运行程序"><a href="#汇编、连接和运行程序" class="headerlink" title="汇编、连接和运行程序"></a>汇编、连接和运行程序</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 53</p></blockquote><p>用汇编语言编写的源程序不能直接在其目标计算机上执行，必须通过翻译或汇编将其转换为可执行代码。汇编器生成包含机器语言的文件，称为目标文件 (object file)。</p><p>这个文件还没有准备好执行，它还需传递给一个被称为链接器 (linker) 的程序，从而生成可执行文件 (executable file)。</p><p>这个文件就准备好在操作系统命令提示符下执行。</p><p><font size = 5><b>汇编-连接-执行周期</b></font></p><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221231174038959.png" alt="汇编-连接-执行周期" style="zoom: 67%;" /></center><p>对上图每一个步骤进行说明：</p><ol><li>编程者用文本编辑器 (text editor) 创建一个 <code>ASCII</code> 文本文件，称之为<strong>源文件</strong>。</li><li><strong>汇编器</strong>读取源文件，并<strong>生成目标文件</strong>，即对程序的机器语言翻译。或者，它也会生成列表文件。只要出现任何错误，编程者就必须返回步骤1，修改程序。</li><li><strong>链接器</strong>读取并<strong>检查目标文件</strong>，以便发现该程序是否包含了任何对链接库中过程的调用。链接器从链接库中复制任何被请求的过程，将它们与目标文件组合，以生成<strong>可执行文件</strong>。</li><li>操作系统<strong>加载</strong>程序将可执行文件读入内存，并使 CPU 分支到该程序起始地址，然后程序开始执行。</li></ol><h2 id="习题整理-1"><a href="#习题整理-1" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  在汇编语言中，能将目标文件生成可执行文件的程序是： （C）<br>  A. 调试程序<br>  B. 汇编程序<br>  C. 链接程序<br>  D. 编译程序</p></blockquote><p>链接器从链接库中复制任何被请求的过程，将它们与目标文件组合，以生成<strong>可执行文件</strong>。</p><hr><h1 id="定义数据"><a href="#定义数据" class="headerlink" title="定义数据"></a>定义数据</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 55</p></blockquote><p><strong>数据定义语句</strong>形如：<code>count DWORD 12345</code>。</p><h2 id="内部数据类型"><a href="#内部数据类型" class="headerlink" title="内部数据类型"></a>内部数据类型</h2><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221231175027618.png" alt="内部数据类型" style="zoom:67%;" /></center><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221231202803655.png" alt="image-20221231202803655" style="zoom: 67%;" /></center><h2 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h2><h3 id="定义整数类型"><a href="#定义整数类型" class="headerlink" title="定义整数类型"></a>定义整数类型</h3><p>初始值数据定义中<strong>至少要有一个初始值</strong>，即使该值为 0。</p><p>其他初始值，如果有的话，用逗号分隔（例如初始化数组：<code>list BYTE 10, 20, 30</code>）。<strong>对整数数据类型而言，初始值 (initializer) 是整数常量或是与变量类型</strong>，如 <code>BTYE</code> 或 <code>WORD</code> 相匹配的整数表达式。</p><p>如果程序员希望不对变量进行初始化（随机分配数值)，可以用符号 <code>?</code> 作为初始值。使用 <code>?</code> 初始值使得变量未初始化，这意味着在运行时分配数值到该变量。</p><p>所有初始值，不论其格式，都由汇编器转换为二进制数据。初始值 00110010b、32h 和 50d 都具有相同的二进制数值。</p><h3 id="定义字符串"><a href="#定义字符串" class="headerlink" title="定义字符串"></a>定义字符串</h3><p>定义一个字符串，要用单引号或双引号将其括起来。</p><p>最常见的字符串类型是用一个空字节(值为 0)作为结束标记，称为<strong>以空字节结束的字符串</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">greeting1 BYTE &quot;Good Afternoon&quot;, 0<br>greeting2 BYTE &#x27;Good Night&#x27;, 0<br></code></pre></td></tr></table></figure><p>十六进制代码 <code>ODh</code> 和 <code>0Ah</code> 也被称为 <code>CR/LF</code> (回车换行符) 或行结束字符。在编写标准输出时，它们将光标移动到当前行的下一行的左侧。</p><h3 id="DUP-操作符"><a href="#DUP-操作符" class="headerlink" title="DUP 操作符"></a>DUP 操作符</h3><p>DUP 操作符使用一个整数表达式作为计数器，<strong>为多个数据项分配存储空间</strong>。在为字符串或数组分配存储空间时，这个操作符非常有用，它可以使用初始化或非初始化数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">BYTE 20 DUP(O)       ; 20个字节，值都为0<br>BYTE 20 DUP(?)       ; 20个字节，非初始化<br>BYTE  4 DUP(&quot;STACK&quot;) ; 20个字节<br></code></pre></td></tr></table></figure><h3 id="定义浮点类型"><a href="#定义浮点类型" class="headerlink" title="定义浮点类型"></a>定义浮点类型</h3><ul><li><p>REAL4 定义 4 字节单精度浮点变量。</p></li><li><p>REAL8 定义 8 字节双精度数值。</p></li><li><p>REAL10 定义 10 字节扩展精度数值。</p></li></ul><p>每个伪指令都需要一个或多个实常数初始值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">rVal1     REAL4   -1.2<br>rVal2     REAL8   3.2E-260<br>rVal3     REAL10  4.6E+4096<br>shortArray  REAL4   20 DUP(0.0)<br></code></pre></td></tr></table></figure><p>下图描述了标准实数类型的最少有效数字个数和近似范围：</p><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221231190349341.png" alt="标准实数类型" style="zoom:67%;" /></center><h2 id="习题整理-2"><a href="#习题整理-2" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  语句“array WORD 6 DUP (4)”分配主存的存储单元个数是：（B）<br>  A. 6<br>  B. 12<br>  C. 24<br>  D. 48</p></blockquote><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/115640956">吐血整理！这篇带你彻底理解主存中存储单元地址的分配 - 知乎 (zhihu.com)</a></p><p>通常都是以8位二进制为一个存储单元，也就是一个字节。一个 <code>WORD</code> 拥有2个字节，<code>DUP</code> 前面的数字为6，表示共创建6个 <code>WORD</code>，即共12个字节。</p><blockquote><hr><p>  语句“array WORD 10 DUP (?)”分配主存的存储单元个数是：（20）</p></blockquote><p>解析无</p><blockquote><hr><p>  语句“array DWORD 10,20,30,40”分配主存的存储单元个数是：（16）</p></blockquote><p>解析无</p><blockquote><hr><p>  语句“array WORD 10,20,30,40”分配主存的存储单元个数是：（8）</p></blockquote><p>解析无</p><blockquote><hr><p>  语句“array DWORD 10,20,30,40,50”分配主存的存储单元个数是：（20）</p></blockquote><p>解析无</p><blockquote><hr><p>  语句“array word 5 dup(1, 2)”分配主存的存储单元个数是：（10）</p></blockquote><p><em><strong>待添加注释</strong></em></p><blockquote><hr><p>  下列哪个数据伪指令定义32位无符号整数变量：（D）<br>  A. WORD<br>  B. SWORD<br>  C. BYTE<br>  D. DWORD</p></blockquote><p><code>WORD</code> 16位无符号整数；<code>SWORD</code> 16位有符号整数；<code>BYTE</code> 8位无符号整数；<code>DWORD</code> 32位无符号整数。</p><blockquote><hr><p>  下列哪个数据伪指令定义16位有符号整数变量：（B）<br>  A. WORD<br>  B. SWORD<br>  C. BYTE<br>  D. SBYTE</p></blockquote><p><code>WORD</code> 16位无符号整数；<code>SWORD</code> 16位有符号整数；<code>BYTE</code> 8位无符号整数；<code>SBYTE</code> 8位有符号整数。</p><blockquote><hr><p>  下列哪个数据伪指令定义16位无符号整数变量？（C）<br>  A. DWORD<br>  B. SWORD<br>  C. WORD<br>  D. SDWORD</p></blockquote><p>解析无</p><blockquote><hr><p>  下列哪个数据伪指令定义32位有符号整数变量？（D）<br>  A. DWORD<br>  B. SWORD<br>  C. FWORD<br>  D. SDWORD</p></blockquote><p>解析无</p><blockquote><hr><p>  下列哪个数据伪指令定义8位有符号整数变量？（SBYTE）</p></blockquote><p>解析无</p><hr><h1 id="小端顺序"><a href="#小端顺序" class="headerlink" title="小端顺序"></a>小端顺序</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 62</p></blockquote><p>x86 处理器在内存中按<strong>小端顺序</strong> (低到高) <strong>存放和检索数据</strong>。</p><p>最低有效字节存放在分配给该数据的第一个内存地址中，剩余字节存放在随后的连续内存位置中。</p><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221231191909818.png" alt="image-20221231191909818" style="zoom:60%;" /></center><p>其他有些计算机系统采用的是大端顺序(高到低)。下图展示了 12345678h 从偏移量 0000 开始的大端顺序存放。</p><center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221231192011363.png" alt="image-20221231192011363" style="zoom:63%;" /></center><h2 id="习题整理-3"><a href="#习题整理-3" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  变量保存于字节编址的内存存储器中，每个存储单元保存一个8位、字节量数据。多个字节数据顺序逐个存放在主存相邻单元。<br>  一般采用<strong>小端方式</strong>存储，即高字节数据保存在（<strong>高地址</strong>）存储单元，低字节数据保存在（<strong>低地址</strong>）存储单元。</p></blockquote><p>解析见上文整理内容。</p><hr><h1 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h1><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》 Page 63</p></blockquote><h2 id="等号伪指令"><a href="#等号伪指令" class="headerlink" title="等号伪指令"></a>等号伪指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">name = expression<br></code></pre></td></tr></table></figure><p>通常，表达式是一个32位的整数值。当程序进行汇编时，在汇编器预处理阶段，所有出现的 name 都会被替换为 expression。类比 C 语言的 <code>#define name expression</code>。</p><h2 id="计算数组大小"><a href="#计算数组大小" class="headerlink" title="计算数组大小"></a>计算数组大小</h2><p><code>$</code> 运算符（当前地址计数器）返回当前程序语句的偏移量。在下例中，从当前地址计数器（<code>$</code>）中减去list的偏移量，计算得到 ListSize。<strong>ListSize 必须紧跟在 list 的后面。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">list BYTE 10, 20, 30, 40<br>ListSize = ($ - list)<br></code></pre></td></tr></table></figure><h2 id="字数组和双字数组"><a href="#字数组和双字数组" class="headerlink" title="字数组和双字数组"></a>字数组和双字数组</h2><p>当要计算元素数量的数组中包含的不是字节时，就应该用数组总的大小（按字节计）除以单个元素的大小。</p><p>比如，在下例中，由于数组中的每个字要占2个字节（16位)，因此，地址范围应该除以2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">list WORD 1000h, 2000h, 3000h, 4000h<br>ListSize = ($ - list) / 2<br></code></pre></td></tr></table></figure><p>同样，双字数组中每个元素长4个字节，因此，其总长度除以4才能产生数组元素的个数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">list DOWRD 10000000h, 20000000h, 30000000h, 40000000h<br>ListSize = ($ - list) / 4<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言:基于x86处理器-学习笔记-第一二章</title>
    <link href="/posts/79eb2112a323/"/>
    <url>/posts/79eb2112a323/</url>
    
    <content type="html"><![CDATA[<center><font size = 5><b>《汇编语言：基于x86处理器（原书第7版）》<br>第一、二章学习笔记</b></font></center><br><span id="more"></span><h1 id="汇编语言基本概念"><a href="#汇编语言基本概念" class="headerlink" title="汇编语言基本概念"></a>汇编语言基本概念</h1><p><font size = 4><b>1. 汇编语言可移植吗?</b></font></p><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 3</p></blockquote><p>一种语言，如果它的源程序能够在各种各样的计算机系统中进行编译和运行，那么这种语言被称为是可移植的 (portable)。</p><p>例如，一个C++程序，除非需要特别引用某种操作系统的库函数，否则它就几乎可以在任何一台计算机上编译和运行。Java语言的一大特点就是，其编译好的程序几乎能在所有计算机系统中运行。</p><p><strong>汇编语言不是可移植的，因为它是为特定处理器系列设计的。</strong> 目前广泛使用的有多种不同的汇编语言，每一种都基于一个处理器系列。对于一些广为人知的处理器系列如 <code>Motorola68x00</code>、<code>x86</code>、<code>SUN Sparc</code>、<code>Vax</code> 和 <code>IBM-370</code>，汇编语言指令会直接与该计算机体系结构相匹配，或者在执行时用一种被称为微代码解释器 (microcode interpreter) 的处理器内置程序来进行转换。</p><p><font size = 4><b>2. 汇编语言与机器语言有什么关系?</b></font></p><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 3</p></blockquote><p>机器语言 (machine language) 是一种数字语言，专门设计成能被计算机处理器（CPU）理解。所有 <code>x86</code> 处理器都理解共同的机器语言。汇编语言 (assembly language) 包含用短助记符如 <code>ADD</code>、<code>MOV</code>、<code>SUB</code> 和 <code>CALL</code> 书写的语句。</p><p><strong>汇编语言与机器语言是一对一 (one-to-one) 的关系：每一条汇编语言指令对应一条机器语言指令。</strong></p><p><font size = 4><b>3. C++ 和 Java 与汇编语言有什么关系?</b></font></p><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 3</p></blockquote><p><strong>高级语言如 <code>Python</code>、<code>C++</code> 和 <code>Java</code> 与汇编语言和机器语言的关系是一对多 (one-to-many)。</strong></p><p>比如，<code>C++</code> 的一条语句就会扩展为多条汇编指令或机器指令。这种转换需要多条语句，因为每条汇编语句只对应一条机器指令。</p><p><font size = 4><b>4. 汇编语言有规则吗?</b></font></p><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 4</p></blockquote><p><strong>大多数汇编语言规则都是以目标处理器及其机器语言的物理局限性为基础的。</strong> 比如，CPU要求两个指令操作数的大小相同。</p><p>与 C++ 或 Java 相比，汇编语言的规则较少，因为，前者是用语法规则来减少意外的逻辑错误，而这是以限制底层数据访问为代价的。反之，汇编语言可以访问所有的内存地址。</p><p><font size = 4><b>5. 为什么高级语言这么发达还会用汇编语言？</b></font></p><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 3</p></blockquote><ul><li><p>嵌入式程序是指一些存放在专用设备中小容量存储器内的短程序。高级语言可能生成很大的可执行文件，以至于超出设备的内存容量。由于汇编语言占用内存少，因此它是编写嵌入式程序的理想工具。</p></li><li><p>处理仿真和硬件监控的实时应用程序要求精确定时和响应。高级语言不会让程序员对编译器生成的机器代码进行精确控制。汇编语言则允许程序员精确指定程序的可执行代码。</p></li><li><p>电脑游戏要求软件在减少代码大小和加快执行速度方面进行高度优化。游戏程序员经常选择汇编语言作为工具，因为汇编语言允许直接访问计算机硬件，所以，为了提高速度可以对代码进行手工优化。</p></li></ul><p><font size = 4><b>6. 汇编语言与高级语言的比较</b></font></p><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 4</p></blockquote><table><thead><tr><th>应用类型</th><th>高级语言</th><th>汇编语言</th></tr></thead><tbody><tr><td>商业或科学应用程序，为单一的中型或大型平台编写</td><td>规范结构使其易于组织和维护大量代码</td><td>最小规范结构，因此必须由具有不同程度经验的程序员来维护结构。这导致对已有代码的维护困难</td></tr><tr><td>硬件设备驱动程序</td><td>语言不一定提供对硬件的直接访问。即使提供了,可能也需要难以控制的编码技术，这导致维护困难</td><td>对硬件的访问直接且简单。当程序较短且文档良好时易于维护</td></tr><tr><td>为多个平台（不同的操作系统）编写的商业或科学应用程序</td><td>通常可移植。在每个目标操作系统上,源程序只做少量修改就能重新编译</td><td>需要为每个平台单独重新编写代码，每个汇编器都使用不同的语法。维护困难</td></tr><tr><td>需要直接访问硬件的嵌入式系统和电脑游戏</td><td>可能生成很大的可执行文件，以至于超出设备的内存容量</td><td>理想，因为可执行代码小，运行速度快</td></tr></tbody></table><h2 id="习题整理"><a href="#习题整理" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  （机器语言）是一种数字语言，专门设计成能被计算机处理器理解。<br>  （汇编语言）是包含用短助记符如 <code>ADD</code>、<code>MOV</code> 和 <code>CALL</code> 书写的语句，两者是（一对一）的关系。<br>  （高级语言）如 <code>Python</code>、<code>C++</code> 等与汇编语言的是（一对多）的关系。</p></blockquote><p>参考上文整理内容。</p><hr><h1 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h1><h2 id="整数存储大小"><a href="#整数存储大小" class="headerlink" title="整数存储大小"></a>整数存储大小</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 9</p></blockquote><p>在 <code>x86</code> 计算机中，所有数据存储的基本单位都是字节 (<code>byte</code>)，<strong>一个字节有8位</strong>。</p><p>其他的存储单位还有：</p><ul><li>字 (<code>word</code>，2个字节)</li><li>双字 ( <code>doubleword</code>，4个字节) </li><li>四字 (<code>quadword</code>，8个字节)</li></ul><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 12</p></blockquote><ol><li><p><strong>负整数使用补码表示。</strong> </p></li><li><p>将一个二进制整数按位取反(求补)再加 1，就形成了它的补码。将一个十六进制整数按位取反并加1，就生成了该十六进制整数的补码。</p></li><li><p><strong>补码操作是可逆的。</strong> 以 8 位二进制数 $0000 \space 0001$ 为例，其补码为 $1111 \space 1111$ 。同时，$1111 \space 1111$ 的补码也为 $0000 \space 0001$。</p></li></ol><h2 id="习题整理-1"><a href="#习题整理-1" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  对于下列8位有符号数来说，哪个值最大？（A）<br>  A. 81<br>  B. 0010 1100<br>  C. F5H<br>  D. 1101 0110</p></blockquote><p>A 为十进制数，值为 81；<br>B 为二进值数，值为 44；<br>C 为十六进制数，转换成二进值后为 $1111 \space 0101$，所以值为 -11；<br>D 为二进值数，值为 -42。</p><p>综上可得，A 的值最大</p><blockquote><hr><p>  A. 将16位十六进制数 55AAH 转化为二进制数的值为（$0101\space 0101\space 1010\space 1010$）；<br>  B. 将16位二进制数1100 1011 1001 0111B 转化为十六进制数的值为（$CB97$）；<br>  C. 有符号十进制整数-46的8位二进制补码是（$1101\space 0010$）；<br>  D. 十六进制整数A598 + 32A7&#x3D;（$D83F$）</p></blockquote><p>A 易得 $0101\space 0101\space 1010\space 1010$；<br>B 易得 $CB97$；<br>C 将 $46D &#x3D; 0010\space 1110B$，对 $0010\space 1110B$ 进行取反操作后 $+ 1$，可以到最终结果为 $1101\space 0010$；<br>D 通过 16 进制加法，可以计算出结果为 $D83F$。</p><blockquote><hr><p>  A. 将16位十六进制数AAF0H 转化为二进制数的值为（1010 1010 1111 0000）；<br>  B. 将16位二进制数1011 1101 0110 1001B 转化为十六进制数的值为（BD69）；<br>  C. 有符号十进制整数-98的8位二进制补码是（1001 1110）；<br>  D. 十六进制整数3A7+32F6&#x3D;（369D）</p></blockquote><p>解析无</p><blockquote><hr><p>  字长为8位的无符号数，其数值范围为（0）到（255）</p></blockquote><p>数值范围为 $2^0 \sim (2^8-1)$，即 0 ~ 255。</p><blockquote><hr><p>  将16位十六进制数6A8DH 转化为二进制数的值为（0110 1010 1000 1101）；<br>  将16位二进制数1010 0001 1110 1011B 转化为十六进制数的值为（A1EB）；<br>  有符号十进制整数-100的8位二进制补码是（1001 1100）；<br>  十六进制整数068A+7D08&#x3D;（8392）。</p></blockquote><p>解析无</p><blockquote><hr><p>  将16位十六进制数7DF6H 转化为二进制数的值为（0111 1101 1111 0110）；<br>  将16位二进制数1110 1101 0111 1000B 转化为十六进制数的值为（ED78）；<br>  有符号十进制整数-89的8位二进制补码是（1010 0111）；<br>  十六进制整数0F3D+A256&#x3D;（B193）。</p></blockquote><p>解析无</p><blockquote><hr><p>  将16位十六进制数8A5DH 转化为二进制数的值为（1000 1010 0101 1101）；<br>  将16位二进制数1010 0101 0110 1100B 转化为十六进制数的值为（A56C）；<br>  有符号十进制整数-98的8位二进制补码是（1001 1110）；<br>  十六进制整数753A+32F6&#x3D;（A830）。</p></blockquote><p>解析无</p><blockquote><hr><p>  在8位二进制数01101011中，最高有效位(MSB)的值是（0），最低有效位(LSB)的值是（1）。</p></blockquote><p>参考资料：<a href="https://blog.csdn.net/qq_29350001/article/details/51177404">LSB最低有效位和MSB最高有效位_聚优致成的博客-CSDN博客_最低有效位</a></p><p>最低有效位是指一个二进制数字中的即最低位，具有权值为 $2^0$，可以用它来检测数的奇偶性。在大端序中，<code>LSB</code> 指最右边的位。</p><p>最高有效位是指一个n位二进制数字中的最高位，具有最高的权值为 $2^n - 1$。在大端序中，<code>MSB</code> 即指最左端的位。对于有符号二进制数，负数采用反码或补码形式，此时 <code>MSB</code>用来表示符号，<code>MSB</code> 为 1 表示负数，为 0 表示正数。</p><blockquote><hr><p>  对于下列8位有符号数来说，最小的是：（D）<br>  A. 0<br>  B. 00101100B<br>  C. 75H<br>  D. 11010110B</p></blockquote><p>A B C 都为正数。而 D 的符号位为 1，表示负数。</p><blockquote><hr><p>  负数在内存里是以其哪种形式存放？（C）<br>  A. 原码<br>  B. 反码<br>  C. 补码<br>  D. 真值</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  对于下列8位有符号数来说，哪个值最大？（B）<br>  A. FFH<br>  B. 48H<br>  C. 70<br>  D. 11010110</p></blockquote><p>A ：-1；B：72；C：70；D：-42。</p><hr><h1 id="x86-处理器架构"><a href="#x86-处理器架构" class="headerlink" title="x86 处理器架构"></a>x86 处理器架构</h1><h2 id="基本微机设计"><a href="#基本微机设计" class="headerlink" title="基本微机设计"></a>基本微机设计</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 23</p></blockquote><div align="center"><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221230210411168.png" alt="image-20221230210411168" style="zoom:80%;" /></div><p>上图给出了假想机的基本设计。</p><ol><li><p>中央处理单元 (<code>CPU</code>) 是<strong>进行算术和逻辑操作</strong>的部件,包含了：</p><ul><li>寄存器 (register)<br>有限数量的存储位置。</li><li>一个高频时钟<br>时钟 (clock) <strong>对 <code>CPU</code> 内部操作与系统其他组件进行同步</strong>。</li><li>一个控制单元<br>控制单元 (control unit，<code>CU</code>) <strong>协调参与机器指令执行的步骤序列</strong>。</li><li>一个算术逻辑单元<br>算术逻辑单元 (arithmetic logic unit，<code>ALU</code>) <strong>执行算术运算</strong>，如加法和减法，以及逻辑运算，如 <code>AND</code> (与)、<code>OR</code>(或) 和 <code>NOT</code> (非)。</li></ul></li><li><p>内存存储单元 (memory storage unit) 用于<strong>在程序运行时保存指令与数据</strong>。<br> 它接受来自 <code>CPU</code> 的数据请求，<strong>将数据从随机存储器（<code>RAM</code>）传输到 <code>CPU</code>，并从 <code>CPU</code> 传输到内存</strong>。由于所有的数据处理都在 <code>CPU</code> 内进行，因此<strong>保存在内存中的程序在执行前需要被复制到 <code>CPU</code> 中</strong>。程序指令在复制到 <code>CPU</code> 时，可以一次复制一条，也可以一次复制多条。</p></li><li><p>CPU 通过主板上 CPU 插座的引脚与计算机其他部分相连。大部分引脚连接的是<strong>数据总线</strong>、<strong>控制总线</strong>和<strong>地址总线</strong>。</p></li><li><p>总线 (bus) 是一组并行线，用于<strong>将数据从计算机一个部分传送到另一个部分</strong>。<br> 一个计算机系统通常包含<strong>四类总线：数据类，I&#x2F;O类、控制类和地址类</strong>。</p><ul><li>数据总线 (data bus) <strong>在 <code>CPU</code> 和内存之间传输指令和数据</strong>。</li><li>I&#x2F;O总线<strong>在 <code>CPU</code> 和系统输入&#x2F;输出设备之间传输数据</strong>。</li><li>控制总线 (control bus) <strong>用二进制信号对所有连接在系统总线上设备的行为进行同步</strong>。</li><li>当前执行指令在 <code>CPU</code> 和内存之间传输数据时，地址总线 (address bus) <strong>用于保持指令和数据的地址</strong>。</li></ul></li><li><p>时钟︰与 CPU 和系统总线相关的每一个操作都是由一个恒定速率的内部时钟脉冲来进行同步。<br> <strong>机器指令的基本时间单位</strong>是机器周期 (machine cycle) 或<strong>时钟周期</strong> (clock cycle)。<br> 一个时钟周期的时长是一个完整时钟脉冲所需要的时间。<br> <strong>执行一条机器指令最少需要1个时钟周期</strong>，有几个需要的时钟则超过了50个（比如8088处理器中的乘法指令)。<br> 由于在 <code>CPU</code>、系统总线和内存电路之间存在速度差异，因此，<strong>需要访问内存的指令常常需要空时钟周期</strong>，也被称为<strong>等待状态</strong> (wait states )。</p></li></ol><h2 id="指令执行周期"><a href="#指令执行周期" class="headerlink" title="指令执行周期"></a>指令执行周期</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 24</p></blockquote><p>三个步骤：<strong>取指</strong> (Fetch)、<strong>译码</strong> (Decode) 和<strong>执行</strong> (Execute)。</p><p>操作数 (operand) 是指操作过程中输入或输出的值。</p><h2 id="读取内存"><a href="#读取内存" class="headerlink" title="读取内存"></a>读取内存</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 25</p></blockquote><p>作为一个常见现象，计算机<strong>从内存读取数据比从内部寄存器读取速度要慢很多</strong>。</p><p>这是因为从内存读取一个值，需要经过下述步骤：</p><ol><li>将想要读取的值的地址放到地址总线上。</li><li>设置处理器 RD（读取）引脚（改变 RD 的值）。</li><li>等待一个时钟周期给存储器芯片进行响应。</li><li>将数据从数据总线复制到目标操作数。</li></ol><p>上述每一步常常只需要一个时钟周期，虽然一共只需要4个时钟周期。但是，与CPU寄存器相比，这个速度还是慢了，因为访问寄存器一般只需要1个时钟周期。</p><p>CPU 设计者想出了一个可以减少读写内存的时间的方法——<strong>将大部分近期使用过的指令和数据存放在高速存储器 <code>cache</code> 中</strong>。</p><p>其思想是，程序更可能希望反复访问相同的内存和指令。因此，<code>cache</code> 保存这些值就能使它们能被快速访问到。此外，当 <code>CPU</code> 开始执行一个程序时，它会预先将后续（比如）一千条指令加载到 <code>cache</code> 中，这个行为是基一种假设，即这些指令很快就会被用到。如果这种情况重复发生在一个代码块中，则 <code>cache</code> 中就会有相同的指令。</p><p>当处理器能够在 <code>cache</code> 存储器中发现想要的数据，则称为 <strong><code>cache</code> 命中</strong> (cache hit)。反之，如果 <code>CPU</code> 在 <code>cache</code> 中没有找到数据，则称为 <strong><code>cache</code> 未命中</strong> (cache miss)。</p><p>x86 系列中的 <code>cache</code> 存储器有两种类型：</p><ul><li>一级 <code>cache</code> (或主 <code>cache</code>)位于 <code>CPU</code> 上</li><li>二级 <code>cache</code> (或次 <code>cache</code> )速度略慢，通过高速数据总线与 <code>CPU</code> 相连</li></ul><p>这两种 <code>cache</code> 以最佳方式一起工作。</p><p>还有一个原因使得 <code>cache</code> 存储器比传统 <code>RAM</code> 速度快—— <code>cache</code> 存储器是由一种被称为<strong>静态 <code>RAM</code></strong> ( static RAM）的特殊存储器芯片构成的。</p><h2 id="习题整理-2"><a href="#习题整理-2" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  在微型计算机中，微处理器的主要功能是：（A）<br>  A. 算术逻辑运算及全机的控制<br>  B. 逻辑运算<br>  C. 算术逻辑运算<br>  D. 算术运算</p></blockquote><p>解析无</p><blockquote><hr><p>  中央处理单元是进行算术和逻辑操作的部件，包含了（寄存器）、高频时钟、（控制单元）和（算术逻辑单元）。</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  （总线）是一组并行线，用于将数据从计算机的一个部分传到另一部分。<br>  其中，（数据总线）用于在内存和 <code>CPU</code> 之间传递指令和数据；<br>  （控制总线）使用二进制信号对所有连接在总线上的设备的行为进行同步。</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  当处理器能够在 <code>cache</code> 存储器中发现想要的数据，则称为 <code>cache</code>（命中）。<br>  反之，如果 <code>CPU</code> 在 <code>cache</code> 中没有找到数据，则称为 <code>cache</code>（未命中）。</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  CPU可以用来描述计算机的：（A）<br>  A. 运算速度<br>  B. 输入功率<br>  C. 磁盘转速<br>  D. 更新频率</p></blockquote><p><em><strong>解析待添加</strong></em></p><blockquote><hr><p>  一条指令的执行通常可分为(取指)、（编码）和（执行）三个阶段。</p></blockquote><p>解析见上文整理内容。</p><hr><h1 id="x86-处理器"><a href="#x86-处理器" class="headerlink" title="x86 处理器"></a>x86 处理器</h1><h2 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 27</p></blockquote><p>x86处理器有四个主要的操作模式：</p><ul><li>保护模式</li><li>实地址模式</li><li>系统管理模式</li><li>子模式：虚拟8086 (virtual-8086) 模式，这是保护模式的特殊情况。</li></ul><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 27</p></blockquote><p>在32位<strong>保护模式</strong>下，一个任务或程序最大可以寻址 <strong>4GB 的线性地址空间</strong>。</p><p>从 P6 处理器开始，一种被称为<strong>扩展物理寻址</strong> (extended physical addressing) 的技术使得可以被寻址的<strong>物理内存空间增加到 64GB</strong>。</p><p>与之相反，<strong>实地址模式</strong>程序只能<strong>寻址 1MB 空间</strong>。</p><p>如果处理器在<strong>保护模式下运行多个虚拟8086程序</strong>，则<strong>每个程序只能拥有自己的1MB内存空间</strong>。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><blockquote><p>  《汇编语言：基于x86处理器（原书第7版）》Page 28</p></blockquote><p>寄存器是直接位于 <code>CPU</code> 内的高速存储位置，其设计访问速度远高于传统存储器。</p><div align="center"><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221230231001537.png" alt="image-20221230231001537" style="zoom: 67%;" /></div><p>上图展示的是 32位 x86 处理器的基本程序执行寄存器 (basic program execution registers)。8个通用寄存器，6个段寄存器，一个处理器状态标志寄存器 (EFLAGS)，和一个指令指针寄存器 (EIP)。下图为 64为 x86-64 处理器中的寄存器。</p><div align="center"><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-909063cd57cd5b2136ff8ed4d04bc5e6_1440w.jpg" alt="img" style="zoom:57%;" /></div><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>通用寄存器主要用于算术运算和数据传输。其中，存在一些拥有特殊用法的通过寄存器：</p><ul><li>乘除指令默认使用 <code>EAX</code>。它常常被称为扩展累加器 (extended accumulator) 寄存器。</li><li><code>CPU</code> 默认使用 <code>ECX</code> 为循环计数器。</li><li><code>ESP</code> 用于寻址堆栈（一种系统内存结构）数据。它极少用于一般算术运算和数据传输，通常被称为扩展堆栈指针 (extended stack pointer) 寄存器。</li><li><code>ESI</code> 和 <code>EDI</code> 用于高速存储器传输指令，有时也被称为扩展源变址（ extended source index）寄存器和扩展目的变址 (extended destination index) 寄存器。</li><li>高级语言通过 <code>EBP</code> 来引用堆栈中的函数参数和局部变量。除了高级编程，它不用于一般算术运算和数据传输。它常常被称为扩展帧指针 (extended frame pointer) 寄存器。</li></ul><h3 id="指令指针"><a href="#指令指针" class="headerlink" title="指令指针"></a>指令指针</h3><p>指令指针 (<code>EIP</code>) 寄存器中包含下一条将要执行指令的地址。某些机器指令能控制 <code>EIP</code>，使得程序分支转向到一个新位置。</p><h3 id="状态标志位"><a href="#状态标志位" class="headerlink" title="状态标志位"></a>状态标志位</h3><blockquote><p>  设置标志位时，该标识位 &#x3D; 1；</p><p>  清除（或重置）标识位时，该标志位 &#x3D; 0。</p></blockquote><ul><li>进位标志位 (<code>CF</code>)，与目标位置相比，<strong>无符号</strong>算术运算结果太大时，设置该标志位。</li><li>溢出标志位 (<code>OF</code>)，与目标位置相比，<strong>有符号</strong>算术运算结果太大或太小时，设置该标志位。</li><li>符号标志位 (<code>SF</code>)，算术或逻辑操作产生<strong>负结果</strong>时,设置该标志位。</li><li>零标志位 (<code>ZF</code>)，算术或逻辑操作产生的<strong>结果为零</strong>时，设置该标志位。</li><li>辅助进位标志位 (<code>AC</code>)，算术操作在8位操作数中产生了位3向位4的<strong>进位</strong>时，设置该标志位。</li><li>奇偶校验标志位 (<code>PF</code>)，结果的最低有效字节包含偶数个1时，设置该标志位，否则，清除该标志位。一般情况下，如果数据有可能被修改或损坏时，该标志位用于进行错误检测。</li></ul><h2 id="习题整理-3"><a href="#习题整理-3" class="headerlink" title="习题整理"></a>习题整理</h2><blockquote><hr><p>  当无符号数算术运算结果超过目标位置大小时，应设置（进位）标志位；<br>  当有符号数算术运算结果对目标位置而言太大或太小时，应设置（溢出）标志位；<br>  当运算产生负数结果时，应设置（符号）标志位；<br>  当运算结果为零时，应设置（零）标志位。</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  算术或逻辑操作产生结果为零时，设置（零）标志位；<br>  与目标位置相比，有符号算术运算结果太大或太小时，设置（溢出）标志位。</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  下列标志位中，可用来判断无符号数运算结果太大的是：（B）<br>  A. OF<br>  B. CF<br>  C. ZF<br>  D. SF</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  下列几种存储器中，存取速度最快的是：（B）<br>  A. Cache<br>  B. 寄存器<br>  C. 内存<br>  D. 光盘</p></blockquote><p>在存储器层次结构中，存储器速度从最快到最慢的排列顺序是：<strong>寄存器 -&gt; <code>cache</code> -&gt; 主存 -&gt; 辅存</strong>。</p><blockquote><hr><p>  在程序执行过程中，EIP 寄存器保存的是？（B）<br>  A. 上一条已执行指令的地址<br>  B. 下一条即将要执行指令的地址<br>  C. 正在执行指令的地址<br>  D. 当前堆栈的栈顶</p></blockquote><p>参考上文整理内容。</p><blockquote><hr><p>  下列标志位中，可用来判断计算结果为零的是？（$ZF$）</p></blockquote><p>零标志位 (<code>ZF</code>)、算术或逻辑操作产生的<strong>结果为零</strong>时，设置该标志位。</p><blockquote><hr><p>  算数或逻辑操作产生负结果时，设置（ 符号）标志位；<br>  与目标位置相比，无符号算术运算结果太大时，设置（进位）标志位。</p></blockquote><p>解析见上文整理内容。</p><blockquote><hr><p>  两个整数相减等于0，则标志位正确的是：（D）<br>  A. ZF&#x3D;0 , PF&#x3D;0 , SF&#x3D;0<br>  B. ZF&#x3D;1 , PF&#x3D;0 , SF&#x3D;1<br>  C. ZF&#x3D;0 , PF&#x3D;1 , SF&#x3D;0<br>  D. ZF&#x3D;1 , PF&#x3D;1 , SF&#x3D;0</p></blockquote><ul><li>零标志位 (<code>ZF</code>)，算术或逻辑操作产生的<strong>结果为零</strong>时，设置该标志位。</li><li>符号标志位 (<code>SF</code>)，算术或逻辑操作产生<strong>负结果</strong>时,设置该标志位。</li><li>奇偶校验标志位 (<code>PF</code>)，结果的最低有效字节包含偶数个1时，设置该标志位，否则，清除该标志位。</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>汇编语言:基于x86处理器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-TCP/IP协议族</title>
    <link href="/posts/92834ef31539/"/>
    <url>/posts/92834ef31539/</url>
    
    <content type="html"><![CDATA[<blockquote><p>   一系列协议所组成的一个网络分层模型。</p></blockquote><hr><h1 id="为什么要分层"><a href="#为什么要分层" class="headerlink" title="为什么要分层"></a>为什么要分层</h1><p>由于现实网络的不稳定性以及不可靠性，所以需要将大数据进行分块传输，才能保障传输效率。但是应用层有许多协议，所有的协议都可能需要分块传输以及稳定传输等众多功能需求，所以为了能够复用一部分相同或者相似的功能，我们使用了分层，方便各个功能模块的解耦和复用。</p><p>如果网络能够稳定的话，那么分成两层也就够了。一层为应用层 HTTP，第二层就直接可以是数据链路层了。</p><hr><h1 id="四层网络模型"><a href="#四层网络模型" class="headerlink" title="四层网络模型"></a>四层网络模型</h1><table><thead><tr><th align="left">层级</th><th>协议</th></tr></thead><tbody><tr><td align="left">应用层</td><td>- <code>HTTP</code><br />- <code>FTP</code><br />- <code>DNS</code></td></tr><tr><td align="left">传输层</td><td>- <code>TCP</code><br />- <code>UDP</code></td></tr><tr><td align="left">网络层</td><td>- <code>IP</code></td></tr><tr><td align="left">数据链路层</td><td>- 以太网<br />- <code>Wi-Fi</code></td></tr></tbody></table><p>应用层负责完成我们所期望的实际的工作的内容。</p><p>但是因为现实网络的不稳定性以及不可靠性，所以有了传输层来用于分块传输。但是由于有些数据在网络不稳定的时候即使丢失了也不需要进行重传，所以在 TCP 之外有了一个 UDP，他们并行存在，都位于传输层。如果所有的协议都不需要重传的话，那么也就不需要这一层了。</p><p>但是为了对他们有一个共同的下位支持，所以分离出来了一个有着 IP 协议的网络层。网络层负责以最小的单位发送和接受上层分块的网络数据以及选址、路由等最下层的网络方面工作。这些工作主要就是 IP 协议做的。</p><p>最下层的数据链路层可以看作是一个物理级别的支持，当然也不止是纯粹的物理设备，比如还有线缆标准，无线网络标准等等用于保障数据的发送和接受不会出现歧义的内容。</p><hr><h1 id="七层网络模型"><a href="#七层网络模型" class="headerlink" title="七层网络模型"></a>七层网络模型</h1><p>由 OSI 制定。较四层模型更加的细致。</p><hr><h1 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a><code>TCP</code> 连接</h1><h2 id="什么是连接"><a href="#什么是连接" class="headerlink" title="什么是连接"></a>什么是连接</h2><p>通信双方建立确认「可以通信」，不会将对方的消息丢弃，即为「建立连接」。</p><p>通过双方建立连接，可以使得双方认识彼此，在以后的通信中可以不用每次确认身份而直接开始交流。</p><p>建立连接后，双方会各自确定一个端口，当使用该端口，发送或接受信息时，就可以直接确认对方的身份了。</p><p>将端口更加具象化后，就成为了 <code>Java</code> 中的 <code>Socket</code>（套接字）类，即 Java 对于 TCP 的端口的一个具体的实现。</p><blockquote><p>  Socket <code>n. 插口</code></p></blockquote><h2 id="TCP-连接的建立与关闭"><a href="#TCP-连接的建立与关闭" class="headerlink" title="TCP 连接的建立与关闭"></a><code>TCP</code> 连接的建立与关闭</h2><p><font size = 4><b>建立：三次握手</b></font></p><ul><li><p>开启双方的认识和交流。</p></li><li><p>开启端口。</p></li></ul><p><font size = 4><b>关闭：四次挥手</b></font></p><ul><li><p>忘记对方，结束双方的交流。</p></li><li><p>释放资源，关闭端口。</p></li></ul><h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><h3 id="为什么要长连接"><a href="#为什么要长连接" class="headerlink" title="为什么要长连接"></a>为什么要长连接</h3><p>因为移动网络并不在 Internet 中，而是在运营商的内网，并不具有真正的公网 IP， 因此当某个 TCP 连接在一段时间不通信之后，网关会出于网络性能考虑而关闭这条 TCP 连接和公网的连接通道，导致这个 TCP 端口不再能收到外部通信消息，即 TCP 连接被动关闭。</p><h3 id="长连接的实现方式：心跳"><a href="#长连接的实现方式：心跳" class="headerlink" title="长连接的实现方式：心跳"></a>长连接的实现方式：心跳</h3><p>在一定的时间间隔之内，不断的使用 TCP 的连接去发送一些超级短的且没有意义的消息到对方。目的是确认双方之间的连接是通畅的，让网关不能将自己定义为「空闲连接」，从而防止网关将自己的连接关闭。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP/IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-登录和授权</title>
    <link href="/posts/8dd7eb707626/"/>
    <url>/posts/8dd7eb707626/</url>
    
    <content type="html"><![CDATA[<h1 id="登录和授权的区别"><a href="#登录和授权的区别" class="headerlink" title="登录和授权的区别"></a><font size = 5><b>登录和授权的区别</b></font></h1><ul><li>登录：身份认证，即确认「你是你」的过程。 </li><li>授权：由身份或持有的令牌确认享有某些权限（例如获取用户信息）。而登录过程实质上的⽬的也是为了确认权限。</li></ul><hr><h1 id="登录和授权的两种方式"><a href="#登录和授权的两种方式" class="headerlink" title="登录和授权的两种方式"></a><font size = 5><b>登录和授权的两种方式</b></font></h1><ul><li><code>Cookie Header</code></li><li><code>Authorization Header</code></li></ul><hr><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><code>Cookie</code></h1><blockquote><ul><li><p>可以把任何服务器希望存在用户本地的数据都存在用户本地。</p></li><li><p>可以认为是浏览器的缓存。</p></li><li><p>是一个 <code>Header</code>，也是一种信息存储机制。</p></li><li><p>同一个服务器可以用多个 <code>Cookie</code>，只要每个 <code>Cookie</code> 的名字不一样就行了。</p></li></ul></blockquote><h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><ol><li><p>服务器需要客户端保存的内容，放在 <code>Set-Cookie</code> headers 里返回，客户端会<strong>自动</strong>保存。</p></li><li><p>客户端保存的 Cookies，会在之后的所有请求里都 <strong>自动</strong> 携带进 <code>Cookie</code> header 里发回给服务器。</p></li><li><p>客户端保存 <code>Cookie</code> 是按照 <strong>服务器域名</strong> 来分类的，例如 shop.com 发回的 <code>Cookie</code> 保存下来以后，在之后向 games.com 的请求中并不会携带。</p></li><li><p>客户端保存的 <code>Cookie</code> 在超时后会被删除、没有设置超时时间的 <code>Cookie</code> （称作 <code>Session Cookie</code>）在浏览器关闭后就会自动删除；另外，服务器也可以主动删除还未过期的客户端 Cookies。</p></li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>出现 <code>Cookie</code> 的时候还没有 <code>JavaScript</code> 语言，所以不能对 <code>Cookie</code> 进行浏览器本地计算，必须要将 <code>Cookie</code> 传到服务器处理。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li><p>会话管理：登录状态、购物车等</p><p>移动开发通常也只将 Cookie 用于登录状态管理，且现在也越来越少的进行使用了。</p><blockquote><p>  <strong>使用 <code>Cookie</code> 管理登录状态</strong></p><p>  客户端向服务器发送用户名和密码后，当服务器验证用户登录成功后，会通过 <code>Set-Cookie</code> 向客户端传输一个 <code>SessionId</code> 的字段。<code>SessionId</code> 可以是记录了用户此次登录的会话编号。</p><p>  此后客户端每次发送请求的时候通过携带该 <code>Cookie</code> 便可将 <code>HTTP</code> 从无状态变为有状态。</p><p>  当服务器从数据库中发现存在一样的 <code>SessionId</code> 后，便可确认用户的身份信息了。</p></blockquote></li><li><p>个性化：用户篇好、主题等</p><p>如果由服务器网页有多个主题以及其他个性化内容的话，可以通过存储 <code>client_id</code> 等相似字段记录用户的选择，从而记录并显示用户的偏好。</p></li><li><p>Tracking：分析用户行为，追踪用户行为。</p><p>通过记录用户访问的网站信息或者其他信息，可以更加方便得向用户推广广告。</p></li></ol><h2 id="XSS-Cross-site-scripting"><a href="#XSS-Cross-site-scripting" class="headerlink" title="XSS(Cross-site scripting)"></a><code>XSS(Cross-site scripting)</code></h2><p><strong>跨站脚本攻击。</strong>通过 <code>JavaScript</code> 获取客户端浏览器中的 <code>Cookie</code> 并利用其中的信息，如网站登录信息等。</p><p>可以通过 <code>HttpOnly</code> 进行防护，作用是让 <code>Cookie</code> 只能用于发送请求时自动携带，而无法通过 <code>JavaScript</code> 主动获取。添加方法形如 <code>Set-Cookie:session_id=123;HttpOnly</code> 即可。</p><h2 id="XSRF-Cross-site-request-forgery"><a href="#XSRF-Cross-site-request-forgery" class="headerlink" title="XSRF(Cross-site request forgery)"></a><code>XSRF(Cross-site request forgery)</code></h2><p><strong>跨站请求伪造。</strong>在用户不知情的情况下访问了一个用户保存了 <code>Cookie</code> 的网站，以此来进行一些越权操作。</p><p>例如，私自访问用户保存了 <code>Cookie</code> 的银行网站并通过添加 <code>url</code> 参数来进行转账操作等等。</p><p>可以通过 <code>Referer</code> 校验解决，通过在发送请求的时候 <strong>自动且强制</strong> 在 Header 中添加 <code>Referer</code> 参数，参数保存了从哪一个网址跳转进入了该网址。服务器只需要校验 <code>Referer</code> 参数是否在白名单中即可保证访问安全。</p><hr><h1 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a><code>Authorization</code></h1><blockquote><p>  目前较 <code>Cookie</code> 更加流行。</p></blockquote><p><font size = 5><b>两种用法</b></font></p><h2 id="Basic-token"><a href="#Basic-token" class="headerlink" title="Basic token"></a><code>Basic token</code></h2><p>格式：<code>Authorization: Basic &lt;username:password(Base64ed)&gt;</code>。其中，<code>&lt;username:password(Base64ed)&gt;</code> 部分是将 <code>username:password</code> 格式的字符串进行 <code>Base64</code> 处理后重新替换到 <code>Basic</code> 后面。</p><p>服务器对 token 进行校验，如果校验通过，那么授权验证通过，客户端就可以获取到用户信息。如果数据不对，那么就获取不到用户信息，服务器对报 401 错误，即权限不足。</p><h2 id="Bearer-token"><a href="#Bearer-token" class="headerlink" title="Bearer token"></a><code>Bearer token</code></h2><blockquote><p>  Bearer : n. 拿着的人，持票人</p></blockquote><p>格式：<code>Authorization: Bearer &lt;bearer token&gt;</code>。<code>&lt;bearer token&gt;</code> 是授权方发给我们的 <code>access token</code>。</p><h3 id="access-token-获取方法"><a href="#access-token-获取方法" class="headerlink" title="access token 获取方法"></a><code>access token</code> 获取方法</h3><h4 id="OAuth2-流程"><a href="#OAuth2-流程" class="headerlink" title="OAuth2 流程"></a><code>OAuth2</code> 流程</h4><ol start="0"><li><p>第三方网站向授权方网站申请第三方授权合作，拿到 <code>client_id</code> 和 <code>client_secret</code></p><blockquote><p>  <code>client_id</code>：申请授权的 app 的 id。</p><p>  <code>client_secret</code>：需要严格保密，保存在第三方网站服务器中，作为密码的作用，证明是第三方网站自己申请的授权。</p></blockquote></li><li><p>用户在使用第三方网站时，点击「通过 XX (如 <code>GitHub</code>) 授权」按钮，第三方网站将页面跳转到授权方网站，并传入 <code>client_id</code> 作为自己的身份标识。</p></li><li><p>授权方网站根据  <code>client_id</code>  ，将第三方网站的信息和第三方网站需要的用户权限展示给用户，并询问用户是否同意授权</p></li><li><p>用户点击「同意授权」按钮后，授权方网站将页面跳转回第三方网站，并传入 <code>Authorization code</code> 作为用户认可的凭证。</p></li><li><p>第三方网站将 <code>Authorization code</code> 发送回自己的服务器。</p></li><li><p>服务器将 <code>Authorization code</code> 和自己的 <code>client_secret</code> ⼀并发送给授权方的服务器，授权方服务器在验证通过后，返回 <code>access token</code>。OAuth 流程结束。</p></li><li><p>在上面的过程结束之后，第三方网站的服务器（或者有时客户端也会）就可以使用 <code>access token</code> 作为用户授权的令牌，通过 <code>Authorization: Bearer &lt;access token&gt;</code> 向授权方网站发送请求来获取用户信息或操作用户账户。但这已经在 OAuth 流程之外。</p></li></ol><blockquote><p>  为什么 <code>OAuth</code> 要引入 <code>Authorization code</code>，并需要申请授权的第三方将 <code>Authorization code</code> 发送回自己的服务器，再从服务器来获取 <code>access token</code>， 而不是直接返回 <code>access token</code> ？这样复杂的流程意义何在？ </p><p>  为了安全。<code>OAuth</code> 不强制授权流程必须使用 <code>HTTPS</code>，因此需要保证当通信路径中存在窃听者时，依然具有足够高的安全性。</p></blockquote><h4 id="微信登录流程"><a href="#微信登录流程" class="headerlink" title="微信登录流程"></a>微信登录流程</h4><p>第三方 App 通过微信登录的流程，也是一个 <code>OAuth2</code> 流程：</p><ol start="0"><li>第三方 App 向腾讯申请第三方授权合作，拿到 <code>client_id</code> 和 <code>client_secret</code></li><li>用户在使用第三方 App 时，点击「通过微信登录」，第三方 App 将使用微信 SDK 跳转到微信，并传入自己的 <code>client_id</code> 作为自己的身份标识</li><li>微信通过和服务器交互，拿到第三方 App 的信息，并显示在界面中，然后询问用户是否同意授权该 App 使用微信来登录。</li><li>用户点击「使用微信登录」后，微信和服务器交互将授权信息提交，然后跳转回第三方 App，并传入 <code>Authorization code</code> 作为用户认可的凭证。</li><li>第三方 App 调用自己服务器的「微信登录」API，并传入 <code>Authorization code</code>，然后等待服务器的响应。</li><li>服务器在收到登录请求后，拿收到的 <code>Authorization code</code> 去向微信的第三方授权接口发送请求，将 <code>Authorization code</code> 和自己的 <code>client_secret</code> 一起作为参数发送，微信在验证通过后，返回 <code>access token</code>。</li><li>服务器在收到 <code>access token</code> 后，立即拿着 <code>access token</code> 去向微信的用户信息接口发送请求，微信验证通过后，返回用户信息。</li><li>服务器在收到用户信息后，在自己的数据库中为用户创建一个账户，并使用从微信服务器拿来的用户信息填入自己的数据库，以及将用户的 ID 和用户的微信 ID 做关联。</li><li>用户创建完成后，服务器向客户端的请求发送响应，传送回刚创建好的用户信息。</li><li>客户端收到服务器响应，用户登录成功。</li></ol><h4 id="在自家-App-中使用-Bearer-token-登录"><a href="#在自家-App-中使用-Bearer-token-登录" class="headerlink" title="在自家 App 中使用 Bearer token 登录"></a>在自家 App 中使用 <code>Bearer token</code> 登录</h4><p>有的 App 会在 API 的设计中，将登录和授权设计成类似 OAuth2 的过程，但简化掉 <code>Authorization code</code> 概念。</p><p>即：登录接口请求成功时，会直接返回 <code>access token</code>，然后客户端在之后的请求中，就可以使用这个 <code>access token</code> 来当做 <code>bearer token</code> 进行用户操作了。</p><blockquote><p>  <strong>Refresh token</strong></p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Bearer&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxxxx&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxxxx&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;expires_time&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxxxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>  用法：</p><ul><li><code>access token</code> 有失效时间，在它失效后，调⽤ <code>refresh_token</code> 接口，传入 <code>refresh_token</code> 来获取新的 <code>access token</code>。</li></ul><p>  目的：</p><ul><li>安全。当 <code>access token</code> 失窃，由于它有失效时间，因此坏人只有较短的时间来「做坏事」。</li><li>同时，由于（在标准的 <code>OAuth2</code> 流程中）<code>refresh token</code> 永远只存在与第三方服务的服务器中，因此 <code>refresh token</code> 几乎没有失窃的风险。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OAuth2</tag>
      
      <tag>Cookie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-HTTPS</title>
    <link href="/posts/ea887c778efc/"/>
    <url>/posts/ea887c778efc/</url>
    
    <content type="html"><![CDATA[<blockquote><p>   <code>HTTP Secure</code> &#x2F; <code>HTTP over SSL</code> &#x2F; <code>HTTP over TLS</code></p><p>  即工作在 <code>SSL</code>（或 <code>TLS</code>）上的 <code>HTTP</code>。说白了就是加密通信的 <code>HTTP</code>。</p><ul><li><code>SSL</code> : Secure Socket Layer（安全套接字层）（<code>TLS</code> 前身）</li><li><code>TLS</code> : Transport Layer Security（传输层安全性）</li></ul></blockquote><hr><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在 <code>HTTP</code> 和 <code>TCP</code> 之间增加了一个 <strong>安全层</strong>（安全的加密层），用于保障 <code>HTTP</code> 的加密传输。</p><p>即 <code>HTTP</code> 将数据交给 <code>TCP</code> 之前，先把数据交给 <code>TLS</code>，由 <code>TLS</code> 将数据进行加密后，再往下交给 <code>TCP</code> 进行数据去传输。</p><p>以及对面的接受方在 <code>TCP</code> 层收到数据且拼接好之后，不直接交给 <code>HTTP</code> 层，而是先交给 <code>TCP</code> 层进行解密，解密完后再由 <code>TLS</code> 交给 <code>HTTP</code>。</p><hr><h1 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h1><p>在客户端和服务器之间用 <strong>非对称加密</strong> 协商出一套 <strong>对称密钥</strong> ，每次发送信息之前将内容加密，收到之后解密，达到内容的加密传输。</p><h2 id="为什么不直接用非对称加密"><a href="#为什么不直接用非对称加密" class="headerlink" title="为什么不直接用非对称加密"></a>为什么不直接用非对称加密</h2><p>非对称加密由于使用了复杂了数学原理，因此计算相当复杂，如果完全使用非对称加密来加密通信内容，会严重影响用户网络通信的性能。</p><hr><h1 id="HTTPS-TLS-的连接"><a href="#HTTPS-TLS-的连接" class="headerlink" title="HTTPS (TLS) 的连接"></a>HTTPS (TLS) 的连接</h1><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><ol><li>客户端请求建立 <code>TLS</code> 连接</li><li>服务器发挥证书</li><li>客户端验证服务器证书</li><li>客户端信任服务器后，和服务器协商对称密钥（此时通过非对称加密的方式协商对称密钥）</li><li>使用对称密码开始通信</li></ol><h2 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h2><blockquote><p>  可以通过 WireShark 进行更加详细的查看。</p></blockquote><ol><li><p>客户端和服务器第一次打招呼。</p><p>客户端向服务器发送 Client Hello（大小为1字节的数据，值为1，这个数据的名字叫做 Client Hello）。</p><p>同时，也会再附加信息中发送服务器可选的 <code>TLS</code> 版本、可选的加密套件（对称加密算法、非对称加密算法、哈希算法）、客户端生成的随机数。</p></li><li><p>服务器收到 Client Hello 后，确定双方可以共同使用的 <code>TLS</code> 版本、加密套件 ，以及服务端自己生成的以及随机数，并将这些信息发回给客户端，称为 Server Hello。Server Hello 也是一个单字节数据，值为2。</p><p>如果没有可以共同使用的内容，那么 <code>HTTPS</code> 就直接建立失败。</p></li><li><p>服务器发送自己的证书。</p><blockquote><p>   <strong>证书中主要包含了</strong>：</p><ol><li>服务器的公钥（其实是个数据）</li><li>服务器的证书的签名（由证书签发机构的私钥对服务器证书的签名）</li><li>证书签发机构的公钥（用户验证这个“公钥签名”的另一个公钥）</li><li>证书签发机构的证书的签名</li><li>证书签发机构的签发机构（根证书机构）的公钥</li><li>服务器主机名</li></ol></blockquote><p>可以让客户端进行信息加密。客户端通过服务器的公钥进行信息加密，服务器可以通过自己的密钥进行信息的解密。</p><blockquote><p>   <strong>服务器公钥的签名</strong></p><p>   用私钥对服务器公钥的 Hash 值版进行一次非对称加密的计算得到的结果数据。这个数据可以被该私钥对应的公钥所解开。</p><p>   如果解开签名之后的值正好等于服务器公钥经过一次 Hash 计算后的结果值，那么就证明这个源数据是没有问题的。</p><p>   注意：用于解开的公钥和被签名的公钥不是同一个，它是由私钥生成的另一个公钥。</p></blockquote></li><li><p>客户端验证公钥的正确性。</p><p>证书签发机构的签发机构的证书，在所有的操作系统中都默认带有一份，被认为是最可信的证书，被称为“根证书”。</p><p>当需要查询这些证书的时候，会从设备中进行查询，如果能够查询的到的话，那么第5个文件内容就是可信的了。</p><p>当证书签发机构的签发机构的公钥是可信的话，我们就可以使用这个公钥去验证第4个内容的正确性。再使用第3个内容的公钥去验证第2个内容的正确性了。</p><p>如果第2个内容是正确的话，那么说明服务器的公钥就是正确的了。</p><blockquote><p>  除了操作系统自带的根证书，我们也可以自行往自己的设备中安装自己需要的根证书。</p></blockquote><p><strong>注：客户端除了验证公钥是否正确，还需要验证服务器主机名是否是我们所需要到达的地址。</strong></p></li><li><p>客户端发送 <code>Pre-master Secret</code> 的数据</p><p>使用的服务器的公钥加密发过去的，也是一个客户端生成的随机数。</p></li><li><p>客户端和服务器都通过上述三个随机数生成一个 <code>Master Secret</code> 的值</p><p>通过 <code>Master Secret</code> 就可以算出双方进行对称加密的密钥等相关的一些信息了。然后双方就可以进行加密通信了。</p><p><code>Master Secret</code> 会生成四个内容：</p><ol><li>客户端加密密钥</li><li>服务端加密密钥</li><li>客户端 <code>MAC Secret</code></li><li>服务端 <code>MAC Secret</code></li></ol><blockquote><p>  <strong>为什么使用三个随机数生成数据，而不是仅使用 <code>Pre-master Secret</code> 来生成数据？</strong></p><p>  为了防止<strong>重放攻击</strong>。通过多个随机数，防止攻击者使用一个以前收到的随机数就可以获取用户的身份认证。</p><blockquote><p>  <strong>重放攻击(Replay Attacks)</strong></p><p>  又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行。</p></blockquote></blockquote><blockquote><p>  为什么客户端和服务器要使用两个加密密钥呢？</p><p>  为了防止出现攻击人将客户端发送的消息重新发送给客户端，使用相同的密钥会使客户端能够解密并认为这个服务器发送的数据，从而导致数据错误。而通过两个不同的密钥，便可以防止客户端和服务器双方无法分辨数据的来源了。</p></blockquote><p>注意：</p><ol><li>客户端向服务端发送对称加密数据时，双方使用客户端加密密钥进行加解密操作。服务端向客户端发送对称加密数据时，双方使用服务端加密密钥进行加解密操作。</li><li><code>MAC Secret</code>。其中 <code>MAC</code> 也即 <code>HMAC</code> (Hash-based Message Authentication Code 哈希运算消息认证码)，可以使数据进行带密码的哈希计算。仅仅只是无密码的哈希算法容易被攻击者碰撞，但是使用带特定的密码的哈希算法就是极大的增加难度。当接收方也使用带该密码的，相同的哈希算法进行计算后，与发送过来的哈希值进行比较，如果两者一样的话，那么就可以证明数据使对方发的且是安全的。</li></ol></li><li><p>客户端向服务器发送1个字节的数据（值为20，名称为 Change Cipher Spec），通知自己将使用加密通信。</p></li><li><p>客户端将前7步得到的数据通过客户端加密密钥以及客户端 <code>MAC Secret</code> 加密，然后发送给服务器。服务器对获得的结果进行验证。</p><p>消息名称为 Encrypted Handshake Message。</p><p><strong>此步之后，客户端就可以通过对称加密发送信息了。</strong></p></li><li><p>服务器向客户端发送1个字节的数据（值为20，名称为 Change Cipher Spec），通知自己将使用加密通信。</p></li><li><p>服务器将前9步得到的数据通过服务器加密密钥以及服务器 <code>MAC Secret</code> 加密，然后发送给客户端。客户端对获得的结果进行验证。</p><p>消息名称为 Encrypted Handshake Message。</p><p><strong>此步之后，服务器也可以通过对称加密发送信息了。</strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo-theme-butterfly 修改分割线的样式</title>
    <link href="/posts/5c76ad4123cd/"/>
    <url>/posts/5c76ad4123cd/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习大佬们的博客的时候，并没有看到详细自定义分割线样式的博客，所以想记录一下自己美化分割线的过程。</p><blockquote><p>  <strong>Butterfly 主题默认分割线样式</strong></p>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221024200848426.png" alt="Butterfly 主题默认分割线样式" style="zoom:80%;" />  <p>  <strong>通过修改后的分割线样式</strong></p>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026222103059.png" alt="通过修改后的分割线样式" style="zoom:90%;" /></blockquote><hr><blockquote><p>   <strong>更改设置后需要进行 <code>hexo clean</code> 操作哦~</strong> </p></blockquote><hr><h1 id="修改浮动图标图片"><a href="#修改浮动图标图片" class="headerlink" title="修改浮动图标图片"></a>修改浮动图标图片</h1><p>将剪刀图片修改为其他的图片，如上文中的小汽车图片。</p><p>两种方式可以修改：</p><ol><li><p>修改 <code>_config.butterfly.yml</code> 文件中的 <code>hr_icon -&gt; icon</code> 内容（推荐）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># The setting of divider icon (水平分隔線圖標設置)</span><br><span class="hljs-attr">hr_icon:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">icon:</span> <span class="hljs-string">&#x27;\f5e4&#x27;</span> <span class="hljs-comment"># the unicode value of Font Awesome icon, such as &#x27;\3423&#x27;</span><br>  <span class="hljs-string">//</span> <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure></li><li><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>hr -&gt; &amp;:before -&gt; content</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hr<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-selector-pseudo">&amp;:before</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attribute">content</span>: <span class="hljs-variable">$hr</span>-icon // 同样修改为如 <span class="hljs-string">&#x27;\3423&#x27;</span> 形式<br></code></pre></td></tr></table></figure></li></ol><p>如果想去除浮动图标，仅需将参数修改为 <code>&#39;&#39;</code> 即可，例如 <code>icon: &#39;&#39;</code>。</p><blockquote><p>  <strong><code>the unicode value of Font Awesome icon</code> 获取方法：</strong></p><ol><li><p>打开 <code>Font Awesome</code> 网址：<a href="https://fontawesome.com/v5/search">Search v5 Icons | Font Awesome</a></p></li><li><p>通过搜索栏选择并点击自己心仪的图标</p></li><li><p>下图中箭头所指内容即为 <code>the unicode value of Font Awesome icon</code></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026225602023.png" alt="the unicode value of Font Awesome icon" style="zoom:60%;" /></li></ol></blockquote><hr><h1 id="修改浮动图标颜色"><a href="#修改浮动图标颜色" class="headerlink" title="修改浮动图标颜色"></a>修改浮动图标颜色</h1><p>修改浮动图标的颜色，同样可以有两种方法进行更改：</p><ol><li><p>修改 <code>_config.butterfly.yml</code> 中的 <code>theme_color -&gt; hr_color</code> 内容（推荐）</p><p><strong>可能会将分割线横线的颜色同时进行更改。</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">theme_color:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-string">//</span> <span class="hljs-string">...</span><br>  <span class="hljs-attr">hr_color:</span> <span class="hljs-string">&quot;#A4D8FA&quot;</span> <span class="hljs-string">//</span> <span class="hljs-string">修改此处内容</span><br></code></pre></td></tr></table></figure></li><li><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>hr -&gt; &amp;:before -&gt; color</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hr<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-selector-pseudo">&amp;:before</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attribute">color</span>: <span class="hljs-built_in">var</span>(--hr-before-color) // 修改为如 <span class="hljs-number">#A4D8FA</span> 形式<br></code></pre></td></tr></table></figure></li></ol><hr><h1 id="修改浮动图标相对于横线的位置"><a href="#修改浮动图标相对于横线的位置" class="headerlink" title="修改浮动图标相对于横线的位置"></a>修改浮动图标相对于横线的位置</h1><p>可以通过两种方式进行修改：</p><ol><li><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>hr -&gt; &amp;:before -&gt; line-height</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hr<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-selector-pseudo">&amp;:before</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1</span> // 图标浮于横线中间，其他参数见下文<br></code></pre></td></tr></table></figure><blockquote><p>  <strong><code>line-height</code> 参数说明：</strong></p><ul><li><p><code>1</code></p><p>图标浮于横线中间</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026230524821.png" style="zoom:80%;" /></li><li><p><code>0</code></p><p>图标浮于横线上方</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026230609189.png" style="zoom:80%;" /></li><li><p><code>-1</code></p><p>图标浮于横线下方</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026230634557.png" style="zoom:80%;" /></li></ul></blockquote></li><li><p>修改 <code>_config.butterfly.yml</code> 文件中的 <code>hr_icon -&gt; icon-top</code> 内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># The setting of divider icon (水平分隔線圖標設置)</span><br><span class="hljs-attr">hr_icon:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-string">//</span> <span class="hljs-string">...</span><br>  <span class="hljs-attr">icon-top:</span><br></code></pre></td></tr></table></figure></li></ol><hr><h1 id="修改横线虚实"><a href="#修改横线虚实" class="headerlink" title="修改横线虚实"></a>修改横线虚实</h1><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>hr -&gt; border</code> 中的 <code>dashed</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hr<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> dashed <span class="hljs-built_in">var</span>(--hr-border)<br></code></pre></td></tr></table></figure><blockquote><p>  <strong>其中第二个参数说明：</strong></p><ul><li><p><code>dashed</code></p><p>虚线效果</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026222103059.png" alt="通过修改后的分割线样式" style="zoom:90%;" /></li><li><p><code>solid</code></p><p>实线效果</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221115165404929.png" alt="pic" style="zoom:80%;" /></li></ul></blockquote><hr><h1 id="修改横线粗细"><a href="#修改横线粗细" class="headerlink" title="修改横线粗细"></a>修改横线粗细</h1><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>hr -&gt; border</code> 中的 <code>2px</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hr<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> dashed <span class="hljs-built_in">var</span>(--hr-border)<br></code></pre></td></tr></table></figure><blockquote><p>  <strong>数字效果对比：</strong></p><ul><li><p><code>2px</code></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026222103059.png" alt="通过修改后的分割线样式"  /></li><li><p><code>5px</code></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221115174052677.png" alt="image-20221115174052677" style="zoom:90%;" /></li></ul></blockquote><hr><h1 id="修改横线颜色"><a href="#修改横线颜色" class="headerlink" title="修改横线颜色"></a>修改横线颜色</h1><ol><li><p>修改 <code>_config.butterfly.yml</code> 中的 <code>theme_color -&gt; hr_color</code> 内容（推荐）</p><p><strong>可能会将分割线横线的颜色同时进行更改。</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">theme_color:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-string">//</span> <span class="hljs-string">...</span><br>  <span class="hljs-attr">hr_color:</span> <span class="hljs-string">&quot;#A4D8FA&quot;</span> <span class="hljs-string">//</span> <span class="hljs-string">修改此处内容</span><br></code></pre></td></tr></table></figure></li><li><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>:root -&gt; --hr-border</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-pseudo">:root</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">--hr-border</span>: <span class="hljs-built_in">lighten</span>(<span class="hljs-variable">$theme</span>-hr-<span class="hljs-attribute">color</span>,;<span class="hljs-number">50%</span>)<br></code></pre></td></tr></table></figure><p>将 <code>lighten($theme-hr-color,;50%)</code> 部分修改为<strong>十六进制颜色表示方式</strong>即可。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo-theme-butterfly</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AutoHotkey v1 变量和字符串</title>
    <link href="/posts/b7ed2dc4d9db/"/>
    <url>/posts/b7ed2dc4d9db/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Variables.htm">变量和表达式 | AutoHotkey (autoahk.com)</a></li><li><a href="https://www.autohotkey.com/boards/viewtopic.php?t=14633">String literal that spans multiple lines? - AutoHotkey Community</a></li></ul></blockquote><hr><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>有关一般说明和变量如何工作的详细信息，请参阅变量。</p><h2 id="给变量赋值"><a href="#给变量赋值" class="headerlink" title="给变量赋值"></a><strong>给变量赋值</strong></h2><p>要将字符串或数字存储在变量中，有两种方法: 传统方式和表达式。传统方法使用等号运算符(&#x3D;) 来指定<strong>不加引号的</strong>原义字符串或用百分号括起来的变量。例如:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs AutoHotKey">MyNumber = <span class="hljs-number">123</span><br>MyString = This is a literal string.<br>CopyOfVar = <span class="hljs-variable">%Var%</span>  <span class="hljs-comment">; 和 = 运算符一起使用时，需要使用百分号来获取变量的内容。</span><br></code></pre></td></tr></table></figure><p>与之相比，表达式方法使用冒号等号运算符(:&#x3D;) 来保存数字，<strong>加引号的</strong>字符串和其他类型的表达式。以下示例在功能上与前面的例子相同:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs AutoHotKey">MyNumber := <span class="hljs-number">123</span><br>MyString := <span class="hljs-string">&quot;This is a literal string.&quot;</span><br>CopyOfVar := Var  <span class="hljs-comment">; 和前面段落中与其作用相同的语句不同，百分号不和 := 运算符一起使用。</span><br></code></pre></td></tr></table></figure><p><strong>后一种方法由于其更清晰并且与其他许多语言几乎一致的表达式语法成为大多数人的首选方法.</strong></p><p>从上面的例子中您可能已经想到了有两种方法来清除变量的内容(即让变量为空):</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs AutoHotKey">MyVar =<br>MyVar := <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>上面的这对空引号只能和 :&#x3D; 运算符一起使用，因为和 &#x3D; 运算符一起使用时，则会在变量中保存两个原义的引号字符。</p><h2 id="获取变量的内容"><a href="#获取变量的内容" class="headerlink" title="获取变量的内容"></a><strong>获取变量的内容</strong></h2><p>如同赋值有两种方法，获取变量的内容也有两种方法: 传统方法和表达式方法。传统方法需要将变量名包围在百分号中来获取变量的内容。例如:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs AutoHotKey">MsgBox The value in the variable named Var is <span class="hljs-variable">%Var%</span>.<br>CopyOfVar = <span class="hljs-variable">%Var%</span><br></code></pre></td></tr></table></figure><p>与之相比，表达式方法省去了变量名两边的百分号，但原义的字符串必须包围在双引号中。所以，下面的表达式作用等同于上面的例子:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs AutoHotKey"><span class="hljs-built_in">MsgBox %</span> <span class="hljs-string">&quot;The value in the variable named Var is &quot;</span> . Var . <span class="hljs-string">&quot;.&quot;</span>  <span class="hljs-comment">; 使用句点连接(join 拼接) 两个字符串。</span><br>CopyOfVar := Var<br></code></pre></td></tr></table></figure><p>在上面的 MsgBox 这行，通过使用百分号和空格把参数从传统模式改变为表达式模式。因为所有的命令默认情况下使用传统模式(除了另外注明的那些), 所以这是必须的。</p><h2 id="变量的比较"><a href="#变量的比较" class="headerlink" title="变量的比较"></a><strong>变量的比较</strong></h2><p>请阅读下面表达式部分中关于不同类型变量比较的重要提示，尤其是关于何时使用小括号的内容。</p><hr><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="保存带有引号的字符串"><a href="#保存带有引号的字符串" class="headerlink" title="保存带有引号的字符串"></a>保存带有引号的字符串</h2><p>如果我们想用变量保存一个带有双引号的字符串，需要使用 &#x3D; 操作符：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs AutoHotKey">var = this is <span class="hljs-string">&quot; ; 输出的字符串中包含双引号</span><br></code></pre></td></tr></table></figure><h2 id="保存多行字符串"><a href="#保存多行字符串" class="headerlink" title="保存多行字符串"></a>保存多行字符串</h2><p>如果我们想要保存多行的字符串，可以使用 <code>()</code> 包含文本内容并使用 <code>=</code> 且 <strong>不加 <code>&quot;&quot;</code></strong> 的方式（文本中每行的字符串形式与使用 <code>=</code> 操作符保存单行字符串的形式相同）：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs AutoHotKey">var = string<br><br>exampleString =<br>(                      <span class="hljs-comment">; 左括号右侧的字符会被自动忽略，正文从下行开始</span><br>    multiple<br>        lines          <span class="hljs-comment">; 该行字符的所有字符（包括空格）会全部输出</span><br>                       <span class="hljs-comment">; 空行也会如实输出  </span><br><span class="hljs-built_in">    of</span><br><span class="hljs-built_in">        %</span>var%<br>)                      <span class="hljs-comment">; 右括号左侧不能有其他字符，否则将报错</span><br><span class="hljs-built_in"></span><br><span class="hljs-built_in">MsgBox,</span> % exampleString<br></code></pre></td></tr></table></figure><p>输出结果截图（第一个非空字符前的空格将忽略）：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220723170233064.png" alt="image-20220723170233064" style="zoom: 50%;" /><p><strong>注意：</strong></p><ol><li>该方式中的 <code>()</code> 必须分别、单独在一行，不能接在其他语句末尾。且文本将严格按照输入形式输出，两个括号之间的空行和空格也会如实输出，但是第一个非空字符前的空格将忽略。</li><li>左括号右侧的字符会被自动忽略，正文从下行开始；右括号左侧不能有其他字符，否则将报错。</li><li>如果需要使用 <code>:=</code> 操作符进行多行字符串保存，请使用 &#96;n 转义字符进行换行操作。</li></ol>]]></content>
    
    
    <categories>
      
      <category>AutoHotkey</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AutoHotkey</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AutoHotkey v1 类的定义与部分使用技巧</title>
    <link href="/posts/e17fd16bc395/"/>
    <url>/posts/e17fd16bc395/</url>
    
    <content type="html"><![CDATA[<div class="note note-warning">            <p>本文所使用的 AHK 版本为 AutoHotKey v1 。</p>          </div><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本人想在 AHK 中使用面向对象的方式编写代码，但是发现在官方文档中仅有较少关于 <code>class</code> 的操作代码示例，所以根据自己这两天的代码编写过程，整理出常用的一些使用技巧供大家参考。</p><hr><h1 id="类的创建和使用"><a href="#类的创建和使用" class="headerlink" title="类的创建和使用"></a>类的创建和使用</h1><p>类的创建使用 <code>class</code>  关键字。可以显式定义构造方法以及析构方法：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs AutoHotKey"><span class="hljs-comment">; 类的创建</span><br>class A &#123;<br>    <span class="hljs-comment">; 静态变量的创建</span><br>    static var1 := Expression1<br>    <span class="hljs-comment">; 类字段的创建</span><br>    var2 := Expression2<br>    <br>    <span class="hljs-comment">; 构造方法，可传入任意参数，也可不传入参数</span><br>    __New(...) &#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">; 方法的创建</span><br>    <span class="hljs-comment">; 可传入任意参数，参数支持默认参数值</span><br>    <span class="hljs-comment">; 根据需要可不写 return</span><br>    methodName(...) &#123;<br>        ...<br>        <span class="hljs-keyword">return</span> ...<br>    &#125;<br>    <br>    <span class="hljs-comment">; 析构方法</span><br>    __Delete() &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类的使用：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">a := <span class="hljs-keyword">new</span> A(...)   <span class="hljs-comment">; 类的实例化，根据构造方法传入对应的参数</span><br>a.methodName(...) <span class="hljs-comment">; 使用变量的方法</span><br></code></pre></td></tr></table></figure><hr><h1 id="在类中创建热键并绑定类方法"><a href="#在类中创建热键并绑定类方法" class="headerlink" title="在类中创建热键并绑定类方法"></a>在类中创建热键并绑定类方法</h1><p>使用面向对象的思想编写代码的话，我们或许需要在类中创建热键及其响应逻辑的方法：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">class A &#123;<br>    <span class="hljs-comment">; 自定义的一个方法，用于加载类中所有的热键</span><br>    loadHotKey() &#123;<br>        <span class="hljs-comment">; 创建响应方法的方法引用</span><br>        varFunctionA := ObjBindMethod(this, <span class="hljs-string">&quot;functionA&quot;</span>)<br><br>        <span class="hljs-comment">; 创建 Alt + A 的热键以及绑定其响应方法</span><br><span class="hljs-built_in">        HotKey,</span> !A, % varFunctionA, On<br>    &#125;<br>    <br>    functionA() &#123;<br>    <span class="hljs-comment">; 热键的响应逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码便在类中创建了一个使用类中方法作为响应逻辑的热键。其中：</p><ol><li><code>varFunctionA := ObjBindMethod(this, &quot;functionA&quot;)</code> 部分：<ol><li><code>&quot;functionA&quot;</code> 中双引号必须保留，双引号中间内容为对应的方法名。</li><li><code>varFunctionName</code> 为自定义的变量名称，与第7行第3个参数相对应。</li></ol></li><li><code>HotKey, !A, % varFunctionA, On</code> 部分：<ol><li><code>!A</code> 为热键的内容，具体可以参考文档中 <strong>热键</strong> 部分内容。</li><li><code>% varFunctionA</code> 中百分号必须保留，后面的内容对应上面一行自定义的变量名。</li></ol></li></ol><p>热键的使用：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-keyword">new</span> A().loadHotKey()<br></code></pre></td></tr></table></figure><p>通过对该类的实例化并调用实例化对象的 <code>loadHotKey</code> 方法即可。</p><hr><h1 id="在类中绘制-UI-并绑定类方法"><a href="#在类中绘制-UI-并绑定类方法" class="headerlink" title="在类中绘制 UI 并绑定类方法"></a>在类中绘制 <code>UI</code> 并绑定类方法</h1><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">class B &#123;<br>    <span class="hljs-comment">; 自定义的一个方法，用于绘制 UI 以及绑定响应的方法</span><br>    loadView() &#123;<br>        <span class="hljs-comment">; 绘制了一个按钮</span><br><span class="hljs-built_in">        Gui,</span> Add, Button, w200 h35 hwndHFuncB, This is a button.<br><br>        <span class="hljs-comment">; 创建了响应方法的方法引用</span><br>        varFuncB := ObjBindMethod(this, <span class="hljs-string">&quot;functionB&quot;</span>)<br><br>        <span class="hljs-comment">; 通过 HWND 将按钮与方法绑定</span><br><span class="hljs-built_in">        GuiControl,</span> +g, <span class="hljs-variable">%HFuncB%</span>, % varFuncB<br>    &#125;<br>    <br>    functionB() &#123;<br>        <span class="hljs-comment">; 按钮的响应逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><code>Gui, Add, Button, w200 h35 hwndHFuncB, This is a button.</code> 中 <code>hwndHFuncB</code> 部分：<ol><li>形式为 <code>hwnd + 自定义变量名</code></li><li>自定义变量名与第9行中第3个参数相对应。</li></ol></li><li><code>varFuncB := ObjBindMethod(this, &quot;functionB&quot;)</code> 部分：<ol><li><code>varFuncB</code> 为另一个自定义变量名，与第9行中第4个变量名相对应。</li><li><code>&quot;functionB&quot;</code> 中双引号必须保留，双引号中间内容为对应的方法名。</li></ol></li><li><code>GuiControl, +g, %HFuncB%, % varFuncB</code> 中第3、4个参数分别为上述的两个自定义变量名。</li></ol><hr><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><blockquote><p>  使用面向对象思想重构 <a href="https://luoyu-ying.github.io/posts/050a11a7817a/">通过 AutoHotKey 简化 Hexo 操作 | 洛语 の Blog (luoyu-ying.github.io)</a> 中 Deploy 部分的操作。</p></blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-comment">; 加载类的 UI 以及热键</span><br><span class="hljs-keyword">new</span> Deploy().load()<br><br><span class="hljs-comment">; -------------------------</span><br><br><span class="hljs-comment">; 类的创建</span><br>class Deploy &#123;<br><br>    load() &#123;<br>        this.loadView()<br>        this.loadHotKey()<br>    &#125;<br>    <br>    <span class="hljs-comment">; 本代码中 GAD -&gt; generate and deploy</span><br>    <br>    loadView() &#123;<br><span class="hljs-built_in">        Gui,</span> Add, Button, w200 h35 hwndHGAD, Generate &amp;&amp; Deploy<br>        <br>        varGAD := ObjBindMethod(this, <span class="hljs-string">&quot;generateDeploy&quot;</span>)<br><span class="hljs-built_in">        </span><br><span class="hljs-built_in">        GuiControl,</span> +g, <span class="hljs-variable">%HGAD%</span>, % varGAD<br>    &#125;<br>    <br>    loadHotKey() &#123;<br>        varGAD := ObjBindMethod(this, <span class="hljs-string">&quot;generateDeploy&quot;</span>)<br><span class="hljs-built_in">        </span><br><span class="hljs-built_in">        Hotkey,</span> CapsLock &amp; G, % varGAD, On<br>    &#125;<br>    <br>    generateDeploy() &#123;<br><span class="hljs-built_in">        Run,</span> <span class="hljs-variable">%comSpec%</span> /c hexo g &amp;&amp; hexo d, , Min<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AutoHotkey</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AutoHotkey</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AutoHotkey v1 问题解决记录</title>
    <link href="/posts/c3ce2acc1b27/"/>
    <url>/posts/c3ce2acc1b27/</url>
    
    <content type="html"><![CDATA[<blockquote><p>更多的资料请参考 AHK 官方技术文档以及 AHK 社区。</p></blockquote><hr><h1 id="代码中有些代码总是无法运行"><a href="#代码中有些代码总是无法运行" class="headerlink" title="代码中有些代码总是无法运行"></a>代码中有些代码总是无法运行</h1><blockquote><p>  处理方法参考自：</p><ul><li><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Scripts.htm#auto">脚本 - 定义与使用 | AutoHotkey (autoahk.com)</a></li></ul></blockquote><blockquote><p>  下文中的所有链接皆为 AHK 技术文档中该词条的链接，可正常使用。</p></blockquote><p><strong><font size="4"><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Scripts.htm#auto">脚本顶部(自动执行段)</a></font></strong></p><p>脚本加载完成后, 它会从顶行开始执行, 直到遇到 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Return.htm">Return</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Exit.htm">Exit</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Hotkeys.htm">热键&#x2F;热字串标签</a> 或脚本的底部(无论最先遇到哪个). 脚本的这个顶端部分被称为 <em>自动执行段</em>.</p><blockquote><p>   <strong>注意:</strong> 虽然脚本的 <em>第一个</em> 热键&#x2F;热字串标签与 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Return.htm">return(返回)</a> 的效果相同, 但其他热键和标签却没有.</p></blockquote><p>如果脚本不是<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/_Persistent.htm">持续运行的</a>, 它将在自动执行部分完成后终止. 否则, 它会以空闲状态持续运行, 从而对诸如<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Hotkeys.htm">热键</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Hotstrings.htm">热字串</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Gui.htm#label">GUI 事件</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Menu.htm">自定义菜单项</a>和<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/SetTimer.htm">计时器</a>等事件做出响应. 如果一个脚本包含了热键, 热字串, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/OnMessage.htm">OnMessage()</a> 或 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Gui.htm">GUI</a>, 以及一些其他情况, 它就会自动变为持续运行的. 也可以用 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/_Persistent.htm">#Persistent</a> 指令来显式地使脚本持续运行.</p><hr><h1 id="通过函数创建热键"><a href="#通过函数创建热键" class="headerlink" title="通过函数创建热键"></a>通过函数创建热键</h1><p>通过 <code>HotKey</code> 函数动态的创建一个热键。</p><blockquote><p>   具体参数可以查看文档：<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Hotkey.htm">Hotkey | AutoHotkey (autoahk.com)</a></p></blockquote><p>示例：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-comment">; 创建一个 CapsLock + K 的一个热键，效果为 Sfunction Lable 中的内容</span><br><span class="hljs-built_in">HotKey,</span> CapsLocks &amp; K, function<br><br>function() &#123;<br><span class="hljs-built_in">MsgBox,</span> <span class="hljs-string">&quot;Hello World!&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="通过函数创建热字串"><a href="#通过函数创建热字串" class="headerlink" title="通过函数创建热字串"></a>通过函数创建热字串</h1><p>通过 <code>HotString</code> 函数动态的创建一个热字串。</p><blockquote><p>  具体的参数可以查看文档：<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Hotstring.htm">Hotstring() | AutoHotkey (autoahk.com)</a></p></blockquote><hr><h1 id="无法正常使用分号（注释符号）"><a href="#无法正常使用分号（注释符号）" class="headerlink" title="无法正常使用分号（注释符号）"></a>无法正常使用分号（注释符号）</h1><p>当我们想要使用 分号 作为热键中的一部分时，我们可以使用 <code>SC027</code> 替换分号的位置，以达到分号的作用、</p><p>示例：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-comment">; 创建一个 CapsLock + K 的一个热键，效果为 function Lable 中的内容</span><br><span class="hljs-built_in">HotKey,</span> CapsLocks &amp; SC027, function <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AutoHotkey</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AutoHotkey</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin 函数嵌套</title>
    <link href="/posts/369d9c399bcc/"/>
    <url>/posts/369d9c399bcc/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li><li><a href="https://www.cnblogs.com/Anker/archive/2013/03/04/2943498.html">递归与尾递归总结 - Rabbit_Dale - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/zsp765098084/article/details/90901260">kotlin学习笔记之尾递归优化（tailrec）_mictoy_朱的博客-CSDN博客_kotlin tailrec</a></li></ul></blockquote><hr><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>在 <code>Kotlin</code> 中，我们可以在函数的代码块中创建另一个新的函数并使用该函数。并且该函数可以使用外部函数的变量。</p><p>如下方的代码；</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">outerMethod</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-comment">// 计算 1 + 2 + 3 + ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">innerMethod</span><span class="hljs-params">(c: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span>)</span></span> &#123;<br>        sum += c<br>        <span class="hljs-keyword">if</span> (c &gt; <span class="hljs-number">0</span>)<br>        innerMethod(c - <span class="hljs-number">1</span>)<br>    &#125;  <br>    <br>    innerMethod()<br>  println(sum)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    outerMethod()<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>函数嵌套在工程中应尽量少的使用，容易造成代码可读性的降低。</p><p>但是在两种情况下可以创建内部函数：</p><ol><li>在某些情况下需要临时使用 <strong>递归</strong> 函数，如上文中的代码。</li><li>不希望被外部函数访问到的函数。</li></ol><hr><h1 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h1><p>实际上，在函数式编程当中，我们有时候也会使用递归来替代循环。</p><p>我们知道，递归都是有调用栈开销的，所以我们应该尽量使用 <strong>尾递归</strong>。对于这种类型的递归，在经过栈复用优化以后，它的开销就可以忽略不计了，我们可以认为它的空间复杂度是 O(1)。</p><blockquote><p>  尾递归就是从最后开始计算，每递归一次就算出相应的结果，也就是说, 函数调用出现在调用者函数的尾部，因为是尾部，所以根本没有必要去保存任何局部变量，直接让被调用的函数返回时越过调用者，返回到调用者的调用者去。</p><p>  <strong>尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数</strong>，深层函数所面对的不是越来越简单的问题，而是越来越复杂的问题，因为参数里带有前面若干步的运算路径。</p><p>  尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。</p></blockquote><h2 id="尾递归的特点"><a href="#尾递归的特点" class="headerlink" title="尾递归的特点"></a>尾递归的特点</h2><ul><li>递归的一种特殊形式</li><li>调用自身后无其他操作</li><li><code>tailrec</code> 关键字提示编译器尾递归优化</li></ul><p>示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-keyword">val</span> value: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">var</span> next: ListNode? = <span class="hljs-literal">null</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findListNode</span><span class="hljs-params">(head: <span class="hljs-type">ListNode</span>?, value: <span class="hljs-type">Int</span>)</span></span>: ListNode? &#123; <span class="hljs-comment">// 定义一个递归函数</span><br>    head ?: <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">if</span> (head.value == value) <span class="hljs-keyword">return</span> head<br>    <span class="hljs-keyword">return</span> findListNode(head.next, value) <span class="hljs-comment">// return 除了调用自己，没有多余的操作，所以是尾递归</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="尾递归优化的使用"><a href="#尾递归优化的使用" class="headerlink" title="尾递归优化的使用"></a>尾递归优化的使用</h2><p>在 <code>Kotlin</code> 语言中，我们即使写出了符合尾递归的递归函数，编译器也不会自动帮我们进行优化。</p><p>我们需要在 <code>fun</code> 关键字前面加上 <code>tailrec</code> 关键字以表示我们需要进行尾递归优化。</p><p>示例代码1：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-keyword">val</span> value: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">var</span> next: ListNode? = <span class="hljs-literal">null</span>)<br><br><span class="hljs-keyword">tailrec</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findListNode</span><span class="hljs-params">(head: <span class="hljs-type">ListNode</span>?, value: <span class="hljs-type">Int</span>)</span></span>: ListNode? &#123; <span class="hljs-comment">// 定义一个递归函数</span><br>    head ?: <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">if</span> (head.value == value) <span class="hljs-keyword">return</span> head<br>    <span class="hljs-keyword">return</span> findListNode(head.next, value) <span class="hljs-comment">// return 除了调用自己，没有多余的操作，所以是尾递归</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例代码2：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">recursionLoop</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br><span class="hljs-comment">// 变化在这里</span><br><span class="hljs-comment">//     ↓</span><br>    <span class="hljs-keyword">tailrec</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">go</span><span class="hljs-params">(i: <span class="hljs-type">Int</span>, sum: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> =<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">10</span>) sum <span class="hljs-keyword">else</span> go(i + <span class="hljs-number">1</span>, sum + i)<br><br>    <span class="hljs-keyword">return</span> go(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="尾递归优化的实质"><a href="#尾递归优化的实质" class="headerlink" title="尾递归优化的实质"></a>尾递归优化的实质</h2><p>通过对上文中的 <code>findListNode</code> 方法对 <strong>加了 <code>tailrec</code> 关键字</strong> 与 <strong>去除 <code>tailrec</code> 关键字</strong> 的两份代码分别进行反编译，我们发现：</p><ul><li><p>没有优化的 <code>findListNode</code> 对应的 <code>Java</code> 代码依然是递归函数，并且递归运行次数较大时出现了 <code>StackOverflowError</code> 错误；</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135701617.png" alt="img" style="zoom: 90%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135611929.png" alt="img" style="zoom:87%;" /></li><li><p>优化后（即添加了 <code>tailrec</code> 关键字）的 <code>findListNode</code> 方法对应的 <code>Java</code> 代码已经不再是递归函数，而是通过循环来实现功能，这样就不会再出现 <code>stackoverflowerror</code> 了。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135710491.png" alt="img" style="zoom:90%;" /></li></ul><p>这样我们就在 <code>Kotlin</code> 中既实现了递归函数代码简洁的优势，又规避了在 <code>Java</code> 中使用递归函数容易出出现的问题。</p>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin 类的创建与继承</title>
    <link href="/posts/959140b987fa/"/>
    <url>/posts/959140b987fa/</url>
    
    <content type="html"><![CDATA[<blockquote><p><code>Kotlin</code> 官方在线编程网址：</p><ul><li><a href="https://play.kotlinlang.org/">https://play.kotlinlang.org/</a></li></ul></blockquote><hr><blockquote><p>  本文参考自：</p><ul><li>《第一行代码  Android 第3版》</li><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li><li><a href="https://blog.csdn.net/c1392851600/article/details/80990570">Kotlin之类的继承及属性和方法的重写_c1392851600的博客-CSDN博客</a></li></ul></blockquote><hr><h1 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h1><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>通过 <code>class</code> 关键字创建一个类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">var</span> age = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$name</span> is eating.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实例化方式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> person = Person()<br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>默认所有非抽象类都是不可以被继承的</strong>。</p><p>如果需要将其变为父类，则需要在 <code>class</code> 前使用 <code>open</code> 关键字。 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">var</span> age = <span class="hljs-number">0</span><br>    <br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$name</span> is eating.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要继承另一个类，则使用 <code>:</code> 符号：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-type">Person</span>() &#123;<br>    <span class="hljs-keyword">var</span> grade = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><h3 id="重写父类的方法"><a href="#重写父类的方法" class="headerlink" title="重写父类的方法"></a>重写父类的方法</h3><p>需要注意的是如果父类的方法没有 <code>open</code> 声明，那么该方法是不允许被重写的。重写方法的时候需要使用 <code>override</code> 关键字注明。还有一点就是子类可以选择不重写父类的方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;汪汪&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;萌萌哒&quot;</span>)<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Husky</span> : <span class="hljs-type">Dog</span>() &#123;<br>    <span class="hljs-comment">// 由于父类的shout方法没有写open, 也就是默认是final的, 所以这里不能重写shout方法</span><br>    <span class="hljs-comment">// Error:(15, 5) Kotlin: &#x27;shout&#x27; in &#x27;Dog&#x27; is final and cannot be overridden 不能重写 shout 因为默认是 final 的</span><br>    <span class="hljs-comment">/* override fun shout() &#123;</span><br><span class="hljs-comment">        println(&quot;汪汪汪&quot;)</span><br><span class="hljs-comment">    &#125;*/</span><br> <br>    <span class="hljs-comment">// 重写父类方法的时候要加上override关键字, show方法也可以选择不进行重写</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;喵喵&quot;</span>)<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> husky =  Husky()<br>    husky.shout()<br>    husky.show()<br>&#125;<br></code></pre></td></tr></table></figure><p>再次需要注意的是，如果一个类集成了多个类&#x2F;接口，并且父类&#x2F;接口中有相同名字的方法需要重写的时候，那么子类这时候必须重写该方法，并且如果子类想区分开父类的方法的时候，可以使用 <code>super</code> 关键字调用不同父类的方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">shout</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;汪汪&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;萌萌哒&quot;</span>)<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">WatchDog</span> &#123;<br>    <span class="hljs-comment">// interface里不用写open, 因为默认就是open的</span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;看门电子狗&quot;</span>)<br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">// 使用接口的时候不用写(), 是因为接口是没有构造函数的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Husky</span> : <span class="hljs-type">Dog</span>(), WatchDog &#123;<br>    <span class="hljs-comment">// 由于父类的shout方法没有写open, 也就是默认是final的, 所以这里不能重写父类的方法</span><br>    <span class="hljs-comment">// Error:(15, 5) Kotlin: &#x27;shout&#x27; in &#x27;Dog&#x27; is final and cannot be overridden  不能重写shout因为默认是final的</span><br>    <span class="hljs-comment">/*override fun shout() &#123;</span><br><span class="hljs-comment">        println(&quot;汪汪汪&quot;)</span><br><span class="hljs-comment">    &#125;*/</span><br> <br>    <span class="hljs-comment">// 重写父类方法的时候要加上override关键字</span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 当重写的方法在父类中有多个实现的时候, 如果继承的多个类中, 有相同的方法需要重写的时候, 则子类必须重写该方法, 并且, 为了区分, 可以使用super关键字来调用不同的父类中的方法</span><br>        <span class="hljs-keyword">super</span>&lt;WatchDog&gt;.show()  <span class="hljs-comment">// 看萌电子狗</span><br>        <span class="hljs-keyword">super</span>&lt;Dog&gt;.show() <span class="hljs-comment">// 萌萌哒</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">(args: <span class="hljs-type">Array</span>&lt;<span class="hljs-type">String</span>&gt;)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> husky =  Husky()<br>    husky.shout()   <span class="hljs-comment">// 汪汪</span><br>    husky.show()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="重写父类的变量"><a href="#重写父类的变量" class="headerlink" title="重写父类的变量"></a>重写父类的变量</h3><p>父类变量的重写的时候有几个需要注意的地方：</p><ol><li><p>被重写的变量也要有 <code>open</code> 的声明。</p></li><li><p>子类可以使用 <code>var</code> 类型的变量去重写父类 <code>val</code> 类型的变量，但是不能使用 <code>val</code> 类型的变量去重写父类 <code>var</code> 类型的变量。</p><p>如果使用 <code>val</code> 类型的变量去重写父类的 <code>var</code> 类型的变量, 那么子类这个 <code>val</code> 类型的变量会多一个 <code>set</code> 方法, 而 <code>val</code> 类型的变量是不允许有 <code>set</code> 方法的。</p></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">open</span> <span class="hljs-keyword">val</span> x: <span class="hljs-built_in">Int</span> <span class="hljs-keyword">get</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    &#125;<br> <br>    <span class="hljs-keyword">open</span> <span class="hljs-keyword">var</span> y : String = <span class="hljs-string">&quot;a&quot;</span><br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-type">A</span>() &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> x: <span class="hljs-built_in">Int</span> = <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> y: String = <span class="hljs-string">&quot;b&quot;</span><br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> : <span class="hljs-type">A</span>() &#123;<br>    <span class="hljs-keyword">override</span>  <span class="hljs-keyword">var</span> x : <span class="hljs-built_in">Int</span> = <span class="hljs-number">2</span><br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> y : String = <span class="hljs-string">&quot;c&quot;</span> <span class="hljs-comment">// Error: Var-property public open val y: String defined in C cannot be overridden by val-property public open var y: String defined in A</span><br><br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p><code>Kotlin</code> 将构造函数分为了两种：主构造函数和次构造函数。</p><h2 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h2><p>主构造函数是最常使用的构造函数，每个类默认都会有一个不带参数的主构造函数。</p><p>（特殊情况：如果在没有实现主构造函数的情况下实现了次构造函数，则会失去该不带参数的主构造函数。）</p><p>当然也是可以显式地为其指明参数。主构造函数的特点就是没有函数体，直接定义在类名的后面即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> studentNo: String, <span class="hljs-keyword">var</span> grade: <span class="hljs-built_in">Int</span>) : Person() &#123;<br>&#125;<br><br><span class="hljs-comment">// 或者可以写成</span><br><span class="hljs-comment">// class Student constructor(val studentNo: String, var grade: Int) : Person() &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>我们在实例化的时候需要传入构造函数中的所有的参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> student = Student(<span class="hljs-string">&quot;123456789&quot;</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>由于主构造函数没有函数体，所以我们无法直接在其中编写一些逻辑。但是 <code>Kotlin</code> 给我们提供了一个 <code>init</code> 结构体，所有主构造函数的逻辑都可以写在里面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> studentNo: String, <span class="hljs-keyword">var</span> grade: <span class="hljs-built_in">Int</span>) : Person() &#123;<br>    <span class="hljs-keyword">init</span> &#123;<br>        println(<span class="hljs-string">&quot;Student No is <span class="hljs-variable">$studentNo</span> AND grade is <span class="hljs-variable">$grade</span>.&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>根据 <code>Java</code> 语言继承特性中的一个规定：子类的构造函数必须调用父类中的构造函数。这个规定在 <code>Kotlin</code> 中也要遵守。 </p><p>所以在上文中 <code>class Student : Person()</code> 以及 <code>class Student(val studentNo: String, var grade: Int) : Person()</code> 中 <code>Person</code> 类后面的一对空括号表示 <code>Student</code> 类的主构造函数在初始化的时候会调用 <code>Person</code> 类的无参数构造函数，即使在自身的主构造函数为默认的无参数的时候也是不能省略的。</p><p>现在我们将 <code>Person</code> 类改造一下，将姓名和年龄都放到主构造函数中，即：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>        println(<span class="hljs-string">&quot;<span class="hljs-variable">$name</span> is eating.&quot;</span>)<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们自定义了主构造函数，所以默认提供的无参数的主构造函数就不存在了，所以我们也需要修改一下 <code>Student</code> 类的表示方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-keyword">val</span> studentNo: String, <span class="hljs-keyword">var</span> grade: <span class="hljs-built_in">Int</span>, name: String, age: <span class="hljs-built_in">Int</span>) : Person(name, age) &#123;<br>            <br>    <span class="hljs-keyword">init</span> &#123;<br>        println(<span class="hljs-string">&quot;Student No is <span class="hljs-variable">$studentNo</span> AND grade is <span class="hljs-variable">$grade</span>.&quot;</span>)<br>    &#125;    <br>            <br>&#125;<br></code></pre></td></tr></table></figure><p>注意，我们在 <code>Student</code> 类的主构造函数中增加 <code>name</code> 和 <code>age</code> 这两个字段时，不能再将它们声明成 <code>val</code>，因为在主构造函数中声明成 <code>val</code> 或者 <code>var</code> 的参数将自动成为该类的字段,这就会导致和父类中同名的 <code>name</code> 和 <code>age</code> 字段造成冲突。因此，<strong>这里的 <code>name</code> 和 <code>age</code> 参数前面我们不用加任何关键字,让它的作用域仅限定在主构造函数当中即可</strong> 。</p><p>现在就可以通过如下的代码来创建一个 <code>Student</code> 类的实例并使用了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> student = Student(<span class="hljs-string">&quot;123456789&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&quot;LiHua&quot;</span>, <span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><h2 id="次构造函数"><a href="#次构造函数" class="headerlink" title="次构造函数"></a>次构造函数</h2><p>其实你几乎是用不到次构造函数的，<code>Kotlin</code> 提供了一个给函数设定参数默认值的功能，基本上可以替代次构造函数的作用。</p><p>任何一个类只能有一个主构造函数，但是可以有多个次构造函数。次构造函数也可以用于实例化一个类，这一点和主构造函数没有什么不同，只不过它是有函数体的。</p><p><code>Kotlin</code> 规定，当一个类既有主构造函数又有次构造函数时，所有的次构造函数都必须调用主构造函数（包括间接调用)。</p><p>比如以下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">var</span> age: <span class="hljs-built_in">Int</span>) &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(name: String, age: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> studentNo: String, <span class="hljs-keyword">var</span> grade: <span class="hljs-built_in">Int</span>) : Person(name, age) &#123;<br>    <span class="hljs-keyword">init</span> &#123;<br>        println(<span class="hljs-string">&quot;name : <span class="hljs-variable">$name</span> AND age : <span class="hljs-variable">$age</span> AND studentNo : <span class="hljs-variable">$studentNo</span> AND grade : <span class="hljs-variable">$grade</span>&quot;</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">constructor</span>(name: String , age: <span class="hljs-built_in">Int</span>) : <span class="hljs-keyword">this</span>(name, age, <span class="hljs-string">&quot;12345&quot;</span>, <span class="hljs-number">2</span>) &#123;&#125;<br>    <br>    <span class="hljs-keyword">constructor</span>() : <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;XiaoMei&quot;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&quot;1234567&quot;</span>, <span class="hljs-number">1</span>) &#123;&#125; <span class="hljs-comment">// 如果 &#123;&#125; 内没有内容的话，可以省略大括号</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> student1 = Student(<span class="hljs-string">&quot;LiHua&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">val</span> student2 = Student(<span class="hljs-string">&quot;XiaoMing&quot;</span>, <span class="hljs-number">21</span>)<br>    <span class="hljs-keyword">val</span> student3 = Student()<br>&#125;<br><br><span class="hljs-comment">// 运行结果</span><br>name : LiHua AND age : <span class="hljs-number">20</span> AND studentNo : <span class="hljs-number">123456</span> AND grade : <span class="hljs-number">3</span><br>name : XiaoMing AND age : <span class="hljs-number">21</span> AND studentNo : <span class="hljs-number">12345</span> AND grade : <span class="hljs-number">2</span><br>name : XiaoMei AND age : <span class="hljs-number">19</span> AND studentNo : <span class="hljs-number">1234567</span> AND grade : <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>特殊情况：</strong></p><p>那么接下来我们就再来看一种非常特殊的情况：类中只有次构造函数，没有主构造函数。</p><p>这种情况真的十分少见，但在 <code>Kotlin</code> 中是允许的。</p><p><strong>当一个类没有显式地定义主构造函数且定义了次构造函数时，它就是没有主构造函数的。</strong></p><p>我们结合代码来看一下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> : <span class="hljs-type">Person</span> &#123;<br>    <span class="hljs-keyword">constructor</span>(name: String, age: <span class="hljs-built_in">Int</span>) : <span class="hljs-keyword">super</span>(name, age) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里的代码变化，首先 <code>Student</code> 类的后面没有显式地定义主构造函数，同时又因为定义了次构造函数，所以现在 <code>Student</code> 类是没有主构造函数的。那么既然没有主构造函数，继承 <code>Person</code> 类的时候也就不需要再加上括号了（因为主构造函数会调用父类的构造函数）。</p><p>另外，由于没有主构造函数，次构造函数只能直接调用父类的构造函数，上述代码也是将 <code>this</code> 关键字换成了 <code>super</code> 关键字，这部分就很好理解了，因为和 <code>Java</code> 比较像，也就不再多说了。</p><hr><h1 id="函数的命名参数以及参数默认值"><a href="#函数的命名参数以及参数默认值" class="headerlink" title="函数的命名参数以及参数默认值"></a>函数的命名参数以及参数默认值</h1><blockquote><p>  类的构造函数同样适用于命名参数以及参数默认值，所以我们在极大多数的情况下通过这两个特性配合主构造函数来可以实现次构造函数的功能。</p></blockquote><h2 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h2><p>简单理解，就是它允许我们在调用函数的时候传入“形参的名字”。</p><p>如同以下形式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">helloFunction(name = <span class="hljs-string">&quot;Kotlin&quot;</span>)<br></code></pre></td></tr></table></figure><p>让我们看一个更具体的使用场景：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createUser</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    name: <span class="hljs-type">String</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    age: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    gender: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    friendCount: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    feedCount: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    likeCount: <span class="hljs-type">Long</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    commentCount: <span class="hljs-type">Int</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>    <span class="hljs-comment">//..</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过如下的方法使用函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">createUser(<br>    name = <span class="hljs-string">&quot;Tom&quot;</span>,<br>    age = <span class="hljs-number">30</span>,<br>    gender = <span class="hljs-number">1</span>,<br>    friendCount = <span class="hljs-number">78</span>,<br>    feedCount = <span class="hljs-number">2093</span>,<br>    likeCount = <span class="hljs-number">10937</span>,<br>    commentCount = <span class="hljs-number">3285</span><br>)<br></code></pre></td></tr></table></figure><p>可以看到，在这段代码中，我们把函数的形参加了进来，形参和实参用 <code>=</code> 连接，建立了两者的对应关系。对比前面 <code>Java</code> 风格的写法，这样的代码可读性更强了。如果将来你想修改 <code>likeCount</code> 这个参数，也可以轻松做到。这其实就体现出了 <code>Kotlin</code> 命名参数的可读性与易维护性两个优势。</p><h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><p>而除了命名参数这个特性，<code>Kotlin</code> 还支持参数默认值，这个特性在参数较多的情况下同样有很大的优势：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">createUser</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    name: <span class="hljs-type">String</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    age: <span class="hljs-type">Int</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    gender: <span class="hljs-type">Int</span> = <span class="hljs-number">1</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    friendCount: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    feedCount: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    likeCount: <span class="hljs-type">Long</span> = <span class="hljs-number">0</span>L,</span></span><br><span class="hljs-params"><span class="hljs-function">    commentCount: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span> &#123;<br>    <span class="hljs-comment">//..</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到，<code>gender</code>、<code>friendCount</code>、<code>feedCount</code>、<code>likeCount</code>、<code>commentCount</code> 这几个参数都被赋予了默认值。这样做的好处就在于，我们在调用的时候可以省很多事情。比如说，下面这段代码就只需要传 3 个参数，剩余的 4 个参数没有传，但是 <code>Kotlin</code> 编译器会自动帮我们填上默认值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">createUser(<br>    name = <span class="hljs-string">&quot;Tom&quot;</span>,<br>    age = <span class="hljs-number">30</span>,<br>    commentCount = <span class="hljs-number">3285</span><br>)<br></code></pre></td></tr></table></figure><p>对于无默认值的参数，编译器会强制要求我们在调用处传参；对于有默认值的参数，则可传可不传。<code>Kotlin</code> 这样的特性，在一些场景下就可以极大地提升我们的开发效率。而如果是在 <code>Java</code> 当中要实现类似的事情，我们就必须手动定义“3 个参数的 <code>createUser</code> 函数”，或者是使用 <code>Builder</code> 设计模式。</p><h2 id="在构造函数中的使用案例"><a href="#在构造函数中的使用案例" class="headerlink" title="在构造函数中的使用案例"></a>在构造函数中的使用案例</h2><p>通过写出如下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<br>    name: String = <span class="hljs-string">&quot;&quot;</span>, <br>    age: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span>, <br>    <span class="hljs-keyword">val</span> studentNo: String = <span class="hljs-string">&quot;&quot;</span>, <br>    <span class="hljs-keyword">val</span> grade: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><br>) : Person(name, age) &#123;<br>    <span class="hljs-comment">//..</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在给主构造函数的每个参数都设定了默认值之后，我们就可以使用任何传参组合的方式来对 <code>Student</code> 类进行实例化，当然也包含了上文中的两种次构造函数的使用场景。</p><hr><h1 id="函数的可见性修饰符"><a href="#函数的可见性修饰符" class="headerlink" title="函数的可见性修饰符"></a>函数的可见性修饰符</h1><p>熟悉 <code>Java</code> 的人一定知道，<code>Java</code> 中有 <code>public</code>、 <code>private</code>、 <code>protected</code> 和 <code>default</code>(什么都不写）这4种函数可见性修饰符。</p><p><code>Kotlin</code>中也有4种，分别是 <code>public</code>、 <code>private</code>、<code>protected</code> 和 <code>internal</code>，需要使用哪种修饰符时，直接定义在 <code>fun</code> 关键字的前面即可。</p><p>下面将详细介绍一下 <code>Java</code> 和 <code>Kotlin</code> 中这些函数可见性修饰符的异同。</p><ol><li><p><code>private</code> 修饰符在两种语言中的作用是一模一样的，都表示只对当前类内部可见。</p></li><li><p><code>public</code> 修饰符的作用虽然也是一致的，表示对所有类都可见，但是在 <code>Kotlin</code>中 <code>public</code> 修饰符是默认项，而在 <code>Java</code> 中 <code>default</code> 才是默认项。前面我们定义了那么多的函数，都没有加任何的修饰符，所以它们默认都是 <code>public</code> 的。</p></li><li><p><code>protected</code> 关键字在 <code>Java</code> 中表示对当前类、子类和同一包路径下的类可见，在 <code>Kotlin</code> 中则表示只对当前类和子类可见。</p></li><li><p><code>Kotlin</code> 抛弃了 <code>Java</code> 中的 <code>default</code> 可见性（同一包路径下的类可见），引人了一种新的可见性概念，只对同一模块中的类可见，使用的是 <code>internal</code> 修饰符。比如我们开发了一个模块给别人使用，但是有一些函数只允许在模块内部调用，不想暴露给外部，就可以将这些函数声明成 <code>internal</code> 。</p></li></ol><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220708221406391.png" alt="image"></p><p>所以，我们可以通过 <code>private</code> 关键字将类的构造函数定义为私有属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 私有的主构造函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>(<br>    <span class="hljs-keyword">val</span> studentNo: String, <br>    <span class="hljs-keyword">var</span> grade: <span class="hljs-built_in">Int</span><br>) : Person() &#123;<br>    <br>    <span class="hljs-comment">// 私有的次构造函数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">constructor</span>(grade: <span class="hljs-built_in">Int</span>) : <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;123&quot;</span>, grade) &#123;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo-theme-butterfly 修改侧边栏分类排序规则</title>
    <link href="/posts/8cb0fd83894c/"/>
    <url>/posts/8cb0fd83894c/</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><code>hexo-theme-butterfly</code> 主题中，主页侧边栏中的 <code>categories</code> 默认显示顺序是按 <code>name</code> 排序，导致某些分类下虽然文章数量较少，但却排序靠前。并且默认设置下，主题中侧边 <code>categories</code> 只显示8条（如需修改可以修改<strong>主题配置文件</strong>）。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220608210201564.png" alt="image" style="zoom:67%;" /><p>便想将其修改为 <strong>按照分类内文章的数量进行降序排序</strong> 。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><blockquote><p>  该方法需要修改源代码，建议及时备份需要修改的文件。</p></blockquote><ol><li><p>找到 <code>themes\butterfly\scripts\helpers\aside_categories.js</code> 文件，并修改源代码。</p></li><li><p>修改以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// const orderby = options.orderby || &#x27;name&#x27; // name(default) -&gt; 按 categories 字母顺序</span><br><span class="hljs-keyword">const</span> orderby = options.<span class="hljs-property">orderby</span> || <span class="hljs-string">&#x27;length&#x27;</span>  <span class="hljs-comment">// length -&gt; 按 categories 下文章数量排序</span><br><span class="hljs-comment">// const order = options.order || 1  // 1(default) -&gt; 升序; -1 -&gt; 逆序</span><br><span class="hljs-keyword">const</span> order = options.<span class="hljs-property">order</span> || -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>执行 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code> 查看修改效果。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220608205749969.png" alt="image" style="zoom: 67%;" /></li></ol><h1 id="参考教程"><a href="#参考教程" class="headerlink" title="参考教程"></a>参考教程</h1><ul><li><a href="https://www.yanchengxu.top/hexo-categories-sort/">【Hexo-Butterfly】修改侧边栏分类排序规则 | yanchengxu</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo-theme-butterfly</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络 基本概念</title>
    <link href="/posts/7da3e33e8404/"/>
    <url>/posts/7da3e33e8404/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  答案参考自：</p><ul><li><a href="http://www.cyc2018.xyz/">CS-Notes (cyc2018.xyz)</a></li></ul></blockquote><h1 id="主机之间的通信方式"><a href="#主机之间的通信方式" class="headerlink" title="主机之间的通信方式"></a>主机之间的通信方式</h1><ul><li>客户-服务器（C&#x2F;S）：客户是服务的请求方，服务器是服务的提供方。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/914894c2-0bc4-46b5-bef9-0316a69ef521.jpg" style="zoom: 67%;" /><ul><li>对等（P2P）：不区分客户和服务器。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/42430e94-3137-48c0-bdb6-3cebaf9102e3.jpg" style="zoom: 67%;" /><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" style="zoom: 67%;" /><h2 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h2><ul><li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</li><li><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：<strong>传输控制协议 TCP</strong> ，提供面向连接、可靠的数据传输服务，数据单位为报文段：<strong>用户数据报协议 UDP</strong> ，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li><li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><h2 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h2><p>其中表示层和会话层用途如下：</p><ul><li><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li><li><strong>会话层</strong> ：建立及管理会话。</li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><h2 id="TCP-x2F-IP"><a href="#TCP-x2F-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h2><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP&#x2F;IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/48d79be8-085b-4862-8a9d-18402eb93b31.png" style="zoom:67%;" /><h2 id="数据在各层之间的传递过程"><a href="#数据在各层之间的传递过程" class="headerlink" title="数据在各层之间的传递过程"></a>数据在各层之间的传递过程</h2><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/29a14735-e154-4f60-9a04-c9628e5d09f4.png" style="zoom:67%;" /><h2 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h2><p>透明表示一个实际存在的事物看起来好像不存在一样。</p><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出 </p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/e738a3d2-f42e-4755-ae13-ca23497e7a97.png" style="zoom: 50%;" /><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p><h2 id="信道分类"><a href="#信道分类" class="headerlink" title="信道分类"></a>信道分类</h2><h3 id="广播信道"><a href="#广播信道" class="headerlink" title="广播信道"></a>广播信道</h3><p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA&#x2F;CD 协议。</p><h3 id="点对点信道"><a href="#点对点信道" class="headerlink" title="点对点信道"></a>点对点信道</h3><p>一对一通信。</p><p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><h3 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h3><p>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/4aa5e057-bc57-4719-ab57-c6fbc861c505.png" style="zoom:50%;" /><h3 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h3><p>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/67582ade-d44a-46a6-8757-3c1296cc1ef9.png" style="zoom:50%;" /><p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，<strong>因此这两种方式对信道的利用率都不高</strong> 。</p><h3 id="统计时分复用"><a href="#统计时分复用" class="headerlink" title="统计时分复用"></a>统计时分复用</h3><p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/6283be2a-814a-4a10-84bf-9592533fe6bc.png" style="zoom:50%;" /><h3 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h3><p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p><h3 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h3><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><h2 id="IP-数据报格式"><a href="#IP-数据报格式" class="headerlink" title="IP 数据报格式"></a>IP 数据报格式</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" style="zoom: 67%;" /><ul><li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li><li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li><li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li><li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li></ul><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。</p><h2 id="UDP-和-TCP-的特点"><a href="#UDP-和-TCP-的特点" class="headerlink" title="UDP 和 TCP 的特点"></a>UDP 和 TCP 的特点</h2><ul><li><strong>用户数据报协议 UDP（User Datagram Protocol）</strong> 是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），<strong>支持一对一、一对多、多对一和多对多的交互通信</strong> 。</li><li><strong>传输控制协议 TCP（Transmission Control Protocol）</strong> 是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），<strong>每一条 TCP 连接只能是点对点的（一对一）</strong> 。</li></ul><h2 id="UDP-首部格式"><a href="#UDP-首部格式" class="headerlink" title="UDP 首部格式"></a>UDP 首部格式</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" style="zoom: 50%;" /><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><h2 id="TCP-首部格式"><a href="#TCP-首部格式" class="headerlink" title="TCP 首部格式"></a>TCP 首部格式</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" style="zoom: 50%;" /><ul><li><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li><li><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li><li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li><strong>确认 ACK</strong> ：当 ACK&#x3D;1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN&#x3D;1，ACK&#x3D;0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN&#x3D;1，ACK&#x3D;1。</li><li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN&#x3D;1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li><li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ul><h2 id="TCP-的三次握手"><a href="#TCP-的三次握手" class="headerlink" title="TCP 的三次握手"></a>TCP 的三次握手</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/e92d0ebc-7d46-413b-aec1-34a39602f787.png" style="zoom: 50%;" /><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN&#x3D;1，ACK&#x3D;0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN&#x3D;1，ACK&#x3D;1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20191129144820655.png" alt="TCP 三次握手" style="zoom:80%;" /><p><strong>三次握手的原因</strong></p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><p><strong>为什么不能只进行两次挥手</strong></p><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/lengxiao1993/article/details/82771768">TCP 为什么三次握手而不是两次握手（正解版）_萧萧九宸的博客-CSDN博客_tcp为什么是三次握手不是两次握手</a></li></ul></blockquote><ul><li><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。</p></li><li><p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。少了第三次，服务端就没法确认客户端有没有收到数据包。</p></li></ul><h2 id="TCP-的四次挥手"><a href="#TCP-的四次挥手" class="headerlink" title="TCP 的四次挥手"></a>TCP 的四次挥手</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="TCP 四次挥手" style="zoom: 67%;" /><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li>A 发送连接释放报文，FIN&#x3D;1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN&#x3D;1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><p><strong>四次挥手的原因</strong></p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong></p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><p><strong>为什么不能是三次挥手?</strong></p><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/King___Ding/article/details/114873506">TCP 四次挥手的过程，为什么是四次挥手而不是三次_King-Ding的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/bytebai/article/details/22191677">TCP：半关闭_ByteBai的博客-CSDN博客_tcp 半关闭</a></li></ul></blockquote><p>因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。</p><p>如果是三次挥手会有什么问题？</p><p>等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。 不断的进行数据包重发。</p><blockquote><p>  TODO : 客户端处于半关闭状态时能够主动发出消息？如不能，如何回复第三次FIN消息？</p></blockquote><h2 id="TCP-可靠传输"><a href="#TCP-可靠传输" class="headerlink" title="TCP 可靠传输"></a>TCP 可靠传输</h2><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><h2 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg"  style="zoom: 67%;" /><h2 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="请求和响应报文"><a href="#请求和响应报文" class="headerlink" title="请求和响应报文"></a>请求和响应报文</h3><p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。</p><p>请求报文结构：</p><ul><li>第一行是包含了请求方法、URL、协议版本；</li><li>接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。</li><li>一个空行用来分隔首部和内容主体 Body</li><li>最后是请求的内容主体</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">http://www.example.com/</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=0<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.example.com<br><span class="hljs-attribute">If-Modified-Since</span><span class="hljs-punctuation">: </span>Thu, 17 Oct 2019 07:18:26 GMT<br><span class="hljs-attribute">If-None-Match</span><span class="hljs-punctuation">: </span>&quot;3147526947+gzip&quot;<br><span class="hljs-attribute">Proxy-Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 xxx<br><br><span class="language-apache"><span class="hljs-attribute">param1</span>=<span class="hljs-number">1</span>&amp;param2=<span class="hljs-number">2</span></span><br></code></pre></td></tr></table></figure><p>响应报文结构：</p><ul><li>第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了</li><li>接下来多行也是首部内容</li><li>一个空行分隔首部和内容主体</li><li>最后是响应的内容主体</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Age</span><span class="hljs-punctuation">: </span>529651<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=604800<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>gzip<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>648<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=UTF-8<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 02 Nov 2020 17:53:39 GMT<br><span class="hljs-attribute">Etag</span><span class="hljs-punctuation">: </span>&quot;3147526947+ident+gzip&quot;<br><span class="hljs-attribute">Expires</span><span class="hljs-punctuation">: </span>Mon, 09 Nov 2020 17:53:39 GMT<br><span class="hljs-attribute">Keep-Alive</span><span class="hljs-punctuation">: </span>timeout=4<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Thu, 17 Oct 2019 07:18:26 GMT<br><span class="hljs-attribute">Proxy-Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>ECS (sjc/16DF)<br><span class="hljs-attribute">Vary</span><span class="hljs-punctuation">: </span>Accept-Encoding<br><span class="hljs-attribute">X-Cache</span><span class="hljs-punctuation">: </span>HIT<br><br><span class="language-xml"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Example Domain<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><br><span class="language-xml">// 省略... </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>HTTP 使用 URL（ <strong>U</strong> niform <strong>R</strong>esource <strong>L</strong>ocator，统一资源定位符）来定位资源，它是 URI（<strong>U</strong>niform <strong>R</strong>esource <strong>I</strong>dentifier，统一资源标识符）的子集，URL 在 URI 的基础上增加了定位能力。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png" style="zoom: 67%;" /><h2 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h2><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><blockquote><p>  获取资源</p></blockquote><p>当前网络请求中，绝大部分使用的是 GET 方法。</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><blockquote><p>  传输实体主体</p></blockquote><p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><blockquote><p>  上传文件</p></blockquote><p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><blockquote><p>  删除文件</p></blockquote><p>与 PUT 功能相反，并且同样不带验证机制。</p><h2 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h2><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr><th align="center">状态码</th><th align="center">类别</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">1XX</td><td align="center">Informational（信息性状态码）</td><td align="center">接收的请求正在处理</td></tr><tr><td align="center">2XX</td><td align="center">Success（成功状态码）</td><td align="center">请求正常处理完毕</td></tr><tr><td align="center">3XX</td><td align="center">Redirection（重定向状态码）</td><td align="center">需要进行附加操作以完成请求</td></tr><tr><td align="center">4XX</td><td align="center">Client Error（客户端错误状态码）</td><td align="center">服务器无法处理请求</td></tr><tr><td align="center">5XX</td><td align="center">Server Error（服务器错误状态码）</td><td align="center">服务器处理请求出错</td></tr></tbody></table><h3 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h3><ul><li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><ul><li><strong>200 OK</strong></li></ul><h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><ul><li><strong>301 Moved Permanently</strong> ：永久性重定向</li><li><strong>302 Found</strong> ：临时性重定向</li></ul><h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><ul><li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li><li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden</strong> ：请求被拒绝。</li><li><strong>404 Not Found</strong></li></ul><h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><ul><li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li></ul><h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/HTTP1_x_Connections.png" style="zoom:67%;" /><h3 id="短连接与长连接"><a href="#短连接与长连接" class="headerlink" title="短连接与长连接"></a>短连接与长连接</h3><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p><p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p><ul><li>从 HTTP&#x2F;1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li><li>在 HTTP&#x2F;1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li></ul><h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p><p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h3 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h3><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>缓解服务器压力；</li><li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li></ul><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li>让代理服务器进行缓存；</li><li>让客户端浏览器进行缓存。</li></ul><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>HTTP&#x2F;1.1 通过 Cache-Control 首部字段来控制缓存。</p><h2 id="通信数据转发"><a href="#通信数据转发" class="headerlink" title="通信数据转发"></a>通信数据转发</h2><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理服务器接受客户端的请求，并且转发给其它服务器。</p><h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。</p><h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</p><h2 id="HTTP-的安全性问题"><a href="#HTTP-的安全性问题" class="headerlink" title="HTTP  的安全性问题"></a>HTTP  的安全性问题</h2><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTP 有以下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p><p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ssl-offloading.jpg" style="zoom:67%;" /><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="对称密钥加密"><a href="#对称密钥加密" class="headerlink" title="对称密钥加密"></a>对称密钥加密</h3><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p><ul><li>优点：运算速度快；</li><li>缺点：无法安全地将密钥传输给通信方。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png"  style="zoom:67%;" /><h3 id="非对称密钥加密"><a href="#非对称密钥加密" class="headerlink" title="非对称密钥加密"></a>非对称密钥加密</h3><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p><p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p><ul><li>优点：可以更安全地将公开密钥传输给通信发送方；</li><li>缺点：运算速度慢。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png" style="zoom: 67%;" /><h3 id="HTTPS-采用的加密方式"><a href="#HTTPS-采用的加密方式" class="headerlink" title="HTTPS 采用的加密方式"></a>HTTPS 采用的加密方式</h3><p>上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：</p><ul><li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;</li><li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/How-HTTPS-Works.png" style="zoom: 33%;" /><h2 id="HTTPS-的缺点"><a href="#HTTPS-的缺点" class="headerlink" title="HTTPS 的缺点"></a>HTTPS 的缺点</h2><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高额费用。</li></ul><h1 id="从-URL-输入到页面展现到底发生什么？"><a href="#从-URL-输入到页面展现到底发生什么？" class="headerlink" title="从 URL 输入到页面展现到底发生什么？"></a>从 URL 输入到页面展现到底发生什么？</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/57895541">经典面试题：从 URL 输入到页面展现到底发生什么？ - 知乎 (zhihu.com)</a></li></ul></blockquote><p>总体来说分为以下几个过程:</p><ol><li><p>DNS 解析:将域名解析成 IP 地址</p></li><li><p>TCP 连接：TCP 三次握手</p></li><li><p>发送 HTTP 请求</p></li><li><p>服务器处理请求并返回 HTTP 报文</p></li><li><p>浏览器解析渲染页面</p></li><li><p>断开连接：TCP 四次挥手</p></li></ol><p><strong><font size="5">DNS解析</font></strong></p><p>在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。</p><p><strong><font size="4">IP地址</font></strong></p><p>IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址是一个 32 位的二进制数，比如 127.0.0.1 为本机 IP。</p><p><strong><font size="4">域名解析</font></strong></p><p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。</p><p><strong><font size="4">浏览器如何通过域名去查询 URL 对应的 IP 呢</font></strong></p><ul><li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li><li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。</li><li>路由缓存：路由器也有 DNS 缓存。</li><li>ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li><li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器.com 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）</li></ul><p><strong><font size="4">小结</font></strong></p><p>浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息、关闭 TCP 连接。</p>]]></content>
    
    
    <categories>
      
      <category>面试整理-2022</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP/IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程的相关知识，你了解吗？</title>
    <link href="/posts/834ec61b5019/"/>
    <url>/posts/834ec61b5019/</url>
    
    <content type="html"><![CDATA[<h1 id="Java中创建线程的方式"><a href="#Java中创建线程的方式" class="headerlink" title="Java中创建线程的方式"></a><code>Java</code>中创建线程的方式</h1><blockquote><p>  <code>Future</code>, <code>FutureTask</code>的实现方式暂未学习，待补充。</p></blockquote><ol><li>写一个类继承自<code>Thread</code>类，重写<code>run</code>方法。用<code>start</code>方法启动线程。</li><li>写一个类实现<code>Runnable</code>接口，实现<code>run</code>方法。用<code>new Thread(Runnable target).start</code>方法来启动。</li></ol><h1 id="线程的几种状态"><a href="#线程的几种状态" class="headerlink" title="线程的几种状态"></a>线程的几种状态</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/pange1991/article/details/53860651/">Java线程的6种状态及切换(透彻讲解)_潘建南的博客-CSDN博客_线程状态</a></li></ul></blockquote><p><code>Java</code>中的线程的状态总共有6种。</p><blockquote><ol><li><strong>初始(<code>NEW</code>)：</strong> 新创建了一个线程对象，但还没有调用start()方法。</li><li><strong>运行(<code>RUNNABLE</code>)：</strong> Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>  线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li><li><strong>阻塞(<code>BLOCKED</code>)：</strong> 表示线程阻塞于锁。</li><li><strong>等待(<code>WAITING</code>)：</strong> 进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li><strong>超时等待(<code>TIMED_WAITING</code>)：</strong> 该状态不同于<code>WAITING</code>，它可以在指定的时间后自行返回。</li><li><strong>终止(<code>TERMINATED</code>)：</strong> 表示该线程已经执行完毕。</li></ol></blockquote><p>这6种状态定义在<code>Thread</code>类的<code>State</code>枚举中，可查看源码进行一一对应。</p><p><strong><font size="4">线程状态图</font></strong></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20181120173640764.jpeg" alt="线程状态图"></p><p><strong><font size="4">状态详细说明</font></strong></p><ol><li><p><strong>初始状态(<code>NEW</code>)</strong><br>实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</p></li><li><p><strong>运行状态(<code>RUNNABLE</code>)</strong></p><ol><li><strong>就绪状态(<code>RUNNABLE</code>之<code>READY</code>)</strong><ul><li>就绪状态只是说你有资格运行，调度程序没有挑选到你，你就永远是就绪状态。</li><li>调用线程的start()方法，此线程进入就绪状态。</li><li>当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。</li><li>当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。</li><li>锁池里的线程拿到对象锁后，进入就绪状态。</li></ul></li><li><strong>运行中状态(<code>RUNNABLE</code>之<code>RUNNING</code>)</strong><br>线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一的一种方式。</li></ol></li><li><p><strong>阻塞状态(<code>BLOCKED</code>)</strong><br>阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。</p></li><li><p><strong>等待(<code>WAITING</code>)</strong><br>处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</p></li><li><p><strong>超时等待(<code>TIMED_WAITING</code>)</strong><br>处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</p></li><li><p><strong>终止状态(<code>TERMINATED</code>)</strong><br>当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。<br>在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p></li></ol><h1 id="Thread-sleep与Object-wait的区别"><a href="#Thread-sleep与Object-wait的区别" class="headerlink" title="Thread#sleep与Object#wait的区别"></a><code>Thread#sleep</code>与<code>Object#wait</code>的区别</h1><p><strong><font size="4"><code>Thread#sleep</code></font></strong></p><p><code>Thread.sleep(long millis)</code>，一定是当前线程调用此方法，当前线程进入<code>TIMED_WAITING</code>状态，但<strong>不释放对象锁</strong>，<code>millis</code>后线程自动苏醒进入就绪状态。</p><p>作用：给其它线程执行机会的最佳方式。</p><p><strong><font size="4"><code>Object#wait</code></font></strong></p><p>当前线程调用对象的<code>wait</code>方法，当前线程<strong>释放对象锁</strong>，进入等待队列。</p><p>依靠<code>notify/notifyAll</code>唤醒或者<code>wait(long timeout)</code>， <code>timeout</code>时间到自动唤醒。</p><p><strong><font size="4">总结</font></strong></p><p>可以发现，两者的区别为当前的线程是否会释放对象锁。</p><h1 id="Object-notify和Object-notifyAll的区别"><a href="#Object-notify和Object-notifyAll的区别" class="headerlink" title="Object#notify和Object#notifyAll的区别"></a><code>Object#notify</code>和<code>Object#notifyAll</code>的区别</h1><p><code>Object#notify</code>唤醒在此对象监视器上等待的<strong>单个线程</strong>，<strong>选择是任意性的</strong>。</p><p><code>Object#notifyAll</code>唤醒在此对象监视器上等待的<strong>所有线程</strong>。</p><h1 id="锁池和等待池"><a href="#锁池和等待池" class="headerlink" title="锁池和等待池"></a>锁池和等待池</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.cnblogs.com/javaddd/p/13611981.html">多线程的“锁池”和“等待池” - suncl123 - 博客园 (cnblogs.com)</a></li></ul></blockquote><p>每个对象都有自己的“锁池”和“等待池”，用来存放线程。线程进入“锁池”，会处于竞争锁状态，当其他线程释放锁以后，才可能竞争到锁，然后执行同步块代码。线程进入”等待池“，会等待其他线程调用notify或者notifyAll方法，来进入“锁池”状态。</p><p>synchronized修饰的方法，在执行的时候，线程会被排序依次执行。这时，线程会被阻塞在对象的“锁池”中，只有一个线程会被执行。至于哪个线程被执行，需根据不同的虚拟机实现机制不同。</p><p>进入synchronized方法块的线程，会立即持有该对象的锁，并从“锁池”中移除。执行完毕，会释放锁，“锁池”中的线程依据一定规则会有一个线程依次执行该synchronized代码块。</p><p>进入synchronized代码块的线程，如果执行wait方法，就会释放改对象锁，该线程进入“等待池”，直到其他线程调用该对象的notify方法时，才有可能被唤醒继续执行后续代码，线程被唤醒以后，该线程从“等待池”中移除。</p><h1 id="Thread-run和Thread-start的区别"><a href="#Thread-run和Thread-start的区别" class="headerlink" title="Thread#run和Thread#start的区别"></a><code>Thread#run</code>和<code>Thread#start</code>的区别</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.cnblogs.com/renhui/p/6066750.html">Java Thread 的 run() 与 start() 的区别 - 灰色飘零 - 博客园 (cnblogs.com)</a></li></ul></blockquote><ol><li><p>调用<code>start</code>方法方可启动线程，而<code>run</code>方法只是<code>Thread</code>的一个普通方法调用，还是在主线程里执行。</p></li><li><p>把需要并行处理的代码放在<code>run</code>方法中，<code>start</code>方法启动线程将自动调用 <code>run</code>方法，这是由<code>JVM</code>的内存机制规定的。并且<code>run</code>方法必须是<code>public</code>访问权限，返回值类型为<code>void</code>。</p></li></ol><hr><h1 id="线程死锁，如何有效的避免线程死锁？"><a href="#线程死锁，如何有效的避免线程死锁？" class="headerlink" title="线程死锁，如何有效的避免线程死锁？"></a>线程死锁，如何有效的避免线程死锁？</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://developer.aliyun.com/article/763004">什么是线程死锁？形成条件是什么？如何避免？-阿里云开发者社区 (aliyun.com)</a></li></ul></blockquote><h2 id="什么是线程死锁"><a href="#什么是线程死锁" class="headerlink" title="什么是线程死锁"></a>什么是线程死锁</h2><p>死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/cff16df19c2ffe9621333dd219990df69664a007.png"></p><p>如上图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><h2 id="形成死锁的四个必要条件"><a href="#形成死锁的四个必要条件" class="headerlink" title="形成死锁的四个必要条件"></a>形成死锁的四个必要条件</h2><ol><li><strong>互斥条件：</strong> 线程(进程)对于所分配到的资源具有排它性，即一个资源只能被一个线程(进程)占用，直到被该线程(进程)释放。</li><li><strong>请求与保持条件：</strong> 一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</li><li><strong>不可剥夺条件：</strong> 线程(进程)已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li><strong>循环等待条件：</strong> 当发生死锁时，所等待的线程(进程)必定会形成一个环路（类似于死循环），造成永久阻塞。</li></ol><h2 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁"></a>如何避免线程死锁</h2><p>我们只要<strong>破坏产生死锁的四个条件中的其中一个就可以了</strong>。</p><ol><li><p><strong>破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p></li><li><p><strong>破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p></li><li><p><strong>破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p></li><li><p><strong>破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p></li></ol><hr><h1 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/qq_26545305/article/details/79516610">【多线程】如何保证线程安全_LemmonTreelss的博客-CSDN博客</a></li></ul></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20180315101631748.png" style="zoom: 80%;" /><ol><li><p>互斥同步</p><p>互斥同步是最常见的一种并发正确性保障手段。同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用（同一时刻，只有一个线程在操作共享数据）。</p><p>在java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码质量，这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。</p><p>此外，ReentrantLock 也是通过互斥来实现同步。在基本用法上，ReentrantLock 与 synchronized 很相似，他们都具备一样的线程重入特性。</p><p> 互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也成为阻塞同步。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确地同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁。</p></li><li><p>非阻塞同步 </p><p>随着硬件指令集的发展，出现了基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施。（最常见的补偿错误就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。</p><p>实现非阻塞同步的方式为CAS。</p></li></ol><h1 id="如何实现多线程中的同步"><a href="#如何实现多线程中的同步" class="headerlink" title="如何实现多线程中的同步"></a>如何实现多线程中的同步</h1><blockquote><p>  <strong>同步(synchronization)<strong>就是</strong>指一个线程访问数据时，其它线程不得对同一个数据进行访问，即同一时刻只能有一个线程访问该数据，当这一线程访问结束时其它线程才能对这它进行访问</strong> 。同步最常见的方式就是使用锁(Lock)，也称为<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E9%94%81&spm=1001.2101.3001.7020">线程锁</a>。锁是一种非强制机制，每一个线程在访问数据或资源之前，首先试图获取(Acquire)锁，并在访问结束之后释放(Release)锁。 <strong>在锁被占用时试图获取锁，线程会进入等待状态，直到锁被释放再次变为可用。</strong></p></blockquote><ul><li><p><strong>synchronized</strong></p></li><li><p><strong>Lock</strong></p></li></ul><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a><code>volatile</code></h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/138819184">volatile 关键字，你真的理解吗？ - 知乎 (zhihu.com)</a></li></ul></blockquote><h2 id="volatile-的作用"><a href="#volatile-的作用" class="headerlink" title="volatile 的作用"></a>volatile 的作用</h2><ul><li>保证了变量的内存可见性。</li><li>禁止指令的重排序。</li></ul><h2 id="Java-内存模型（JMM）"><a href="#Java-内存模型（JMM）" class="headerlink" title="Java 内存模型（JMM）"></a>Java 内存模型（JMM）</h2><p>JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读&#x2F;写共享变量的副本。</p><p><strong><font size="4">JMM 的规定：</font></strong></p><ul><li><p>所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p></li><li><p>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p></li><li><p>线程对变量的所有的操作（读，取）都必须在工作内存中完成，而不能直接读写主内存中的变量。</p></li><li><p>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</p></li></ul><p><strong><font size="4">JMM 的抽象示意图：</font></strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-3d312429710bd6a11eca171858f67751_720w.jpg" style="zoom:80%;" /><h2 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h2><p>内存可见性是指当一个线程修改了某个变量的值，其它线程总是能知道这个变量变化。</p><p>也就是说，如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。</p><h2 id="内存可见行的解决方案"><a href="#内存可见行的解决方案" class="headerlink" title="内存可见行的解决方案"></a>内存可见行的解决方案</h2><p>使用 <code>volatile</code> 关键字，或者加锁。</p><p><strong><font size="4">加锁</font></strong></p><blockquote><p>  <strong>为什么加锁后就保证了变量的内存可见性了？</strong></p></blockquote><p>因为当一个线程进入 <code>synchronized</code> 代码块后，线程获取到锁，会清空本地内存，然后从主内存中拷贝共享变量的最新值到本地内存作为副本，执行代码，又将修改后的副本值刷新到主内存中，最后线程释放锁。</p><p>这里除了 <code>synchronized</code> 外，其它锁也能保证变量的内存可见性。</p><p><strong><font size="4">使用 volatile 关键字</font></strong></p><p>使用 <code>volatile</code> 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，当线程操作变量副本并写回主内存后，会通过 <strong><code>CPU</code> 总线嗅探机制</strong>告知其他线程该变量副本已经失效，需要重新从主内存中读取。</p><p><code>volatile</code> 保证了不同线程对共享变量操作的可见性，也就是说一个线程修改了 <code>volatile</code> 修饰的变量，当修改后的变量写回主内存时，其他线程能立即看到最新值。</p><p><strong><font size="4">总结</font></strong></p><p>使用 <code>volatile</code> 和 <code>synchronized</code> 锁都可以保证共享变量的可见性。相比 <code>synchronized</code> 而言，<code>volatile</code> 可以看作是一个轻量级锁，所以使用 <code>volatile</code> 的成本更低，因为它不会引起线程上下文的切换和调度。</p><p>但 <code>volatile</code> 无法像 <code>synchronized</code> 一样保证操作的原子性。</p><h2 id="volatile-的原子性问题"><a href="#volatile-的原子性问题" class="headerlink" title="volatile 的原子性问题"></a><code>volatile</code> 的原子性问题</h2><blockquote><p>  原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。</p></blockquote><p>在多线程环境下，<code>volatile</code> 关键字可以保证共享数据的可见性，但是并不能保证对数据操作的原子性。也就是说，多线程环境下，使用 <code>volatile</code> 修饰的变量是<strong>线程不安全的</strong>。</p><p>要解决这个问题，我们可以使用锁机制，或者使用原子类（如 <code>AtomicInteger</code>）。</p><p>这里特别说一下，对任意单个使用 <code>volatile</code> 修饰的变量的读 &#x2F; 写是具有原子性，但类似于 <code>flag = !flag</code> 这种复合操作不具有原子性。简单地说就是，<strong>单纯的赋值操作是原子性的</strong>。</p><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><p>为了提高性能，在遵守 <code>as-if-serial</code> 语义（即不管怎么重排序，单线程下程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守。）的情况下，编译器和处理器常常会对指令做重排序。</p><p>一般重排序可以分为如下三种类型：</p><ul><li>编译器优化重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统重排序。由于处理器使用缓存和读 &#x2F; 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul> <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-8655d85c8a9df1bc2262485248b07d4d_720w.jpg" style="zoom: 80%;" /><h2 id="happen-before-原则"><a href="#happen-before-原则" class="headerlink" title="happen-before 原则"></a>happen-before 原则</h2><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p><p><strong><font size="4">单一线程原则</font></strong></p><blockquote><p>  Single Thread rule</p></blockquote><p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/874b3ff7-7c5c-4e7a-b8ab-a82a3e038d20.png" style="zoom: 67%;" /><p><strong><font size="4">管程锁定规则</font></strong></p><blockquote><p>  Monitor Lock Rule</p></blockquote><p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/8996a537-7c4a-4ec8-a3b7-7ef1798eae26.png" style="zoom:67%;" /><p><strong><font size="4">volatile 变量规则</font></strong></p><blockquote><p>  Volatile Variable Rule</p></blockquote><p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/942f33c9-8ad9-4987-836f-007de4c21de0.png" style="zoom:67%;" /><p><strong><font size="4">线程启动规则</font></strong></p><blockquote><p>  Thread Start Rule</p></blockquote><p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/6270c216-7ec0-4db7-94de-0003bce37cd2.png" style="zoom:67%;" /><p><strong><font size="4">线程加入规则</font></strong></p><blockquote><p>  Thread Join Rule</p></blockquote><p>Thread 对象的结束先行发生于 join() 方法返回。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/233f8d89-31d7-413f-9c02-042f19c46ba1.png" style="zoom:67%;" /><p><strong><font size="4">线程中断规则</font></strong></p><blockquote><p>  Thread Interruption Rule</p></blockquote><p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p><p><strong><font size="4">对象终结规则</font></strong></p><blockquote><p>  Finalizer Rule</p></blockquote><p>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p><p><strong><font size="4">传递性</font></strong></p><blockquote><p>  Transitivity</p></blockquote><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p><h1 id="synchronized和volatile的区别？"><a href="#synchronized和volatile的区别？" class="headerlink" title="synchronized和volatile的区别？"></a>synchronized和volatile的区别？</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/suifeng3051/article/details/52611233">volatile和synchronized的区别_Heaven-Wang的博客-CSDN博客_synchronized和volatile区别</a></li></ul></blockquote><ol><li><p>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p></li><li><p>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的</p></li><li><p>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性</p></li><li><p>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</p></li><li><p>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</p></li></ol><h1 id="为何不用volatile替代synchronized？"><a href="#为何不用volatile替代synchronized？" class="headerlink" title="为何不用volatile替代synchronized？"></a>为何不用volatile替代synchronized？</h1><p>因为 volatile 不能保证原子性，当有多个线程修改同一个变量时，例如++操作，无法保证线程同步。</p><hr><h1 id="synchronized和Lock的比较"><a href="#synchronized和Lock的比较" class="headerlink" title="synchronized和Lock的比较"></a>synchronized和Lock的比较</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/b343a9637f95">Synchronized和Lock的区别 - 简书 (jianshu.com)</a></li></ul></blockquote><p><strong>两种锁的底层实现</strong></p><blockquote><p>  Synchronized：底层使用指令码方式来控制锁的，映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当线程执行遇到monitorenter指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到monitorexit指令时锁计数器-1，如果计数器为0则释放锁。</p></blockquote><blockquote><p>  Lock：底层是CAS乐观锁，依赖AbstractQueuedSynchronizer类，把所有的请求线程构成一个CLH队列。而对该队列的操作均通过Lock-Free（CAS）操作。</p></blockquote><p><strong>两种锁的区别</strong></p><ol><li><p>Synchronized是关键字，内置语言实现，Lock是接口。</p></li><li><p>Synchronized在线程发生异常时会自动释放锁，因此不会发生异常死锁。Lock异常时不会自动释放锁，所以需要在finally中实现释放锁。</p></li><li><p>Lock是可以中断锁，Synchronized是非中断锁，必须等待线程执行完成释放锁。</p></li><li><p>Lock可以使用读锁提高多线程读效率。</p></li></ol><h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.cnblogs.com/qifengshi/p/6831055.html">Java中的锁分类 - byhieg - 博客园 (cnblogs.com)</a></li></ul></blockquote><h2 id="公平锁-x2F-非公平锁"><a href="#公平锁-x2F-非公平锁" class="headerlink" title="公平锁&#x2F;非公平锁"></a>公平锁&#x2F;非公平锁</h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁。<br>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。<br>对于Java <code>ReentrantLock</code>而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。<br>对于<code>Synchronized</code>而言，也是一种非公平锁。由于其并不像<code>ReentrantLock</code>是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</p><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。<br>对于Java <code>ReentrantLock</code>而言, 他的名字就可以看出是一个可重入锁，其名字是<code>Re entrant Lock</code>重新进入锁。<br>对于<code>Synchronized</code>而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setA</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>setB();<br>&#125;<br><br><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setB</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，<code>setB()</code> 可能不会被当前线程执行，可能造成死锁。</p><h2 id="独享锁-x2F-共享锁"><a href="#独享锁-x2F-共享锁" class="headerlink" title="独享锁&#x2F;共享锁"></a>独享锁&#x2F;共享锁</h2><p>独享锁是指该锁一次只能被一个线程所持有。</p><p>共享锁是指该锁可被多个线程所持有。</p><p>对于<code>Java</code> 的 <code>ReentrantLock</code>而言，其是独享锁。但是对于Lock的另一个实现类<code>ReadWriteLock</code>，其读锁是共享锁，其写锁是独享锁。</p><p>读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p><p>对于<code>Synchronized</code>而言，当然是独享锁。</p><h2 id="互斥锁-x2F-读写锁"><a href="#互斥锁-x2F-读写锁" class="headerlink" title="互斥锁&#x2F;读写锁"></a>互斥锁&#x2F;读写锁</h2><p>上面讲的独享锁&#x2F;共享锁就是一种广义的说法，互斥锁&#x2F;读写锁就是具体的实现。</p><p>互斥锁在Java中的具体实现就是<code>ReentrantLock</code>。</p><p>读写锁在Java中的具体实现就是<code>ReadWriteLock</code>。</p><h2 id="乐观锁-x2F-悲观锁"><a href="#乐观锁-x2F-悲观锁" class="headerlink" title="乐观锁&#x2F;悲观锁"></a>乐观锁&#x2F;悲观锁</h2><p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。</p><p>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。</p><p>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</p><p>从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。</p><p>悲观锁在Java中的使用，就是利用各种锁。</p><p>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</p><h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于<code>ConcurrentHashMap</code>而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p><p>我们以<code>ConcurrentHashMap</code>来说一下分段锁的含义以及设计思想，<code>ConcurrentHashMap</code>中的分段锁称为<code>Segment</code>，它即类似于<code>HashMap</code>（JDK7与JDK8中<code>HashMap</code>的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个<code>ReentrantLock</code>（<code>Segment</code>继承了<code>ReentrantLock</code>)。</p><p>当需要<code>put</code>元素的时候，并不是对整个<code>HashMap</code>进行加锁，而是先通过<code>hashcode</code>来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程<code>put</code>的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</p><p>但是，在统计<code>size</code>的时候，可就是获取<code>hashmap</code>全局信息的时候，就需要获取所有的分段锁才能统计。</p><p>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p><p>典型的自旋锁实现的例子，可以参考<a href="http://ifeve.com/java_lock_see1/">自旋锁的实现</a>。</p><h2 id="偏向锁-x2F-轻量级锁-x2F-重量级锁"><a href="#偏向锁-x2F-轻量级锁-x2F-重量级锁" class="headerlink" title="偏向锁&#x2F;轻量级锁&#x2F;重量级锁"></a>偏向锁&#x2F;轻量级锁&#x2F;重量级锁</h2><p>这三种锁是指锁的状态，并且是针对<code>Synchronized</code>。在Java 5通过引入锁升级的机制来实现高效<code>Synchronized</code>。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</p><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p><p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p><h1 id="锁的几种状态-x2F-JDK-1-6-对-synchronized-的优化"><a href="#锁的几种状态-x2F-JDK-1-6-对-synchronized-的优化" class="headerlink" title="锁的几种状态 &#x2F; JDK 1.6 对 synchronized 的优化"></a>锁的几种状态 &#x2F; JDK 1.6 对 synchronized 的优化</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/zmh458/article/details/93053867"> java中锁的四种状态_Hi-Sunshine的博客-CSDN博客</a></li></ul></blockquote><p>锁有四种状态：无锁状态、偏向锁、轻量级锁、重量级锁。具体细节可以参考上一个问题。</p><p>随着锁的竞争，锁的状态会从偏向锁到轻量级锁，再到重量级锁。而且锁的状态只有升级，没有降级。也就是只有偏向锁-&gt;轻量级锁-&gt;重量级锁，没有重量级锁-&gt;轻量级锁-&gt;偏向锁。</p><p>锁状态的改变是根据竞争激烈程度进行的，在几乎无竞争的条件下，会使用偏向锁，在轻度竞争的条件下，会由偏向锁升级为轻量级锁， 在重度竞争的情况下，会升级到重量级锁。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190620153844690.png" style="zoom: 80%;" /><hr><h1 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://github.com/LRH1993/android_interview/blob/master/java/concurrence/CAS.md">android_interview&#x2F;CAS.md at master · LRH1993&#x2F;android_interview (github.com)</a></li></ul></blockquote><p><strong>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。</strong></p><p>举个CAS操作的应用场景的一个例子，当一个线程需要修改共享变量的值。完成这个操作，先取出共享变量的值赋给A，然后基于A的基础进行计算，得到新值B，完了需要更新共享变量的值了，这个时候就可以调用CAS方法更新变量值了。</p><h2 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h2><p>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。</p><ol><li><p>ABA问题。</p><p>因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A－2B－3A。从Java1.5开始JDK的atomic包里提供了一个类 <code>AtomicStampedReference</code> 来解决ABA问题。这个类的 <code>compareAndSet</code> 方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p></li><li><p>循环时间长开销大。</p><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p></li><li><p>只能保证一个共享变量的原子操作。</p><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量<code>i＝2, j=a</code>，合并一下<code>i, j=2a</code>，然后用CAS来操作<code>i, j</code>。从Java1.5开始 JDK 提供了 <code>AtomicReference</code> 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。</p></li></ol><hr><h1 id="Java-线程池"><a href="#Java-线程池" class="headerlink" title="Java 线程池"></a>Java 线程池</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://github.com/LRH1993/android_interview/blob/master/java/concurrence/thread-pool.md">android_interview&#x2F;thread-pool.md at master · LRH1993&#x2F;android_interview (github.com)</a></li></ul></blockquote><h2 id="为什么Java用线程池"><a href="#为什么Java用线程池" class="headerlink" title="为什么Java用线程池"></a>为什么Java用线程池</h2><ol><li><p>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</p></li><li><p>提高系统响应速度，当有任务到达时，无需等待新线程的创建便能立即执行；</p></li><li><p>方便线程并发数的管控，线程若是无限制的创建，不仅会额外消耗大量系统资源，更是占用过多资源而阻塞系统或 OOM 等状况，从而降低系统的稳定性。线程池能有效管控线程，统一分配、调优，提供资源使用率；</p></li><li><p>更强大的功能，线程池提供了定时、定期以及可控线程数等功能的线程池，使用方便简单。</p></li></ol><h2 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h2><p>我们可以通过 <code>ThreadPoolExecutor</code> 来创建一个线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(....);<br></code></pre></td></tr></table></figure><p>下面我们就来看一下 <code>ThreadPoolExecutor</code> 中的一个构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">   <span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params"><span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params"><span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">TimeUnit unit,</span><br><span class="hljs-params">BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">ThreadFactory threadFactory,</span><br><span class="hljs-params">RejectedExecutionHandler handler</span><br><span class="hljs-params">)</span> <br></code></pre></td></tr></table></figure><h3 id="ThreadPoolExecutor-参数含义"><a href="#ThreadPoolExecutor-参数含义" class="headerlink" title="ThreadPoolExecutor 参数含义"></a><code>ThreadPoolExecutor</code> 参数含义</h3><p><strong>1. corePoolSize</strong></p><p>线程池中的核心线程数，默认情况下，核心线程一直存活在线程池中，即便他们在线程池中处于闲置状态。除非我们将ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这时候处于闲置的核心线程在等待新任务到来时会有超时策略，这个超时时间由keepAliveTime来指定。一旦超过所设置的超时时间，闲置的核心线程就会被终止。</p><p><strong>2. maximumPoolSize</strong></p><p>线程池中所容纳的最大线程数，如果活动的线程达到这个数值以后，后续的新任务将会被阻塞。包含核心线程数+非核心线程数。</p><p><strong>3. keepAliveTime</strong></p><p>非核心线程闲置时的超时时长，对于非核心线程，闲置时间超过这个时间，非核心线程就会被回收。只有对 ThreadPoolExecutor 的 allowCoreThreadTimeOut 属性设为 true 的时候，这个超时时间才会对核心线程产生效果。</p><p><strong>4. unit</strong></p><p>用于指定 <code>keepAliveTime</code> 参数的时间单位。他是一个枚举，可以使用的单位有七种：</p><table><thead><tr><th align="center">时间单位</th><th align="center">变量名</th></tr></thead><tbody><tr><td align="center">天</td><td align="center"><code>TimeUnit.DAYS</code></td></tr><tr><td align="center">小时</td><td align="center"><code>TimeUnit.HOURS</code></td></tr><tr><td align="center">分钟</td><td align="center"><code>TimeUnit.MINUTES</code></td></tr><tr><td align="center">秒</td><td align="center"><code>TimeUnit.SECONDS</code></td></tr><tr><td align="center">毫秒</td><td align="center"><code>TimeUnit.MILLISECONDS</code></td></tr><tr><td align="center">微秒(千分之一毫秒)</td><td align="center"><code>TimeUnit.MICROSECONDS</code></td></tr><tr><td align="center">毫微秒(千分之一微秒)</td><td align="center"><code>TimeUnit.NANOSECONDS</code></td></tr></tbody></table><p><strong>5. workQueue</strong></p><p>线程池中保存等待执行的任务的阻塞队列。通过线程池中的execute方法提交的Runable对象都会存储在该队列中。我们可以选择下面几个阻塞队列。</p><table><thead><tr><th>阻塞队列</th><th>说明</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>基于数组实现的有界的阻塞队列,该队列按照FIFO（先进先出）原则对队列中的元素进行排序。</td></tr><tr><td>LinkedBlockingQueue</td><td>基于链表实现的阻塞队列，该队列按照FIFO（先进先出）原则对队列中的元素进行排序。</td></tr><tr><td>SynchronousQueue</td><td>内部没有任何容量的阻塞队列。在它内部没有任何的缓存空间。对于 SynchronousQueue 中的数据元素只有当我们试着取走的时候才可能存在。</td></tr><tr><td>PriorityBlockingQueue</td><td>具有优先级的无限阻塞队列。</td></tr></tbody></table><p>我们还能够通过实现 BlockingQueue 接口来自定义我们所需要的阻塞队列。</p><p><strong>6. threadFactory</strong></p><p>线程工厂，为线程池提供新线程的创建。ThreadFactory是一个接口，里面只有一个newThread方法。 默认为DefaultThreadFactory类。</p><p><strong>7. handler</strong></p><p>是 RejectedExecutionHandler 对象，而 RejectedExecutionHandler 是一个接口，里面只有一个 rejectedExecution 方法。</p><p>当任务队列已满并且线程池中的活动线程已经达到所限定的最大值或者是无法成功执行任务，这时候 ThreadPoolExecutor 会调用 RejectedExecutionHandler 中的  rejectedExecution 方法。在 ThreadPoolExecutor 中有四个内部类实现了 RejectedExecutionHandler 接口。在线程池中它默认是 AbortPolicy ，在无法处理新任务时抛出 RejectedExecutionException 异常。</p><p>下面是在 ThreadPoolExecutor 中提供的四个可选值。</p><table><thead><tr><th>可选值</th><th>说明</th></tr></thead><tbody><tr><td>CallerRunsPolicy</td><td>只用调用者所在线程来运行任务。</td></tr><tr><td>AbortPolicy</td><td>直接抛出RejectedExecutionException异常。</td></tr><tr><td>DiscardPolicy</td><td>丢弃掉该任务，不进行处理。</td></tr><tr><td>DiscardOldestPolicy</td><td>丢弃队列里最近的一个任务，并执行当前任务。</td></tr></tbody></table><p>我们也可以通过实现RejectedExecutionHandler接口来自定义我们自己的handler。如记录日志或持久化不能处理的任务。</p><p><strong>创建用例</strong></p><p><code>OkHttp</code> 中线程池的创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">executorService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">0</span>, <br>    Integer.MAX_VALUE, <br>    <span class="hljs-number">60</span>, <br>    TimeUnit.SECONDS, <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;(), <br>    Util.threadFactory(<span class="hljs-string">&quot;OkHttp Dispatcher&quot;</span>, <span class="hljs-literal">false</span>)<br>);<br></code></pre></td></tr></table></figure><p>该线程池的核心线程数为 0，线程池最有能容纳 <code>Integer.MAX_VALUE</code> 个线程，且线程的空闲存活时间为 60s（可以理解为 okhttp 随时可以创建新的线程来满足需要。可以保证网络的 I&#x2F;O 任务有线程来处理，不被阻塞）。</p><h2 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h2><p>调用线程池的 <code>shutdown()</code> 或 <code>shutdownNow()</code> 方法来关闭线程池</p><p><code>shutdown</code>原理：将线程池状态设置成 <code>SHUTDOWN</code> 状态，然后中断所有没有正在执行任务的线程。</p><p><code>shutdownNow</code>原理：将线程池的状态设置成 <code>STOP</code> 状态，然后中断所有任务(包括正在执行的)的线程，并返回等待执行任务的列表。</p><h2 id="有几种线程池"><a href="#有几种线程池" class="headerlink" title="有几种线程池"></a>有几种线程池</h2><p>Java中四种具有不同功能常见的线程池。他们都是直接或者间接配置 ThreadPoolExecutor 来实现他们各自的功能。这四种线程池分别是</p><ol><li>newFixedThreadPool</li><li>newCachedThreadPool</li><li>newScheduledThreadPool</li><li>newSingleThreadExecutor</li></ol><p>这四个线程池可以通过Executors类获取。</p><hr><h1 id="Android-多线程通信"><a href="#Android-多线程通信" class="headerlink" title="Android 多线程通信"></a>Android 多线程通信</h1><ol><li><code>Handler</code> 机制</li><li><code>AsyncTask</code> 类</li></ol><hr><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ol><li>CLH 与 AQS</li><li>其他并发容器</li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>面试整理-2022</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Thread</tag>
      
      <tag>Lock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 内存模型、类加载以及垃圾回收</title>
    <link href="/posts/20ccf97165e3/"/>
    <url>/posts/20ccf97165e3/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM-的体系结构"><a href="#JVM-的体系结构" class="headerlink" title="JVM 的体系结构"></a><code>JVM</code> 的体系结构</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/102702428">十分钟带你了解JVM的结构体系 - 知乎 (zhihu.com)</a></li></ul></blockquote><p><code>JVM</code>的组成：</p><ul><li>类加载子系统 Class loader</li><li>运行时数据区</li><li>执行引擎</li></ul><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-f3141f2dd349b87c98543fbc9fc00495_720w.jpg"></p><hr><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><ul><li>负责加载 <code>class</code>文件(<code>class</code>文件在文件开头有特定的文件标识)，将 <code>class</code>文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构。</li><li><code>ClassLoader</code>只负责加载 <code>class</code>文件的加载，至于它是否可以运行，则由<code>Execution Engine</code>决定。</li></ul><p>在 Java 9 以前，一共有三种类加载器：</p><ul><li>启动类加载器（<b><code>BootStrap ClassLoader</code></b>）</li><li>扩展类加载器（<b><code>Extension ClassLoader</code></b>）</li><li>应用类加载器（<b><code>Application ClassLoader</code></b>）</li></ul><p>在 Java 9 之后，经过更改后变成了两种：</p><ul><li>启动类加载器</li><li>平台类加载器</li></ul><p>启动类加载器是所有类加载器的祖先，由 C++ 编程，没有对应的 Java 对象，因此在 Java 中用 <code>null</code> 来指代。</p><p>除了启动类加载器，其他的加载器都有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。</p><hr><h1 id="双亲委派机制及其优势"><a href="#双亲委派机制及其优势" class="headerlink" title="双亲委派机制及其优势"></a>双亲委派机制及其优势</h1><ul><li><p><strong>全盘负责：</strong> </p><p>当前线程的类加载器负责加载某个<code>Class</code>时，该<code>Class</code>所依赖的和引用的其他<code>Class</code>也将由该类加载器负责载入，除非显示使用<code>CLassLoader.loadClass()</code>指定类加载器来载入。</p></li><li><p><strong>父类委托：</strong> </p><p>先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。所以我们在开发中尽量不要使用与JDK相同的类（例如自定义一个<code>java.lang.System</code>类），因为父类加载器中已经有一份<code>java.lang.System</code>类了，它会直接将该类给程序使用，而你自定义的类压根就不会被加载。</p></li><li><p><strong>双亲委派模型：</strong></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中。</p><p>只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p></li><li><p><strong>双亲委派模型的工作流程：</strong></p><ol><li><p>当<code>AppClassLoader</code>加载一个<code>class</code>时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</p></li><li><p>当<code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrap ClassLoader</code>去完成。</p></li><li><p>如果<code>BootStrap ClassLoader</code>加载失败（例如在<code>$JAVA_HOME/jre/lib</code>里未查找到该<code>class</code>），会使用<code>ExtClassLoader</code>来尝试加载。</p></li><li><p>若<code>ExtClassLoader</code>也加载失败，则会使用<code>AppClassLoader</code>来加载，如果<code>AppClassLoader</code>也加载失败，则会报出异常<code>ClassNotFoundException</code>。</p></li></ol></li><li><p><strong>双亲委派模型的优势：</strong></p><ol><li>系统类防止内存中出现多份同样的字节码</li><li>保证<code>Java</code>程序安全稳定运行</li></ol></li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/408997874.png" alt="" style="zoom:67%;" /><hr><h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-205a2605346856d95aec826ed9263c03_720w.jpg"></p><h2 id="线程私有内存"><a href="#线程私有内存" class="headerlink" title="线程私有内存"></a>线程私有内存</h2><p><strong><font size="5">程序计数器(Program Counter Register)</font></strong></p><p>程序计数器可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。</p><p>字节码解释器工作是就是通过改变程序计数器的值来选取下一条需要执行的字节码指令（执行本地方法的时候，程序计数器的值为 <code>null</code>）。</p><p><strong>每条线程都需要有一个独立的程序计数器</strong>，各条的程序计数器互不影响，独立存储。</p><p>此内存区域是唯一一个没有规定任何 <code>OutOfMemoryError</code> 情况的区域。</p><p><strong><font size="5">Java 虚拟机栈(VM Stack)</font></strong></p><p>Java 虚拟机栈为虚拟机执行 Java 方法服务。</p><p><strong>Java 虚拟机栈的生命周期和线程相同。</strong></p><p>虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会在虚拟机栈中同步创建一个 <strong>栈帧</strong> 用于存储局部变量表、操作数栈、方法出口等信息。</p><p>每一个方法被调用直至执行完毕的过程，就对应这一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown">栈帧：<br><span class="hljs-bullet">1.</span> 局部变量表<br><span class="hljs-bullet">2.</span> 操作数栈<br><span class="hljs-bullet">3.</span> 动态链接<br><span class="hljs-bullet">4.</span> 方法出口<br><span class="hljs-bullet">5.</span> ... <br></code></pre></td></tr></table></figure><p><strong><font size="5">本地方法栈(Native Method Stack)</font></strong></p><p>本地方法栈为虚拟机使用本地<code>Native</code>方法服务。</p><h2 id="线程共享内存"><a href="#线程共享内存" class="headerlink" title="线程共享内存"></a>线程共享内存</h2><p><strong><font size="5">Java 堆(Java Heap)</font></strong></p><p>Java 堆是虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p><p><strong>此内存区域的唯一目的就是存放对象实例</strong>，Java 世界里“几乎”所有的对象实例都在这里分配内存。</p><p>Java 堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”。</p><p>Java 堆可以处于物理上不连续的内存空间中，但在逻辑上都连续存放。</p><p>从分配内存的角度看，所有线程共享的 Java 堆中可以划分出多个线程私有的分配缓冲区，以提升对象分配时的效率。无论如何划分，无论是那个区域，存储的都只能是对象的实例。</p><p><strong>Java 堆既可以实现成固定大小的，也可以是扩展的。</strong> 如果在 Java 堆中没有内存完成对象分配时，并且堆也无法再扩展时，Java 虚拟机将会抛出 <code>OutOfMemoryError</code> 异常。</p><p><strong><font size="5">方法区(Method Area)</font></strong></p><p>方法区与 Java 堆一样，是各个线程共享的内存区域，<strong>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</strong></p><p>如果方法区无法满足新的内存分配需求时，将抛出 <code>OutOfMemoryError</code> 异常。</p><p>在 JDK 1.8 之前，<code>HotSpot</code> 虚拟机把它当作永久代进行垃圾回收。</p><p>在 JDK 1.8 以后，移除永久代，并将永久代拆分至堆和元空间。元空间位于本地内存中，而不是虚拟机内存中，存储类的元数据；堆中则额外存放方法区的静态变量和常量池等。</p><p><strong><font size="4">运行时常量池(Runtime Constant Pool)</font></strong></p><p>运行时常量池是方法区的一部分。</p><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>除了 <strong>保存 Class 文件中描述的符号引用</strong> 外，还会把符号引用翻译出来的直接引用也存储再运行时常量池中。</p><p>运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</p><hr><h1 id="类加载机制的几个阶段"><a href="#类加载机制的几个阶段" class="headerlink" title="类加载机制的几个阶段"></a>类加载机制的几个阶段</h1><blockquote><p>  Java 语言的类型可以分为两个大类：基本类型和引用类型。</p><p>  其中的引用类型，Java 又将其细分为了四种：类、接口、数组类以及泛型参数。</p><p>  其中，泛型参数会在编译过程中被擦除，数组类则是由 Java 虚拟机直接在内存中动态构造出来的。所以我们只讨论类和接口的加载过程。</p></blockquote><p><strong>类的加载过程：</strong></p><p><code>JVM</code> 将 <code>javac</code> 编译好的<code>class</code>字节码文件加载到内存中，并对该数据进行验证、解析和初始化、形成<code>JVM</code>可以直接使用的<code>JAVA</code>类，最终回收(卸载)的过程。</p><p><strong>字节码（<code>.class</code>）文件来源：</strong></p><ul><li>从本地系统中直接加载</li><li>通过网络下载<code>.class</code>文件</li><li>从<code>zip</code>, <code>jar</code>等归档文件中加载<code>.class</code>文件</li><li>从专有数据库中提取<code>.class</code>文件</li><li>将<code>Java</code>源文件动态编译为<code>.class</code>文件</li></ul><hr><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/879896-20160414224549770-60006655.png" alt="" style="zoom:70%;" /><p><strong><font size="5">加载</font></strong></p><p>加载阶段是类加载的第一个部分，在此阶段需要完成三件事情：</p><ol><li>通过类的完全限定名找到该类对应的二进制字节流。</li><li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li><li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li></ol><p>对于非数组类的其他类而言，Java 虚拟机需要通过类加载器来完成查找字节流的过程。</p><p><strong><font size="5">验证</font></strong></p><p>验证阶段是连接阶段的第一步，目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p><strong><font size="5">准备</font></strong></p><p>准备阶段是正式为<b>类变量(类字段)</b>（即静态变量，被 <code>static</code> 修饰的变量）分配内存并设置类变量初始值的阶段。</p><p>这些变量所使用的内存都将在方法区中分配，只包括类变量。</p><p>初始值“通常情况”下是数据类型的零值。</p><p>“特殊情况”下，如果类字段的字段属性表中存在 <code>ConstantValue</code> 属性（即被 <code>final</code> 修饰的变量），那么在准备阶段变量的值就会被初始化为 <code>ConstantValue</code> 属性所指定的值。</p><p><strong><font size="5">解析</font></strong></p><p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>这个过程可以在初始化阶段之后进行。</p><p><strong><font size="5">初始化</font></strong></p><p>类加载过程中的最后一步。</p><p>初始化阶段是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。</p><p><code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。</p><p><code>&lt;clinit&gt;()</code> 与类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</p><p>如果一个类没有声明任何的类变量，也没有静态代码块，那么可以没有类<code>&lt;clinit&gt;</code>方法。</p><p><code>JVM</code> 必须确保一个类在初始化的过程中，如果是多线程需要同时初始化它，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程(所以<strong>可以利用静态内部类实现线程安全的单例模式</strong>)。</p><p><strong>简单地说，初始化就是对类变量进行赋值及执行静态代码块。</strong></p><p><strong><font size="5">使用</font></strong></p><p>程序使用 <code>JVM</code> 加载的类。</p><p><strong><font size="5">卸载</font></strong></p><p>触发卸载的五个时机：</p><ul><li>执行了 <code>System.exit()</code> 方法</li><li><code>JVM </code>垃圾回收机制触发回收</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><hr><h1 id="何时触发初始化"><a href="#何时触发初始化" class="headerlink" title="何时触发初始化"></a>何时触发初始化</h1><ol><li><p>遇到 <code>new</code>，<code>getstatic</code>，<code>putstatic</code> 或 <code>invokestatic</code> 这4条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。<br> 生成这4条指令的最常见的Java代码场景是：</p><ol><li>使用new关键字实例化对象的时候</li><li>读取或设置一个类的静态字段的时候</li><li>调用一个类的静态方法的时候</li></ol></li><li><p>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用的时候。</p></li><li><p>当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先出发父类的初始化。</p></li><li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 <code>main()</code> 方法的那个类），虚拟机会先初始化这个主类。</p></li></ol><hr><h1 id="对象实例化时的顺序"><a href="#对象实例化时的顺序" class="headerlink" title="对象实例化时的顺序"></a>对象实例化时的顺序</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/sc179/article/details/109779168">Java实例化对象时的初始化顺序_hellosc01的博客-CSDN博客</a></li></ul></blockquote><blockquote><p>   注：（A，B）表示A和B为同一阶段初始化，执行顺序取决于它们在代码中的顺序。</p></blockquote><p><strong><font size="5">无继承</font></strong></p><p>（静态变量，静态代码块）-&gt; （实例变量，普通代码块） -&gt; 构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">staticField</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;静态变量&quot;</span>;<br><br><span class="hljs-keyword">static</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;静态语句块&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;实例变量&quot;</span>;<br><br>&#123;<br>    System.out.println(<span class="hljs-string">&quot;普通语句块&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">InitialOrderTest</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;构造函数&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><font size="5">有继承</font></strong></p><ol><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ol><hr><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://time.geekbang.org/column/article/13091">11 | 垃圾回收（上） (geekbang.org)</a></li><li><a href="http://www.cyc2018.xyz/Java">Java 虚拟机 | CS-Notes (cyc2018.xyz)</a></li></ul></blockquote><h2 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h2><p><strong><font size="5">引用计数法</font></strong></p><p>它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。</p><p>它的具体实现是这样子的：如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。也就是说，我们<strong>需要截获所有的引用更新操作</strong>，并且相应地增减目标对象的引用计数器。</p><p>除了<strong>需要额外的空间来存储计数器</strong>，以及<strong>繁琐的更新操作</strong>，引用计数法还有一个重大的漏洞，那便是<strong>无法处理循环引用对象</strong>。举个例子，假设对象 a 与 b 相互引用，除此之外没有其他引用指向 a 或者 b。在这种情况下，a 和 b 实际上已经死了，但由于它们的引用计数器皆不为 0，在引用计数法的心中，这两个对象还活着。因此，这些循环引用对象所占据的空间将不可回收，从而造成了内存泄露。</p><p><strong><font size="5">可达性分析</font></strong></p><p>Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后<strong>从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中</strong>，这个过程我们也称之为标记（mark）。最终，<strong>未被探索到的对象便是死亡的，是可以回收的。</strong></p><p><strong><font size="4">GC Roots</font></strong></p><p>可以暂时理解为由堆外指向堆内的引用，一般而言，GC Roots 包括（但不限于）如下几种：</p><ul><li>Java 方法栈桢中的局部变量；</li><li>已加载类的静态变量；</li><li>JNI handles；</li><li>已启动且未停止的 Java 线程。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/83d909d2-3858-4fe1-8ff4-16471db0b180.png" alt="" style="zoom: 67%;" /><p>可达性分析可以解决引用计数法所不能解决的循环引用问题。</p><p>虽然可达性分析的算法本身很简明，但是在实践中还是有不少其他问题需要解决的。</p><p>比如说，在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成<strong>误报</strong>（将引用设置为 null）或者<strong>漏报</strong>（将引用设置为未被访问过的对象）。</p><p>误报并没有什么伤害，Java 虚拟机至多损失了部分垃圾回收的机会。漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 Java 虚拟机崩溃。</p><p>怎么解决这个问题呢？在 Java 虚拟机里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是 <strong>Stop-the-world</strong>，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了<strong>垃圾回收所谓的暂停时间（GC pause）</strong>。</p><h2 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h2><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p><p>主要是对常量池的回收和对类的卸载。</p><p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p><p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p><ul><li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>Class</code> 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ul><h2 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a><code>finalize</code>方法</h2><p>类似 C++ 的析构函数，<strong>用于关闭外部资源</strong>。但是 try-finally 等方式可以做得更好，并且该方法<strong>运行代价很高，不确定性大</strong>，无法保证各个对象的调用顺序，因此<strong>最好不要使用</strong>。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>判定对象是否可被回收都与引用有关。</p><ol><li><p>强引用</p><p>被强引用关联的对象不会被回收。</p><p>使用 <code>new</code> 一个新对象的方式来创建强引用。</p></li><li><p>软引用</p><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>使用 <code>SoftReference</code> 类来创建软引用。</p></li><li><p>弱引用</p><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>使用 <code>WeakReference</code> 类来创建弱引用。</p></li><li><p>虚引用</p><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p><p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p><p>使用 <code>PhantomReference</code> 来创建虚引用。</p></li></ol><h2 id="垃圾回收的三种方式"><a href="#垃圾回收的三种方式" class="headerlink" title="垃圾回收的三种方式"></a>垃圾回收的三种方式</h2><ol><li><p>标记-清除</p><p>即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。</p><p>缺点：</p><ul><li>会造成内存碎片。由于 Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。</li><li>分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/005b481b-502b-4e3f-985d-d043c2b330aa.png" alt="" style="zoom: 67%;" /></li><li><p>标记-整理（压缩）</p><p>即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但<strong>代价是压缩算法的性能开销</strong>。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ccd773a5-ad38-4022-895c-7ac318f31437.png" alt="" style="zoom:67%;" /></li><li><p>标记-复制</p><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p><p><strong>主要不足是只使用了内存的一半。</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png" alt="" style="zoom:67%;" /><blockquote><p>  现在的商业虚拟机都<strong>采用</strong>这种<strong>复制收集算法回收新生代</strong>，但是并不是划分为大小相等的两块，而是一块较大的 <code>Eden</code> 空间和两块较小的 <code>Survivor</code> 空间，每次使用 <code>Eden</code> 和其中一块 <code>Survivor</code>。在回收时，将 <code>Eden</code> 和 <code>Survivor</code> 中还存活着的对象全部复制到另一块 <code>Survivor</code> 上，最后清理 <code>Eden</code> 和使用过的那一块 <code>Survivor</code>。</p><p>  <code>HotSpot</code> 虚拟机的 <code>Eden</code> 和 <code>Survivor</code> 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 <code>Survivor</code> 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p></blockquote></li><li><p><strong>分代收集</strong></p><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p><p>一般将堆分为新生代和老年代。</p><ul><li>新生代使用：<strong>复制算法</strong></li><li>老年代使用：<strong>标记-清除</strong> 或者 <strong>标记-整理</strong> 算法</li></ul></li></ol><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" /><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。‘</p><p><strong><font size="4">基本概念</font></strong></p><ul><li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li><li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul><p>针对新生代的垃圾回收器共有三个：Serial，Parallel Scavenge 和 Parallel New。这三个采用的都是<strong>标记 - 复制</strong>算法。其中，Serial 是一个单线程的，Parallel New 可以看成 Serial 的多线程版本。Parallel Scavenge 和 Parallel New 类似，但更加注重吞吐率。此外，Parallel Scavenge 不能与 CMS 一起使用。</p><p>针对老年代的垃圾回收器也有三个：刚刚提到的 Serial Old 和 Parallel Old，以及 CMS。Serial Old 和 Parallel Old 都是<strong>标记 - 压缩</strong>算法。同样，前者是单线程的，而后者可以看成前者的多线程版本。</p><p>CMS 采用的是<strong>标记 - 清除</strong>算法，并且是并发的。除了少数几个操作需要 Stop-the-world 之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，Java 虚拟机会使用其他两个压缩型垃圾回收器进行一次垃圾回收。由于 G1 的出现，CMS 在 Java 9 中已被废弃。</p><p>G1（Garbage First）是一个横跨新生代和老年代的垃圾回收器。实际上，它已经打乱了前面所说的堆结构，直接将堆分成极其多个区域。每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。它采用的是<strong>标记 - 压缩</strong>算法，而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃圾回收。</p><p>G1 能够针对每个细分的区域来进行垃圾回收。<strong>在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。</strong> 这也是 G1 名字的由来。</p><hr><h1 id="回收策略和内存分配策略"><a href="#回收策略和内存分配策略" class="headerlink" title="回收策略和内存分配策略"></a>回收策略和内存分配策略</h1><p><strong><font size="4">Minor GC &amp; Full GC</font></strong></p><ul><li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li><li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li></ul><p><strong><font size="4">内存分配策略流程</font></strong></p><ol><li>一个人（对象）出来（new 出来）后会在Eden Space（伊甸园）无忧无虑的生活，直到GC到来打破了他们平静的生活。GC会逐一问清楚每个对象的情况，有没有钱（此对象的引用）啊，因为GC想赚钱呀，有钱的才可以敲诈嘛。然后富人就会进入Survivor Space（幸存者区），穷人的就直接kill掉。</li><li>并不是进入Survivor Space（幸存者区）后就保证人身是安全的，但至少可以活段时间。GC会定期（可以自定义）会对这些人进行敲诈，亿万富翁每次都给钱，GC很满意，就让其进入了Genured Gen(养老区)。万元户经不住几次敲诈就没钱了，GC看没有啥价值啦，就直接kill掉了。</li><li>进入到养老区的人基本就可以保证人身安全啦，但是亿万富豪有的也会挥霍成穷光蛋，只要钱没了，GC还是kill掉。</li></ol><p><strong><font size="4">内存分配策略总结</font></strong></p><ol><li><p>对象优先在 Eden 分配</p><p> 大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p></li><li><p>大对象直接进入老年代</p><p> 大对象是指<strong>需要连续内存空间的对象</strong>，最典型的大对象是那种<strong>很长的字符串以及数组</strong>。</p><p> 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p></li><li><p>长期存活的对象直接进入老年代</p><p> 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p><p> Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15，那么该对象将被晋升（promote）至老年代。</p></li><li><p>动态对象年龄判定</p><p> 另外，如果单个 Survivor 区已经被占用了 50%，那么较高复制次数的对象也会被晋升至老年代。</p></li><li><p>空间分配担保</p><p> 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。否则会继续判断其他条件，选择是否进行Full GC。</p></li></ol><p><strong><font size="4">GC 触发条件</font></strong></p><p>对于 Minor GC，其触发条件非常简单，<strong>当 Eden 空间满时，就将触发一次 Minor GC。</strong> 而 Full GC 则相对复杂，有以下条件：</p><ol><li><p>调用 <code>System.gc()</code></p><p> 只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p></li><li><p>老年代空间不足</p><p> 老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p></li><li><p>空间分配担保失败</p><p> 使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。（可参考上文“内存分配策略总结”第5点。）</p></li><li><p>Concurrent Mode Failure</p><p> 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。（可参考上文“垃圾收集器”部分。）</p></li></ol><hr><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ol><li>JVM中synchronized的实现</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试整理-2022</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM Class Loader</tag>
      
      <tag>JVM Garbage Collection</tag>
      
      <tag>JVM Data Area</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android面试整理-设计模式</title>
    <link href="/posts/ad1cccdb201a/"/>
    <url>/posts/ad1cccdb201a/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式 | 菜鸟教程 (runoob.com)</a></li><li><a href="https://blog.csdn.net/hongyinanhai00/article/details/113971787">DCL之单例模式_浦江之猿的博客-CSDN博客_dcl单例模式</a></li><li>《Android源码设计模式解析与实战》</li></ul></blockquote><p><strong>意图：</strong> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>关键代码：</strong> 构造函数是私有的。</p><p><strong>优点：</strong></p><ol><li><p>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</p></li><li><p>避免对资源的多重占用（比如写文件操作）。</p></li></ol><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><ol><li><p>饿汉式</p><p>优点：没有加锁，执行效率会提高。<br>缺点：类加载时就初始化，浪费内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span> <span class="hljs-params">()</span>&#123;&#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> instance;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>DCL</p><p>优点：资源利用率高。</p><p>缺点：第一次加载的时候反应稍慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton singleton;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span> <span class="hljs-params">()</span> &#123;&#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getSingleton</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;  <br>                <span class="hljs-keyword">if</span> (singleton == <span class="hljs-literal">null</span>) &#123;  <br>                    singleton = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <br>                &#125;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> singleton;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>volatile</code>是为了防止指令重排序问题，避免第8行代码被分配了控件但是值为<code>null</code>的情况。</p><p>两次 if 语句的作用：</p><ul><li><p>第一个 if 语句</p><p>防止在变量实例化后仍有线程获取锁，造成性能的开销。</p></li><li><p>第二个 if 语句</p><p>防止变量的重复实例化。</p></li></ul></li><li><p>静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.instance;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonHolder</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一次加载<code>Singleton</code>类的时候并不会初始化<code>instance</code>，只有在第一次调用<code>Singleton.getInstance</code>方法时才会初始化<code>instance</code>。因此第一次调用<code>getInstance</code>方法时也会导致虚拟机加载<code>SingletonHolder</code>类，这种方式不仅确保了线程安全，也能够保证单例模式对象的唯一性，同时也延迟了单例的实例化。</p></li></ol><h2 id="Android源码中的单例模式"><a href="#Android源码中的单例模式" class="headerlink" title="Android源码中的单例模式"></a>Android源码中的单例模式</h2><p><strong><code>LayoutInflater</code>类</strong>。</p><p>在<code>ContextImpl</code>类中，<code>LayoutInflater</code>的获取被写进了该类的<code>static&#123;&#125;</code>，即静态语句块中。表示了只有在该类被加载的时候才会被执行一次且只会执行一次，保证了实例的唯一性。</p><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.runoob.com/design-pattern/builder-pattern.html">建造者模式 | 菜鸟教程 (runoob.com)</a></li><li><a href="https://www.runoob.com/w3cnote/builder-pattern-2.html">设计模式：Builder模式 | 菜鸟教程 (runoob.com)</a></li></ul></blockquote><p><strong>意图：</strong> 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>何时使用：</strong> 一些基本部件不会变，而其组合经常变化的时候。</p><p><strong>优点：</strong> </p><ol><li><p>建造者独立，易扩展。</p></li><li><p>便于控制细节风险。</p></li></ol><p><strong>缺点：</strong> 产品必须有共同点，范围有限制。</p><p><strong>注意事项：</strong> 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p><p><strong>用例：</strong></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/1157683-20180626180216963-8235726.png"></p><p>调用者不需要知道<code>Director</code>类中方法的具体实现，而<code>Director</code>类同样也不需要知道<code>Builder</code>类中的具体实现。</p><p>当我们需求发生变动时，只需要单独修改<code>Director</code>或者<code>Builder</code>类的内部细节即可，不会影响到其他类的实现。</p><h2 id="Android中的建造者模式"><a href="#Android中的建造者模式" class="headerlink" title="Android中的建造者模式"></a>Android中的建造者模式</h2><ol><li><code>Java</code>的<code>StringBuilder</code>。</li><li><code>OkHttp</code>中的<code>OkHttpClient</code>。</li><li><code>Android</code>中的<code>AlterDialog</code>。</li></ol><hr><h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html">责任链模式 | 菜鸟教程 (runoob.com)</a></li></ul></blockquote><p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p><p><strong>意图：</strong> 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><p><strong>主要解决：</strong> 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><p><strong>何时使用：</strong> 在处理消息的时候需要过滤很多道。</p><p><strong>优点：</strong> </p><ol><li><p>降低耦合度。它将请求的发送者和接收者解耦。 </p></li><li><p>简化了对象。使得对象不需要知道链的结构。 </p></li><li><p>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 </p></li><li><p>增加新的请求处理类很方便。</p></li></ol><p><strong>缺点：</strong></p><ol><li><p>不能保证请求一定被接收。 </p></li><li><p>系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 </p></li><li><p>可能不容易观察运行时的特征，有碍于除错。</p></li></ol><h2 id="Android中类似责任链模式的使用"><a href="#Android中类似责任链模式的使用" class="headerlink" title="Android中类似责任链模式的使用"></a>Android中类似责任链模式的使用</h2><ol><li><code>OkHttp</code>的拦截器。</li><li>View事件分发的<code>dispatchTouchEvent</code>以及<code>dispatchTransformedTouchEvent</code>方法。</li></ol><hr><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/ec399a25e9d4">Android 观察者模式 - 简书 (jianshu.com)</a></li><li><a href="https://blog.csdn.net/niuzhijun66/article/details/80328642">RecyclerView中的观察者模式_niuzhijun66的博客-CSDN博客</a></li></ul></blockquote><p>定义一个被观察者和多个观察者，每当被观察者变化，所有观察者都会得到通知。</p><p><strong>要点：</strong> P用一个list把观察者保存起来，并提供add和remove观察者，在被观察者变化的时候就遍历并调用list里观察者的方法。<strong>核心就是一个list遍历</strong>。</p><p><strong>优点：</strong></p><ol><li><p>观察者和被观察者解耦  </p></li><li><p>增强灵活性，解耦</p></li></ol><p> <strong>缺点：</strong> 由于java代码的顺序执行，要考虑被察者的执行效率，多个观察者需要及时响应就得考虑异步的问题了。</p><h2 id="Android源码中的观察者模式"><a href="#Android源码中的观察者模式" class="headerlink" title="Android源码中的观察者模式"></a>Android源码中的观察者模式</h2><ol><li><p><code>RecyclerView</code>的<code>notifyDataChanged</code>方法。</p><p>当数据集发生变化，调用RecyclerView.Adapter的notifyDataSetChanged()时，发生变化的地方就会刷新，这个过程就涉及到了Java中的观察者模式。</p><p>在RecyclerView的使用中，最重要的两个类应该就是RecyclerView和RecyclerView.Adapter了。</p><p>RecyclerView内部维持了一个Observer(RecyclerViewDataObserver)。</p><p>Adapter内部维持了一个Observable(AdapterDataObservable)。</p><p>我们调用setAdapter(Adapter adapter)时，Adapter内的Observable会持有RecyclerView内部的Observer；当调用notifyDataSetChanged()时，Observable持有的Observer会依次调用onChanged()方法，而RecyclerView持有的Observer的onChanged()方法中实现了UI刷新。</p></li></ol><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220526214753683.png"/>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>面试整理-2022</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单例模式</tag>
      
      <tag>责任链模式</tag>
      
      <tag>建造者模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVC MVP MVVM 分别是什么？</title>
    <link href="/posts/02e5ea5a6473/"/>
    <url>/posts/02e5ea5a6473/</url>
    
    <content type="html"><![CDATA[<h1 id="MVC及其优缺点"><a href="#MVC及其优缺点" class="headerlink" title="MVC及其优缺点"></a><code>MVC</code>及其优缺点</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/sunforraining/article/details/79015080">MVC的理解和优缺点的总结_sunforraining的博客-CSDN博客_mvc的缺点</a></li><li><a href="https://zhuanlan.zhihu.com/p/35680070">深入理解MVC - 知乎 (zhihu.com)</a></li></ul></blockquote><p><strong><font size="5">概念</font></strong></p><p>MVC全名是Model-View-Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-30f72a70d6d84065d2147754bf2ad59f_1440w.jpg" alt="MVC" style="zoom: 50%;" /><p> MVC开始是存在于桌面程序中的，M是指业务模型，V是指用户界面，C则是控制器，使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。C存在的目的则是确保M和V的同步，一旦M改变，V应该同步更新。更好的调节M和V的搭配。</p><p> MVC是一种框架模式，说到底是一种框架，而不是一种设计模式，框架通常是代码重用，而设计模式是设计重用，而架构则介于两者之间，部分代码重用，部分设计重用，有时分析也可重用。</p><p><strong><font size="5">优点</font></strong></p><p>分层，结构清晰，耦合性低，大型项目代码的复用性得到极大的提高，开发人员分工明确，提高了开发的效率，维护方便，降低了维护成本。</p><p><strong><font size="5">缺点</font></strong></p><p>简单的小型项目，使用MVC设计反而会降低开发效率，层和层虽然相互分离，但是之间关联性太强，没有做到独立的重用。</p><h1 id="MVP及其优缺点"><a href="#MVP及其优缺点" class="headerlink" title="MVP及其优缺点"></a><code>MVP</code>及其优缺点</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://juejin.cn/post/6844903752588066830">MVP 与 MVVM 优缺点总结 - 掘金 (juejin.cn)</a></li></ul></blockquote><p><strong><font size="5">概念</font></strong></p><p>实际上按照代码在 App 中所处位置，描述为 VPM 更合适，即 View -&gt; Presenter -&gt; Model：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/4/16818bbae077f9e3~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="MVP"></p><p>这个架构的核心就是 View 与 Presenter 都被抽象成了接口，是面向接口编程的一个实践。因为面向接口，所以实现了依赖隔离，即无需知道具体的 Class 类型。</p><p><strong><font size="5">优点</font></strong></p><ol><li><strong>模块职责划分明显</strong>,层次清晰,接口功能清晰，遵循了单一职责类的设计原则，提升了代码的可维护性.</li><li><strong>降低耦合度</strong>，Model层和View层分离,解耦.修改View而不影响Model.</li><li><strong>功能复用度高</strong>,方便.一个Presenter可以复用于多个View,而不用更改Presenter的逻辑.</li><li><strong>有利于测试驱动开发</strong>,以前的Android开发是难以进行单元测试.</li><li><strong>代码灵活性</strong>，如果后台接口还未写好,但已知返回数据类型的情况下,完全可以写出此接口完整的功能.</li></ol><p><strong><font size="5">缺点</font></strong></p><ol><li>其实这并不是 MVP 架构的痛点，而是整个 Android App 开发的痛点，那就是对 UI 的操作必须在 Activity 与 Fragment 的生命周期之内，更细致一点，最好在 <code>onStart()</code> 之后 <code>onPause()</code>之前，否则极其容易出现各种异常。而 MVP 架构中，Presenter 对 Activity 与 Fragment 的生命周期是无感知的，所以我们需要手动添加相应的生命周期方法，并进行特殊处理，以避免出现异常或内存泄露。</li><li>MVP中接口过多.</li><li>每一个功能,相比于MVC要多写好几个文件.</li><li>如果某一个界面中需要请求多个服务器接口,这个界面文件中会实现很多的回调接口,导致代码繁杂.</li><li>如果更改了数据源和请求中参数,会导致更多的代码修改.<br>额外的代码复杂度及学习成本.</li><li>由于对视图的渲染放在了Presenter中，所以视图和Presenter的交互会过于频繁。还有一点需要明白，如果Presenter过多地渲染了视图，往往会使得它与特定的视图的联系过于紧密。一旦视图需要变更，那么Presenter也需要变更了。</li></ol><h1 id="MVVM及其优缺点"><a href="#MVVM及其优缺点" class="headerlink" title="MVVM及其优缺点"></a><code>MVVM</code>及其优缺点</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://juejin.cn/post/6844903752588066830">MVP 与 MVVM 优缺点总结 - 掘金 (juejin.cn)</a></li></ul></blockquote><p><strong><font size="5">概念</font></strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/254216d2594c43b3813739c5d0ecf0cd.png" alt="MVVM" style="zoom:67%;" /><p>View可以独立于Model变化和修改，一个ViewModel可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p><p>在MVVM中，数据是核心，由于ViewModel与View之间的双向绑定，操作了ViewModel中的数据，就会同步到DOM，我们透过DOM事件监控用户对DOM的改动，也会同步到ViewModel。</p><p>MVVM 架构相对复杂，核心是 LifecycleOwner、LifecycleObserver、LifecycleRegistry 组件，在此之上，Google 还开发了 DataBinding、ViewModel、LiveData 以实现完整的 MVVM 架构。相关组件已收纳至 <a href="https://link.juejin.cn/?target=https://developer.android.google.cn/jetpack/arch/">JetPack Architecture</a> 中。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/16818b1814a8a3f8.png" alt="MVVM"></p><p>这个架构的核心就是 ViewModel 和 LiveData。ViewModel 的作用是保证当设备因配置改变而重新创建 FragmentActivity(目前 ViewModel 仅支持 FragmentActivity 和 Fragment) 时，数据也不会丢失。LiveData 的作用是保证只在 FragmentActivity 或 Fragment 的生命周期状态为 [onStarted, onResumed] 时，回调 onChanged(T data)，所以我们可以在 onChanged() 中安全的更新 UI。下面简单介绍源码中是如何实现的：</p><p><strong><font size="5">优点</font></strong></p><ul><li><p>ViewModel：因设备配置改变导致 Activity 重建时，无需从 Model 中再次加载数据，减少了 IO 操作</p></li><li><p>LiveData：更新 UI 时，不用再关注生命周期问题</p></li><li><p>Data Binding： 可以有效减少模板代码的编写，而且目前已经支持双向绑定 (注意：不是所有的 UI 都需要使用 Data Binding，虽然通过 @BindingAdapter 我们真的可以“为所欲为”，最好还是只用于需要绑定 Bean 类的布局)</p></li></ul><p><strong><font size="5">缺点</font></strong></p><ul><li>LiveData 本身是没有 public 方法的，所以我们应该使用其子类 MutableLiveData。这样设计，我们就可以在 Model 中使用 MutableLiveData，在 ViewModel 中，只对 View 提供 LiveData，避免 View 去更新 LiveData。</li></ul><h1 id="MVP如何防止内存泄漏"><a href="#MVP如何防止内存泄漏" class="headerlink" title="MVP如何防止内存泄漏"></a><code>MVP</code>如何防止内存泄漏</h1><ul><li><p>在<code>BasePresenter</code>中使用对<code>View</code>的弱引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasePresenter</span>&lt;M <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseModel</span>, V <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseView</span>, CONTRACT&gt; &#123;<br>    <span class="hljs-keyword">protected</span> M m;<br>    <span class="hljs-keyword">protected</span> WeakReference&lt;V&gt; weakReference;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BasePresenter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.m = getModel();<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bindView</span><span class="hljs-params">(V v)</span> &#123;<br>        weakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(v);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unbindView</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (weakReference != <span class="hljs-literal">null</span>) &#123;<br>            weakReference.clear();<br>            weakReference = <span class="hljs-literal">null</span>;<br>            System.gc();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> V <span class="hljs-title function_">getView</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (weakReference != <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> weakReference.get();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> CONTRACT <span class="hljs-title function_">getContract</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> M <span class="hljs-title function_">getModel</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在<code>BaseView</code>中<code>onCreate</code>和<code>onDestory</code>方法中主动绑定和解绑<code>Presenter</code>，防止内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseView</span>&lt;P <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BasePresenter</span>, CONTRACT&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Activity</span> &#123;<br>    <span class="hljs-keyword">protected</span> P p;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        p = getPresenter();<br>        p.bindView(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>        p.unbindView();<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> P <span class="hljs-title function_">getPresenter</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> CONTRACT <span class="hljs-title function_">getContract</span><span class="hljs-params">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ol><li>MVP如何管理Presenter的生命周期，何时取消网络请求</li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>面试整理-2022</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MVC</tag>
      
      <tag>MVP</tag>
      
      <tag>MVVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Service 简单介绍</title>
    <link href="/posts/60d6ebb66cb6/"/>
    <url>/posts/60d6ebb66cb6/</url>
    
    <content type="html"><![CDATA[<h1 id="Service-的生命周期，两种启动方式的区别"><a href="#Service-的生命周期，两种启动方式的区别" class="headerlink" title="Service 的生命周期，两种启动方式的区别"></a><code>Service</code> 的生命周期，两种启动方式的区别</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.cnblogs.com/jisheng/archive/2011/12/13/2286262.html">Service生命周期 - Hecker385 - 博客园 (cnblogs.com)</a></li><li><a href="https://www.cnblogs.com/Lwenlong/p/15939996.html">Android面试——Service篇 - 向着内核前进！ - 博客园 (cnblogs.com)</a></li><li><a href="https://www.jianshu.com/p/a58780595d2b">Service-服务(一)生命周期及使用方式 - 简书 (jianshu.com)</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/15821503-f7f98e2e43fa178b.png" alt="Service 生命周期"></p><h2 id="使用context-startService-启动Service"><a href="#使用context-startService-启动Service" class="headerlink" title="使用context.startService 启动Service"></a><strong>使用<code>context.startService</code> 启动<code>Service</code></strong></h2><p>其生命周期为 <em>context.startService()</em> -&gt; <code>onCreate()</code>- &gt; <code>onStartCommand()</code>-&gt; <strong>Service</strong> <strong>running</strong> -&gt; <em>context.stopService()</em> | -&gt; <code>onDestroy()</code> -&gt; <strong>Service</strong> <strong>stop</strong></p><ol><li>如果<code>Service</code>还没有运行，则<code>Android</code>先调用<code>onCreate()</code>然后调用onStart()；</li><li>如果<code>Service</code>已经运行，则只调用<code>onStartCommand()</code>，所以一个<code>Service</code>的<code>onStartCommand</code>方法可能会重复调用多次。</li></ol><p><code>stopService</code>的时候直接<code>onDestroy</code>，如果是调用者自己直接退出而没有调用<code>stopService</code>的话，<code>Service</code>会一直在后台运行。该Service的调用者再启动起来后可以通过<code>stopService</code>关闭<code>Service</code>。</p><p>**所以调用<code>startService</code>的生命周期为：<code>onCreate</code> –&gt; <code>onStartCommand</code>(可多次调用) –&gt; <code>onDestroy</code>**。 </p><h2 id="对于bindService启动Service会经历："><a href="#对于bindService启动Service会经历：" class="headerlink" title="对于bindService启动Service会经历："></a><strong>对于<code>bindService</code>启动<code>Service</code>会经历：</strong></h2><p><em>context.bindService()</em> -&gt; <code>onCreate()</code>-&gt; <code>onBind()</code> -&gt;<strong>Service running</strong> -&gt; <code>onUnbind()</code> -&gt; <code>onDestroy()</code> -&gt; <strong>Service stop</strong></p><p><code>onBind</code>将返回给客户端一个<code>IBind</code>接口实例，<code>IBind</code>允许客户端回调服务的方法，比如得到<code>Service</code>运行的状态或其他操作。</p><p>这个时候把调用者（<code>Context</code>，例如<code>Activity</code>）会和<code>Service</code>绑定在一起，<code>Context</code>退出了，<code>Srevice</code>就会调用<code>onUnbind</code> -&gt; <code>onDestroy</code>相应退出。</p><p><strong>所以调用<code>bindService</code>的生命周期为：<code>onCreate</code> –&gt; <code>onBind</code>(只一次，不可多次绑定) –&gt; <code>onUnbind</code> –&gt; <code>onDestory</code>。</strong></p><p>一但销毁<code>activity</code>它就结束，如果按<code>home</code>把它放到后台，那他就不退出。</p><p> <strong><font size="4">补充</font></strong> </p><p>在 Service 每一次的开启关闭过程中，只有<code>onStartCommand</code>可被多次调用(通过多次<code>startService</code>调用)，<br>其他<code>onCreate</code>，<code>onBind</code>，<code>onUnbind</code>，<code>onDestory</code>在一个生命周期中只能被调用一次。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>面试整理-2022</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Service</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BroadcastReceiver 简单介绍</title>
    <link href="/posts/4c8cd102d397/"/>
    <url>/posts/4c8cd102d397/</url>
    
    <content type="html"><![CDATA[<h1 id="广播的分类和使用场景"><a href="#广播的分类和使用场景" class="headerlink" title="广播的分类和使用场景"></a>广播的分类和使用场景</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.cnblogs.com/Lwenlong/p/15940123.html">Android面试——BroadcastReceiver篇 - 向着内核前进！ - 博客园 (cnblogs.com)</a></li></ul></blockquote><p> <strong><font size="4">分类</font></strong></p><ol><li><p>普通广播：通过 <code>Context#sendBroadcast</code> 发送，可并行处理</p></li><li><p>系统广播：系统发送的广播，只需要注册广播接收器，并定义好action等待接收广播</p></li><li><p>有序广播：发出的广播会被接收器按照先后顺序进行接收，发送方式为sendOrderedBroadcast(intent)； 广播接受者接收的顺序规则：按照Priority属性值排序，Priority相同者，动态注册的广播优先；</p></li><li><p>APP 应用内广播（Local Broadcast）：由于广播可以跨进程的特性，导致应用可能不断收到来自其他应用的广播，或者别的应用接收到当前应用的私密广播；解决方法为使用应用内广播；也称局部广播，接收者和发送者同属于一个 APP。</p></li></ol><p> <strong><font size="4">使用方法</font></strong> </p><ul><li><p>方法1：注册广播时设置 exported 属性为 false；在广播发送接收时，增加权限，用于权限验证；发送广播时执行广播接收器的包名</p></li><li><p>方法2：使用封装好的 LocalBroadcastManager，这种方式的广播只能动态注册，不能静态注册</p></li></ul><p> <strong><font size="4">使用场景</font></strong> </p><ul><li><p>同一 App 内部的不同组件之间的消息通信（单个进程）；</p></li><li><p>不同 App 之间的组件之间消息通信；</p></li><li><p>Android 系统在特定情况下与 App 之间的消息通信，如：网络变化、电池电量、屏幕开关等；</p></li></ul><hr><h1 id="广播的两种注册方式的区别"><a href="#广播的两种注册方式的区别" class="headerlink" title="广播的两种注册方式的区别"></a>广播的两种注册方式的区别</h1><ul><li><p>静态注册</p><p>常驻系统，不受组件生命周期影响，即便应用退出，广播还是可以被接收，耗电、占内存。</p></li><li><p>动态注册</p><p>非常驻，跟随组件的生命变化，组件结束，广播结束。在组件结束前，需要先移除广播，否则容易造成内存泄漏。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>面试整理-2022</category>
      
    </categories>
    
    
    <tags>
      
      <tag>BroadcastReceiver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Activity 知识点快问快答</title>
    <link href="/posts/c221e751d218/"/>
    <url>/posts/c221e751d218/</url>
    
    <content type="html"><![CDATA[<h1 id="Activity的启动流程"><a href="#Activity的启动流程" class="headerlink" title="Activity的启动流程"></a><code>Activity</code>的启动流程</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/cpcpcp123/article/details/122055099">面试：Activity的启动流程简述_沙漠一只雕得儿得儿的博客-CSDN博客_activity启动流程面试</a></li><li><a href="https://www.jianshu.com/p/6c55c169ba54">Android 系统启动 - SystemServer 进程 - 简书 (jianshu.com)</a></li></ul></blockquote><p>大致为以下过程：</p><ol><li><code>Launcher</code> 通过 <code>startActivity</code> 方法调用 <code>AMS</code>。</li><li><code>AMS</code> 向 <code>Zygote</code> 进程发送创建应用进程的请求。</li><li><code>Zygote</code> 进程接受请求并在 <code>main</code> 方法中孵化应用进程。</li><li>应用进程通过<code>SystemServer#main</code>启动<code>ActivityThread</code>。</li><li><code>Activity</code>的入口是<code>ActivityThread</code>的<code>main</code>函数，在<code>main</code>函数中创建一个新的<code>ActivityThread</code>对象，开启消息循环(UI线程)后创建新的<code>Activity</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SystemServer#main</span><br>    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemServer</span>().run();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    ···<br>    <span class="hljs-comment">// Ensure binder calls into the system always run at foreground priority.</span><br>    <span class="hljs-comment">// 确保当前进程的 binder 调用总是运行在前台优先级</span><br>    BinderInternal.disableBackgroundScheduling(<span class="hljs-literal">true</span>);<br>    ···<br>    <span class="hljs-comment">// 创建主线程 Looper</span><br>    Looper.prepareMainLooper();<br><br>    <span class="hljs-comment">// Initialize native services.</span><br>    <span class="hljs-comment">// 加载android_servers.so库，该库包含的源码在frameworks/base/services/目录下</span><br>    System.loadLibrary(<span class="hljs-string">&quot;android_servers&quot;</span>);<br>    ···<br>    <span class="hljs-comment">// Initialize the system context.</span><br>    <span class="hljs-comment">// 初始化系统上下文</span><br>    createSystemContext();<br><br>    <span class="hljs-comment">// Create the system service manager.</span><br>    <span class="hljs-comment">//创建系统服务管理</span><br>    mSystemServiceManager = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemServiceManager</span>(mSystemContext);<br>    <span class="hljs-comment">// 将mSystemServiceManager添加到本地服务的成员sLocalServiceObjects</span><br>    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);<br><br>    <span class="hljs-comment">// Start services.</span><br>    <span class="hljs-comment">//  启动各种系统服务</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        startBootstrapServices(); <span class="hljs-comment">// 启动引导服务</span><br>        startCoreServices();      <span class="hljs-comment">// 启动核心服务</span><br>        startOtherServices();     <span class="hljs-comment">// 启动其他服务</span><br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        ···<br>    &#125;<br>    ···<br>    <span class="hljs-comment">// Loop forever.</span><br>    <span class="hljs-comment">// 启动 Looper 循环</span><br>    Looper.loop();<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Main thread loop unexpectedly exited&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="onSaveInstanceState和onRestoreInstanceState的调用时机"><a href="#onSaveInstanceState和onRestoreInstanceState的调用时机" class="headerlink" title="onSaveInstanceState和onRestoreInstanceState的调用时机"></a><code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>的调用时机</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/cpcpcp123/article/details/113396301">Android onSaveInstanceState和onRestoreInstanceState调用时机、及大小限制_沙漠一只雕得儿得儿的博客-CSDN博客_onsaveinstancestate</a></li></ul></blockquote><p><strong><font size = "5">onSaveInstanceState(Bundle outState)</font></strong></p><p>当 Activity 在不正常销毁的情况下，就会调用 onSaveInstanceState 方法，并将 Activity 中需要保存的数据（比如 View 状态 或者我们自己的数据）保存到这个方法的参数 Bundle 中。</p><p><strong>onSaveInstanceState(Bundle outState)会在以下情况被调用</strong>：</p><ol><li>当用户按下HOME键时。</li><li>从最近应用中选择运行其他的程序时。</li><li>按下电源按键（关闭屏幕显示）时。</li><li>从当前activity启动一个新的activity时。</li><li>屏幕方向切换时(无论竖屏切横屏还是横屏切竖屏都会调用)。</li></ol><p><strong>Activity的onSaveInstanceState回调时机，取决于app的targetSdkVersion</strong>：</p><ul><li><p>targetSdkVersion低于11的app，onSaveInstanceState方法会在Activity.onPause之前回调；</p></li><li><p>targetSdkVersion低于28的app，则会在onStop之前回调；</p></li><li><p><strong>28之后，onSaveInstanceState在onStop回调之后才回调。</strong></p></li></ul><p><strong><font size = "5">onRestoreInstanceState(Bundle savedInstanceState)</font></strong></p><p>onRestoreInstanceState(Bundle savedInstanceState)只有在activity确实是被系统回收，重新创建activity的情况下才会被调用。</p><p><strong>onRestoreInstanceState(Bundle outState)会在以下情况被调用</strong>：</p><ol><li>屏幕方向切换时（无论竖屏切横屏还是横屏切竖屏都会调用）</li><li>由于内存紧张导致后台运行的程序被kill掉时（这种不太好模拟）</li></ol><p><strong>onRestoreInstanceState(Bundle outState)</strong> 的回调时机：</p><p>回调发生在<code>onStart</code>回调之后。</p><hr><h1 id="onCreate和onRestoreInstance方法中恢复数据时的区别"><a href="#onCreate和onRestoreInstance方法中恢复数据时的区别" class="headerlink" title="onCreate和onRestoreInstance方法中恢复数据时的区别"></a><code>onCreate</code>和<code>onRestoreInstance</code>方法中恢复数据时的区别</h1><p>因为<code>onSaveInstanceState</code> 不一定会被调用，所以<code>onCreate</code>里的<code>Bundle</code>参数可能为空，如果使用<code>onCreate</code>来恢复数据，一定要做非空判断。</p><p>而<code>onRestoreInstanceState</code>的<code>Bundle</code>参数一定不会是空值，因为它只有在上次<code>activity</code>被回收了才会调用。</p><hr><h1 id="Activity的数据是怎么保存的-进程被Kill后-保存的数据怎么恢复的？"><a href="#Activity的数据是怎么保存的-进程被Kill后-保存的数据怎么恢复的？" class="headerlink" title="Activity的数据是怎么保存的,进程被Kill后,保存的数据怎么恢复的？"></a><code>Activity</code>的数据是怎么保存的,进程被<code>Kill</code>后,保存的数据怎么恢复的？</h1><blockquote><p>  答案参考自：</p><ul><li>《Android 开发艺术探索》</li></ul></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220521185305.png" style="zoom:67%;" /><p>通过<code>onSaveInstanceState</code>方法和<code>onRestoreInstanceState</code>方法进行数据的保存和恢复。</p><p>在 <code>onSaveInstanceState</code>和 <code>onRestoreInstanceState</code>方法中，系统自动为我们做了一定的恢复工作。当 <code>Activity</code> 在异常情况下需要重新创建时，系统会默认为我们保存当前<code>Activity</code> 的视图结构，并且在<code>Activity</code>重启后为我们恢复这些数据，比如文本框中用户输入的数据、<code>ListView</code>滚动的位置等。</p><hr><h1 id="Activity的启动模式和使用场景"><a href="#Activity的启动模式和使用场景" class="headerlink" title="Activity的启动模式和使用场景"></a><code>Activity</code>的启动模式和使用场景</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/sinat_14849739/article/details/78072401">Android中Activity的启动模式（LaunchMode）和使用场景_Shawpoo的博客-CSDN博客_launchmode</a></li></ul></blockquote><p>Activity的启动模式有四种：<b><code>standard</code>、<code>singleTop</code>、<code>singleTask</code>和<code>singleInstance</code></b>。</p><p><strong><font size="5">standard：标准模式</font></strong></p><p>这种启动模式为标准模式，也是默认模式。每当我们启动一个Activity，系统就会相应的创建一个实例，不管这个实例是否已经存在。这种模式，一个栈中可以有多个实例，每个实例也都有自己的任务栈。而且是谁启动了此Activity，那么这个Activity就运行在启动它的Activity所在的栈中。</p><p><strong>分析总结</strong></p><p><strong>标准模式下，只要启动一次Activity，系统就会在当前任务栈新建一个实例。</strong></p><p><strong>使用场景</strong></p><p>正常的去打开一个新的页面，这种启动模式使用最多，最普通 。</p><p><strong><font size="5">singleTop：栈顶复用模式</font></strong></p><p>这种启动模式下，如果要启动的Activity已经处于栈的顶部，那么此时系统不会创建新的实例，而是直接打开此页面，同时它的onNewIntent()方法会被执行，我们可以通过Intent进行传值，而且它的onCreate()，onStart()方法不会被调用，因为它并没有发生任何变化。</p><p><strong>分析总结</strong></p><ol><li>当前栈中已有该Activity的实例并且该实例位于栈顶时，不会创建实例，而是复用栈顶的实例，并且会将Intent对象传入，回调onNewIntent()方法；</li><li>当前栈中已有该Activity的实例但是该实例不在栈顶时，其行为和standard启动模式一样，依然会创建一个新的实例；</li><li>当前栈中不存在该Activity的实例时，其行为同standard启动模式。</li></ol><p><strong>使用场景</strong></p><p>这种模式应用场景的话，假如一个新闻客户端，在通知栏收到了3条推送，点击每一条推送会打开新闻的详情页，如果为默认的启动模式的话，点击一次打开一个页面，会打开三个详情页，这肯定是不合理的。如果启动模式设置为singleTop，当点击第一条推送后，新闻详情页已经处于栈顶，当我们第二条和第三条推送的时候，只需要通过Intent传入相应的内容即可，并不会重新打开新的页面，这样就可以避免重复打开页面了。</p><p><strong><font size="5">singleTask：栈内复用模式</font></strong></p><p>在这个模式下，如果栈中存在这个Activity的实例就会复用这个Activity，不管它是否位于栈顶，复用时，会将它上面的Activity全部出栈，因为singleTask本身自带clearTop这种功能。并且会回调该实例的onNewIntent()方法。其实这个过程还存在一个任务栈的匹配，因为这个模式启动时，会在自己需要的任务栈中寻找实例，这个任务栈就是通过taskAffinity属性指定。如果这个任务栈不存在，则会创建这个任务栈。不设置taskAffinity属性的话，默认为应用的包名。</p><p><strong>分析总结</strong></p><p>在复用的时候，首先会根据taskAffinity去找对应的任务栈：</p><ol><li>如果不存在指定的任务栈，系统会新建对应的任务栈，并新建Activity实例压入栈中。</li><li>如果存在指定的任务栈，则会查找该任务栈中是否存在该Activity实例<ol><li>如果不存在该实例，则会在该任务栈中新建Activity实例。</li><li>如果存在该实例，则会直接引用，并且回调该实例的onNewIntent()方法。并且任务栈中该实例之上的Activity会被全部销毁。</li></ol></li></ol><p><strong>使用场景</strong></p><p>SingleTask这种启动模式最常使用的就是一个APP的首页，因为一般为一个APP的第一个页面，且长时间保留在栈中，所以最适合设置singleTask启动模式来复用。</p><p><strong><font size="5">singleInstance：单实例模式</font></strong></p><p>单实例模式，顾名思义，只有一个实例。该模式具备singleTask模式的所有特性外，与它的区别就是，这种模式下的<strong>Activity会单独占用一个Task栈，具有全局唯一性</strong>，即整个系统中就这么一个实例，由于栈内复用的特性，后续的请求均不会创建新的Activity实例，除非这个特殊的任务栈被销毁了。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。</p><p><strong>分析总结</strong></p><p>启动该模式Activity的时候，会查找系统中是否存在：</p><ol><li>不存在，首先会新建一个任务栈，其次创建该Activity实例。</li><li>存在，则会直接引用该实例，并且回调onNewIntent()方法。</li><li>特殊情况：该任务栈或该实例被销毁，系统会重新创建。</li></ol><p><strong>使用场景</strong></p><p>很常见的是，电话拨号盘页面，通过自己的应用或者其他应用打开拨打电话页面 ，只要系统的栈中存在该实例，那么就会直接调用。</p><p><strong><font size="5">总结</font></strong></p><p>在使用APP过程中，不可避免页面之间的跳转，那么就会涉及到启动模式。其实在对界面进行跳转时，Android系统既能在同一个任务中对Activity进行调度，也能以Task（任务栈）为单位进行整体调度。在启动模式为standard或singleTop时，一般是在同一个任务中对Activity进行调度，而在启动模式为singleTask或singleInstance是，一般会对Task进行整体调度。</p><hr><h1 id="Activity的onNewIntent方法什么时候会执行"><a href="#Activity的onNewIntent方法什么时候会执行" class="headerlink" title="Activity的onNewIntent方法什么时候会执行"></a><code>Activity</code>的<code>onNewIntent</code>方法什么时候会执行</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/8897068505d8">Android中的onNewIntent()函数 - 简书 (jianshu.com)</a></li></ul></blockquote><p><strong>使用<code>SingleTask</code>以及<code>SingleInstance</code>启动模式的时候，会调用<code>onNewInstant</code>方法。</strong></p><p> <code>Activity</code>第一次启动的时候执行<code>onCreate</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>等后续生命周期函数，也就时说第一次启动Activity并不会执行到<code>onNewIntent</code>。</p><p>而后面如果再有想启动<code>Activity</code>的时候，那就是执行 <b><code>onNewIntent</code> -&gt; <code>onResart</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code></b>。</p><p>如果Android系统由于内存不足把已存在<code>Activity</code>释放掉了，那么再次调用的时候会重新启动<code>Activity</code>即执行<code>onCreate</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>等。</p><p>当调用到<code>onNewIntent(intent)</code>的时候，需要在<code>onNewIntent</code>中使用<code>setIntent(intent)</code>赋值给<code>Activity</code>的<code>Intent</code>。否则，后续的<code>getIntent</code>都是得到旧的<code>Intent</code>。</p><hr><h1 id="Activity-生命周期"><a href="#Activity-生命周期" class="headerlink" title="Activity 生命周期"></a><code>Activity</code> 生命周期</h1><blockquote><p>  答案参考自：</p><ul><li><p>《Android 开发艺术探索》</p></li><li><p><a href="https://blog.csdn.net/xiajun2356033/article/details/78741121">activity生命周期（这篇足够了）_android_Mr_夏的博客-CSDN博客</a></p></li></ul></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220521182943.png" alt="Activity的生命周期" style="zoom:67%;" /><ol><li><p><code>onCreate</code></p><p>表示 Activity 正在被创建，这是生命周期的第一个方法。在这个方法中，我们可以做一些<strong>初始化工作</strong>，比如调用 <strong>setContentView</strong> 去加载界面布局资源、初始化 Activity 所需数据等。</p></li><li><p><code>onStart</code></p><p>表示 Activity 正在被启动，即将开始，这时 Activity已经<strong>可见</strong>了，但是还<strong>没有出现在前台</strong>，还<strong>无法和用户交互</strong>。这个时候其实可以理解为 Activity 已经显示出来了，但是我们还<strong>看不到</strong>。</p></li><li><p><code>onResume</code></p><p>表示 Activity <strong>已经可见</strong>了，并且<strong>出现在前台并开始活动</strong>。</p><p>要注意这个和 onStart 的对比，onStart 和 onResume 都表示 Activity 已经可见，但是 onStart 的时候 Activity 还在后台，onResume 的时候 Activity 才显示到前台。</p></li><li><p><code>onPause</code></p><p>表示 Activity 正在停止，正常情况下，紧接着 onStop 就会被调用。</p><p>在特殊情况下，如果这个时候快速地再回到当前 Activity，那么 onResume 会被调用。笔者的理解是，这种情况属于极端情况，用户操作很难重现这一场景。</p><p><strong>当前 Activity 是可见的，但不能与用户交互状态（即不在前台）。</strong></p><p>此时可以做一些<strong>存储数据、停止动画</strong>等工作，但是注意<strong>不能太耗时</strong>，因为这会影响到新 Activity 的显示，<strong>onPause 必须先执行完，新 Activity 的 onResume 才会执行。</strong></p></li><li><p><code>onStop</code></p><p>表示 Activity 即将停止，此时 Activity 对用户是<strong>不可见</strong>的，可以做一些稍微重量级的回收工作，同样<strong>不能太耗时</strong>。</p><p>在系统内存紧张的情况下，有可能会被系统进行回收，所以一般在当前方法可做资源回收。</p></li><li><p><code>onDestroy</code></p><p>表示 Activity 即将被销毁，这是 Activity 生命周期中的最后一个回调，在这里我们可以做一些<strong>回收工作和最终的资源释放</strong>。</p></li><li><p><code>onRestart</code></p><p>表示 Activity 正在重新启动。一般情况下，当当前 Activity 从<strong>不可见重新变为可见状态</strong>时，onRestart 就会被调用。</p><p>这种情形一般是用户行为所导致的，比如用户按 Home 键切换到桌面或者用户打开了一个新的 Activity，这时当前的 Activity 就会暂停，也就是 onPause 和 onStop 被执行了，接着用户又回到了这个 Activity，就会出现这种情况。</p></li></ol><p><strong>具体情况分析</strong>：</p><ol><li><p>针对一个特定的 Activity，<strong>第一次启动</strong>，回调如下：<code>onCreate</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>。</p></li><li><p>当用户<strong>打开新的 Activity</strong> 或者<strong>切换到桌面</strong>的时候，回调如下： <code>onPause</code> -&gt; <code>onStop</code>。</p><p>这里有一种特殊情况，如果新 Activity 采用了透明主题,那么当前 Activity 不会回调 <code>onStop</code>。</p></li><li><p>当用户<strong>再次回到原 Activity</strong> 时，回调如下： <code>onRestart</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>。</p></li><li><p>当用户<strong>按 back 键回退</strong>时，回调如下：<code>onPause</code> -&gt; <code>onStop</code> -&gt; <code>onDestroy</code>。</p></li><li><p>当 <strong>Activity 被系统回收后再次打开</strong>，生命周期方法回调过程和（1）一样，注意只是生命周期方法一样，不代表所有过程都一样，比如 <code>onSaveInstanceState</code> 和 <code>onRestoreInstanceState</code> 的调用。</p></li><li><p>从 <strong>Activity_A跳转到Activity_B</strong>，会先执行 A 活动的 <code>onPause</code>，再执行 B 活动的 <code>onResume</code>。</p></li><li><p>从<strong>整个生命周期</strong>来说，<code>onCreate</code> 和 <code>onDestroy</code> 是配对的，分别标识着 Activity 的创建和销毁，并且只可能有一次调用。</p></li><li><p>从 <strong>Activity 是否可见</strong>来说，<code>onStart</code> 和 <code>onStop</code> 是配对的，随着用户的操作或者设备屏幕的点亮和熄灭，这两个方法可能被调用多次。</p></li><li><p>从 <strong>Activity 是否在前台</strong>来说，<code>onResume</code>和 <code>onPause</code>是配对的，随着用户操作或者设备屏幕的点亮和熄灭，这两个方法可能被调用多次。</p></li></ol><table><thead><tr><th>生命周期</th><th>是否可见</th><th>是否在前台</th></tr></thead><tbody><tr><td><code>onStart</code></td><td>是</td><td>否</td></tr><tr><td><code>onResume</code></td><td>是</td><td>是</td></tr><tr><td><code>onPause</code></td><td>是</td><td>否</td></tr><tr><td><code>onStop</code></td><td>否</td><td>否</td></tr></tbody></table><hr><h1 id="onStart-和-onResume、onPause-和-onStop-的区别"><a href="#onStart-和-onResume、onPause-和-onStop-的区别" class="headerlink" title="onStart 和 onResume、onPause 和 onStop 的区别"></a><code>onStart</code> 和 <code>onResume</code>、<code>onPause</code> 和 <code>onStop</code> 的区别</h1><blockquote><p>  答案参考自：</p><ul><li>《Android 开发艺术探索》</li></ul></blockquote><p>从实际使用过程来说，<code>onStart</code>和 <code>onResume</code>、<code>onPause</code>和 <code>onStop</code>看起来的确差不多，甚至我们可以只保留其中一对，比如只保留<code>onStart</code>和 <code>onStop</code>。既然如此,那为什么Android系统还要提供看起来重复的接口呢？</p><p>根据上面的分析，我们知道，这两个配对的回调分别表示不同的意义，<code>onStart</code>和 <code>onStop</code>是从<strong>Activity是否可见</strong>这个角度来回调的，而 <code>onResume</code>和 <code>onPause</code>是从<strong>Activity是否位于前台</strong>这个角度来回调的，除了这种区别，在实际使用中没有其他明显区别。</p><hr><h1 id="Activity的显式启动和隐式启动"><a href="#Activity的显式启动和隐式启动" class="headerlink" title="Activity的显式启动和隐式启动"></a><code>Activity</code>的显式启动和隐式启动</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/lrq851215/article/details/62881056">显示和隐式启动Activity的方式_卩s秋灬的博客-CSDN博客</a></li></ul></blockquote><p>启动Activity主要是通过Intent（意图）来实现。主要分为显示的和隐式的两种。</p><p><strong><font size="4">隐式启动 <code>Activity</code></font></strong></p><p>优点：</p><ol><li>只要知道被启动<code>Activity</code>的<code>Action</code>和<code>Category</code>即可，不用知道对应的类名或者是包名。</li><li>只要<code>Activity</code>有对应的<code>Action</code>和<code>Category</code>都会被启动起来。然后提供给用户选择要启动哪一个。</li></ol><p> 需要被启动的<code>Activity</code>，需要在自己的<code>AndroidManifest.xml</code>定义对应的<code>action</code> 和 <code>category</code>。     </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.android.activity.demo.SecondActivity&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;@string/second_activity_name&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.SECONDACTIVITY_START&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启动<code>Activity</code>的地方，把对应的<code>Action</code>填入即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startSecondActivityByAction</span><span class="hljs-params">()</span> &#123;<br>    Log.d(TAG, <span class="hljs-string">&quot;startSecondActivityByAction()&quot;</span>);<br>    <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>    intent.setAction(<span class="hljs-string">&quot;android.intent.action.SECONDACTIVITY_START&quot;</span>);<br>    intent.addCategory(Intent.CATEGORY_DEFAULT);<br>    <span class="hljs-keyword">try</span> &#123;<br>        startActivity(intent);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;start activity error!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><font size="4">显示启动 <code>Activity</code></font></strong></p><p>不足：</p><ol><li>被启动的应用的包名或者类名发生变化后，就会无法启动。</li></ol><p>通过类名类启动Activity， 一般是同一个APK里面使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startSecondActivityByClass</span><span class="hljs-params">()</span> &#123;<br>    Log.d(TAG, <span class="hljs-string">&quot;startSecondActivityByClass()&quot;</span>);<br>    <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(FirstActivity.<span class="hljs-built_in">this</span>, SecondActivity.class);<br>    <span class="hljs-keyword">try</span> &#123;<br>        startActivity(intent);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        Log.d(TAG, <span class="hljs-string">&quot;start activity error!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="Activity间传递数据的方式"><a href="#Activity间传递数据的方式" class="headerlink" title="Activity间传递数据的方式"></a><code>Activity</code>间传递数据的方式</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/u010112268/article/details/83832021">关于Android Activity之间传递数据的6种方式_淼淼1111的博客-CSDN博客_activity传递数据</a></li></ul></blockquote><p>共六种传递数据的方式。</p><ol><li><p><strong>使用Intent的putExtra传递</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建意图对象</span><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>,TwoActivity.class);<br><span class="hljs-comment">//设置传递键值对</span><br>intent.putExtra(<span class="hljs-string">&quot;data&quot;</span>,str);<br><span class="hljs-comment">//激活意图</span><br>startActivity(intent);<br></code></pre></td></tr></table></figure><p>第二个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取意图对象</span><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> getIntent();<br><span class="hljs-comment">//获取传递的值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> intent.getStringExtra(<span class="hljs-string">&quot;data&quot;</span>);<br><span class="hljs-comment">//设置值</span><br>tv.setText(str);<br></code></pre></td></tr></table></figure></li><li><p><strong>使用Intention的Bundle传递</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建意图对象</span><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(MainActivity.<span class="hljs-built_in">this</span>,TwoActivity.class);<br><span class="hljs-comment">//用数据捆传递数据</span><br><span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bundle</span>();<br>bundle.putString(<span class="hljs-string">&quot;data&quot;</span>, str);<br><span class="hljs-comment">//把数据捆设置改意图</span><br>intent.putExtra(<span class="hljs-string">&quot;bun&quot;</span>, bundle);<br><span class="hljs-comment">//激活意图</span><br>startActivity(intent);<br></code></pre></td></tr></table></figure><p>第二个Activity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取Bundle</span><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> getIntent();<br><span class="hljs-type">Bundle</span> <span class="hljs-variable">bundle</span> <span class="hljs-operator">=</span> intent.getBundleExtra(<span class="hljs-string">&quot;bun&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> bundle.getString(<span class="hljs-string">&quot;data&quot;</span>);<br>tv.setText(str);<br></code></pre></td></tr></table></figure></li><li><p><strong>使用Activity销毁时传递数据(startActivityForResult)</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(MainActivity.<span class="hljs-built_in">this</span>,TwoActivity.class);<br><span class="hljs-comment">//用一种特殊方式开启Activity</span><br>startActivityForResult(intent, <span class="hljs-number">11</span>);<br><br><span class="hljs-comment">//设置数据</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onActivityResult</span><span class="hljs-params">(<span class="hljs-type">int</span> requestCode, <span class="hljs-type">int</span> resultCode, Intent data)</span> &#123;<br>    <span class="hljs-built_in">super</span>.onActivityResult(requestCode, resultCode, data);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> data.getStringExtra(<span class="hljs-string">&quot;data&quot;</span>);<br>    tvOne.setText(str);<br>&#125;<br></code></pre></td></tr></table></figure><p>第二个activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置返回的数据</span><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>intent.putExtra(<span class="hljs-string">&quot;data&quot;</span>, edtOne.getText().toString().trim());<br>setResult(<span class="hljs-number">3</span>, intent);<br><span class="hljs-comment">//关闭当前activity</span><br>finish();<br></code></pre></td></tr></table></figure></li><li><p><strong>SharedPreferences传递数据</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SharedPreferences</span> <span class="hljs-variable">sp</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getSharedPreferences(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-comment">//获取sp编辑器</span><br><span class="hljs-type">Editor</span> <span class="hljs-variable">edit</span> <span class="hljs-operator">=</span> sp.edit();<br>edit.putString(<span class="hljs-string">&quot;data&quot;</span>, str);<br>edit.commit();<br><span class="hljs-comment">//创建意图对象</span><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(MainActivity.<span class="hljs-built_in">this</span>,TwoActivity.class);<br><span class="hljs-comment">//激活意图</span><br>startActivity(intent);<br></code></pre></td></tr></table></figure><p>第二个activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SharedPreferences</span> <span class="hljs-variable">sp</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getSharedPreferences(<span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-number">1</span>);<br><span class="hljs-comment">//设置数据</span><br>tv.setText(sp.getString(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;&quot;</span>));<br></code></pre></td></tr></table></figure></li><li><p><strong>使用序列化对象Seriazable</strong></p><p>工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sex;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(String sex)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建意图</span><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(MainActivity.<span class="hljs-built_in">this</span>,TwoActivity.class);<br><span class="hljs-type">DataBean</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataBean</span>();<br><span class="hljs-comment">//通过set方法把数据保存到DataBean对象中</span><br>bean.setName(<span class="hljs-string">&quot;啦啦&quot;</span>);<br>bean.setSex(<span class="hljs-string">&quot;男&quot;</span>);<br>intent.putExtra(<span class="hljs-string">&quot;key&quot;</span>, bean);<br>startActivity(intent);<br></code></pre></td></tr></table></figure><p>第二个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> getIntent();<br><span class="hljs-comment">//反序列化数据对象</span><br><span class="hljs-type">Serializable</span> <span class="hljs-variable">se</span> <span class="hljs-operator">=</span> intent.getSerializableExtra(<span class="hljs-string">&quot;key&quot;</span>);<br><span class="hljs-keyword">if</span>(se <span class="hljs-keyword">instanceof</span> DataBean)&#123;<br>    <span class="hljs-comment">//获取到携带数据的DataBean对象db</span><br>    <span class="hljs-type">DataBean</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> (DataBean) se;<br>    tv.setText(db.getName() + <span class="hljs-string">&quot;===&quot;</span> + db.getSex());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>使用静态变量传递数据</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(MainActivity.<span class="hljs-built_in">this</span>,TwoActivity.class);<br>TwoActivity.name = <span class="hljs-string">&quot;NAME&quot;</span>;<br>TwoActivity.str = <span class="hljs-string">&quot;STR&quot;</span>;<br>startActivity(intent);<br></code></pre></td></tr></table></figure><p>第二个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//静态变量</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> String name;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> String str;<br>tv.setText(str + name);<br></code></pre></td></tr></table></figure></li></ol><hr><h1 id="有哪些Activity常用的标记位Flags"><a href="#有哪些Activity常用的标记位Flags" class="headerlink" title="有哪些Activity常用的标记位Flags"></a>有哪些<code>Activity</code>常用的标记位<code>Flags</code></h1><ol><li><p><code>FLAG_ACTIVITY_NEW_TASK</code></p><p>指定启动模式为SingleTask</p></li><li><p><code>FLAG_ACTIVITY_SINGLE_TOP</code></p><p>指定启动模式为SingleTop</p></li><li><p><code>FLAG_ACTIVITY_CLEAR_TOP</code></p><p>一般与SingleTask启动模式一起出现，启动时位于它上方的Activity出栈，如果被启动的Activity实例已存在，系统则会调用它的onNewIntent</p></li></ol><hr><h1 id="Activity任务栈是什么"><a href="#Activity任务栈是什么" class="headerlink" title="Activity任务栈是什么"></a><code>Activity</code>任务栈是什么</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.cnblogs.com/Lwenlong/p/15939583.html">Android面试——Activity篇 - 向着内核前进！ - 博客园 (cnblogs.com)</a></li></ul></blockquote><p>即Task，栈结构，存放Activity；退出应用程序时只有将所有任务栈找那个的所有Activity出栈，任务栈才能销毁。</p><p>任务栈可以移动到后台，在其中保留每一个Activity的状态。</p><p>对应的类：ActivityRecord、TaskRecord、ActivityStack。</p><hr><h1 id="跨App启动Activity的方式-注意事项"><a href="#跨App启动Activity的方式-注意事项" class="headerlink" title="跨App启动Activity的方式,注意事项"></a>跨<code>App</code>启动<code>Activity</code>的方式,注意事项</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.cnblogs.com/Lwenlong/p/15939583.html">Android面试——Activity篇 - 向着内核前进！ - 博客园 (cnblogs.com)</a></li><li>《Android 开发艺术探索》</li></ul></blockquote><ol><li><p>指定打开的应用</p><p>通过 Intent 隐式启动时，如果有多个 action 值相同的 Activity，系统会让你选择启动哪个，解决办法时通过指定 Intent-filter 的 <code>data</code> 属性，Intent 则要加上一个 URI，该 URI 的 scheme 必须与 data 的 scheme 相同。</p><blockquote><p>  data 由两部分组成，mimeType 和 URI。mimeType 指媒体类型，比如 image&#x2F;ijpeg、audio&#x2F;mpeg4-generic 和 video&#x2F;* 等，可以表示图片、文本、视频等不同的媒体格式，而 URI 中包含的数据就比较多了，下面是 URI 的结构：</p>  <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">&lt;scheme&gt;<span class="hljs-symbol">://&lt;host&gt;</span><span class="hljs-symbol">:&lt;port&gt;/</span>[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]<br></code></pre></td></tr></table></figure><p>  Scheme：URI 的模式，比如 http、file、content等，如果 URI 中没有指定 scheme，那么整个 URI 的其他参数无效，这也意味着 URI 是无效的。</p></blockquote></li><li><p>如何防止自己的 Activity 被外部非正常启动</p><p>给自己的 Activity 添加 <code>android:permission=”xxx.xxx.xx”</code>，那么想要访问你的 Activity 就必须声明 <code>uses-permission xxx.xxx.xx</code>。</p></li></ol><hr><h1 id="ANR-的四种场景"><a href="#ANR-的四种场景" class="headerlink" title="ANR 的四种场景"></a><code>ANR</code> 的四种场景</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/xingyu19911016/article/details/122080235">ANR 的四种场景_橙子19911016的博客-CSDN博客_anr的四种场景</a></li></ul></blockquote><ol><li><p><code>Service TimeOut</code></p><p><code>Service</code>未在规定时间执行完成，前台服务20s，后台200s。</p></li><li><p><code>BroadCastQueue TimeOut</code></p><p>未在规定时间内未处理完广播，前台广播10s内，后台60s内。</p></li><li><p><code>ContentProvider TimeOut</code></p><p><code>publish</code>在10s内没有完成。</p></li><li><p><code>Input Dispatching timeout</code></p><p>5s内未响应键盘输入、触摸屏幕等事件。</p></li></ol><p>Activity的生命周期回调的阻塞并不在触发ANR的场景里面，所以并不会直接触发ANR。 只不过死循环阻塞了主线程，如果系统再有上述的四种事件发生，就无法在相应的时间内处理从而触发ANR。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>面试整理-2022</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Activity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArrayList 你了解这些吗？</title>
    <link href="/posts/a0f8379be91e/"/>
    <url>/posts/a0f8379be91e/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://blog.csdn.net/qq_51596354/article/details/122398978">Java ArrayList底层原理详情笔记和相关面试题_抹泪的知更鸟的博客-CSDN博客</a></li></ul></blockquote><hr><h1 id="ArrayList是如何扩容的？"><a href="#ArrayList是如何扩容的？" class="headerlink" title="ArrayList是如何扩容的？"></a><code>ArrayList</code>是如何扩容的？</h1><p>初始容量为 10，第一扩容就为 10。</p><p>以后每次的扩容都是原容量的 1.5 倍。</p><hr><h1 id="ArrayList继承关系"><a href="#ArrayList继承关系" class="headerlink" title="ArrayList继承关系"></a><code>ArrayList</code>继承关系</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable<br></code></pre></td></tr></table></figure><h2 id="实现Serializable标记型接口"><a href="#实现Serializable标记型接口" class="headerlink" title="实现Serializable标记型接口"></a>实现<code>Serializable</code>标记型接口</h2><p>序列化：将对象转化为字节数组的过程</p><p>反序列化：将字节数组转化为对象的过程</p><h2 id="实现Cloneable标记型接口"><a href="#实现Cloneable标记型接口" class="headerlink" title="实现Cloneable标记型接口"></a>实现<code>Cloneable</code>标记型接口</h2><p>克隆：将<code>ArrayList</code>集合的数组clone到另一个集合</p><p>实际底层调用的是Object中的<code>clone</code>方法，而<code>clone</code>是一个<code>native</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> list.clone();<br>System.out.println(o == list);<span class="hljs-comment">//地址不一样，深度克隆</span><br></code></pre></td></tr></table></figure><p>使用了<code>Arrays#copyOf</code>方法进行复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="hljs-built_in">super</span>.clone();<br>v.elementData = Arrays.copyOf(elementData, size);<br></code></pre></td></tr></table></figure><p>浅拷贝：基本数据类型可以达到完全复制，引用数据类型拷贝的是栈上的地址值，所以修改引用类型的数据，会改变原来的数据。</p><p>深拷贝：基本数据类型和引用类型都可以完全复制，引用对象在堆中创建新的对象，对原数据没有任何影响。</p><p><strong>深拷贝的实现方式：</strong></p><p> 实现<code>Cloneable</code>接口并重写<code>clone</code>方法。</p><p> 让其<code>clone</code>方法通过序列化和反序列化的方式来生成一个原对象的深拷贝副本</p><h2 id="实现RandomAccess标记型接口"><a href="#实现RandomAccess标记型接口" class="headerlink" title="实现RandomAccess标记型接口"></a>实现<code>RandomAccess</code>标记型接口</h2><p><strong><code>ArrayList</code>支持随机访问。</strong></p><blockquote><p>  随机访问：直接 <code>first+N</code>，便可以得到第<code>N</code>个元素的地址，因为这些相邻元素是按顺序连续存储的。<br>  比如普通数组就是可随机访问的。</p><p>  文件随机访问是指<strong>在某个文件内直接读写任何给定位置数据的能力</strong>。</p></blockquote><p>通过<code>get(i)</code>即可获得相应内存中存放的值。原因是因为<code>ArrayList</code>存放的内容在内存中是连续的，数组直接用<code>[]</code>访问，相当于直接操作内存地址，所以随机访问的效率较高。</p><p>普通的for循环是随机访问的，所以遍历<code>ArrayList</code>使用普通<code>for</code>循环比增强<code>for</code>循环和迭代器的效率高。</p><p>而<code>LinkedList</code>是一个双向链表，链表只能顺序访问，不支持随机访问，<code>LinkedList</code>中的<code>get</code>方法是按照顺序从列表的一端开始检查，直到找到要找的地址。所以遍历<code>LinkedList</code>使用增强<code>for</code>循环和迭代器的效率高，使用普通<code>for</code>循环会每次都从头开始遍历，效率较差。</p><h2 id="AbstractList抽象类"><a href="#AbstractList抽象类" class="headerlink" title="AbstractList抽象类"></a><code>AbstractList</code>抽象类</h2><p><code>AbstractList</code> 虽然是抽象类，但其内部只有一个抽象方法 <code>get</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>;<br></code></pre></td></tr></table></figure><p>从字面上看这是获取的方法，子类必须实现它，一般是作为获取元素的用途，除此之外，如果子类要操作元素，还需要重写 <code>add</code>、<code>set</code>、 <code>remove</code>方法，因为 <code>AbstractList</code> 虽然定义了这几个方法，但默认是不支持的。</p><hr><h1 id="ArrayList频繁扩容导致添加性能急剧下降，如何处理？"><a href="#ArrayList频繁扩容导致添加性能急剧下降，如何处理？" class="headerlink" title="ArrayList频繁扩容导致添加性能急剧下降，如何处理？"></a><code>ArrayList</code>频繁扩容导致添加性能急剧下降，如何处理？</h1><p>每次扩容都会创建一个数据，将数据复制到新数组，所以在<code>ArrayList</code>中有一个构造方法，参数是自定义长度，指定初始容量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123; <span class="hljs-comment">// 手动初始化</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果长度为0，使用final修饰的空数组</span><br>        <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="ArrayList插入或删除元素一定比LinkedList慢吗？"><a href="#ArrayList插入或删除元素一定比LinkedList慢吗？" class="headerlink" title="ArrayList插入或删除元素一定比LinkedList慢吗？"></a><code>ArrayList</code>插入或删除元素一定比<code>LinkedList</code>慢吗？</h1><p>不一定，<code>LinkedList</code> 其底层调用了 Node 的方法，该方法循环也是比较复杂的。如果这个 <code>LinkedList</code> 上的数据很多，虽说进行了折半的 但是效率也是比较低的。</p><p>而 <code>ArrayList</code> 底层数组需要移动位置，复制数组。</p><hr><h1 id="ArrayList是线程安全的吗？"><a href="#ArrayList是线程安全的吗？" class="headerlink" title="ArrayList是线程安全的吗？"></a><code>ArrayList</code>是线程安全的吗？</h1><p><code>ArrayList</code>不是线程安全的，效率高。</p><hr><h1 id="如何解决ArrayList线程安全问题？"><a href="#如何解决ArrayList线程安全问题？" class="headerlink" title="如何解决ArrayList线程安全问题？"></a>如何解决<code>ArrayList</code>线程安全问题？</h1><ul><li><p>可以使用安全集合 <code>Vector</code>。</p></li><li><p>可以使用 <code>Collections</code> 工具类中的 <code>SyschronizedList</code> 方法解决 <code>ArrayList</code> 的线程安全问题。</p></li></ul><p>定义为全局变量，被多个线程所共享，就要考虑线程问题。</p><p>定义为局部变量时，调用方法会在虚拟机栈处创建一个栈帧，虚拟机栈线程私有的，每一次只有一个线程执行，所以<strong>局部变量的数据是独立的</strong>，不需要考虑安全问题。</p><hr><h1 id="如何复制一个ArrayList集合到另一个ArrayList集合中？"><a href="#如何复制一个ArrayList集合到另一个ArrayList集合中？" class="headerlink" title="如何复制一个ArrayList集合到另一个ArrayList集合中？"></a>如何复制一个<code>ArrayList</code>集合到另一个<code>ArrayList</code>集合中？</h1><ul><li><p>可以使用 clone() 方法</p></li><li><p>使用其中的构造器</p></li><li><p>使用 addAll() 方法</p></li><li><p>for 循环遍历复制</p></li></ul><hr><h1 id="已知成员变量集合存储N多用户名称，在多线程的环境下，使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合？"><a href="#已知成员变量集合存储N多用户名称，在多线程的环境下，使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合？" class="headerlink" title="已知成员变量集合存储N多用户名称，在多线程的环境下，使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合？"></a>已知成员变量集合存储N多用户名称，在多线程的环境下，使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合？</h1><p>在多线程读写操作，<code>ArrayList</code> 会抛出并发异常，所以在进行读写数据时，使用读写的操作时，使用<code>CopyOnWriteArrayList</code>这个读写分离的集合。</p><hr><h1 id="ArrayList和LinkedList区别？"><a href="#ArrayList和LinkedList区别？" class="headerlink" title="ArrayList和LinkedList区别？"></a><code>ArrayList</code>和<code>LinkedList</code>区别？</h1><p><strong><code>ArrayList</code></strong></p><ul><li><p>基于动态数组的数据结构</p></li><li><p><code>ArrayList</code>支持随机访问</p></li><li><p>查询快，增删慢，但并不一定比<code>LinkedList</code>慢</p></li></ul><p><strong><code>LinkedList</code>（双向链表）</strong></p><ul><li><p>基于链表的数据结构</p></li><li><p>对于顺序操作，<code>LinkedList</code>不一定比<code>ArrayList</code>慢</p></li><li><p>查询慢，增删快</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试整理-2022</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ArrayList</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 中 HashMap 的那些事</title>
    <link href="/posts/9f36eff79423/"/>
    <url>/posts/9f36eff79423/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/weixin_44015043/article/details/105346187">看完还不懂HashMap算我输（附职场面试常见问题）_黛色翩翩的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/weixin_39603469/article/details/110639674">hashmap为什么用红黑树_HashMap面试必问的6个点，你知道几个？_weixin_39603469的博客-CSDN博客</a></li></ul></blockquote><h1 id="JDK-1-8-中-HashMap-更改了什么内容？"><a href="#JDK-1-8-中-HashMap-更改了什么内容？" class="headerlink" title="JDK 1.8 中 HashMap 更改了什么内容？"></a><code>JDK 1.8</code> 中 <code>HashMap</code> 更改了什么内容？</h1><ol><li>将存储方式更改为了 数组 + 链表&#x2F;<strong>红黑树</strong>。</li><li>优化了高位运算的<code>hash</code>算法：<code>h &amp; (h &gt;&gt;&gt; 16)</code>。</li><li>扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。</li></ol><h1 id="HashMap-原理"><a href="#HashMap-原理" class="headerlink" title="HashMap 原理"></a><code>HashMap</code> 原理</h1><p><strong>几个重要的变量</strong></p><ul><li><p><code>DEFAULT_INITIAL_CAPACITY</code> </p><p>Table数组的初始化长度： <code>1 &lt;&lt; 4</code> 。</p></li><li><p><code>MAXIMUM_CAPACITY</code> </p><p>Table数组的最大长度： <code>1 &lt;&lt; 30</code>。</p></li><li><p><code>DEFAULT_LOAD_FACTOR</code> </p><p>负载因子：默认值为<code>0.75</code>。</p><p> 当<code>元素的总个数 &gt; (当前数组的长度 * 负载因子)</code>，数组会进行扩容，<strong>扩容为原来的两倍</strong>。</p></li><li><p><code>TREEIFY_THRESHOLD</code> </p><p>链表树化阈值： 默认值为 <code>8</code> 。</p><p>表示在一个node（Table）节点下的值的个数大于8时候，会将链表转换成为红黑树。</p></li><li><p><code>UNTREEIFY_THRESHOLD</code> </p><p>红黑树链化阈值： 默认值为 <code>6</code> 。 </p><p>表示在进行扩容期间，单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。</p></li><li><p><code>MIN_TREEIFY_CAPACITY = 64</code> </p><p>最小树化阈值，值为 64。</p><p>当Table所有元素超过改值，才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突）。</p></li></ul><p><strong>实现原理</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220522214849.png" style="zoom:67%;" /><p><code>HashMap</code>采⽤<code>Entry</code>数组来存储<code>key-value</code>对，每⼀个键值对组成了⼀个<code>Entry</code>实体，<code>Entry</code>类实际上是⼀个单向的链表结构，它具有<code>Next</code>指针，可以连接下⼀个<code>Entry</code>实体。 只是在<code>JDK1.8</code>中，链表⻓度⼤于<code>8</code>的时候，链表会转成<strong>红黑树</strong>。</p><h1 id="为什么使用-链表-数组-的存储方式？"><a href="#为什么使用-链表-数组-的存储方式？" class="headerlink" title="为什么使用 链表 + 数组 的存储方式？"></a>为什么使用 <code>链表</code> + <code>数组</code> 的存储方式？</h1><p>由于我们的数组的值是限制死的，我们在对<code>key</code>值进行散列取到下标以后，放入到数组中时，难免出现两个<code>key</code>值不同，但是却放入到下标相同的<strong>格子</strong>中，此时我们就可以使用链表来对其进行链式的存放。</p><h1 id="用LinkedList代替数组结构可以吗？"><a href="#用LinkedList代替数组结构可以吗？" class="headerlink" title="用LinkedList代替数组结构可以吗？"></a>用<code>LinkedList</code>代替<code>数组</code>结构可以吗？</h1><p>可以的。</p><h1 id="既然可以使用进行替换处理，为什么偏偏使用到数组呢？"><a href="#既然可以使用进行替换处理，为什么偏偏使用到数组呢？" class="headerlink" title="既然可以使用进行替换处理，为什么偏偏使用到数组呢？"></a>既然可以使用进行替换处理，为什么偏偏使用到<code>数组</code>呢？</h1><p>因为使用数组效率最高。</p><p> 在<code>HashMap</code>中，定位节点的位置是通过 <code>i = (n - 1) &amp; hash</code> 得到。此时，我们已得到节点的位置。显然数组的查找效率比<code>LinkedList</code>更优（底层是链表结构）。</p><p>那<code>ArrayList</code>，底层也是数组，查找也快啊，为啥不⽤<code>ArrayList</code>? </p><p>因为采用基本数组结构，扩容机制可以自己定义，<code>HashMap</code>中数组扩容刚好是<strong>2的次幂</strong>，方便原数组中的元素的位置变动， 而<code>ArrayList</code>的扩容机制是1.5倍扩容。</p><h1 id="HashMap中如何计算出存放位置的？hash函数怎么实现的"><a href="#HashMap中如何计算出存放位置的？hash函数怎么实现的" class="headerlink" title="HashMap中如何计算出存放位置的？hash函数怎么实现的?"></a><code>HashMap</code>中如何计算出存放位置的？<code>hash</code>函数怎么实现的?</h1><p><strong>该问题解析同下问。</strong></p><h1 id="为什么不直接将hashcode作为哈希值去做取模-而是要先高16位异或低16位"><a href="#为什么不直接将hashcode作为哈希值去做取模-而是要先高16位异或低16位" class="headerlink" title="为什么不直接将hashcode作为哈希值去做取模,而是要先高16位异或低16位"></a>为什么不直接将<code>hashcode</code>作为哈希值去做取模,而是要先高16位异或低16位</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HashMap#putVal 计算位置并存放</span><br><span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>            tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p><strong>通过图做进一步的了解 <code>i = (n - 1) &amp; hash</code>：</strong></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220522214907.png" alt="img"></p><p>这里我们也就得知为什么<code>Table</code>数组的长度要一直都为 $2^n$，只有这样，减一进行<strong>与操作</strong>时候，才能够达到最大的<code>n-1</code>值。</p><p><strong>通过反例验证一下：</strong></p><p>我们现 数组的长度为 15 ，减一为 14 ，二进制表示 <code>0000 1110</code> 。进行<strong>与操作</strong>时候，最后一位永远是0，这样就可能导致不能够完完全全的进行Table数组的使用。违背了我们最开始的想要对Table数组进行<strong>最大限度的无序使用</strong>的原则，因为HashMap为了能够存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表⻓度⼤致相同。</p><p><strong>此时还有一点需要注意的是： 我们对key值进行hashcode以后，进行相与时候都是只用到了后四位，前面的很多位都没有能够得到使用,这样也可能会导致我们所生成的下标值不能够完全散列。</strong></p><p><strong>解决方案：</strong></p><p>将生成的<code>hashcode</code>值的高16位于低16位进行异或运算，这样得到的值再进行<strong>与操作</strong>，得散列的下标值，异或的1或0的结果都是1&#x2F;2，使得散列更均匀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="还有哪些hash函数的实现方式？"><a href="#还有哪些hash函数的实现方式？" class="headerlink" title="还有哪些hash函数的实现方式？"></a>还有哪些<code>hash</code>函数的实现方式？</h1><p>先说⼀下<code>hash</code>算法⼲嘛的，<code>hash</code>函数是指把⼀个⼤范围映射到⼀个⼩范围。把⼤范围映射到⼀个⼩范围的⽬的往往是为了 节省空间，使得数据容易保存。</p><p>⽐较出名的有<code>MurmurHash</code>、<code>MD4</code>、<code>MD5</code>等等。</p><p><strong><code>String</code>中<code>hashcode</code>的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hash;<br>    <span class="hljs-keyword">if</span> (h == <span class="hljs-number">0</span> &amp;&amp; value.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">char</span> val[] = value;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; value.length; i++) &#123;<br>            h = <span class="hljs-number">31</span> * h + val[i];<br>        &#125;<br>        hash = h;<br>    &#125;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="hash冲突有哪些解决办法"><a href="#hash冲突有哪些解决办法" class="headerlink" title="hash冲突有哪些解决办法"></a>hash冲突有哪些解决办法</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/qq_48241564/article/details/118613312">解决哈希冲突（四种方法）_君诀的博客-CSDN博客_解决哈希冲突的方法</a></li></ul></blockquote><p>有三个方法：</p><ol><li>开放定址法</li><li>再哈希法</li><li>链地址法</li></ol><h1 id="解决hash冲突的时候，为什么用红黑树？"><a href="#解决hash冲突的时候，为什么用红黑树？" class="headerlink" title="解决hash冲突的时候，为什么用红黑树？"></a>解决<code>hash</code>冲突的时候，为什么用红黑树？</h1><p>当链表过长的时候，如果仍旧使用链表进行搜索和删改，时间复杂度为$O(n)$，所消耗的时间叫较大。</p><p>如果采用了红黑树的设计，则可以使得在数据量较大的情况下，以$O(logn)$的时间复杂度进行搜索和删改，大幅减少使用的时间。</p><h1 id="红黑树的效率高，为什么一开始不用红黑树存储？"><a href="#红黑树的效率高，为什么一开始不用红黑树存储？" class="headerlink" title="红黑树的效率高，为什么一开始不用红黑树存储？"></a>红黑树的效率高，为什么一开始不用红黑树存储？</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/baidu_37147070/article/details/98785367">JDK1.8以后的hashmap为什么在链表长度为8的时候变为红黑树_向日葵班学霸的博客-CSDN博客</a></li></ul></blockquote><p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。</p><p>源码中的注释写的很清楚，因为树节点所占空间是普通节点的两倍，所以只有当节点足够多的时候，才会使用树节点。也就是说，节点少的时候，尽管时间复杂度上，红黑树比链表好一点，但是红黑树所占空间比较大，综合考虑，认为只能在节点太多的时候，红黑树占空间大这一劣势不太明显的时候，才会舍弃链表，使用红黑树。</p><h1 id="不用红黑树，用二叉查找树可以不？"><a href="#不用红黑树，用二叉查找树可以不？" class="headerlink" title="不用红黑树，用二叉查找树可以不？"></a>不用<a href="https://luoyu-ying.github.io/posts/59c5aea57d8c/">红黑树</a>，用二叉查找树可以不？</h1><p>可以。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。</p><h1 id="为什么阈值是8才转为红黑树"><a href="#为什么阈值是8才转为红黑树" class="headerlink" title="为什么阈值是8才转为红黑树"></a>为什么阈值是8才转为红黑树</h1><blockquote><p>   答案参考自：</p><ul><li><a href="https://blog.csdn.net/baidu_37147070/article/details/98785367">JDK1.8以后的hashmap为什么在链表长度为8的时候变为红黑树_向日葵班学霸的博客-CSDN博客</a></li></ul></blockquote><p>源码上说，为了配合使用分布良好的hashCode，树节点很少使用。并且在理想状态下，受随机分布的hashCode影响，链表中的节点<strong>遵循泊松分布</strong>，而且根据统计，<strong>链表中节点数</strong>是8的概率已经接近千分之一，而且此时链表的性能已经很差了。</p><p>所以在这种比较罕见和极端的情况下，才会把链表转变为红黑树。因为链表转换为红黑树也是需要消耗性能的，特殊情况特殊处理，为了挽回性能，权衡之下，才使用红黑树，提高性能。</p><p>也就是大部分情况下，hashmap还是使用的链表，如果是理想的均匀分布，节点数不到8，hashmap就自动扩容了。为什么这么说呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;<br>    <span class="hljs-type">int</span> n, index; Node&lt;K,V&gt; e;<br>    <br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        resize();<br><span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <br>   <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>在链表转变为红黑树方法中，有这样一个判断，数组长度小于<code>MIN_TREEIFY_CAPACITY = 64</code>，就会扩容，而不是直接转变为红黑树，可不是什么链表长度为8就变为红黑树，要仔细看代码，还有别的条件。</p><p>现在回头想想，为啥用8？</p><p><strong>因为通常情况下，链表长度很难达到8，但是特殊情况下链表长度为8，哈希表容量又很大，造成链表性能很差的时候，只能采用红黑树提高性能，这是一种应对策略。</strong></p><h1 id="为什么退化为链表的阈值是6"><a href="#为什么退化为链表的阈值是6" class="headerlink" title="为什么退化为链表的阈值是6"></a>为什么退化为<a href="https://luoyu-ying.github.io/posts/59c5aea57d8c/">链表</a>的阈值是6</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/a7a76c5b8435">HashMap系列：树化阀值8，退化阀值6 - 简书 (jianshu.com)</a></li></ul></blockquote><p>如果不设退化阀值，只以8来树化与退化：<br> 那么8将成为一个临界值，时而树化，时而退化，此时会非常影响性能，因此，我们需要一个比8小的退化阀值；</p><p>UNTREEIFY_THRESHOLD &#x3D; 7<br> 同样，与上面的情况没有好多少，仅相差1个元素，仍旧会在链表与树之间反复转化；</p><p>那为什么是6呢？<br> 源码中也说了，考虑到内存（树节点比普通节点内存大2倍，以及避免反复转化），所以，退化阀值最多为6。</p><h1 id="HashMap中put如何实现的"><a href="#HashMap中put如何实现的" class="headerlink" title="HashMap中put如何实现的"></a><code>HashMap</code>中<code>put</code>如何实现的</h1><p><code>put</code> 方法中会实现以下的过程：</p><ol><li>如果 <code>table</code> 没有初始化，就先进行初始化（<code>resize</code>）操作。</li><li>对 <code>key</code> 进行 <code>hash</code>，并计算出存放位置 <code>index</code> (<code>i = (n - 1) &amp; hash</code>)。</li><li>如果没碰撞直接放到<code>bucket</code>中。</li><li>如果发生碰撞了，就遍历链表：<ol><li>如果出现了key相同，value不同的节点，就替换该value(保证key的唯⼀性)。</li><li>否则直接加入到链表的结尾（<strong>尾插法</strong>）。</li></ol></li><li>如果链表过长(大于等于<code>TREEIFY_THRESHOLD</code>)，就把链表转换成红黑树(<code>JDK1.8</code>中的改动)。</li><li>如果<code>bucket</code>满了(超过<code>DEFAULT_LOAD_FACTOR</code> * <code>CAPACITY</code>)，就要<code>resize</code>。</li></ol><h1 id="HashMap中get如何实现的"><a href="#HashMap中get如何实现的" class="headerlink" title="HashMap中get如何实现的"></a><code>HashMap</code>中<code>get</code>如何实现的</h1><p><code>get</code> 方法中会实现以下的过程：</p><ol><li>判断<code>table</code>是否为<code>null</code>，若为<code>null</code>，则直接返回<code>null</code>。</li><li>计算<code>key</code>的<code>hash</code>，并计算存放位置。</li><li>直接判断第一个元素是否为自己所需要的元素。如果是，则直接返回该节点。</li><li>如果有冲突，则通过<code>key.equals(k)</code>去查找对应的<code>Entry</code>。<ol><li>若为树，则<strong>在树中</strong>通过<code>key.equals(k)</code>查找，时间复杂度为 $O(logn)$。</li><li>若为链表，则<strong>在链表中</strong>通过<code>key.equals(k)</code>查找，时间复杂度为 $O(n)$。</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;<br>    <span class="hljs-comment">// 判断 表是否为空，表重读是否大于零，并且根据此 key 对应的表内是否存在 Node节点。    </span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-comment">// 检查第一个Node 节点，若是命中则不需要进行do... whirle 循环。</span><br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-comment">//树形结构，采用 对应的检索方法，进行检索。</span><br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">//链表方法 做while循环，直到命中结束或者遍历结束。</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="链表的查找的时间复杂度是多少"><a href="#链表的查找的时间复杂度是多少" class="headerlink" title="链表的查找的时间复杂度是多少"></a>链表的查找的时间复杂度是多少</h1><p>时间复杂度为 $O(n)$。</p><h1 id="HashMap在什么条件下扩容"><a href="#HashMap在什么条件下扩容" class="headerlink" title="HashMap在什么条件下扩容"></a><code>HashMap</code>在什么条件下扩容</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.cnblogs.com/yanzige/p/8392142.html">深入理解HashMap的扩容机制 - 颜子歌 - 博客园 (cnblogs.com)</a></li></ul></blockquote><p>Java8不再像Java7中那样需要满足两个条件，Java8中扩容只需要满足一个条件：</p><p><strong>当前存放新值<em>（注意不是替换已有元素位置时）</em>的时候已有元素的个数大于等于阈值（已有元素等于阈值，下一个存放后必然触发扩容机制）</strong></p><p>注：</p><ol><li>扩容一定是放入新值的时候，该新值不是替换以前位置的情况下（说明：<code>put(&quot;name&quot;,&quot;zhangsan&quot;)</code>，而map里面原有数据<code>&lt;&quot;name&quot;,&quot;lisi&quot;&gt;</code>，则该存放过程就是替换一个原有值，而不是新增值，则不会扩容）。</li><li>扩容发生在存放后，即是数据存放后（先存放后扩容），判断当前存入对象的个数，如果大于阈值则进行扩容。</li></ol><h1 id="为什么扩容是2的次幂"><a href="#为什么扩容是2的次幂" class="headerlink" title="为什么扩容是2的次幂"></a>为什么扩容是<strong>2的次幂</strong></h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/weixin_44273302/article/details/113733422">HashMap初始容量为什么是2的n次幂及扩容为什么是2倍的形式？_喜欢敲代码的Apollo的博客-CSDN博客</a></li></ul></blockquote><ol><li><p>得到的新的数组索引和老数组索引只有最高位区别，更快地得到新索引。</p></li><li><p>rehash 时的取余操作，<code>hash % length == hash &amp; (length - 1)</code> 这个关系只有在 length 等于二的幂次方时成立，位运算能比%高效得多。</p></li></ol><p><strong>HashMap#resize 源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HashMap#resize</span><br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> newCapacity)</span> &#123;<br>    HashMapEntry[] oldTable = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> oldTable.length;<br>    <span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;<br>        threshold = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    HashMapEntry[] newTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMapEntry</span>[newCapacity]; <span class="hljs-comment">// 新建一个数组</span><br>    transfer(newTable); <span class="hljs-comment">// 完成新旧数组拷贝</span><br>    table = newTable;<br>    threshold = (<span class="hljs-type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);<br>&#125;<br><br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(HashMapEntry[] newTable)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> newTable.length;<br>    <span class="hljs-keyword">for</span> (HashMapEntry&lt;K,V&gt; e : table) &#123; <span class="hljs-comment">// 遍历整个数组</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">null</span> != e) &#123; <span class="hljs-comment">// 将同一个位置的元素按链表顺序取出</span><br>            HashMapEntry&lt;K,V&gt; next = e.next; <span class="hljs-comment">// 先将当前元素指向的下一个元素存起来，一个一个存放到新表的位置中，记住不一定是同一位置，因为长度变了</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(e.hash, newCapacity); <span class="hljs-comment">// 根据新数组长度，重新生成数组索引</span><br>            e.next = newTable[i]; <span class="hljs-comment">// 将当前位置的元素链表头指向即将新加入的元素，</span><br>            newTable[i] = e; <span class="hljs-comment">// 然后放入数组中，完成同一位置元素链表的拼接，最先添加的元素总在链表末尾</span><br>            e = next; <span class="hljs-comment">// 然后继续循环，拿出下一个元素</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="为什么HashMap线程不安全"><a href="#为什么HashMap线程不安全" class="headerlink" title="为什么HashMap线程不安全"></a>为什么<code>HashMap</code>线程不安全</h1><p>HashMap 没有通过锁的方式使得同一时间只有一个线程可以访问，如果多个线程同一时间对同一个元素进行修改，便会出现结果错误的情况。</p><h1 id="处理HashMap线程不安全"><a href="#处理HashMap线程不安全" class="headerlink" title="处理HashMap线程不安全"></a>处理<code>HashMap</code>线程不安全</h1><ol><li>在之前使用<code>HashTable</code>。 在每一个函数前面都加上了 <code>synchronized</code> 但是<strong>效率太低</strong>我们现在不常用了。</li><li>使用 <code>ConcurrentHashmap</code>。用于提高效率。</li></ol><hr><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><code>ConcurrentHashMap</code></h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://cloud.tencent.com/developer/article/1873182">ConcurrentHashMap（JDK8） - 云+社区 - 腾讯云 (tencent.com)</a></li></ul></blockquote><p><font size="5"><strong>对比</strong></font></p><p><font size="4"><strong>与 HashMap 的区别是什么？</strong></font></p><p>ConcurrentHashMap 是 HashMap 的升级版，HashMap 是线程不安全的，而 ConcurrentHashMap 是线程安全。而其他功能和实现原理和 HashMap 类似。</p><p><font size="4"><strong>与 Hashtable 的区别是什么？</strong></font></p><p>Hashtable 也是线程安全的，但每次要锁住整个结构，并发性低。相比之下，ConcurrentHashMap 获取 size 时才锁整个对象。</p><p>Hashtable 对 get&#x2F;put&#x2F;remove 都使用了同步操作。ConcurrentHashMap 只对 put&#x2F;remove 同步。</p><p>Hashtable 是快速失败的，遍历时改变结构会报错 ConcurrentModificationException。ConcurrentHashMap 是安全失败，允许并发检索和更新。</p><p><font size="4"><strong>JDK8 的 ConcurrentHashMap 和 JDK7 的 ConcurrentHashMap 有什么区别？</strong></font></p><ol><li>JDK8 中新增了红黑树 </li><li>JDK7 中使用的是头插法，JDK8 中使用的是尾插法 </li><li>JDK7 中使用了分段锁，而 JDK8 中没有使用分段锁了 </li><li>JDK7 中使用了ReentrantLock，JDK8 中没有使用 ReentrantLock 了，而使用了 Synchronized </li><li>JDK7 中的扩容是每个 Segment 内部进行扩容，不会影响其他 Segment，而 JDK8 中的扩容和 HashMap 的扩容类似，只不过支持了多线程扩容，并且保证了线程安全</li></ol><p><font size="5"><strong>特性</strong></font></p><p><font size="4"><strong>ConcurrentHashMap 是如何保证并发安全的？</strong></font></p><p>JDK7 中 ConcurrentHashMap 是通过 <strong>ReentrantLock+CAS+分段思想</strong> 来保证的并发安全的，ConcurrentHashMap 的 put 方法会通过 CAS 的方式，把一个 Segment 对象存到 Segment 数组中，一个 Segment 内部存在一个 HashEntry 数组，相当于分段的 HashMap，Segment 继承了 ReentrantLock，每段 put 开始会加锁。</p><p>在 JDK7 的 ConcurrentHashMap 中，首先有一个 Segment 数组，存的是 Segment 对象，Segment 相当于一个小 HashMap，Segment 内部有一个 HashEntry 的数组，也有扩容的阈值，同时 Segment 继承了 ReentrantLock 类，同时在 Segment 中还提供了 put、get 等方法，比如 Segment 的 put 方法在一开始就会去加锁，加到锁之后才会把 key、value 存到 Segment 中去，然后释放锁。同时在ConcurrentHashMap 的 put 方法中，会通过 CAS 的方式把一个 Segment 对象存到 Segment 数组的某个位置中。同时因为一个 Segment 内部存在一个 HashEntry 数组，所以和 HashMap 对比来看，相当于分段了，每段里面是一个小的 HashMap，每段公用一把锁，同时在ConcurrentHashMap 的构造方法中是可以设置分段的数量的，叫做并发级别 concurrencyLevel。</p><p>JDK8 中 ConcurrentHashMap 是通过 <strong>synchronized+CAS</strong> 来实现了。在 JDK8 中只有一个数组，就是 Node 数组，Node 就是 key、value、hashcode 封装出来的对象，和 HashMap 中的 Entry 一样，在 JDK8 中通过对 Node 数组的某个 index 位置的元素进行同步，达到该 index 位置的并发安全。同时内部也利用了 CAS 对数组的某个位置进行并发安全的赋值。</p><p><font size="4"><strong>JDK8 中的 ConcurrentHashMap 为什么使用 synchronized 来进行加锁？</strong></font></p><p>JDK8 中使用 synchronized 加锁时，是对链表头结点和红黑树根结点来加锁的，而 ConcurrentHashMap 会保证，数组中某个位置的元素一定是链表的头结点或红黑树的根结点，所以 JDK8 中的 ConcurrentHashMap 在对某个桶进行并发安全控制时，只需要使用 synchronized 对当前那个位置的数组上的元素进行加锁即可，对于每个桶，只有获取到了第一个元素上的锁，才能操作这个桶，不管这个桶是一个链表还是红黑树。</p><p>相比于 JDK7 中使用 ReentrantLock 来加锁，因为 JDK7 中使用了分段锁，所以对于一个 ConcurrentHashMap 对象而言，分了几段就得有几个 ReentrantLock 对象，表示得有对应的几把锁。</p><p>而 JDK8 中使用 synchronized 关键字来加锁就会更节省内存，并且 JDK 也已经对 synchronized 的底层工作机制进行了优化，效率更好。</p><p><font size="4"><strong>JDK7 中的 ConcurrentHashMap 是如何扩容的？</strong></font></p><p>JDK7 中的 ConcurrentHashMap 和 JDK7 的 HashMap 的扩容是不太一样的。首先 JDK7 中也是支持多线程扩容的，原因是 JDK7 中的 ConcurrentHashMap 分段了，每一段叫做 Segment 对象，每个 Segment 对象相当于一个 HashMap，分段之后，对于 ConcurrentHashMap 而言，能同时支持多个线程进行操作，前提是这些操作的是不同的 Segment，而 ConcurrentHashMap 中的扩容是仅限于本 Segment，也就是对应的小型 HashMap 进行扩容，所以是可以多线程扩容的。</p><p>每个 Segment 内部的扩容逻辑和 HashMap 中一样。</p><p><font size="4"><strong>JDK8 中的 ConcurrentHashMap 是如何扩容的？</strong></font></p><p>首先，JDK8 中是支持多线程扩容的，JDK8 中的 ConcurrentHashMap 不再是分段，或者可以理解为每个桶为一段，在需要扩容时，首先会生成一个双倍大小的数组，生成完数组后，线程就会开始转移元素，在扩容的过程中，如果有其他线程在 put，那么这个 put 线程会帮助去进行元素的转移，虽然叫转移，但是其实是基于原数组上的 Node 信息去生成一个新的 Node 的，也就是原数组上的 Node 不会消失，因为在扩容的过程中，如果有其他线程在 get 也是可以的。</p><p><font size="4"><strong>JDK8 中的 ConcurrentHashMap 有一个 CounterCell，你是如何理解的？</strong></font></p><p>CounterCell 是 JDK8 中用来统计 ConcurrentHashMap 中所有元素个数的，在统计 ConcurentHashMap 时，不能直接对 ConcurrentHashMap 对象进行加锁然后再去统计，因为这样会影响 ConcurrentHashMap 的 put 等操作的效率，在 JDK8 的实现中使用了 <strong>CounterCell+baseCount</strong> 来辅助进行统计，baseCount 是 ConcurrentHashMap 中的一个属性，某个线程在调用 ConcurrentHashMap 对象的 put 操作时，会先通过 CAS 去修改 baseCount 的值，如果 CAS 修改成功，就计数成功，如果 CAS 修改失败，则会从 CounterCell 数组中随机选出一个 CounterCell 对象，然后利用 CAS 去修改 CounterCell 对象中的值，因为存在 CounterCell 数组，所以，当某个线程想要计数时，先尝试通过 CAS 去修改 baseCount 的值，如果没有修改成功，则从 CounterCell 数组中随机取出来一个 CounterCell 对象进行 CAS 计数，这样在计数时提高了效率。</p><p>所以 ConcurrentHashMap 在统计元素个数时，就是 baseCount 加上所有 CountCeller 中的 value 值，所得的和就是所有的元素个数。</p><h1 id="key-可以是-null-吗，value-可以是-null-吗"><a href="#key-可以是-null-吗，value-可以是-null-吗" class="headerlink" title="key 可以是 null 吗，value 可以是 null 吗"></a>key 可以是 <code>null</code> 吗，<code>value</code> 可以是 <code>null</code> 吗</h1><p>当然都是可以的，但是对于 <code>key</code>来说只能运行出现一个<code>key</code>值为<code>null</code>，但是可以出现多个<code>value</code>值为<code>null</code>。</p><h1 id="一般用什么值作为key值？"><a href="#一般用什么值作为key值？" class="headerlink" title="一般用什么值作为key值？"></a>一般用什么值作为<code>key</code>值？</h1><p>一般用 Integer、String 这种不可变类当 HashMap 当 key，⽽且 String 最为常用。</p><ol><li>因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。 这就使得字符串很适合作为 Map 中的键，字符串的处理速度要快过其它的键对象。 这就是 HashMap 中的键往往都使用字符串。</li><li>因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是⾮常重要的，这些类已经很规范的覆写了 hashCode() 以及 equals() 方法。</li></ol><h1 id="用可变类当-Hashmap-的-key-会有什么问题"><a href="#用可变类当-Hashmap-的-key-会有什么问题" class="headerlink" title="用可变类当 Hashmap 的 key 会有什么问题"></a>用可变类当 <code>Hashmap</code> 的 <code>key</code> 会有什么问题</h1><p><code>hashcode</code> 可能会发生变化，导致 <code>put</code> 进行的值，无法 <code>get</code> 出来。</p>]]></content>
    
    
    <categories>
      
      <category>面试整理-2022</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HashMap</tag>
      
      <tag>ConcurrentHashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>View 事件分发的那些问题</title>
    <link href="/posts/0403f1031cdf/"/>
    <url>/posts/0403f1031cdf/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/qq_40959750/article/details/119218780">View事件分发相关面试题_打架不行的二哈的博客-CSDN博客_事件分发机制面试题</a></li></ul></blockquote><hr><h1 id="View事件分发机制"><a href="#View事件分发机制" class="headerlink" title="View事件分发机制"></a><code>View</code>事件分发机制</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://luoyuy.top/posts/ca3478f63a25/">View 的事件体系 - 洛语 の Blog (luoyuy.top)</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/22046c435b7d49f29b7ad04214c4c2fb.png"></p><blockquote><p>  以下内容原文链接：<a href="https://blog.csdn.net/muanye5091/article/details/108019063">言简意赅的View分发机制_view事件分发机制_兜哥的博客-CSDN博客</a></p></blockquote><p>当一个 <code>Touch</code> 事件来到时，首先 <code>Activity</code> 的 <code>dispatchTouchEvent</code> 方法会被触发，如果在 <code>Activity</code> 中没有重写该方法，那么这个方法最终会走到 <code>ViewGroup#dispatchTouchEvent</code> 中进行分发处理：</p><ol><li><p>首先会判断是否已经有子 <code>View</code> 拦截过该方法。</p></li><li><p>如果已有子 <code>View</code> 拦截了该事件，则后续的 <code>move</code> 和 <code>up</code> 事件都由这个 <code>ViewGroup</code> 处理，他的 <code>onTouchEvent</code> 被调用。</p></li><li><p>如果该事件没有被拦截过，他就会遍历他下面的子 <code>View</code>，然后调用子 <code>View</code> 的 <code>dispatchTouchEvent</code> 方法，若返回了 <code>true</code>，代表该  <code>View</code> 处理了事件，并将 <code>mFirstTouchTarget</code> 赋值为空，若为 <code>false</code> 则继续遍历分发（若还有子 <code>View</code> 的话）。</p></li><li><p>若遍历了所有的子 <code>View</code>，都没有被合适处理，则根 <code>View</code> 会自己来处理，<code>Activity</code> 的 <code>onTouchEvent</code> 会被触发。</p></li></ol><h1 id="事件是先到-DecorView-还是先到-Window"><a href="#事件是先到-DecorView-还是先到-Window" class="headerlink" title="事件是先到 DecorView 还是先到 Window"></a>事件是先到 <code>DecorView</code> 还是先到 <code>Window</code></h1><p>由上述流程图中可以得知，事件的分发顺序为 </p><p><code>Activity -&gt; Window -&gt; DecorView -&gt; ViewGroup -&gt; View</code></p><h1 id="View的onTouchEvent、OnClickListerner和OnTouchListener的onTouch方法的三者优先级"><a href="#View的onTouchEvent、OnClickListerner和OnTouchListener的onTouch方法的三者优先级" class="headerlink" title="View的onTouchEvent、OnClickListerner和OnTouchListener的onTouch方法的三者优先级"></a><code>View</code>的<code>onTouchEvent</code>、<code>OnClickListerner</code>和<code>OnTouchListener</code>的<code>onTouch</code>方法的三者优先级</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://cloud.tencent.com/developer/article/1333422">Android View的Touch事件分发</a></li></ul></blockquote><p>点击事件的执行顺序为</p><p><code>OnTouchListener.DOWN -&gt; OnTouchEvent.DOWN -&gt; OnTouchListener.MOVE -&gt; OnTouchEvent.MOVE -&gt; OnTouchListener.UP -&gt; OnTouchEvent.UP -&gt; OnClickListener</code></p><p>所以三者的优先级为</p><p><code>OnTouchListener &gt; onTouchEvent &gt; onClick</code></p><h1 id="onTouch-和-onTouchEvent-的区别"><a href="#onTouch-和-onTouchEvent-的区别" class="headerlink" title="onTouch 和 onTouchEvent 的区别"></a><code>onTouch</code> 和 <code>onTouchEvent</code> 的区别</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/huiguixian/article/details/22193977">Android View的onTouchEvent和OnTouch区别_小小攻城师的博客-CSDN博客_ontouch和ontouchevent区别</a></li></ul></blockquote><ol><li><p><code>onTouchListener</code>的<code>onTouch</code>方法优先级比<code>onTouchEvent</code>高，会先触发。</p></li><li><p>假如<code>onTouch</code>方法返回false会接着触发<code>onTouchEvent</code>，反之<code>onTouchEvent</code>方法不会被调用。</p></li><li><p>内置诸如<code>click</code>事件的实现等等都基于<code>onTouchEvent</code>，假如<code>onTouch</code>返回<code>true</code>，这些事件将不会被触发。</p></li></ol><h1 id="Activity-、ViewGroup和View都不消费ACTION-DOWN-那么ACTION-UP事件是怎么传递的"><a href="#Activity-、ViewGroup和View都不消费ACTION-DOWN-那么ACTION-UP事件是怎么传递的" class="headerlink" title="Activity 、ViewGroup和View都不消费ACTION_DOWN,那么ACTION_UP事件是怎么传递的"></a><code>Activity</code> 、<code>ViewGroup</code>和<code>View</code>都不消费<code>ACTION_DOWN</code>,那么<code>ACTION_UP</code>事件是怎么传递的</h1><p>首先，如果大家都不消费 ACTION_DOWN，那么 ACTION_DOWN 的事件传递流程是这样的：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript">-&gt; Activity.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.onInterceptTouchEvent<span class="hljs-function"><span class="hljs-params">()</span></span><br><span class="hljs-function">-&gt;</span> view1.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> view1.onTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.onTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> Activity.onTouchEvent();<br></code></pre></td></tr></table></figure><p>接着，由于大家都不消费 <code>ACTION_DOWN</code>，对于 <code>ACTION_MOVE</code> 和 <code>ACTION_UP</code> 的事件传递是这样的：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">-&gt; Activity.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span></span><br><span class="hljs-function">-&gt;</span> Activity.onTouchEvent();<br>-&gt; 消费<br></code></pre></td></tr></table></figure><h1 id="点击事件被拦截，但是想传到下面的View，如何操作"><a href="#点击事件被拦截，但是想传到下面的View，如何操作" class="headerlink" title="点击事件被拦截，但是想传到下面的View，如何操作"></a>点击事件被拦截，但是想传到下面的<code>View</code>，如何操作</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">getParent().requestDisallowInterceptTouchEvent(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>可将点击事件传到下面的<code>View</code>, 剥夺了父<code>View</code> 对除了<code>ACTION_DOWN</code>以外的事件的处理权。</p><h1 id="如何解决View的事件冲突"><a href="#如何解决View的事件冲突" class="headerlink" title="如何解决View的事件冲突"></a>如何解决<code>View</code>的事件冲突</h1><h2 id="三种出现滑动冲突的情况"><a href="#三种出现滑动冲突的情况" class="headerlink" title="三种出现滑动冲突的情况"></a>三种出现滑动冲突的情况</h2><ol><li><code>内部View</code>与<code>外部View</code>的滑动方向相反。</li><li><code>内部View</code>与<code>外部View</code>的滑动方向相同。</li><li>前两种情况的嵌套。</li></ol><p>三种情况的处理思路：</p><ol><li>通过手势滑动的角度判断滑动的方向。</li><li>通过当前处于的不同的页面状态来判断应该滑动的<code>View</code>。</li><li>通过前两种的综合使用。</li></ol><h2 id="滑动冲突的解决方式"><a href="#滑动冲突的解决方式" class="headerlink" title="滑动冲突的解决方式"></a>滑动冲突的解决方式</h2><h3 id="外部拦截法"><a href="#外部拦截法" class="headerlink" title="外部拦截法"></a>外部拦截法</h3><p>通过重写<strong>父容器的</strong><code>onInterceptTouchEvent</code>方法，所有的事件都先经过父容器的筛选，对其中父容器需要的事件进行拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">intercepted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getX();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getY();<br>    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN : &#123;<br>            intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE : &#123;<br>            <span class="hljs-keyword">if</span> (父容器需要当前的点击事件)<br>                intercepted = <span class="hljs-literal">true</span>;<br>           <span class="hljs-keyword">else</span> <br>                intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP : &#123;<br>            intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span> :<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    mLastXIntercept = x;<br>    mLastYIntercept = y;<br>    <span class="hljs-keyword">return</span> intercepted;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内部拦截法"><a href="#内部拦截法" class="headerlink" title="内部拦截法"></a>内部拦截法</h3><p>父元素拦截除<code>ACTION_DOWN</code>以外的其他事件，当事件到达子元素后，由子元素判断是否需要这些事件，不需要的事件将重新交由父容器来处理。这种方法和Android的事件分发机制不一致，需要配合<code>requestDisallowInterceptTouchEvent</code>方法才能正常的工作。</p><p>相关阅读链接：<a href="https://www.jianshu.com/p/fe3d109eb27e">Android TouchEvent之requestDisallowInterceptTouchEvent - 简书 (jianshu.com)</a></p><p><strong>子元素的<code>dispatchTouchEvent</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getX();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getY();<br>    <br>    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN : &#123;<br>            parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 此子View的所有父ViewGroup会跳过onInterceptTouchEvent回调</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE : &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">deltaX</span> <span class="hljs-operator">=</span> x - mLastX;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">deltaY</span> <span class="hljs-operator">=</span> y - mLastY;<br>            <span class="hljs-keyword">if</span> (父容器需要当前的点击事件) &#123;<br>                parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">false</span>);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP : &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span> : <br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    mLastX = x;<br>    mLastY = y;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.dispatchTouchEvent(event);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>父容器的<code>onInterceptTouchEvent</code>方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> event.getAction();<br>    <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="requestDisallowInterceptTouchEvent的调用时机"><a href="#requestDisallowInterceptTouchEvent的调用时机" class="headerlink" title="requestDisallowInterceptTouchEvent的调用时机"></a><code>requestDisallowInterceptTouchEvent</code>的调用时机</h1><p><strong><code>parent.requestDisallowInterceptTouchEvent</code>的调用需要写在<code>onTouchEvent</code>方法中</strong></p><p>我们一个手势的操作，会经历<code>ACTION_DOWN</code>、<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等操作。</p><p>子<code>view</code>调用<code>requestDisallowInterceptTouchEvent(true)</code>的时间，是必须在能拿到点击事件的时候。</p><p>比如我们在<code>ACTION_DOWN</code>的时候调用了方法，接下来的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>都会直接传递到子<code>view</code>上了；如果是在子<code>view</code>的<code>ACTION_MOVE</code>方法中调用的话，那么要确认父<code>view</code>在<code>ACTION_MOVE</code>的过程中，能否将事件传递给子<code>view</code>就好了。</p><h1 id="同时对父-View-和子-View-设置点击方法，优先响应哪个"><a href="#同时对父-View-和子-View-设置点击方法，优先响应哪个" class="headerlink" title="同时对父 View 和子 View 设置点击方法，优先响应哪个"></a>同时对父 <code>View</code> 和子 <code>View</code> 设置点击方法，优先响应哪个</h1><p>优先响应子 view。</p><p>如果先响应父 view，那么子 view 将永远无法响应。父 view 要优先响应事件，必须先调用 onInterceptTouchEvent 对事件进行拦截，那么事件不会再往下传递，直接交给父 view 的 onTouchEvent 处理。</p><p>Android系统中ViewGroup的拦截事件默认不拦截。</p><h1 id="ACTION-CANCEL什么时候触发"><a href="#ACTION-CANCEL什么时候触发" class="headerlink" title="ACTION_CANCEL什么时候触发"></a><code>ACTION_CANCEL</code>什么时候触发</h1><ol><li><p>如果在父<code>View</code>中拦截<code>ACTION_UP</code>或<code>ACTION_MOVE</code>，在第一次父视图拦截消息的瞬间，父视图指定子视图不接受后续消息了，同时子视图会收到<code>ACTION_CANCEL</code>事件。一般是系统自己处理</p></li><li><p>如果触摸某个控件，但是又不是在这个控件的区域上抬起（移动到别的地方了），就会出现<code>ACTION_CANCEL</code>。</p></li></ol><h1 id="为什么子-View-不消费-ACTION-DOWN-之后的所有事件都不会向下传递了"><a href="#为什么子-View-不消费-ACTION-DOWN-之后的所有事件都不会向下传递了" class="headerlink" title="为什么子 View 不消费 ACTION_DOWN,之后的所有事件都不会向下传递了"></a>为什么子 <code>View</code> 不消费 <code>ACTION_DOWN</code>,之后的所有事件都不会向下传递了</h1><p>答案是：<code>mFirstTouchTarget</code>。</p><p>当子 view 对事件进行处理的时，那么 <code>mFirstTouchTarget</code> 就会被赋值，若是子 <code>view</code> 不对事件进行处理，那么 <code>mFirstTouchTarget</code> 就为 <code>null</code>，之后 <code>VIewGroup</code> 就会默认拦截所有的事件。</p><p>我们可以从 <code>dispatchTouchEvent</code> 中找到如下代码，可以看出来，若是子 <code>View</code> 不处理 <code>ACTION_DOWN</code>,那么之后的事件也不会给到它了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 检查是否拦截</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> intercepted;<br><span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 省略和问题无关代码</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 默认拦截</span><br>    intercepted = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="在-ViewGroup-中的-onTouchEvent-中消费-ACTION-DOWN-事件（onInterceptTouch-默认设置），那么-ACTION-MOVE-和-ACTION-UP-事件是怎么传递的？"><a href="#在-ViewGroup-中的-onTouchEvent-中消费-ACTION-DOWN-事件（onInterceptTouch-默认设置），那么-ACTION-MOVE-和-ACTION-UP-事件是怎么传递的？" class="headerlink" title="在 ViewGroup 中的 onTouchEvent 中消费 ACTION_DOWN 事件（onInterceptTouch 默认设置），那么 ACTION_MOVE 和 ACTION_UP 事件是怎么传递的？"></a>在 <code>ViewGroup</code> 中的 <code>onTouchEvent</code> 中消费 <code>ACTION_DOWN</code> 事件（<code>onInterceptTouch</code> 默认设置），那么 <code>ACTION_MOVE</code> 和 <code>ACTION_UP</code> 事件是怎么传递的？</h1><p>首先，我们先分析一下 ACTION_DOWN 的事件走向，由于 ViewGroup 中的 onInterceptTouch 是默认设置的，那么 ACTION_DOWN 的事件最终在 ViewGroup 中的 onTouchEvent 方法中停止了，事件走向是这样的：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">-&gt; Activity.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.onInterceptTouchEvent<span class="hljs-function"><span class="hljs-params">()</span></span><br><span class="hljs-function">-&gt;</span> view1.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> view1.onTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.onTouchEvent() <br></code></pre></td></tr></table></figure><p>接着 ACTION_MOVE 和 ACTION_UP 的事件分发流程，之后 onInterceptTouch 和 View 中的方法都不会被调用了，事件分发如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">-&gt; Activity.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.dispatchTouchEvent<span class="hljs-function"><span class="hljs-params">()</span> </span><br><span class="hljs-function">-&gt;</span> ViewGroup1.onTouchEvent() <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>面试整理-2022</category>
      
    </categories>
    
    
    <tags>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单了解 Animation</title>
    <link href="/posts/1b15630c9502/"/>
    <url>/posts/1b15630c9502/</url>
    
    <content type="html"><![CDATA[<h1 id="动画的类型"><a href="#动画的类型" class="headerlink" title="动画的类型"></a>动画的类型</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/luzaiyy611/article/details/82083213">Android 属性动画和补间动画的区别和特性_luzaiyy611的博客-CSDN博客_属性动画和补间动画的区别</a></li></ul></blockquote><ol><li><p>View 动画（补间动画）</p><p>只产生了一个动画效果，其真实的坐标并没有发生改变（只是改变了View的显示效果而已，并不会真正的改变View的属性）。View做在做动画的时候，它并没有真正的移动它的位置，而是根据动画时间的插值，计算出一个Matrix，然后不停的invalidate，在onDraw中的Canvas上使用这个计算出来的Matrix去draw这个View的内容，并有onLayout中还是原来的位置，所以点击事件只能点击到原来的位置才能触发</p></li><li><p>帧动画</p></li><li><p>属性动画</p><p>属性动画可以对任何对象的属性做动画而不仅仅是View，甚至可以没有对象。除了作用对象进行扩展外，属性动画的效果也加强了，不仅能实现View动画的四种效果，还能实现其它多种效果，这些效果都是通过<code>ValueAnimator</code>或<code>ObjectAnimator</code>、<code>AnimatorSet</code>等来实现的。我们只需要告诉系统动画的运行时长，需要执行哪种类型的动画，以及动画的初始值和结束值，剩下的工作就可以全部交给系统去完成了。</p></li></ol><hr><h1 id="补间动画和属性动画的区别"><a href="#补间动画和属性动画的区别" class="headerlink" title="补间动画和属性动画的区别"></a>补间动画和属性动画的区别</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.cnblogs.com/lgdcoder/p/10684996.html">Android补间动画和属性动画的区别及属性动画使用详解</a></li></ul></blockquote><ol><li>作用对象不同，补间动画只能作用在view上，属性动画可以作用在所有对象上。</li><li>属性变化不同，补间动画只是改变显示效果，不会改变view的属性，比如位置、宽高等，而属性动画实际改变对象的属性。</li><li>动画效果不同，补间动画只能实现位移、缩放、旋转和透明度四种动画操作，而属性动画还能实现补间动画所有效果及其他更多动画效果。</li></ol><hr><h1 id="ObjectAnimator，ValueAnimator及其区别"><a href="#ObjectAnimator，ValueAnimator及其区别" class="headerlink" title="ObjectAnimator，ValueAnimator及其区别"></a><code>ObjectAnimator</code>，<code>ValueAnimator</code>及其区别</h1><p><strong>ValueAnimator</strong></p><p>ValueAnimator是整个属性动画机制当中最核心的一个类，前面我们已经提到了，属性动画的运行机制是通过不断地<strong>对值进行操作</strong>来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等，确实是一个非常重要的类。</p><p><strong>ObjectAnimator</strong></p><p>相比于ValueAnimator，ObjectAnimator可能才是我们最常接触到的类，因为ValueAnimator只不过是对值进行了一个平滑的动画过渡，但我们实际使用到这种功能的场景好像并不多。而ObjectAnimator则就不同了，它是可以直接<strong>对任意对象的任意属性进行动画操作</strong>的，比如说View的alpha属性。</p><p>不过虽说ObjectAnimator会更加常用一些，但是它其实是继承自ValueAnimator的，底层的动画实现机制也是基于ValueAnimator来完成的，因此ValueAnimator仍然是整个属性动画当中最核心的一个类。</p><p><strong>总结</strong></p><p><code>ValueAnimator</code> 是<strong>对 数值 进行平滑操作</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ValueAnimator</span> <span class="hljs-variable">anim</span> <span class="hljs-operator">=</span> ValueAnimator.ofFloat(<span class="hljs-number">0f</span>, <span class="hljs-number">1f</span>);  <br></code></pre></td></tr></table></figure><p><code>ObjectAnimator</code> 功能更加强大，是<strong>对 任意对象 的 任意属性值 进行平滑操作</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectAnimator</span> <span class="hljs-variable">animator</span> <span class="hljs-operator">=</span> ObjectAnimator.ofFloat(textview, <span class="hljs-string">&quot;alpha&quot;</span>, <span class="hljs-number">1f</span>, <span class="hljs-number">0f</span>, <span class="hljs-number">1f</span>);<br></code></pre></td></tr></table></figure><hr><h1 id="TimeInterpolator插值器，TypeEvaluator估值器"><a href="#TimeInterpolator插值器，TypeEvaluator估值器" class="headerlink" title="TimeInterpolator插值器，TypeEvaluator估值器"></a>TimeInterpolator插值器，TypeEvaluator估值器</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://luoyuy.top/posts/ac02c3bbb00b/">Android 动画深入分析 - 洛语 の Blog (luoyuy.top)</a></li></ul></blockquote><p>插值器和估值器是实现非匀速动画的重要手段。</p><h3 id="TimeInterpolator"><a href="#TimeInterpolator" class="headerlink" title="TimeInterpolator"></a><code>TimeInterpolator</code></h3><p>时间插值器。作用为<strong>根据时间的流逝的百分比计算当前属性值改变的百分比</strong>。</p><p>预设的有多种插值器，常见的三种如下：</p><ol><li><code>LinearInterpolator</code>——线性插值器：匀速动画</li><li><code>AccelerateDecelerateInterpolator</code>——加速减速插值器：动画两头慢中间快</li><li><code>DecelerateInterpolator</code>——减速插值器：动画越来越慢</li></ol><p>三个类都实现了<code>Interpolartor</code>接口，接口内部只有一个用来计算属性值的改变的百分比的<code>getInterpolation</code>方法需要实现。</p><h3 id="TypeEvaluator"><a href="#TypeEvaluator" class="headerlink" title="TypeEvaluator"></a><code>TypeEvaluator</code></h3><p>类型估值算法，也叫估值器。作用是<strong>根据属性值改变的百分比来计算改变后的属性值</strong>。</p><p>系统预置的有3种：</p><ol><li><code>IntEvaluator</code>：针对整形属性</li><li><code>FloatEvaluator</code>：针对浮点型属性</li><li><code>ArgbEvaluator</code>：针对Color属性</li></ol><p>三个类都实现了<code>TypeEvalator</code>接口，接口内部只有一个用来计算改变后的属性值的<code>evaluate</code>方法需要实现。</p><h3 id="计算顺序"><a href="#计算顺序" class="headerlink" title="计算顺序"></a>计算顺序</h3><p>系统会根据当前的帧所在时刻与动画播放的总时间求出时间的流逝的百分比，再通过插值器计算出当前属性值改变的百分比，后用此值通过估值器计算出当前的属性改变后的确定的值是多少并通过<code>set</code>方法对属性赋值。</p><p>故属性动画要求对象的该属性有<code>set</code>方法（必须有）和<code>get</code>方法（可选）。</p><hr><h1 id="自定义插值器和估值器"><a href="#自定义插值器和估值器" class="headerlink" title="自定义插值器和估值器"></a>自定义插值器和估值器</h1><p>我们可以自定义插值器和估值器，来实现自己想要的动画效果。实现方式也很简单。</p><p>因为插值器和估值器都是一个接口，且内部都只有一个方法，所以我们只需要派生一个类并实现接口就可以了，然后就可以做出千奇百怪的动画效果了。即：</p><ul><li>自定义插值器需要实现<code>Interpolator</code>或者<code>TimeInterpolator</code>接口</li><li>自定义估值器需要实现<code>TypeEvaluator</code>接口。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>面试整理-2022</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Animation</tag>
      
      <tag>属性动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅答 View 绘制部分面试知识点</title>
    <link href="/posts/00e069ccc001/"/>
    <url>/posts/00e069ccc001/</url>
    
    <content type="html"><![CDATA[<h1 id="View-的绘制流程"><a href="#View-的绘制流程" class="headerlink" title="View 的绘制流程"></a>View 的绘制流程</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://luoyu-ying.github.io/posts/19429a22b2b2/">View 的绘制原理 | 洛语 の Blog (luoyu-ying.github.io)</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-3d1255a5093de81fd5bdc27a300d2f0d_720w.jpg"></p><h1 id="MeasureSpec-是什么"><a href="#MeasureSpec-是什么" class="headerlink" title="MeasureSpec 是什么"></a><code>MeasureSpec</code> 是什么</h1><blockquote><p>  <code>spec</code> <strong><code>英[spek]</code></strong><code>n.</code>规格 <code>vt.</code>按特定标准设计并制造</p></blockquote><p><code>MeasureSpec</code>参与了<code>View</code>的<code>measure</code>过程。在测量过程中，系统将<code>View</code>的<code>LayoutParams</code>根据父容器所施加的规则转换成对应的<code>MeasureSpec</code>，然后再根据这个<code>MeasureSpec</code>来测量出<code>View</code>的测量宽&#x2F;高。</p><p><code>MeasureSpec</code>代表一个32位的<code>int</code>值，高两位代表 测量模式<code>SpecMode</code>，低30位代表 该测量模式下的规格大小<code>SpecSize</code>。</p><p><code>MeasureSpec</code>与<code>SpecMode</code>、<code>SpecSize</code>之间可以通过位运算互相求出。</p><p>每个<code>View</code>的<code>measure</code>过程之前都会先计算其<code>MeasureSpec</code>的值，然后再对其进行<code>measure</code>。</p><p><strong>注意</strong>：<code>View</code>的宽和高各有一个<code>MeasureSpec</code>值，分别为<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>。</p><p><strong><code>SpecMode</code>的三种状态</strong></p><ol><li><p><code>UNSPECIFIED</code></p><p>父容器不对<code>View</code>做任何的限制，要多大给多大。<strong>这种情况一般用于系统的内部</strong>，表示一种测量方式的状态。</p></li><li><p><code>EXACTLY</code></p><p>父容器已经测出了<code>View</code>所需要的精确大小，此时的大小就是<code>View</code>的最终大小。</p><p>它对应于<code>LayoutParams</code>的<code>match_parent</code>和具体的数值这两种模式。</p></li><li><p><code>AT_MOST</code></p><p>父容器指定了一个可用的大小，<code>View</code>的大小不能大于这个值。</p><p>它对应于<code>LayoutParams</code>中的<code>wrap_content</code>。</p></li></ol><h1 id="子View创建MeasureSpec创建规则是什么"><a href="#子View创建MeasureSpec创建规则是什么" class="headerlink" title="子View创建MeasureSpec创建规则是什么"></a>子View创建<code>MeasureSpec</code>创建规则是什么</h1><p><strong><code>MeasureSpec</code>和<code>LayoutParams</code>的对应关系</strong></p><p>对于<code>DecorView</code>和普通<code>View</code>来说，<code>MeasureSpec</code>的转化过程略有不同。</p><p><strong>对于<code>DecorView</code>：</strong></p><p><strong><code>DecorView</code>的<code>MeasureSpec</code>由窗口的大小和<code>DecorView</code>自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在<code>ViewRootImpl</code>中的<code>measureHierarchy</code>方法中，调用<code>getRootMeasureSpec</code>方法，获得<code>DecorView</code>的<code>MeasureSpec</code>。</p><p>其中<code>getRootMeasureSpec</code>方法中，根据自身<code>LayoutParams</code>的不同大小，共有三种情况：</p><ol><li><code>LayoutParams.MATCH_PARENT</code>：精确模式，大小就是窗口的大小。</li><li><code>LayoutParams.WRAP_CONTENT</code>：最大模式，大小不定，但是不能超过窗口的大小。</li><li>固定大小(比如100dp)：精确模式，大小为<code>LayoutParams</code>中指定的大小。</li></ol><p><strong>对于普通<code>View</code>：</strong></p><p><strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在父容器的<code>measureChildWithMargins</code>中的<code>getChildMeasureSpec</code>方法获得<code>View</code>的<code>MeasureSpec</code>。</p><p>其中<code>getChildMeasureSpec</code>方法的参数中使用到了父容器的<code>MeasureSpec</code>。在这个方法中通过<code>switch</code>和<code>if</code>语句，对<code>View</code>的<code>MeasureSpec</code>进行了决定。结果如下：</p><table><thead><tr><th>↓<code>childLayoutParams</code> \ <code>parentMeasureSpec</code>→</th><th><code>EXACTLY</code></th><th><code>AT_MOST</code></th><th><code>UNSPECIFIED</code></th></tr></thead><tbody><tr><td><code>dp</code>&#x2F;<code>px</code></td><td><code>EXACTLY</code><br>childSize</td><td><code>EXACTLY</code><br/>childSize</td><td><code>EXACTLY</code><br/>childSize</td></tr><tr><td><code>match_parent</code></td><td><code>EXACTLY</code><br/>parentSize</td><td><code>AT_MOST</code><br>parentSize</td><td><code>UNSPECIFIED</code><br>0</td></tr><tr><td><code>wrap_content</code></td><td><code>AT_MOST</code><br>parentSize</td><td><code>AT_MOST</code><br/>parentSize</td><td><code>UNSPECIFIED</code><br/>0</td></tr></tbody></table><p>上图可以简单记为：除了<code>dp</code>&#x2F;<code>px</code>的精确模式情况外，三种<code>MeasureSpec</code>的级别为：<code>EXACTLY</code> &lt; <code>AT_MOST</code> &lt; <code>UNSPECIFIED</code> 且<code>childMeasureSpec</code> &#x3D; max(<code>childLayoutParams</code> , <code>parentMeasureSpec</code>)。（<strong>实际上并无级别之分</strong>）</p><p>通过上面的表格，可以更加直观的看出：<strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><h1 id="自定义View-wrap-content不起作用的原因"><a href="#自定义View-wrap-content不起作用的原因" class="headerlink" title="自定义View wrap_content不起作用的原因"></a>自定义View <code>wrap_content</code>不起作用的原因</h1><p>对于直接继承<code>View</code>的自定义<code>View</code>来说，<strong>需要重写<code>onMeasure</code>方法并设置在<code>wrap_content</code>情况时的自身大小</strong>，否则在布局中使用<code>wrap_content</code>就相当于使用<code>match_parent</code>。</p><p>因为当自定义<code>View</code>处于<code>wrap_content</code>时，它的<code>SpecMode</code>为<code>AT_MOST</code>模式，由前文可知，当父容器无论为<code>AT_MOST</code>还是<code>ECACTLY</code>模式时，自定义<code>View</code>都为<code>AT_MOST</code>模式且尺寸大小为<code>parentSize</code>，也就是父容器的剩余空间，即自定义<code>View</code>的大小变得与父容器的剩余空间大小一致，显然不是我们需要的。</p><p><strong>解决方法：</strong></p><p>解决方法也是非常简单的。我们只需要在<code>onMeasure</code>方法中对</p><ol><li>仅<code>width</code>方向为<code>AT_MOST</code>模式</li><li>仅<code>height</code>方向为<code>AT_MOST</code>模式</li><li><code>width</code>方向以及<code>height</code>方向都为<code>AT_MOST</code>模式</li><li>其他的情况</li></ol><p>这四个状态单独判断，分别使用<code>setMeasuredDimension</code>方法直接为自定义<code>View</code>设置我们需要的值即可。</p><p>源码中对于<code>TextView</code>、<code>ImageView</code>等控件的<code>wrap_content</code>也做了特殊的处理。</p><h1 id="在Activity中获取某个View的宽高有几种方法"><a href="#在Activity中获取某个View的宽高有几种方法" class="headerlink" title="在Activity中获取某个View的宽高有几种方法"></a>在Activity中获取某个View的宽高有几种方法</h1><p>由于<code>Activity</code>的启动和<code>View</code>的测量过程并不是同步进行的，因此无法保证在<code>Activity</code>启动时某个<code>View</code>已经测量完毕了。所以我们在<code>Activity</code>启动的时候，如果直接通过<code>getMeasuredWidth</code>&#x2F;<code>getMeasuredHeight</code>方法获得的值可能为0。</p><p>以下有四种方法可以解决这个问题（详细代码见《Android开发艺术探索》190页）。</p><ol><li><p><code>Activity/View#onWindowFocusChanged</code></p><p>在<code>Activity</code>的<code>onResume</code>和<code>onPause</code>方法启动时，<code>onWindowFocusChanged</code>方法也会同时被调用，可以重写里面的内容，使之计算<code>View</code>的宽高。</p><p><strong>注意</strong>：<code>onWindowFocusChanged</code>方法会在<code>View</code>已经初始化完毕后才开始调用。</p></li><li><p><code>view.post(runnable)</code></p><p>通过<code>post</code>可以将一个<code>runnable</code>投递都消息队列的尾部，然后等待<code>Looper</code>调用此<code>runnable</code>的时候，<code>View</code>也已经初始化好了。</p></li><li><p><code>ViewTreeObserver</code></p><p><code>ViewTreeObserver</code>中的众多回调可以完成这个功能。</p><p>比如<code>OnGlobalLayoutListener</code>接口，当<code>View</code>树的状态发生改变或者<code>View</code>树内部的<code>View</code>的可见性发生改变的时候，<code>onGlobalLayout</code>方法将被回调，此时就可以获取<code>View</code>的宽高了。</p></li><li><p><code>view.measure(int widthMeasureSpec, int heightMeasureSpec)</code></p><p>可以主动调用该方法开始计算<code>view</code>的宽高。</p><ol><li><p><strong><code>match_parent</code></strong></p><p>由于正常的<code>measure</code>过程中，我们需要父容器的<code>MeasureSpec</code>的值，而此时父容器并没开始计算，我们无从得知这两个值的大小。故我们无法对<code>match_parent</code>的<code>view</code>计算其宽高。</p></li><li><p><strong><code>dp</code>&#x2F;<code>px</code></strong></p><p>因为有精确的数值了，所以我们可以直接使用这个精确的数值通过<code>MeasureSpec.makeMeasureSpec</code>方法构建<code>view</code>的<code>MeasureSpec</code>。</p></li><li><p><strong><code>wrap_content</code></strong></p><p>直接将<code>MeasureSpec.makeMeasureSpec</code>方法中参数的值设置为<code>(1&lt;&lt;30)-1</code>即可，这是<code>View</code>理论上可以支持的最大值，所以这样构建<code>MeasureSpec</code>是合理的。</p></li></ol></li></ol><h1 id="onCreate、onResume中可以获取View的宽高吗？怎么做？View-post-为什么可以获取？"><a href="#onCreate、onResume中可以获取View的宽高吗？怎么做？View-post-为什么可以获取？" class="headerlink" title="onCreate、onResume中可以获取View的宽高吗？怎么做？View#post 为什么可以获取？"></a><code>onCreate</code>、<code>onResume</code>中可以获取View的宽高吗？怎么做？<br><code>View#post</code> 为什么可以获取？</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/qq_40714317/article/details/117666277">onCreate()、onResume() 中可以获取View的宽高吗？怎么做？ View.post{} 为什么可以获取？_qq_40714317的博客</a></li><li><a href="https://github.com/Moosphan/Android-Daily-Interview/issues/126">2019-08-21：View.post()为什么可以获取到宽高信息？ · Issue #126 · Moosphan&#x2F;Android-Daily-Interview </a></li></ul></blockquote><p><strong><code>onCreate</code>、<code>onResume</code>中可以获取 View 的宽高吗？怎么做？</strong></p><p>View 的测绘绘制流程就是从 ViewRootImpl#performTraversals 开始的，而这个方法的调用是在 onResume 方法之后，所以在 onCreate 和 onResume 方法中拿不到 View 的测量值。</p><p> View 的宽高是在 onLayout 阶段才能最终确定的，而在 Activity#onCreate 中并不能保证 View 已经执行到了 onLayout 方法，也就是说 Activity 的声明周期与View的绘制流程并不是一一绑定。所以 onCreate 和 onResume 中获取不到 View 的宽高值。以 Handler 为基础，View#post 将传入任务的执行时机调整到 View 绘制完成之后。</p><p><strong><code>View#post</code> 为什么可以获取？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">view.post(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">width</span> <span class="hljs-operator">=</span> view.getWidth();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">height</span> <span class="hljs-operator">=</span> view.getHeight();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这样写一般是在 Activity 的 onResume 方法中，因为 onResume 执行在 View 初始化之前，如果在 onResume 中直接获取 View 宽高是获取不到的。</p><p>使用 view#post 就能获取到，因为 view#post 是向主 Handler 的 MessageQueue 中插入一条待执行消息，但是因为系统在 ViewRoot 中初始化 View 时也是利用 Handler 机制，平且为了优先执行 View 的初始化设置了同步屏障，导致 view#post 插入的消息会在 View 初始化之后执行，那么肯定就能获取到 View 的宽高啦！</p><p><strong><code>Runnable</code>的执行时机具体是什么</strong></p><p> 在 <strong>Android 7.0</strong> 之后，view.post()中的runnbale 能确定被执执行。具体来说：</p><p>Android 7.0之后，除了<code>performTraversal</code>中会调用外，在View的<code>dispatchAttachedToWindow</code>中也会调用，但Android 7.0之后不管在主线程还是在子线程都可以成功执行<code>view.post</code>内部逻辑，并不是因为增加了调用时机，而是取消了<code>ThreadLocal</code>机制，使得 <strong>不管在主线程还是子线程调用view.post方法，都会将runnable对象丢到主线程的任务队列中，更新UI或者获取view的信息</strong>。</p><h1 id="View-post与Handler-post的区别"><a href="#View-post与Handler-post的区别" class="headerlink" title="View#post与Handler#post的区别"></a><code>View#post</code>与<code>Handler#post</code>的区别</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/7280b2d3b4d1">Handler.post和View.post的区别 - 简书 (jianshu.com)</a></li></ul></blockquote><ol><li><p><code>Handler.post</code>，它的执行时间基本是等同于<code>onCreate</code>里那行代码触达的时间；</p></li><li><p>View.post，则不同，它说白了执行时间一定是在<code>Activity#onResume</code>发生后才开始算的；或者换句话说它的效果相当于你上面的<code>View.post</code>方法是写在<code>Activity#onResume</code>里面的（但只执行一次，因为<code>onCreate</code>不像onResume会被多次触发）；</p></li><li><p>当然，虽然这里说的是<code>post</code>方法，但对应的<code>postDelayed</code>方法区别也是类似的。</p></li></ol><h1 id="getWidth-方法和getMeasureWidth-方法的区别"><a href="#getWidth-方法和getMeasureWidth-方法的区别" class="headerlink" title="getWidth()方法和getMeasureWidth()方法的区别"></a><code>getWidth()</code>方法和<code>getMeasureWidth()</code>方法的区别</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/7d8a54dd692f">getMeasureWidth和getWidth的区别 - 简书 (jianshu.com)</a></li><li><a href="https://www.cnblogs.com/yongdaimi/p/13612622.html">android: View的getWidth() 和 getMeasureWidth()方法的区别 - 夜行过客 - 博客园 (cnblogs.com)</a></li></ul></blockquote><ol><li><p><code>getMeasureWidth()</code>方法在<code>measure()</code>过程结束后就可以获取到了，而<code>getWidth()</code>方法要在<code>layout()</code>过程结束后才能获取到。<code>getMeasuredWidth()</code>获取的是<code>View</code>原始的大小，也就是这个<code>View</code>在<code>XML</code>文件中配置或者是代码中设置的大小。<code>getWidth()</code>获取的是这个<code>View</code>最终显示的大小，这个大小有可能等于原始的大小，也有可能不相等。只要在代码里重新修改了子控件的摆放位置，<code>getWidth()</code>和<code>getMeasureWidth()</code>的值就会不同。</p></li><li><p><code>getMeasureWidth()</code>方法中的值是通过<code>setMeasuredDimension()</code>方法来进行设置的，而<code>getWidth()</code>方法中的值则是通过视图右边的坐标减去左边的坐标计算出来的。</p></li></ol><h1 id="View加载流程（setContentView）"><a href="#View加载流程（setContentView）" class="headerlink" title="View加载流程（setContentView）"></a>View加载流程（setContentView）</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://blog.csdn.net/pgg_cold/article/details/79481301"> Android面试题（28）-android的view加载和绘制流程_胖哥哥飘过的博客-CSDN博客_android view加载流程</a></li></ul></blockquote><ol><li><p>通过Activity的setContentView方法间接调用PhoneWindow的setContentView()，在PhoneWindow中通过getLayoutInflate()得到LayoutInflate对象。</p></li><li><p>通过LayoutInflate对象去加载View，主要步骤是：</p><ol><li>通过xml的Pull方式去解析xml布局文件，获取xml信息，并保存缓存信息，因为这些数据是静态不变的。</li><li>根据xml的tag标签通过反射创建View逐层构建View。</li><li>递归构建其中的子View，并将子View添加到父ViewGroup中。</li></ol></li></ol><p>其中，有四种加载XML文件的常用方法：</p><ol><li><p>使用view的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> View.inflate(context, R.layout.child, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure></li><li><p>通过系统获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LayoutInflater</span> <span class="hljs-variable">inflater</span> <span class="hljs-operator">=</span> (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);<br><span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> inflater.inflate(R.layout.child, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure></li><li><p>通过LayoutInflater</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LayoutInflater</span> <span class="hljs-variable">inflater</span> <span class="hljs-operator">=</span> LayoutInflater.from(context);<br><span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> inflater.inflate(R.layout.child, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure></li><li><p>通过getLayoutInflater</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> getLayoutInflater().inflate(R.layout.child, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure></li></ol><p>View 加载过程结束后，便会开始 View 的绘制流程了。</p><h1 id="invalidate-和-postInvalidate-的区别"><a href="#invalidate-和-postInvalidate-的区别" class="headerlink" title="invalidate() 和 postInvalidate() 的区别"></a><code>invalidate()</code> 和 <code>postInvalidate()</code> 的区别</h1><p>这两个方法都是在<strong>重绘当前控件</strong>的时候调用的。</p><p><strong>invalidate在UI线程中调用，postInvalidate在非UI线程中调用。</strong> 因为android的UI线程是非线程安全的，所以在非UI线程中，需要使用postInvalidate来使View重绘。</p><p>view调用invalidate将导致当前view的重绘（draw调用），view的父类将不会执行draw方法；viewGroup调用invalidate会使viewGroup的子view调用draw，也就是viewGroup内部的子view进行重绘。</p><h1 id="requestLayout-和-onLayout-的区别"><a href="#requestLayout-和-onLayout-的区别" class="headerlink" title="requestLayout() 和 onLayout() 的区别"></a><code>requestLayout()</code> 和 <code>onLayout()</code> 的区别</h1><p><strong>requestLayout()</strong></p><p><code>requestLayout</code>方法只会**导致当前<code>view</code>的<code>measure</code>和<code>layout</code>**，而<code>draw</code>不一定被执行，只有当<code>view</code>的位置发生改变才会执行<code>draw</code>方法，因此如果要使当前<code>view</code>重绘需要调用<code>invalidate</code>。</p><p><strong>onLayout()</strong></p><p>在很多情况下requestLayout是不需要被调用的。</p><p>例如，我们把一个AbsoluteLayout里面的childView挪动一下位置。我们仅仅需要调用的可能就是重新布局当前AbsoluteLayout，然后调用invalidate方法进行重绘。而不是从当前View向上的整个View树形结构都要重新layout，onLayout，measure，onMeasure一次。在这种情况下可以直接调用onLayout。然后调用invalidate进行重绘。很明显可以提升绘制效率。</p><p>由于父View的layout实现了会通知布局的listener。但是由于无法得到listener，因此调用onlayout的时候无法对其进行通知，这也是这种实现的缺陷。</p><h1 id="自定义-View-的流程和注意事项"><a href="#自定义-View-的流程和注意事项" class="headerlink" title="自定义 View 的流程和注意事项"></a>自定义 View 的流程和注意事项</h1><blockquote><p>  答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/b0f0d5462d16">自定义View学习–定义View流程和注意事项 - 简书 (jianshu.com)</a></li><li><a href="https://blog.csdn.net/lmj623565791/article/details/38339817"> Android 手把手教您自定义ViewGroup（一）_鸿洋_的博客-CSDN博客_自定义viewgroup</a></li></ul></blockquote><hr><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ol><li>invalidate怎么局部刷新</li><li>Android绘制和屏幕刷新机制原理&#96;</li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>面试整理-2022</category>
      
    </categories>
    
    
    <tags>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RecyclerView 缓存及复用机制</title>
    <link href="/posts/156f4346b4b7/"/>
    <url>/posts/156f4346b4b7/</url>
    
    <content type="html"><![CDATA[<h1 id="RecyclerView-为什么要预布局"><a href="#RecyclerView-为什么要预布局" class="headerlink" title="RecyclerView 为什么要预布局"></a>RecyclerView 为什么要预布局</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://juejin.cn/post/6908256535005102094">RecyclerView：预布局和 ItemAnimator 解析</a></li></ul></blockquote><p><strong>什么是预布局</strong></p><p>预布局是指在正式布局 <code>RecyclerView</code> 中的 <code>ItemView</code> 前执行的一次布局过程。</p><p><strong>预布局的作用</strong></p><p>预布局的作用是为了使 <code>ItemAnimator</code> 执行时能给用户更好的视觉体验。</p><p><strong>预布局和正式布局的区别</strong></p><p>预布局过程和正式布局过程执行的都是一样的代码，不同的是预布局过程得到的是 <code>ItemAnimator</code> 执行前的布局，而正式布局得到的是 <code>ItemAnimator</code> 执行后的布局也就是最终用户看到的布局。</p><p><strong>什么情况下会执行预布局</strong></p><p>当布局结束后若有新的 <code>ItemView</code> 在布局结尾显示则需要执行预布局，也就是当 <code>RecycleView</code> 中有 <code>ItemView</code> 被删除或更新时需要执行预布局。看下图更清晰。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/recyclerview-interviewList-1.awebp" alt="RecyclerView 预布局"></p><p>从上图中可以看到当不执行预布局时如果布局结尾有新的 <code>ItemView</code> 出现会执行 <code>DefaultItemAnimator</code> 的添加动画（淡入），这种看起来好像卡顿一样的显示给用户的感觉并不好。当然如果根本没有动画那预布局也就没有了意义。</p><h1 id="RecyclerView的多级缓存机制-每一级缓存具体作用是什么-分别在什么场景下会用到哪些缓存"><a href="#RecyclerView的多级缓存机制-每一级缓存具体作用是什么-分别在什么场景下会用到哪些缓存" class="headerlink" title="RecyclerView的多级缓存机制,每一级缓存具体作用是什么,分别在什么场景下会用到哪些缓存"></a>RecyclerView的多级缓存机制,每一级缓存具体作用是什么,分别在什么场景下会用到哪些缓存</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://juejin.cn/post/6935605122567241742">详细讲解RecyclerView缓存机制</a></li><li><a href="https://blog.csdn.net/jb_home/article/details/111647931">Android深入理解RecyclerView的缓存机制</a></li></ul></blockquote><p>RecyclerView 是先复用，后回收。</p><p>共四级缓存，分别为：</p><ol><li><code>ArrayList&lt;ViewHolder&gt; mAttachedScrap</code> &amp; <code>ArrayList&lt;ViewHolder&gt; mChangedScrap</code> (屏幕内)</li><li><code>ArrayList&lt;ViewHolder&gt; mCachedViews</code> (屏幕外)</li><li><code>ViewCacheExtension mViewCacheExtension</code> (自定义缓存)</li><li><code>RecycledViewPool mRecyclerPool</code> (缓存池)</li></ol><p>每一级缓存的具体作用是什么？</p><ol><li>mAttachedScrap(屏幕内)<ol><li>用于屏幕内itemview快速重用，不需要重新createView和bindView。</li><li>缓存大小没有限制，大小等于RecyclerView子View的数量。</li><li>该缓存中的ViewHolder无需重新绑定，只要ViewHolder的position和数据源中的position对应上。</li></ol></li><li>mCacheViews(屏幕外)<ol><li>保存最近移出屏幕的ViewHolder，包含数据和position信息，复用时必须是相同位置的ViewHolder才能复用。</li><li>应用场景在那些需要来回滑动的列表中，当往回滑动时，能直接复用ViewHolder数据，不需要重新bindView。</li><li>缓存大小有限制，默认缓存大小为2，可以修改默认缓存大小。</li><li>该缓存的特性是FIFO。</li><li>该缓存中的ViewHolder无需重新绑定，只要ViewHolder的position和数据源中的position和itemType对应上。</li></ol></li><li>mViewCacheExtension(自定义缓存)。<ol><li>不直接使用，需要用户自定义实现，默认不实现。</li><li>该接口只提供了get方法，没提供put方法。</li></ol></li><li>mRecyclerPool(缓存池)<ol><li>当cacheView满了后或者adapter被更换，将cacheView中移出的ViewHolder放到Pool中，放之前会把ViewHolder数据清除掉，所以复用时需要重新bindView。需要重新执行onBindView的只有一种缓存区，就是缓存池mRecyclerPool。</li><li>每个itemType对应的ScrapData的缓存大小默认值是5，可以修改缓存大小。</li><li>该缓存中的ViewHolder需要重新绑定数据。</li><li>可以提供给多个RecyclerView共享。</li></ol></li></ol><h1 id="RecyclerView的回收复用机制"><a href="#RecyclerView的回收复用机制" class="headerlink" title="RecyclerView的回收复用机制"></a>RecyclerView的回收复用机制</h1><p><code>RecyclerView</code>滑动时会触发<code>onTouchEvent#onMove</code>，回收及复用<code>ViewHolder</code>在这里就会开始。</p><p><strong>保存缓存流程：</strong></p><ol><li><p>插入或是删除itemView时，先把屏幕内的ViewHolder保存至AttachedScrap中。</p></li><li><p>滑动屏幕的时候，先消失的itemview会保存到CacheView，CacheView大小默认是2，超过数量的话按照先入先出原则，移出头部的itemview保存到RecyclerPool缓存池（如果有自定义缓存就会保存到自定义缓存里），RecyclerPool缓存池会按照itemview的itemtype进行保存，每个itemType缓存个数为5个，超过就会被回收。</p></li></ol><p><strong>获取缓存流程：</strong></p><ol><li><p>AttachedScrap中获取，通过pos匹配holder——&gt;获取失败，从CacheView中获取，也是通过pos获取holder缓存 ——&gt;获取失败，从自定义缓存中获取缓存——&gt;获取失败，从mRecyclerPool中获取 ——&gt;获取失败，重新创建viewholder——createViewHolder并bindview。</p></li><li><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/d7f4bedb15c617e67c094b234c8b0958.webp"></p></li><li><p>总结一下上述流程：</p><ol><li>通过mAttachedScrap、mCachedViews及mViewCacheExtension获取的ViewHolder不需要重新创建布局及绑定数据；</li><li>通过缓存池mRecyclerPool获取的ViewHolder不需要重新创建布局，但是需要重新绑定数据；</li><li>如果上述缓存中都没有获取到目标ViewHolder，那么就会回调Adapter#onCreateViewHolder创建布局，以及回调Adapter#onBindViewHolder来绑定数据。</li></ol></li></ol><h1 id="ListView-和-RecyclerView-的区别"><a href="#ListView-和-RecyclerView-的区别" class="headerlink" title="ListView 和 RecyclerView 的区别"></a>ListView 和 RecyclerView 的区别</h1><p>缓存机制</p><ol><li>ListView 是二级缓存，缓存的对象为 View</li><li>RecyclerView 是四级缓存，缓存的对象为 RecyclerView.ViewHolder</li></ol><p>使用方式</p><ol><li>ListView<ol><li>需要继承 BaseAdapter 类</li><li>需要自定义 ViewHolder 实现 Item 的复用</li></ol></li><li>RecyclerView<ol><li>需要继承 RecyclerView.Adapter 以及 RecyclerView.ViewHolder</li></ol></li></ol><p>布局效果</p><ol><li>ListView 只有一种纵向布局</li><li>RecyclerView 默认有三种布局效果，可以自己继承 LayoutManager 实现自己想要的效果</li></ol><p>空数据处理</p><ol><li>ListView 有 <code>setEmptyView</code> 方法处理 Adapter 数据为空的情况</li><li>RecyclerView 必须自己处理数据为空的情况</li></ol><p>Header View 与 Footer View</p><ol><li>ListView 提供了添加 Header View 与 Footer View 的方法</li><li>RecyclerView 必须自己实现添加的方法</li></ol><p>动画效果</p><ol><li>ListView 中没有默认实现的动画效果，但是我们可以在 Adapter 中自行实现。</li><li>RecyclerView 中已经实现了部分默认的动画效果，例如 <code>notifyItemChanged()</code>、<code>notifyDataInserted()</code>等方法。如果需要自定义动画，我们可以继承 RecyclerView.ItemAnimator类实现自己的动画效果。</li></ol><p>点击事件</p><ol><li>ListView 实现了 <code>onItemClickListener</code> 接口。</li><li>RecyclerView 中并没有实现默认的点击事件的监听方法，我们需要自行实现。</li></ol><p>嵌套滚动机制</p><ol><li>ListView没有实现嵌套滚动机制。</li><li>在事件分发机制中，Touch事件在进行分发的时候，由父View向子View传递，一旦子View消费这个事件的话，那么接下来的事件分发的时候，父View将不接受，由子View进行处理；但是与Android的事件分发机制不同，嵌套滚动机制（<code>Nested Scrolling</code>）可以弥补这个不足，<strong>能让子View与父View同时处理这个Touch事件</strong>，主要实现在于NestedScrollingChild与NestedScrollingParent这两个接口；而在RecyclerView中，实现的是NestedScrollingChild，所以能实现嵌套滚动机制。</li></ol><h1 id="RecyclerView性能优化"><a href="#RecyclerView性能优化" class="headerlink" title="RecyclerView性能优化"></a>RecyclerView性能优化</h1><blockquote><p>  答案参考自：</p><ul><li>[RecyclerView性能优化](<a href="https://www.jianshu.com/p/1853ff1e8de6">RecyclerView性能优化 - 简书 (jianshu.com)</a>)</li><li>[RecyclerView性能优化及高级使用](<a href="https://www.jianshu.com/p/b79ee254f848">RecyclerView性能优化及高级使用 - 简书 (jianshu.com)</a>)</li></ul></blockquote><ol><li><p><strong>减少 xml 文件 inflate 时间</strong></p><p>xml文件包括：layout、drawable的xml，xml文件inflate出ItemView是通过耗时的IO操作。可以使用代码去生成布局，即new View()的方式。这种方式是比较麻烦，但是在布局太过复杂，或对性能要求比较高的时候可以使用。</p></li><li><p><strong>设置高度固定</strong></p><p>如果item高度是固定的话，可以使用RecyclerView.setHasFixedSize(true);来避免requestLayout浪费资源。</p></li><li><p><strong>共用RecycledViewPool</strong></p><p>在嵌套RecyclerView中，如果子RecyclerView具有相同的adapter，那么可以设置RecyclerView.setRecycledViewPool(pool)来共用一个RecycledViewPool。</p><p><strong>Note</strong>: 如果LayoutManager是LinearLayoutManager或其子类，需要手动开启这个特性：layout.setRecycleChildrenOnDetach(true)。</p></li><li><p><strong>加大RecyclerView的缓存</strong></p><p>用空间换时间，来提高滚动的流畅性。</p><p>recyclerView.setItemViewCacheSize(20);</p><p>recyclerView.setDrawingCacheEnabled(true);</p><p>recyclerView.setDrawingCacheQuality(View.DRAWING_CACHE_QUALITY_HIGH);</p></li><li><p><strong>增加RecyclerView预留的额外空间</strong></p><p>额外空间：显示范围之外，应该额外缓存的空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">newLinearLayoutManager( <span class="hljs-built_in">this</span> &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getExtraLayoutSpace</span><span class="hljs-params">(RecyclerView.Statestate)</span> &#123;<br><span class="hljs-keyword">return</span> size;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>减少ItemView监听器的创建</strong></p><p>对ItemView设置监听器，不要对每个item都创建一个监听器，而应该共用一个XxListener，然后根据ID来进行不同的操作，优化了对象的频繁创建带来的资源消耗。</p></li><li><p><strong>回收资源</strong></p><p>通过重写 RecyclerView.onViewRecycled(holder) 来回收资源。</p></li></ol><hr><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><ol><li>RecyclerView的刷新回收复用机制</li><li>RecyclerView的滑动回收复用机制</li></ol><hr><h1 id="更多推荐阅读"><a href="#更多推荐阅读" class="headerlink" title="更多推荐阅读"></a>更多推荐阅读</h1><ul><li><a href="https://www.cnblogs.com/jimuzz/p/14040674.html">再也不用担心问RecycleView了——面试真题详解 - jimuzz - 博客园 (cnblogs.com)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
      <category>面试整理-2022</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RecyclerView</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串哈希 模板</title>
    <link href="/posts/c662e1206816/"/>
    <url>/posts/c662e1206816/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="http://www.yhzq-blog.cc/%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E6%80%BB%E7%BB%93/">字符串Hash总结 | 远航休息栈</a></li></ul></blockquote><hr><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> StringHash &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1e5</span> + <span class="hljs-number">50</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> BASE = <span class="hljs-number">131</span>;<br>    <span class="hljs-type">char</span> s[MAXN]; <span class="hljs-comment">// cin &gt;&gt; (s + 1);</span><br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> hash[MAXN], power[MAXN];<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">preHash</span><span class="hljs-params">()</span> </span>&#123;<br>        power[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) <br>            power[i] = power[i - <span class="hljs-number">1</span>] * BASE;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">calcHash</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<br>            hash[i] = hash[i - <span class="hljs-number">1</span>] * BASE + s[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">getHash</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>)hash[r] - hash[l - <span class="hljs-number">1</span>] * power[r - l + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">input</span><span class="hljs-params">()</span> </span>&#123;<br>        cin &gt;&gt; (s + <span class="hljs-number">1</span>);<br>        len = <span class="hljs-built_in">strlen</span>(s + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    StringHash::<span class="hljs-built_in">input</span>();<br>    StringHash::<span class="hljs-built_in">preHash</span>();<br>    StringHash::<span class="hljs-built_in">calcHash</span>();<br>    cout &lt;&lt; StringHash::<span class="hljs-built_in">getHash</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="字符串哈希实现其他算法"><a href="#字符串哈希实现其他算法" class="headerlink" title="字符串哈希实现其他算法"></a>字符串哈希实现其他算法</h1><h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><blockquote><p>给两个字符串 S1、S2，求 S2 是否是 S1 的字串，并求出 S2 在 S1 中出现的次数。</p></blockquote><p>将 S2 哈希后，在 S1 中查询所有长度为 $|S2|$ 的字串，并进行哈希比较。</p><blockquote><p>复杂度：$O(|S1|)$。</p></blockquote><h2 id="AC-自动机"><a href="#AC-自动机" class="headerlink" title="AC 自动机"></a>AC 自动机</h2><blockquote><p>给出 N 个单词串，和一个文章串，求每个单词串是否是文章串的子串，并求每个单词在文章中出现的次数。</p></blockquote><p>先把每一个单词串哈希，再把文章的每一个子串也进行整数，接下来只需要进行整数上的查找即可。</p><blockquote><p>复杂度：$O(|A|^2+|S|)$。$|S|$ 是单词串总长，$|A|$ 是文章串长度。</p></blockquote><h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><blockquote><p>给出两个字符串 S1、S2，求它们的最长公共子串的长度。</p></blockquote><p>将 S1 的每一个子串都哈希成一个整数，再对 S2 的每一个字串进行哈希，并判断是否与 S1 的某一个字串相同，不断维护相同的字串的长度最大值即可。</p><blockquote><p>复杂度：$O(|S1|^2+|S2|^2)$。</p></blockquote><h2 id="马拉车"><a href="#马拉车" class="headerlink" title="马拉车"></a>马拉车</h2><blockquote><p>给一个字符串 S，求 S 的最长回文子串。</p></blockquote><p>将 S 从前后两个方向分别进行字符串哈希。<br>对子串长度为奇数和偶数的情况分别进行求解。<br>枚举回文子串的中心位置，然后二分子串的长度，直到找到一个该位置的最长回文子串，不断维护长度最大值即可。</p><blockquote><p>复杂度：$O(|S|log|S|)$。</p></blockquote><h2 id="扩展-KMP"><a href="#扩展-KMP" class="headerlink" title="扩展 KMP"></a>扩展 KMP</h2><blockquote><p>给一个字符串 S，求 S 的每个后缀与S的最长公共前缀。</p></blockquote><p>枚举每一个后缀的起始位置，二分长度，求出每个后缀与S的最长公共前缀。</p><blockquote><p>复杂度：$O(|S|log|S|)$。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>View 的事件体系</title>
    <link href="/posts/ca3478f63a25/"/>
    <url>/posts/ca3478f63a25/</url>
    
    <content type="html"><![CDATA[<h1 id="View基础知识"><a href="#View基础知识" class="headerlink" title="View基础知识"></a>View基础知识</h1><h2 id="一、View的相关坐标和位置"><a href="#一、View的相关坐标和位置" class="headerlink" title="一、View的相关坐标和位置"></a>一、<code>View</code>的相关坐标和位置</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20180802114150486.jpg" style="zoom:80%;" /><p><strong>先来了解一个概念：</strong></p><p><code>view动画</code>不改变<code>view</code>的真实位置，就是肉眼看上去，<code>view</code>位置发生了变化，但是它的点击区域还是在原来的位置。</p><p>为了方便描述，下文中的的 <code>真实View</code>，表示真实位置的<code>View</code>，<code>看到的View</code>，表示肉眼看到的<code>View</code>。</p><p>属性动画和 <code>setTranslationX</code> &#x2F; <code>setTranslationY</code> ，会改变显示位置和真实位置。</p><p>上图中<code>view1</code>是初始位置，通过执行<code>setTranslation</code>函数，得到的<code>view2</code>位置，其中<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>这几个值不会改变。</p><h3 id="left，top，right，bottom"><a href="#left，top，right，bottom" class="headerlink" title="left，top，right，bottom"></a><code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code></h3><p><code>View</code>的位置主要由它的四个顶点的位置来决定，分别对应 View 的四个属性：<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>。对应的函数是<code>getLeft</code>，<code>getTop</code>，<code>getRight</code>，<code>getBottom</code>。</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>left</code></td><td><code>View</code> 左上顶点相对于父容器的横坐标</td></tr><tr><td><code>top</code></td><td><code>View</code> 左上顶点相对于父容器的纵坐标</td></tr><tr><td><code>right</code></td><td><code>View</code> 右下顶点相对于父容器的横坐标</td></tr><tr><td><code>bottom</code></td><td><code>View</code> 右下顶点相对于父容器的纵坐标</td></tr></tbody></table><p>这几个值表示的是View的真身位置，它表示哪里，点击区域就在哪里。和肉眼在屏幕上看到的位置可能不一样。</p><h3 id="X，Y"><a href="#X，Y" class="headerlink" title="X，Y"></a><code>X</code>，<code>Y</code></h3><p>上面说到view动画不改变<code>view</code>的真实位置（也就是不改变<code>view</code>的<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>）。</p><p>看到的view相对于真实<code>view</code>，位置发生了变化，但是它的点击区域还是在真实view的位置。</p><p>从 Android 3.0 开始，<code>View</code> 增加了 x，y，<code>translationX</code> 和 <code>translationY</code>。</p><p>x，y 是看到的<code>view</code>的左上角相对父容器的坐标，但不同于 left 和 top ，这两个坐标点的值并一定都是相等的。</p><p>真实<code>view</code> 和 看到<code>view</code>的偏差用 <code>translationX</code> 和 <code>translationY</code> <code>来表示</code>。</p><h3 id="translationX，translationY"><a href="#translationX，translationY" class="headerlink" title="translationX，translationY"></a><code>translationX</code>，<code>translationY</code></h3><p><strong>android开发艺术探索中，关于<code>translationX</code>的讲解是错误的。</strong>真实情况是，<code>translationX</code>是<code>真实view</code> 相对于<code>看到view</code>的 x 方向偏移量。</p><p>从上图可以得知：<code>x</code> &#x3D; <code>left</code> + <code>translationX</code>。</p><h2 id="二、点击事件的XY坐标"><a href="#二、点击事件的XY坐标" class="headerlink" title="二、点击事件的XY坐标"></a>二、点击事件的<code>XY</code>坐标</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20180802143219331.jpg" style="zoom:50%;" /><h2 id="三、MotionEvent"><a href="#三、MotionEvent" class="headerlink" title="三、MotionEvent"></a>三、<code>MotionEvent</code></h2><p>常见的触摸动作一共有三个：</p><ol><li><code>ACTION_DOWN</code>手指按下动作</li><li><code>ACTION_MOVE</code>手指滑动动作</li><li><code>ACTION_UP</code>    手指抬起动作</li></ol><h2 id="四、GestureDetector"><a href="#四、GestureDetector" class="headerlink" title="四、GestureDetector"></a>四、<code>GestureDetector</code></h2><p>手势检测，检测用户的单击、双击、长按等操作。</p><p>通过创建<code>GestureDetector</code>对象并实现<code>OnGestureListener</code>接口（检测单击相关手势）或者<code>OnDoubleTapListener</code>接口（检测双击相关动作）。</p><h2 id="五、TouchSlop"><a href="#五、TouchSlop" class="headerlink" title="五、TouchSlop"></a>五、<code>TouchSlop</code></h2><p>不同安卓设备认为的最小的滑动距离，低于此距离，将不认为用户在滑动，开发者可自行更改，默认为<code>8dp</code>。</p><h2 id="六、VelocityTracker"><a href="#六、VelocityTracker" class="headerlink" title="六、VelocityTracker"></a>六、<code>VelocityTracker</code></h2><p>速度检测，可以计算出用户的手势的滑动速度。</p><p>注意，在<code>VelocityTracker#computeCurrentVelocity(int time)</code>中的<code>time</code>参数是我们计算速度的单位时间，相同的速度用不同的单位时间会有不同的表示方法。</p><h2 id="七、Scroller"><a href="#七、Scroller" class="headerlink" title="七、Scroller"></a>七、<code>Scroller</code></h2><p>弹性滑动对象，由于View中的<code>scrollTo/scrollBy</code>都是瞬间完成位移的。对用户的使用体验不太友好，所以引入弹性滑动对象，使得<code>View</code>的滑动变得可视化。</p><h1 id="View的滑动"><a href="#View的滑动" class="headerlink" title="View的滑动"></a>View的滑动</h1><h2 id="一、scrollTo-x2F-scrollBy"><a href="#一、scrollTo-x2F-scrollBy" class="headerlink" title="一、scrollTo&#x2F;scrollBy"></a>一、<code>scrollTo</code>&#x2F;<code>scrollBy</code></h2><p>View有专门的方法实现滑动，即<code>scrollTo()</code>, <code>scrollBy()</code>;</p><p>这两个函数只能将<code>View</code>中间的内容进行位移，但是不能改变<code>View</code>本身的位置。</p><p>可以方便的实现滑动效果并且不影响内部元素的点击事件。</p><p><code>scrollTo(int destX, int destY)</code>直接让View出现在目标位置，无中间动画。</p><p>参数变量的单位都是像素级。</p><h2 id="二、使用动画"><a href="#二、使用动画" class="headerlink" title="二、使用动画"></a>二、使用动画</h2><p>有两种动画的使用方法。</p><ol><li><p><code>View</code>动画</p><p>在<code>XML</code>文件里面通过改变<code>translationX</code>&#x2F;<code>translationY</code>的方式来实现View的移动效果。</p></li><li><p>属性动画</p><p>在<code>Android3.0</code>版本以上，可以使用<code>ObjectAnimator</code>类来实现属性动画的效果。</p><p>在<code>Android3.0</code>以下的版本中，我们需要自己加载开源动画库<code>NineOldAndroids</code>。</p></li></ol><p>在<code>XML</code>文件中，有一个<code>andoird:fillAfter=&quot;true|false&quot;</code>的选项。</p><p>当为<code>true</code>的时候，View在动画结束后，图像将停留在目标位置上。</p><p>当为<code>false</code>的时候，View会在动画结束后，从末位置消失，重新在初位置出现。</p><p>不论是<code>true</code>还是<code>false</code>，View的点击事件的坐标还是在原先的初始位置上，并不会随着<code>View</code>的移动而移动。</p><p>在<code>Android3.0</code>以上使用属性动画可以解决这样的问题。</p><h2 id="三、改变布局参数"><a href="#三、改变布局参数" class="headerlink" title="三、改变布局参数"></a>三、改变布局参数</h2><p>通过修改<code>View</code>的<code>marginLeft</code>等等布局参数，以此来达到<code>View</code>滑动的效果。</p><h1 id="弹性滑动"><a href="#弹性滑动" class="headerlink" title="弹性滑动"></a>弹性滑动</h1><h2 id="一、Scroller"><a href="#一、Scroller" class="headerlink" title="一、Scroller"></a>一、<code>Scroller</code></h2><p><code>Scroller#smoothScrollTo(int destX, int destY)</code>将<strong>目标位置与初始位置的偏移值delta</strong>计算后调用<code>startScroller()</code>方法存储相关参数，并开始使用<code>invalidate()</code>方法重绘<code>View</code>。重绘<code>View</code>时的<code>draw()</code>方法会调用<code>computeScroll()</code>方法，其中又会调用<code>invalidate</code>方法重绘<code>View</code>，不断的循环。由于<code>scrollTo(int destX, int destY)</code>直接让View出现在目标位置，所以我们在<code>computeScroll()</code>方法中采取微分法的做法，即将一段长距离拆分成许多微小的距离。不断通过<code>scrollTo()</code>的直接滑动以及<code>computeScrollOffset()</code>的重新计算下一个短距离的相关参数以及<code>postInvalidate()</code>的重绘View，最终达到弹性滑动的效果。</p><p><code>computeScrollOffset()</code>方法通过计算目前已经位移的百分比来计算下一次的位移目标以及是否已经完成的滑动，不通过计时器等工具。</p><pre><code class=" mermaid">flowchart TDA[startScroll]B[invalidate]C[computeScroll]D[computeScrollOffset : boolean]E[invalidate]A --&gt; B --&gt;|draw| C --&gt; D --&gt;|not finish| E --&gt;|draw| CD --&gt;|finish| F[finish]</code></pre><h2 id="二、通过动画"><a href="#二、通过动画" class="headerlink" title="二、通过动画"></a>二、通过动画</h2><p>通过<code>ObjectAnimator类</code>我们可以直接的通过动画完成<code>View</code>的弹性滑动。</p><p>我们也可以通过<code>onAnimatorUpdate</code>方法还自定义自己想要的动画效果。</p><h2 id="三、使用延时策略"><a href="#三、使用延时策略" class="headerlink" title="三、使用延时策略"></a>三、使用延时策略</h2><p>可以通过<code>Thread#sleep</code>或者<code>Handler#postDelayed</code>方法来达到间隔一定的时间就改变一次微小位置变化的操作。</p><p>在此次的<code>scrollTo</code>方法执行结束后，通过<code>sleep|postDelayed</code>方法暂停一定的时间，然后重复执行<code>scrollTo</code>的方法，以此来达到弹性滑动的效果。</p><p><strong>注意：</strong>无法在精准的时间内移动固定的位移，因为系统的消息调度（<code>sleep|postDelayed</code>）也是需要时间的。</p><h1 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a><code>View</code>的事件分发机制</h1><h2 id="一、点击事件的传递规则"><a href="#一、点击事件的传递规则" class="headerlink" title="一、点击事件的传递规则"></a>一、点击事件的传递规则</h2><p>点击事件分发过程，即将一系列的<code>MotionEvent</code>事件序列（由<code>ACTION_DOWN</code>开始到<code>ACTION_UP</code>结束的一连串操作）交给一个<code>View</code>执行的过程。</p><p>点击事件的分发主要由三个重要方法构成：<code>dispatchTouchEvent</code>, <code>onInterceptTouchEvent</code>,<code>onTouchEvent</code>。</p><p>三个方法的执行顺序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123; <span class="hljs-comment">// 对当前的View进行事件的分发</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">consume</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;                        <span class="hljs-comment">// 判断是否可以消耗这个事件序列</span><br>    <span class="hljs-keyword">if</span> (onInterceptTouchEvent(ev)) &#123;                <span class="hljs-comment">// 如果准备拦截此次事件序列</span><br>        consume = onTouchEvent(ev);                 <span class="hljs-comment">// 事件由该View执行，并返回结果</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        consume = child.dispatchTouchEvent(ev);     <span class="hljs-comment">// 若不准备拦截，则交给子View进行判断</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> consume;                                 <span class="hljs-comment">// 向父级返回结果</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中执行事件序列的不同方法中同样由优先顺序：<code>onTouchListener &gt; onTouchEvent &gt; onClickListener</code></p><p>当点击事件发生后，它的传递过程会遵循以下的顺序：<code>Activity　-&gt; Window -&gt; DecorView -&gt; View -&gt; ...</code>、</p><p>同时，如果子级发现无法执行这个事件的时候，那么它的父容器的<code>onTouchEvent</code>就会重新调用，直到<code>Activity</code>。</p><p>其中，<code>ViewGroup</code>默认不拦截任何事件，<code>View</code>没有<code>onInterceptTouchEvent</code>方法。</p><h2 id="二、事件分发解析"><a href="#二、事件分发解析" class="headerlink" title="二、事件分发解析"></a>二、事件分发解析</h2><h3 id="Activity对点击事件的分发"><a href="#Activity对点击事件的分发" class="headerlink" title="Activity对点击事件的分发"></a><code>Activity</code>对点击事件的分发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent ev)</span> &#123;<br>    <span class="hljs-keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) <span class="hljs-comment">// 如果Window可以处理点击事件</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> onTouchEvent(ev); <span class="hljs-comment">// 返回Activity自己处理点击事件的结果(true|false)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Window对点击事件的分发"><a href="#Window对点击事件的分发" class="headerlink" title="Window对点击事件的分发"></a><code>Window</code>对点击事件的分发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> PhoneWindow#superDispatchTouchEvent(MotionEvent ev) &#123;<br>  <span class="hljs-keyword">return</span> mDecor.superDispatchTouchEvent(ev); <span class="hljs-comment">// 返回DecorView的处理结果</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="顶级View对点击事件的分发"><a href="#顶级View对点击事件的分发" class="headerlink" title="顶级View对点击事件的分发"></a><code>顶级View</code>对点击事件的分发</h3><p>由此开始，将执行（一）所讲述的事件传递规则。其主要的部分是<code>ViewGroup</code>的事件传递。<code>顶级View</code>一般来说都是<code>ViewGroup</code>。</p><h4 id="判断当前ViewGroup是否拦截点击事件"><a href="#判断当前ViewGroup是否拦截点击事件" class="headerlink" title="判断当前ViewGroup是否拦截点击事件"></a>判断当前<code>ViewGroup</code>是否拦截点击事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> intercepted;<br><span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION.DOWN || mFirstTouchTarget != NULL) &#123; <span class="hljs-comment">// 意思见下方文字</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">disallowIntercept</span> <span class="hljs-operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="hljs-number">0</span>; <span class="hljs-comment">// 判断是否允许屏蔽自身的onInterceptTouchEvent方法</span><br>    <span class="hljs-keyword">if</span> (!disallowIntercept) &#123; <span class="hljs-comment">// 如果允许拦截</span><br>        intercepted = onInterceptTouchEvent(ev); <span class="hljs-comment">// 询问能否拦截并赋值</span><br>        ev.setAction(action); <span class="hljs-comment">// 防止事件被修改，存储事件的动作</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        intercepted = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 由于不允许拦截，则直接赋值</span><br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    intercepted = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 由于直接拦截，则不用询问</span><br>&#125;<br></code></pre></td></tr></table></figure><p>代码中的几个变量的作用：</p><ol><li><p>当事件由<code>ViewGroup</code>的子元素处理成功时，<code>mFirstTouchTarget</code>就会被赋值并指向子元素，此时的<code>mFirstTouchTarget != NULL</code>。</p></li><li><p><code>FLAG_DISALLOW_INTERCEPT</code>一旦被设置后，那么当前的<code>ViewGroup</code>就无法拦截<code>ACTION_MOVE</code>以及<code>ACTION_UP</code>。</p><p>由于事件为<code>ACTION_DOWN</code>的时候，<code>ViewGroup</code>会重置<code>FLAG_DISALLOW_INTERCEPT</code>，所以每次事件为<code>ACTION_DOWN</code>的时候，都会执行一次<code>onInterceptTouchEvent</code>方法。</p></li></ol><p>第3行的判断语句的意思为：</p><ol><li>如果当前的事件为<code>ACTION_DOWN</code>时，作为一个点击事件的开始，需要向子元素传递，返回<code>true</code>。允许向子元素传递。</li><li>如果当前的事件为<code>ACTION_MOVE</code>或者<code>ACTION_UP</code>的时候，如果<code>ACTION_DOWN</code>已经被子元素处理了（<code>mFirstTouchTarget != NULL</code>），那么由于一系列的点击事件都要有同一个<code>View</code>处理，则不能在此拦截，故返回<code>true</code>。反之，如果<code>mFirstTouchTarget == NULL</code>，则代表<code>ACTION_DOWN</code>是由<code>ViewGroup</code>自身处理的，则不能向下传递，返回<code>false</code>。</li></ol><h4 id="ViewGroup在ACTION-DOWN到来时的重置操作"><a href="#ViewGroup在ACTION-DOWN到来时的重置操作" class="headerlink" title="ViewGroup在ACTION_DOWN到来时的重置操作"></a><code>ViewGroup</code>在<code>ACTION_DOWN</code>到来时的重置操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Handle an initial down.</span><br><span class="hljs-keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;<br>    <span class="hljs-comment">// Throw away all previous state when starting a new touch gesture.</span><br>cancelAndClearTouchTargets(ev);<br>resetTouchState();<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>resetTouchState</code>方法中会对<code>FLAG_DISALLOW_INTERCEPT</code>进行重置。</p><p>因此<code>子View</code>的<code>requestDisallowInterceptTouchEvent</code>方法并不能影响<code>ViewGroup</code>对<code>ACTION_DOWN</code>事件的处理。</p><h4 id="ViewGroup不拦截事件时，对点击事件的分发"><a href="#ViewGroup不拦截事件时，对点击事件的分发" class="headerlink" title="ViewGroup不拦截事件时，对点击事件的分发"></a><code>ViewGroup</code>不拦截事件时，对点击事件的分发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> View[] = mChildren;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> childrenCount - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-comment">// 获取每一个子View的位置以及其他信息</span><br>    <span class="hljs-keyword">if</span> (子元素正在播放动画 || 点击事件的坐标落在当前子元素的区域外) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    newTouchTarget = getTouchTarget(child); <br>    <span class="hljs-keyword">if</span> (newTouchTarget != NULL) &#123; <span class="hljs-comment">// 如果不是NULL的话(该child之前初始化过)，就直接向其中添加元素就行了</span><br>        newTouchTarget.pointerIdBits |= idBitsToAssign;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">//如果 newTouchTarget == NULL, 那么就初始化 + 添加第一个可用子元素</span><br>    resetCancelNextUpFlag(child);<br>    <span class="hljs-keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="hljs-literal">false</span>, child, idBitsToAssign)) &#123;<br>        ...<br>        newTouchTarget = addTouchTarget(child, idBitsToAssign);<br>        alreadyDispatchedToNewTouchTarget = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不断的遍历当前<code>ViewGroup</code>的所有子元素，如果<strong>子元素不在播放动画</strong>以及<strong>点击事件的坐标落在当前子元素的区域内</strong>，那么这个子元素就是一个可以传递的。</p><blockquote><p>  由<code>TouchTarget</code>源码可知：</p><p>  <code>TouchTarget</code>保存了响应触摸事件的子<code>view</code>和该子view上的触摸点ID集合，表示一个触摸事件派发目标。通过<code>next</code>成员可以看出，它支持作为一个链表节点储存。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TouchTarget</span> &#123;<br>    <span class="hljs-comment">// ···</span><br><br>    <span class="hljs-comment">// The touched child view.</span><br>    <span class="hljs-comment">// 被触摸的子元素</span><br>    <span class="hljs-meta">@UnsupportedAppUsage</span><br>    <span class="hljs-keyword">public</span> View child;<br><br>    <span class="hljs-comment">// The combined bit mask of pointer ids for all pointers captured by the target.</span><br>    <span class="hljs-comment">// 指针 id 的位的掩码组合，用于目标捕获的所有指针</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> pointerIdBits;<br><br>    <span class="hljs-comment">// The next target in the target list.</span><br>    <span class="hljs-comment">// 目标列表中的下一个目标</span><br>    <span class="hljs-keyword">public</span> TouchTarget next;<br>    <br>    <span class="hljs-comment">// ···</span><br>&#125;<br>————————————————<br>版权声明：本文为CSDN博主「分则能成」的原创文章，遵循CC <span class="hljs-number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：https:<span class="hljs-comment">//blog.csdn.net/dehang0/article/details/104317611</span><br></code></pre></td></tr></table></figure></blockquote><p>如果是第一个可传递元素，那么就会进入初始化部分，其中的<code>dispatchTransformedTouchEvent</code>方法实际上就是调用的子元素的<code>dispatchTouchEvent</code>方法。在该方法中有如下的一段内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (child == NULL) &#123;<br>    handled = <span class="hljs-built_in">super</span>.dispatchTouchTarget(event);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    handled = child.dispatchTouchTarget(event);<br>&#125;<br></code></pre></td></tr></table></figure><p>由于前面的代码中<code>dispatchTransformedTouchEvent</code>方法的第三个参数为<code>child</code>，所以会执行子元素的<code>dispatchTouchEvent</code>方法，点击事件交由子元素处理，从而完成了一轮事件的分发。</p><p>当子元素的<code>dispatchTouchEvent</code>方法返回<code>true</code>时，<code>dispatchTransformedTouchEvent</code>方法同样也会返回<code>true</code>，接着便执行<code>if语句</code>的代码块部分了。如果<code>dispatchTouchEvent</code>方法返回<code>false</code>的话，<code>ViewGroup</code>就会把事件向后遍历，寻找新的可传递的子元素。在<code>if语句</code>的代码块中，<code>mFirstTouchTarget</code>会被赋值同时跳出<code>for循环</code>。</p><p>其中<code>mFirstTouchTarget</code>的赋值由<code>addTouchTarget</code>方法完成，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> TouchTarget <span class="hljs-title function_">addTouchTarget</span><span class="hljs-params">(View child, <span class="hljs-type">int</span> pointerIdBits)</span> &#123;<br>    <span class="hljs-type">TouchTarget</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> TouchTarget.obtain(child, pointerIdBits);<br>   target.next = mFirstTouchTarget;<br>    mFirstTouchTarget = target;<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以很容易的看出，<code>mFirstTouchTarget</code>其实是一个<strong>单链表结构</strong>，<code>mFirstTouchTarget</code>是否被赋值，将直接影响<code>ViewGroup</code>对事件的拦截策略。</p><h4 id="ViewGroup中没有合适的子元素"><a href="#ViewGroup中没有合适的子元素" class="headerlink" title="ViewGroup中没有合适的子元素"></a><code>ViewGroup</code>中没有合适的子元素</h4><p>有两种情况，<code>ViewGroup</code>中会没有合适的子元素可以传递：</p><ol><li><code>ViewGroup</code>没有子元素</li><li>子元素处理了点击事件，但是<code>dispatchTouchEvent</code>方法返回了<code>false</code>，这一般是因为子元素在<code>onTouchEvent</code>中返回了<code>false</code>。</li></ol><p>在这两种情况中，<code>ViewGroup</code>都会自己处理点击事件。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (mFirstTouchTarget == NULL) &#123;<br><span class="hljs-comment">// 没有可分发子元素，就当其是一个普通的View</span><br>handled = dispatchTransformedTouchEvent(ev, canceled, <span class="hljs-literal">null</span>, TouchTarget.ALL_POINTER_IDS);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，代码中的<code>dispatchTransformedTouchEvent</code>方法的第三个参数将其设置为<code>null</code>，此时它就会调用<code>super.dispatchTouchTarget</code>方法了。</p><h3 id="View对点击事件的处理过程"><a href="#View对点击事件的处理过程" class="headerlink" title="View对点击事件的处理过程"></a><code>View</code>对点击事件的处理过程</h3><p>这里的<code>View</code>不包含<code>ViewGroup</code>，因为没有子元素，所以不用向下分发事件，只能自己处理事件。</p><p>先看它的<code>dispatchTouchEvent</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    ...<br>    <span class="hljs-keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;<br>        <span class="hljs-type">ListenerInfo</span> <span class="hljs-variable">li</span> <span class="hljs-operator">=</span> mListenerInfo;<br>        <span class="hljs-keyword">if</span> (li != <span class="hljs-literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="hljs-literal">null</span> &amp;&amp; li.mOnTouchListener.onTouch(<span class="hljs-built_in">this</span>, event) &amp;&amp; ...) &#123;<br>            result = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;<br>            result = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    ...<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上面的代码可以看出，<code>View</code>对点击事件的处理流程中，首先会判断有没有设置<code>onTouchListener</code>，如果有且其中的<code>onTouch</code>方法返回<code>true</code>，则<code>onTouchEvent</code>方法就不会被调用。</p><p>从其他的代码中也可以得出的一些结论：</p><ol><li>如果<code>View</code>的<code>CLICKABLE</code>以及<code>LONG_CLICKABLE</code>中有一个为<code>true</code>，不论<code>View</code>是否为<code>DISABLE</code>，都会消耗事件（也就是即使<code>View</code>看起来没有任何的反应，但是也消耗了点击事件）。</li><li><code>View</code>的<code>LONG_CLICKABLE</code>默认为<code>false</code>，而<code>CLICKABLE</code>是否为<code>false</code>与其<code>View</code>有关，如<code>button</code>的默认为<code>true</code>、<code>textview</code>的默认为<code>false</code>。</li><li>当<code>ACTION_UP</code>事件发生时，会触发<code>performClick</code>方法，如果<code>View</code>设置了<code>OnClickListener</code>，那么<code>performClick</code>方法就会调用它的<code>onClick</code>方法。（即<code>onClick</code>的触发前提时<code>View</code>是可点击的，且收到了<code>DOWN</code>和<code>UP</code>的点击事件。）</li><li><code>setOnClickListener</code>方法会自动将<code>CLICKABLE</code>设置为<code>true</code>，<code>setOnLongClickListener</code>方法会自动将<code>LONG_CLICKABLE</code>设置为<code>true</code>。</li></ol><h1 id="View的滑动冲突"><a href="#View的滑动冲突" class="headerlink" title="View的滑动冲突"></a><code>View</code>的滑动冲突</h1><p>总共会出现三种滑动冲突的情况：</p><ol><li><code>内部View</code>与<code>外部View</code>的滑动方向相反。</li><li><code>内部View</code>与<code>外部View</code>的滑动方向相同。</li><li>前两种情况的嵌套。</li></ol><p>三种情况的处理思路：</p><ol><li>通过手势滑动的角度判断滑动的方向。</li><li>通过当前处于的不同的页面状态来判断应该滑动的<code>View</code>。</li><li>通过前两种的综合使用。</li></ol><h2 id="滑动冲突的解决方式"><a href="#滑动冲突的解决方式" class="headerlink" title="滑动冲突的解决方式"></a>滑动冲突的解决方式</h2><h3 id="外部拦截法"><a href="#外部拦截法" class="headerlink" title="外部拦截法"></a>外部拦截法</h3><p>通过重写<strong>父容器的</strong><code>onInterceptTouchEvent</code>方法，所有的事件都先经过父容器的筛选，对其中父容器需要的事件进行拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">intercepted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getX();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getY();<br>    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN : &#123;<br>            intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE : &#123;<br>            <span class="hljs-keyword">if</span> (父容器需要当前的点击事件)<br>                intercepted = <span class="hljs-literal">true</span>;<br>           <span class="hljs-keyword">else</span> <br>                intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP : &#123;<br>            intercepted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span> :<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    mLastXIntercept = x;<br>    mLastYIntercept = y;<br>    <span class="hljs-keyword">return</span> intercepted;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="内部拦截法"><a href="#内部拦截法" class="headerlink" title="内部拦截法"></a>内部拦截法</h3><p>父元素拦截除<code>ACTION_DOWN</code>以外的其他事件，当事件到达子元素后，由子元素判断是否需要这些事件，不需要的事件将重新交由父容器来处理。这种方法和Android的事件分发机制不一致，需要配合<code>requestDisallowInterceptTouchEvent</code>方法才能正常的工作。</p><p>相关阅读链接：<a href="https://www.jianshu.com/p/fe3d109eb27e">Android TouchEvent之requestDisallowInterceptTouchEvent - 简书 (jianshu.com)</a></p><h4 id="子元素的dispatchTouchEvent方法"><a href="#子元素的dispatchTouchEvent方法" class="headerlink" title="子元素的dispatchTouchEvent方法"></a>子元素的<code>dispatchTouchEvent</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dispatchTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getX();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) event.getY();<br>    <br>    <span class="hljs-keyword">switch</span> (event.getAction()) &#123;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_DOWN : &#123;<br>            parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 此子View的所有父ViewGroup会跳过onInterceptTouchEvent回调</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_MOVE : &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">deltaX</span> <span class="hljs-operator">=</span> x - mLastX;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">deltaY</span> <span class="hljs-operator">=</span> y - mLastY;<br>            <span class="hljs-keyword">if</span> (父容器需要当前的点击事件) &#123;<br>                parent.requestDisallowInterceptTouchEvent(<span class="hljs-literal">false</span>);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> MotionEvent.ACTION_UP : &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">default</span> : <br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    mLastX = x;<br>    mLastY = y;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.dispatchTouchEvent(event);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="父容器的onInterceptTouchEvent方法："><a href="#父容器的onInterceptTouchEvent方法：" class="headerlink" title="父容器的onInterceptTouchEvent方法："></a>父容器的<code>onInterceptTouchEvent</code>方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onInterceptTouchEvent</span><span class="hljs-params">(MotionEvent event)</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> event.getAction();<br>    <span class="hljs-keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM 垃圾回收机制</title>
    <link href="/posts/5127b8731afe/"/>
    <url>/posts/5127b8731afe/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="http://www.cyc2018.xyz/">Java 虚拟机 | CS-Notes</a></li><li><a href="https://blog.csdn.net/jisuanjiguoba/article/details/80156781">JVM中的新生代和老年代（Eden空间、两个Survior空间）</a></li></ul></blockquote><hr><h1 id="判断一个对象是否可以被回收"><a href="#判断一个对象是否可以被回收" class="headerlink" title="判断一个对象是否可以被回收"></a>判断一个对象是否可以被回收</h1><ol><li>引用计数算法</li><li>可达性分析算法</li><li>方法区的回收</li><li><code>finalize</code> 方法</li></ol><hr><h1 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h1><ol><li>强引用：被强引用关联的对象不会被回收。</li><li>软引用：被软引用关联的对象只会在内存不足的情况下被回收。</li><li>弱引用：被弱引用关联的对象一定会被回收，只能活到下次垃圾回收之前。</li><li>虚引用：无法通过虚引用创建一个对象。为对象创建虚引用的唯一目的是在这个对象在被回收时受到一个系统消息。</li></ol><hr><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><ol><li>标记-清除算法</li><li>标记-复制算法</li><li>复制算法</li><li>分代收集算法</li></ol><hr><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>并行与串行</li><li>单线程与多线程</li></ol><h2 id="主要收集器"><a href="#主要收集器" class="headerlink" title="主要收集器"></a>主要收集器</h2><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>CMS(Concurrent Mark Sweep，即多线程的标记-清除算法)</p><p>分为四个流程：</p><ol><li><strong>初始标记</strong><br> 仅仅是标记一下 GC Roots 能直接关联到的对象。</li><li><strong>并发标记</strong><br> 进行 GC Roots Trancing 的过程。</li><li><strong>重新标记</strong><br> 为了修正并发标记期间因用户线程继续运作而产生变动的那一部分的对象的标记记录。</li><li><strong>并发清除</strong><br> 对标记出来的垃圾进行清除操作。</li></ol><p>具有以下的缺点：</p><ol><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不高。</li><li>标记-清除算法导致的空间碎片，导致往往出现老年代空间剩余，但是无法找到一段连续的空间用于存储对象，而不得不进行一次 Full GC。</li><li>无法处理浮动垃圾，而导致 Concurrent Mode Failure。其中，浮动垃圾是指在并发清除阶段由于用户线程的继续运行而产生的垃圾。</li></ol><h3 id="G1-Garbage-First"><a href="#G1-Garbage-First" class="headerlink" title="G1(Garbage First)"></a>G1(Garbage First)</h3><p>G1 垃圾收集器是面向客户端的垃圾收集器，在多 CPU 和大内存场景下有很好的性能。</p><p>堆被分为新生代和老年代，G1 收集器可以直接对新生代和老年代一起回收。</p><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><p>G1 收集器的运作大致分为以下的几个部分：</p><ol><li><strong>初始标记</strong><br> 仅仅是标记 GC Roots 能够直接标记到的对象。</li><li><strong>并发标记</strong><br> 进行 GC Roots Tracing 的过程。</li><li><strong>最终标记</strong><br> 为了修正在并发标记期间因用户线程继续运行而导致标记产生变动的那一部分标记记录。</li><li><strong>筛选回收</strong><br> 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ol><p>具备如下的特点：</p><ol><li>空间整合：从整体上看是基于标记-整理算法实现的收集器，从局部上看是居于复制算法实现的，这就意味着运行期间不会产生内存空闲碎片。</li><li>可预测的停顿：能够有用户自定义 GC收集器 上所消耗的时间。</li></ol><h2 id="其他收集器"><a href="#其他收集器" class="headerlink" title="其他收集器"></a>其他收集器</h2><pre><code class="mermaid" >graph TBsubgraph 新生代     Serial    ParNew    Parallel_Scaevnge[Parallel Scavenge]endsubgraph 老年代    Serial_Old[Serial Old]    Parallel_Old[Parallel Old]end</code></pre><hr><h1 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h1><h2 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h2><ol><li>Minor GC</li><li>Full GC</li></ol><h2 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h2><ol><li><p>一个人（对象）出来（new 出来）后会在Eden Space（伊甸园）无忧无虑的生活，直到GC到来打破了他们平静的生活。GC会逐一问清楚每个对象的情况，有没有钱（此对象的引用）啊，因为GC想赚钱呀，有钱的才可以敲诈嘛。然后富人就会进入Survivor Space（幸存者区），穷人的就直接kill掉。</p></li><li><p>并不是进入Survivor Space（幸存者区）后就保证人身是安全的，但至少可以活段时间。GC会定期（可以自定义）会对这些人进行敲诈，亿万富翁每次都给钱，GC很满意，就让其进入了Genured Gen(养老区)。万元户经不住几次敲诈就没钱了，GC看没有啥价值啦，就直接kill掉了。</p></li><li><p>进入到养老区的人基本就可以保证人身安全啦，但是亿万富豪有的也会挥霍成穷光蛋，只要钱没了，GC还是kill掉。</p></li></ol><p><strong>总结</strong></p><ol><li>对象优先在 Eden 分配</li><li>大对象直接进入老年代</li><li>长期存活的对象直接进入老年代</li><li>动态对象年龄判定</li><li>空间分配担保</li></ol><h2 id="Full-GC-出触发条件"><a href="#Full-GC-出触发条件" class="headerlink" title="Full GC 出触发条件"></a>Full GC 出触发条件</h2><ol><li>调用 <code>System.gc()</code></li><li>老年代空间不足</li><li>空间分配担保失败</li><li>JDK 1.8 之前的永久代空间不足</li><li>Concurrent Mode Failure</li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM Garbage Collection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>View 的绘制原理</title>
    <link href="/posts/bd6906438953/"/>
    <url>/posts/bd6906438953/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="ViewRoot"><a href="#ViewRoot" class="headerlink" title="ViewRoot"></a><code>ViewRoot</code></h2><p><code>ViewRoot</code>对应于<code>ViewRootImpl</code>类，它是连接<code>WindowManager</code>和<code>DecorView</code>的纽带。<code>View</code>的三大流程都是通过<code>ViewRoot</code>来完成的。</p><p>在<code>ActivityThread</code>中，当<code>Activity</code>对象被创建完毕后，会将<code>DecorView</code>添加到<code>Window</code>中，同时也会创建<code>ViewRootImpl</code>对象，并将<code>ViewRootImpl</code>对象与<code>DecorView</code>建立关联。</p><h2 id="View的三大绘制流程"><a href="#View的三大绘制流程" class="headerlink" title="View的三大绘制流程"></a><code>View</code>的三大绘制流程</h2><p><code>View</code>的绘制流程主要有<code>measure</code>、<code>layout</code>和<code>draw</code>过程。</p><ol><li><code>measure</code>：用来确定<code>View</code>的测量宽高。</li><li><code>layout</code>：用来确定<code>View</code>的最终宽高以及四个顶点的位置。</li><li><code>draw</code>：将<code>View</code>绘制在屏幕上。</li></ol><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-d165daed428c4a5312c1ce1af6a9693a_720w.jpg"></p><p><code>View</code>的绘制流程由<code>ViewRoot</code>的<code>performTraversals</code>方法开始。</p><p><code>performTraversals</code>方法会依次调用<code>performMeasure</code>、<code>performLayout</code>、<code>performDraw</code>方法。<strong>这三个方法会分别完成<code>顶层View</code>的<code>measure</code>、<code>layout</code>、<code>draw</code>过程。</strong></p><p>其中、<code>performMeasure</code>方法会调用其中的<code>measure</code>方法，在<code>measure</code>方法中又会调用<code>onMeasure</code>方法，在<code>onMeasure</code>方法中会对所有的子元素进行<code>measure</code>过程，这个时候<code>measure</code>的流程就从父容器传递到了子元素中，这样就完成了一轮<code>measure</code>过程。不断的对子元素进行<code>measure</code>过程。如此反复便完成了对<code>View</code>树的遍历。</p><p>其中，<code>performMeasure</code>方法位于<code>ViewRootImpl</code>中的<code>measureHierarchy</code>方法中(<code>hierarchy</code>：<code>n.</code>层次结构)。</p><p><code>performLayout</code>方法、<code>performDraw</code>方法的流程与之同理，需要注意一点的是，<code>draw</code>流程的传递是通过<code>draw</code>方法中的<code>dispatchDraw</code>实现的，不过并无本质的区别。</p><h2 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a><code>DecorView</code></h2><p><code>DecorView</code>作为<code>顶层View</code>，继承自<code>FrameLayout</code>。一般情况下它的内部都会包含一个<code>LinearLayout</code>。而<code>LinearLayout</code>中有上下两个部分，分别为标题栏和内容栏。我们平时设置指定布局文件的方法<code>setContentView</code>，就是指的是内容栏中的布局。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-8f887429daf00df80319901f69cd1d35_720w.jpg" alt="img" style="zoom:67%;" /><p>通过源码，我们可以得知，<b><code>DecorView</code> 其实是一个 <code>LinearLayout</code></b>，<code>View</code> 层的事件都先通过 <code>DecorView</code>，然后才传递给我们的 <code>View</code>。</p><h2 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a><code>MeasureSpec</code></h2><blockquote><p>  <code>spec</code> <strong><code>英[spek]</code></strong><code>n.</code>规格 <code>vt.</code>按特定标准设计并制造</p></blockquote><p><code>MeasureSpec</code>参与了<code>View</code>的<code>measure</code>过程。在测量过程中，系统将<code>View</code>的<code>LayoutParams</code>根据父容器所施加的规则转换成对应的<code>MeasureSpec</code>，然后再根据这个<code>MeasureSpec</code>来测量出<code>View</code>的测量宽&#x2F;高。</p><p><code>MeasureSpec</code>代表一个32位的<code>int</code>值，高两位代表 测量模式<code>SpecMode</code>，低30位代表 该测量模式下的规格大小<code>SpecSize</code>。</p><p><code>MeasureSpec</code>与<code>SpecMode</code>、<code>SpecSize</code>之间可以通过位运算互相求出。</p><p>每个<code>View</code>的<code>measure</code>过程之前都会先计算其<code>MeasureSpec</code>的值，然后再对其进行<code>measure</code>。</p><p><strong>注意</strong>：<code>View</code>的宽和高各有一个<code>MeasureSpec</code>值，分别为<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>。</p><h3 id="SpecMode的三种状态"><a href="#SpecMode的三种状态" class="headerlink" title="SpecMode的三种状态"></a><code>SpecMode</code>的三种状态</h3><ol><li><p><code>UNSPECIFIED</code></p><p>父容器不对<code>View</code>做任何的限制，要多大给多大。<strong>这种情况一般用于系统的内部</strong>，表示一种测量方式的状态。</p></li><li><p><code>EXACTLY</code></p><p>父容器已经测出了<code>View</code>所需要的精确大小，此时的大小就是<code>View</code>的最终大小。</p><p>它对应于<code>LayoutParams</code>的<code>match_parent</code>和具体的数值这两种模式。</p></li><li><p><code>AT_MOST</code></p><p>父容器指定了一个可用的大小，<code>View</code>的大小不能大于这个值。</p><p>它对应于<code>LayoutParams</code>中的<code>wrap_content</code>。</p></li></ol><h3 id="MeasureSpec和LayoutParams的对应关系"><a href="#MeasureSpec和LayoutParams的对应关系" class="headerlink" title="MeasureSpec和LayoutParams的对应关系"></a><code>MeasureSpec</code>和<code>LayoutParams</code>的对应关系</h3><p>对于<code>DecorView</code>和普通<code>View</code>来说，<code>MeasureSpec</code>的转化过程略有不同。</p><p><strong>对于<code>DecorView</code>：</strong></p><p><strong><code>DecorView</code>的<code>MeasureSpec</code>由窗口的大小和<code>DecorView</code>自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在<code>ViewRootImpl</code>中的<code>measureHierarchy</code>方法中，调用<code>getRootMeasureSpec</code>方法，获得<code>DecorView</code>的<code>MeasureSpec</code>。</p><p>其中<code>getRootMeasureSpec</code>方法中，根据自身<code>LayoutParams</code>的不同大小，共有三种情况：</p><ol><li><code>LayoutParams.MATCH_PARENT</code>：精确模式，大小就是窗口的大小。</li><li><code>LayoutParams.WRAP_CONTENT</code>：最大模式，大小不定，但是不能超过窗口的大小。</li><li>固定大小(比如100dp)：精确模式，大小为<code>LayoutParams</code>中指定的大小。</li></ol><p><strong>对于普通<code>View</code>：</strong></p><p><strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在父容器的<code>measureChildWithMargins</code>中的<code>getChildMeasureSpec</code>方法获得<code>View</code>的<code>MeasureSpec</code>。</p><p>其中<code>getChildMeasureSpec</code>方法的参数中使用到了父容器的<code>MeasureSpec</code>。在这个方法中通过<code>switch</code>和<code>if</code>语句，对<code>View</code>的<code>MeasureSpec</code>进行了决定。结果如下：</p><table><thead><tr><th><code>childLayoutParams</code> \ <code>parentMeasureSpec</code></th><th><code>EXACTLY</code></th><th><code>AT_MOST</code></th><th><code>UNSPECIFIED</code></th></tr></thead><tbody><tr><td><code>dp</code>&#x2F;<code>px</code></td><td><code>EXACTLY</code><br>childSize</td><td><code>EXACTLY</code><br/>childSize</td><td><code>EXACTLY</code><br/>childSize</td></tr><tr><td><code>match_parent</code></td><td><code>EXACTLY</code><br/>parentSize</td><td><code>AT_MOST</code><br>parentSize</td><td><code>UNSPECIFIED</code><br>0</td></tr><tr><td><code>wrap_content</code></td><td><code>AT_MOST</code><br>parentSize</td><td><code>AT_MOST</code><br/>parentSize</td><td><code>UNSPECIFIED</code><br/>0</td></tr></tbody></table><p>上图可以简单记为：除了<code>dp</code>&#x2F;<code>px</code>的精确模式情况外，三种<code>MeasureSpec</code>的级别为：<code>EXACTLY</code> &lt; <code>AT_MOST</code> &lt; <code>UNSPECIFIED</code> 且<code>childMeasureSpec</code> &#x3D; max(<code>childLayoutParams</code> , <code>parentMeasureSpec</code>)。（<strong>实际上并无级别之分</strong>）</p><p>通过上面的表格，可以更加直观的看出：<strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><hr><h1 id="View的工作流程"><a href="#View的工作流程" class="headerlink" title="View的工作流程"></a><code>View</code>的工作流程</h1><h2 id="measure过程"><a href="#measure过程" class="headerlink" title="measure过程"></a><code>measure</code>过程</h2><p><code>measure</code>过程分为两种情况：</p><ol><li><code>View</code>的<code>measure</code>过程：只需要测量自身即可。</li><li><code>ViewGroup</code>的<code>measure</code>过程：则除了完成自己的测量外，还需要遍历去调用所有子元素的<code>measure</code>过程。</li></ol><p>以下对这两种情况分别讨论。</p><h3 id="View的measure过程"><a href="#View的measure过程" class="headerlink" title="View的measure过程"></a><code>View</code>的<code>measure</code>过程</h3><p><code>View</code>的<code>measure</code>方法是<code>final</code>类型的方法，不可以重写，<code>measure</code>方法里面调用了<code>onMeasure</code>方法。</p><p>在<code>onMeasure</code>方法里面也只调用了一个<code>setMeasuredDimension</code>方法来设置<code>View</code>的宽&#x2F;高的测量值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMeasure</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSpec, <span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br>    setMeasuredDimension(getDefaultSize(getSuggestedMininumWidth(), <br>                                        widthMeasureSpec), <br>                         getDefaultSize(getSuggestedMininumHeight(), <br>                                        heightMeasureSpec));<br>&#125;<br></code></pre></td></tr></table></figure><p>而在<code>setMeasureDimension</code>方法的参数中，则使用了<code>getDefaultSize</code>的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getDefaultSize</span><span class="hljs-params">(<span class="hljs-type">int</span> size, <span class="hljs-type">int</span> measureSpec)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> size;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">specMode</span> <span class="hljs-operator">=</span> MeasureSpec.getMode(measureSpec);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">specSize</span> <span class="hljs-operator">=</span> Measurespec.getSize(measureSpec);<br><br>    <span class="hljs-keyword">switch</span> (specMode) &#123;<br>        <span class="hljs-keyword">case</span> MeasureSpec.UNSPECIFIED:<br>            result = size;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> MeasureSpec.AT_MOST:<br>        <span class="hljs-keyword">case</span> MeasureSpec.EXACTLY:<br>            result = specsize;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="对于AT-MOST和EXACTLY的情况"><a href="#对于AT-MOST和EXACTLY的情况" class="headerlink" title="对于AT_MOST和EXACTLY的情况"></a>对于<code>AT_MOST</code>和<code>EXACTLY</code>的情况</h4><p>通过代码可以看出，最终返回的值就是传入的<code>MeasureSpec</code>的中<code>View</code><strong>测量后</strong>的大小（<code>View</code>的<strong>最终的</strong>大小是在<code>layout</code>阶段确定的，但是几乎所有情况下，<code>View</code>的测量大小和最终大小都是相同的）。</p><h4 id="对于UNSPECIFIED的情况"><a href="#对于UNSPECIFIED的情况" class="headerlink" title="对于UNSPECIFIED的情况"></a>对于<code>UNSPECIFIED</code>的情况</h4><p><code>getDefaultSize</code>方法返回的值是<code>getsuggestedMininumWidth</code>方法和<code>getsuggestedMininumHeight</code>方法决定的。</p><p>这里只讨论<code>getsuggestedMininumWidth</code>方法的逻辑，另一个方法同理：</p><ol><li>如果<code>View</code>没有设置背景，那么此方法的返回值就是<code>android:minWidth</code>这个属性所指定的值，这个值默认为0。</li><li>如果<code>View</code>设置了背景，则返回<code>android:minWidth</code>和背景的最小宽度这两者中的最大值。</li></ol><h4 id="对于自定义View的情况"><a href="#对于自定义View的情况" class="headerlink" title="对于自定义View的情况"></a>对于自定义<code>View</code>的情况</h4><p>对于直接继承<code>View</code>的自定义<code>View</code>来说，<strong>需要重写<code>onMeasure</code>方法并设置在<code>wrap_content</code>情况时的自身大小</strong>，否则在布局中使用<code>wrap_content</code>就相当于使用<code>match_parent</code>。</p><p>因为当自定义<code>View</code>处于<code>wrap_content</code>时，它的<code>SpecMode</code>为<code>AT_MOST</code>模式，由前文可知，当父容器无论为<code>AT_MOST</code>还是<code>ECACTLY</code>模式时，自定义<code>View</code>都为<code>AT_MOST</code>模式且尺寸大小为<code>parentSize</code>，也就是父容器的剩余空间，即自定义<code>View</code>的大小变得与父容器的剩余空间大小一致，显然不是我们需要的。</p><p><strong>解决方法：</strong></p><p>解决方法也是非常简单的。我们只需要在<code>onMeasure</code>方法中对</p><ol><li>仅<code>width</code>方向为<code>AT_MOST</code>模式</li><li>仅<code>height</code>方向为<code>AT_MOST</code>模式</li><li><code>width</code>方向以及<code>height</code>方向都为<code>AT_MOST</code>模式</li><li>其他的情况</li></ol><p>这四个状态单独判断，分别使用<code>setMeasuredDimension</code>方法直接为自定义<code>View</code>设置我们需要的值即可。</p><p>源码中对于<code>TextView</code>、<code>ImageView</code>等控件的<code>wrap_content</code>也做了特殊的处理。</p><h3 id="ViewGroup的measure过程"><a href="#ViewGroup的measure过程" class="headerlink" title="ViewGroup的measure过程"></a><code>ViewGroup</code>的<code>measure</code>过程</h3><p>对于<code>ViewGroup</code>来说，处理要完成它自己的<code>measure</code>过程，还需要遍历去调用所有子元素的<code>measure</code>方法，对子元素也进行<code>measure</code>过程。</p><p>由于<code>ViewGroup</code>是一个抽象类，不能重写<code>View</code>的<code>onMeasure</code>方法，但是他提供了一个<code>measureChildren</code>的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measureChildren</span><span class="hljs-params">(<span class="hljs-type">int</span> widthMeasureSepc, <span class="hljs-type">int</span> heightMeasureSpec)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> mChildrenCount;<br>    <span class="hljs-keyword">final</span> View[] children = mChildren;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">View</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> children[i];<br>        <span class="hljs-keyword">if</span> (...) &#123;<br>            measureChild(child, widthMeasureSpec, heightMeasureSpec);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中，可以清晰的看出，<code>measureChildren</code>方法遍历了所有的子元素，并对他们使用了<code>measureChild</code>方法。</p><p>在<code>measureChild</code>方法中，通过</p><ol><li>参数<code>child</code>获得了<code>child.LayoutParams</code>；</li><li><code>measureChild</code>方法中的<code>getChildMeasureSpec</code>方法配合参数中父容器的两个<code>MeasureSpec</code>值，得到子元素的两个<code>MeasureSpec</code>值。</li></ol><p>接着将子元素的两个<code>MeasureSpec</code>值传递给<code>child.measure</code>方法来进行测量，到此便结束了一轮的<code>measure</code>过程。</p><p><strong>注意</strong>：不同的<code>ViewGroup</code>有着不同的布局特性，不易写出通用的供<code>ViewGroup</code>使用的<code>onMeasure</code>方法。故设置成抽象类，需要测量过程中的各个子类（如<code>LinearLayout</code>、<code>RelativeLayout</code>等）自己去具体实现<code>onMeasure</code>方法。</p><h3 id="在Activity启动时获得一个View的宽-x2F-高信息的方法"><a href="#在Activity启动时获得一个View的宽-x2F-高信息的方法" class="headerlink" title="在Activity启动时获得一个View的宽&#x2F;高信息的方法"></a>在<code>Activity</code>启动时获得一个<code>View</code>的宽&#x2F;高信息的方法</h3><p>由于<code>Activity</code>的启动和<code>View</code>的测量过程并不是同步进行的，因此无法保证在<code>Activity</code>启动时某个<code>View</code>已经测量完毕了。所以我们在<code>Activity</code>启动的时候，如果直接通过<code>getMeasuredWidth</code>&#x2F;<code>getMeasuredHeight</code>方法获得的值可能为0。</p><p>以下有四种方法可以解决这个问题（详细代码见《Android开发艺术探索》190页）。</p><ol><li><p><code>Activity/View#onWindowFocusChanged</code></p><p>在<code>Activity</code>的<code>onResume</code>和<code>onPause</code>方法启动时，<code>onWindowFocusChanged</code>方法也会同时被调用，可以重写里面的内容，使之计算<code>View</code>的宽高。</p><p><strong>注意</strong>：<code>onWindowFocusChanged</code>方法会在<code>View</code>已经初始化完毕后才开始调用。</p></li><li><p><code>view.post(runnable)</code></p><p>通过<code>post</code>可以将一个<code>runnable</code>投递都消息队列的尾部，然后等待<code>Looper</code>调用此<code>runnable</code>的时候，<code>View</code>也已经初始化好了。</p></li><li><p><code>ViewTreeObserver</code></p><p><code>ViewTreeObserver</code>中的众多回调可以完成这个功能。</p><p>比如<code>OnGlobalLayoutListener</code>接口，当<code>View</code>树的状态发生改变或者<code>View</code>树内部的<code>View</code>的可见性发生改变的时候，<code>onGlobalLayout</code>方法将被回调，此时就可以获取<code>View</code>的宽高了。</p></li><li><p><code>view.measure(int widthMeasureSpec, int heightMeasureSpec)</code></p><p>可以主动调用该方法开始计算<code>view</code>的宽高。</p><ol><li><p><strong><code>match_parent</code></strong></p><p>由于正常的<code>measure</code>过程中，我们需要父容器的<code>MeasureSpec</code>的值，而此时父容器并没开始计算，我们无从得知这两个值的大小。故我们无法对<code>match_parent</code>的<code>view</code>计算其宽高。</p></li><li><p><strong><code>dp</code>&#x2F;<code>px</code></strong></p><p>因为有精确的数值了，所以我们可以直接使用这个精确的数值通过<code>MeasureSpec.makeMeasureSpec</code>方法构建<code>view</code>的<code>MeasureSpec</code>。</p></li><li><p><strong><code>wrap_content</code></strong></p><p>直接将<code>MeasureSpec.makeMeasureSpec</code>方法中参数的值设置为<code>(1&lt;&lt;30)-1</code>即可，这是<code>View</code>理论上可以支持的最大值，所以这样构建<code>MeasureSpec</code>是合理的。</p></li></ol></li></ol><h2 id="layout过程"><a href="#layout过程" class="headerlink" title="layout过程"></a><code>layout</code>过程</h2><p><code>layout</code>的作用是<code>ViewGroup</code>用来确定子元素的位置。当调用一个<code>View</code>的<code>layout</code>方法时，它会在<code>layout</code>方法中通过<code>setFrame</code>方法确定自身的位置，然后调用<code>onLayout</code>方法确定子元素的位置。</p><p>在<code>onLayout</code>方法中，会遍历所有子元素，对它们计算各自的位置后，调用子元素的<code>layout</code>方法，完成一轮<code>layout</code>过程。</p><p><code>View</code>中实现了<code>layout</code>方法，但是由于<code>onLayout</code>的实现与不同<code>View</code>各自的布局有关，所以源码中仅给出了一个空<code>onLayout</code>方法。需要每个<code>View</code>和<code>ViewGroup</code>自己去重写。</p><p><strong>注意</strong>：单一<code>View</code>一般不需要重写<code>onLayout</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Assign a size and position to a view and all of its</span><br><span class="hljs-comment"> * descendants</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;This is the second phase of the layout mechanism.</span><br><span class="hljs-comment"> * (The first is measuring). In this phase, each parent calls</span><br><span class="hljs-comment"> * layout on all of its children to position them.</span><br><span class="hljs-comment"> * This is typically done using the child measurements</span><br><span class="hljs-comment"> * that were stored in the measure pass().&lt;/p&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Derived classes should not override this method.</span><br><span class="hljs-comment"> * Derived classes with children should override</span><br><span class="hljs-comment"> * onLayout. In that method, they should</span><br><span class="hljs-comment"> * call layout on each of their children.&lt;/p&gt;</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"> * 为视图及其所有子体指定大小和位置</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 这是布局机制的第二阶段。</span><br><span class="hljs-comment"> * （第一个是测量）。在此阶段中，每个父级调用其所有子级上的layout来定位它们。</span><br><span class="hljs-comment"> * 这通常使用存储在方法pass()中的子测量值来完成。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 派生类不应重写此方法。</span><br><span class="hljs-comment"> * 具有子级的派生类应重写onLayout。在该方法中，他们应该对每个子对象调用布局。  </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onLayout</span><span class="hljs-params">(<span class="hljs-type">boolean</span> changed, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> top, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> bottom)</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="draw过程"><a href="#draw过程" class="headerlink" title="draw过程"></a><code>draw</code>过程</h2><p><code>draw</code>过程就比较简单，它的作用是将<code>View</code>绘制到屏幕上面。</p><p><code>View</code>的绘制过程遵循以下的4步：</p><ol><li>绘制背景：<code>background.draw(canvas)</code></li><li>绘制自己：<code>onDraw</code>方法</li><li>绘制children：<code>dispatchDraw</code>方法</li><li>绘制装饰：<code>onDrawScrollBars</code>方法</li></ol><p>所有的绘制过程都在<code>draw</code>方法中进行。</p><p>其中，<code>View</code>绘制过程的传递是通过<code>dispatchDraw</code>方法实现的，<code>dispatchDraw</code>方法会遍历所有的子元素并调用他们的<code>draw</code>方法，完成一轮的<code>draw</code>过程。</p><p><strong>注意</strong>：</p><ol><li>单一<code>View</code>需要重写<code>onDraw</code>方法绘制自身。</li><li><code>ViewGroup</code>需要重写<code>onDraw</code>方法绘制自身以及遍历子元素对它们进行绘制。</li></ol><h2 id="View的工作流程图"><a href="#View的工作流程图" class="headerlink" title="View的工作流程图"></a>View的工作流程图</h2><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-3d1255a5093de81fd5bdc27a300d2f0d_720w.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>View</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 动画深入分析</title>
    <link href="/posts/ac02c3bbb00b/"/>
    <url>/posts/ac02c3bbb00b/</url>
    
    <content type="html"><![CDATA[<h1 id="动画的三个分类"><a href="#动画的三个分类" class="headerlink" title="动画的三个分类"></a>动画的三个分类</h1><ol><li><code>View</code> 动画</li><li>帧动画</li><li>属性动画</li></ol><span id="more"></span><hr><h1 id="View动画"><a href="#View动画" class="headerlink" title="View动画"></a><code>View</code>动画</h1><h2 id="四个动画效果"><a href="#四个动画效果" class="headerlink" title="四个动画效果"></a>四个动画效果</h2><p><code>View</code>动画的作用对象是<code>View</code>，它有四个动画效果：平移动画、缩放动画、旋转动画、透明度动画。</p><p><code>View</code>动画的四个变化效果对应着<code>Animation</code>的四个子类：</p><ol><li>平移动画：<code>TranslateAnimation</code>，<code>XML</code>中对应的标签为<code>&lt;translate&gt;</code></li><li>缩放动画：<code>ScaleAnimation</code>，<code>XML</code>中对应的标签为<code>&lt;scale&gt;</code></li><li>旋转动画：<code>RotateAnimation</code>，<code>XML</code>中对应的标签为<code>&lt;rotate&gt;</code></li><li>透明度动画：<code>AlphaAnimation</code>，<code>XML</code>中对应的标签为<code>&lt;alpha&gt;</code></li></ol><h2 id="lt-set-gt-标签"><a href="#lt-set-gt-标签" class="headerlink" title="&lt;set&gt;标签"></a><code>&lt;set&gt;</code>标签</h2><p><code>&lt;set&gt;</code>标签表示动画的集合，对应着<code>AnimationSet</code>类，其中可以包含着若干的动画，也可以有子动画。</p><p>标签有两个属性：</p><ol><li><code>android:interpolator=&quot;@anim/...&quot;</code>：选定集合所使用的插值器。</li><li><code>android:shareInterpolator=[&quot;true&quot;|&quot;false&quot;]</code>：是否让集合中的动画和集合使用相同的插值器，如果为<code>false</code>，则需要为每一个动画指定一个插值器。</li></ol><h2 id="自定义View动画"><a href="#自定义View动画" class="headerlink" title="自定义View动画"></a>自定义<code>View</code>动画</h2><p>通过继承抽象类<code>Animation</code>，并重写其中的<code>intialize</code>和<code>applyTransformation</code>方法。</p><p><code>intialize</code>方法做初始化工作。</p><p><code>applyTransformation</code>方法中进行相应的矩阵变换，很多时候需要采用<code>Camera</code>类来简化矩阵变换的过程。</p><h2 id="View动画的特殊使用场景"><a href="#View动画的特殊使用场景" class="headerlink" title="View动画的特殊使用场景"></a><code>View</code>动画的特殊使用场景</h2><h3 id="LayoutAnimation"><a href="#LayoutAnimation" class="headerlink" title="LayoutAnimation"></a><code>LayoutAnimation</code></h3><p><code>LayoutAnimation</code>作用于<code>ViewGroup</code>，为<code>ViewGroup</code>指定一个动画，这样当这个<code>ViewGroup</code>的子元素出场时都会具有这个动画效果。</p><p>常常被用在<code>ListView</code>中，让其中的<code>item</code>在出场时都具有动画效果。</p><p><strong>使用步骤：</strong></p><ol><li><p>在<code>XML</code>中定义<code>LayoutAnimation</code>，标签为<code>&lt;layoutAnimation&gt;</code>。其中有两个参数：<code>android:delay</code>和<code>android:animationOrder</code>。两者的作用如下：</p><ol><li><code>android:delay</code>：使子元素的出场时间向后延迟指定的时间，单位为毫秒。</li><li><code>android:animationOrder</code>：指定子元素的出场顺序。有三种选项：<code>normal</code>顺序出场、<code>reverse</code>逆序出场、<code>random</code>随机出场。</li></ol></li><li><p>在<code>XML</code>中指定出场时的动画。</p></li><li><p>在<code>XML</code>中的<code>ViewGroup</code>部分使用<code>android:layoutAnimation</code>参数指定第1步中的<code>LayoutAnimation</code>文件，便可以为<code>ViewGroup</code>中的子元素指定出场动画。</p><p>除了可以在<code>XML</code>中指定<code>ViewGroup</code>的<code>android:layoutAnimation</code>属性，也可以在代码中通过<code>LayoutAnimationController</code>来实现。</p></li></ol><h3 id="Activity的切换效果"><a href="#Activity的切换效果" class="headerlink" title="Activity的切换效果"></a><code>Activity</code>的切换效果</h3><p><code>View</code>动画也可以对<code>Activity</code>的切换效果进行设置，效果如<code>Navigation</code>的<code>Fragment</code>切换效果。</p><p>这个效果是可以自定义的，我们可以通过<code>overridePendingTransition(int enterAnim, int exitAnim)</code>方法，这个方法<code>startActivity(Intent intent)</code>函数或者<code>finish()</code>函数之后被调用才能生效，否则动画效果将不起作用。</p><p>两个参数分别是设置的<strong>入场动画</strong>和<strong>退场动画</strong>的资源Id。</p><p>使用方法例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(...);<br>startActivity(intent);<br>overridePendingTransition(R.anim.enter_anim, R.anim.exit_anim);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finish</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>.finish();<br>    overridePendingTransition(R.anim.enter_anim, R.anim.exit_anim);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Fragment的切换效果"><a href="#Fragment的切换效果" class="headerlink" title="Fragment的切换效果"></a><code>Fragment</code>的切换效果</h3><p>由于<code>Fragment</code>类是在<code>API11</code>中才被新加入的，所以我们使用<code>support-v4</code>这个兼容包。</p><p>我们使用<code>FragmentTransaction</code>类中的<code>setCustomAnimation()</code>方法来添加切换动画，该处的动画<strong>需要是<code>View</code>动画</strong>，而<strong>不能是属性动画</strong>。</p><hr><h1 id="帧动画"><a href="#帧动画" class="headerlink" title="帧动画"></a>帧动画</h1><p>通过<code>&lt;animation-list&gt;</code>标签，并在其中预设好一组图片，类似于电影的播放，按顺序依次播放。</p><p>系统中提供<code>AnimationDrawable</code>类来使用帧动画。</p><p>应避免使用尺寸较大的图片，以防止<code>OOM</code>的发生。</p><hr><h1 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h1><p>属性动画<strong>可以对任意对象的属性进行动画</strong>而不仅仅是<code>View</code>。</p><p>动画的默认时间间隔为<code>300ms</code>，默认的帧率为<code>10ms/帧</code>。</p><p>达到的效果是：在一个时间间隔内完成对象从一个属性值到另一个属性值的改变。</p><p>常用的几个动画类是：<code>ValueAnimator</code>、<code>ObjectAnimator</code>和<code>AnimatorSet</code>。</p><p>其中，<code>ObjectAnimator</code>继承自<code>ValueAnimator</code>，<code>AnimatorSet</code>是动画集合，可以定义一组动画。</p><h2 id="Nineoldandroids"><a href="#Nineoldandroids" class="headerlink" title="Nineoldandroids"></a><code>Nineoldandroids</code></h2><p><code>API11</code>前，可以使用<code>nineoldandroids</code>开源动画库完成类似属性动画的效果，其使用的语法与<code>API11</code>后属性动画的语法完全一致，不同的是，<code>nineoldandroids</code>通过<code>View</code>动画来完成属性动画的效果。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>属性动画可以通过代码的方式完成，也可以在<code>XML</code>文件中定义。属性动画需要定义在<code>res/animator</code>中。</p><p>上述三个动画类在<code>XML</code>文件中的表示方式如下：</p><h3 id="AnimatorSet"><a href="#AnimatorSet" class="headerlink" title="AnimatorSet"></a><code>AnimatorSet</code></h3><p>对应的标签为<code>&lt;set&gt;</code>。</p><p>其中的属性<code>android:ordering=[&quot;together&quot;|&quot;sequentially&quot;]</code>有两个可选值：</p><ol><li><code>together</code>表示集合中所有的子动画同时播放。</li><li><code>sequentially</code>表示集合中的子动画依次播放。</li></ol><h3 id="ObjectAnimator"><a href="#ObjectAnimator" class="headerlink" title="ObjectAnimator"></a><code>ObjectAnimator</code></h3><p>对应的标签为<code>&lt;objectAnimator&gt;</code>。</p><p>部分属性即解释如下：</p><ul><li><p><code>android:propertyName=&quot;string&quot;</code>：表示属性动画的作用对象的属性的名称。</p></li><li><p><code>android:startOffset=&quot;int&quot;</code>：表示动画的延迟时间，当动画开始后，需要延迟多少毫秒才会真正播放此动画。</p></li><li><p><code>android:repeatCount=&quot;int&quot;</code>：表示动画的重复次数，默认值为<code>0</code>，<code>-1</code>表示无限循环。</p></li><li><p><code>android:repearMode=[&quot;restart&quot;|&quot;reverse&quot;]</code>：表示动画的重复模式。</p><ul><li><code>&quot;restart&quot;</code>表示连续重复，即每次都重新开始播放。</li><li><code>&quot;reverse&quot;</code>表示逆向重复，即第一次正放动画，第二次倒放动画，第三次正放动画，第四次倒放动画，如此反复。</li></ul></li><li><p><code>&quot;android:valueType=[&quot;intType&quot;|&quot;floatType&quot;]</code>：表示<code>android:perpertyName</code>所指定的属性的类型，如果指定的属性为颜色，那么不需要指定该属性，系统会自动对颜色类型的属性做处理。</p></li></ul><h3 id="ValueAnimator"><a href="#ValueAnimator" class="headerlink" title="ValueAnimator"></a><code>ValueAnimator</code></h3><p>对应的标签为<code>&lt;animator&gt;</code></p><p>其属性比<code>ObjectAnimator</code>少了一个<code>android:perpertyName</code>，其余的属性都是一样的，故不多介绍。</p><h2 id="理解插值器和估值器"><a href="#理解插值器和估值器" class="headerlink" title="理解插值器和估值器"></a>理解插值器和估值器</h2><p>插值器和估值器是实现非匀速动画的重要手段。</p><h3 id="TimeInterpolator"><a href="#TimeInterpolator" class="headerlink" title="TimeInterpolator"></a><code>TimeInterpolator</code></h3><p>时间插值器。作用为<strong>根据时间的流逝的百分比计算当前属性值改变的百分比</strong>。</p><p>预设的有多种插值器，常见的三种如下：</p><ol><li><code>LinearInterpolator</code>——线性插值器：匀速动画</li><li><code>AccelerateDecelerateInterpolator</code>——加速减速插值器：动画两头慢中间快</li><li><code>DecelerateInterpolator</code>——减速插值器：动画越来越慢</li></ol><p>三个类都实现了<code>Interpolator</code>接口，接口内部只有一个用来计算属性值的改变的百分比的<code>getInterpolation</code>方法需要实现。</p><h3 id="TypeEvaluator"><a href="#TypeEvaluator" class="headerlink" title="TypeEvaluator"></a><code>TypeEvaluator</code></h3><p>类型估值算法，也叫估值器。作用是<strong>根据属性值改变的百分比来计算改变后的属性值</strong>。</p><p>系统预置的有3种：</p><ol><li><code>IntEvaluator</code>：针对整形属性</li><li><code>FloatEvaluator</code>：针对浮点型属性</li><li><code>ArgbEvaluator</code>：针对Color属性</li></ol><p>三个类都实现了<code>TypeEvalator</code>接口，接口内部只有一个用来计算改变后的属性值的<code>evaluate</code>方法需要实现。</p><h3 id="计算顺序"><a href="#计算顺序" class="headerlink" title="计算顺序"></a>计算顺序</h3><p>系统会根据当前的帧所在时刻与动画播放的总时间求出时间的流逝的百分比，再通过插值器计算出当前属性值改变的百分比，后用此值通过估值器计算出当前的属性改变后的确定的值是多少并通过<code>set</code>方法对属性赋值。</p><p>故属性动画要求对象的该属性有<code>set</code>方法（必须有）和<code>get</code>方法（可选）。</p><h3 id="自定义插值器和估值器"><a href="#自定义插值器和估值器" class="headerlink" title="自定义插值器和估值器"></a>自定义插值器和估值器</h3><p>我们可以自定义插值器和估值器，来实现自己想要的动画效果。实现方式也很简单。</p><p>因为插值器和估值器都是一个接口，且内部都只有一个方法，所以我们只需要派生一个类并实现接口就可以了，然后就可以做出千奇百怪的动画效果了。即：</p><ul><li>自定义插值器需要实现<code>Interpolator</code>或者<code>TimeInterpolator</code>接口</li><li>自定义估值器需要实现<code>TypeEvaluator</code>接口。</li></ul><h2 id="属性动画的监听器"><a href="#属性动画的监听器" class="headerlink" title="属性动画的监听器"></a>属性动画的监听器</h2><p>监听器用于监听动画的播放过程，主要有两个接口：<code>AnimatorUpdateListener</code>和<code>AnimatorListener</code>。</p><h3 id="AnimatorUpdateListener"><a href="#AnimatorUpdateListener" class="headerlink" title="AnimatorUpdateListener"></a><code>AnimatorUpdateListener</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AnimatorUpdateListener</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimationUpdate</span><span class="hljs-params">(ValueAnimator animation)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该接口会监听整个动画过程，即每播放一帧，<code>onAnimationUpdate</code>就会被调用一次。</p><h3 id="AnimatorListener"><a href="#AnimatorListener" class="headerlink" title="AnimatorListener"></a><code>AnimatorListener</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">AnimatiorListener</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimatorStart</span><span class="hljs-params">(Animator animation)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimatorEnd</span><span class="hljs-params">(Animator animation)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimatorCancel</span><span class="hljs-params">(Animator animation)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAnimatorRepeat</span><span class="hljs-params">(Animator animation)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该接口会监听动画的开始、结束、取消以及重复播放。同时为了方便开发，系统还提供了<code>AnimatorListenerAdapter</code>这个类，它是<code>AnimatorListener</code>的适配器类，这样我们就可以有选择地实现上面的4个方法了。</p><h2 id="对任意属性做动画"><a href="#对任意属性做动画" class="headerlink" title="对任意属性做动画"></a>对任意属性做动画</h2><p>属性动画<strong>可以对任意对象的属性进行动画</strong>而不仅仅是<code>View</code>。</p><h3 id="属性动画的工作流程"><a href="#属性动画的工作流程" class="headerlink" title="属性动画的工作流程"></a>属性动画的工作流程</h3><p>属性动画要求动画作用的对象提供该属性的<code>set</code>方法，属性动画根据你传递的该属性的初始值和最终值，以动画的效果多次去调用<code>set</code>方法。每次传递给<code>set</code>方法的值都不一样，确切来说是随着时间的推移，所传递的值越来越接近最终值。如果动画的时候没有传递初始值，那么还要提供<code>get</code>方法，因为系统要去获取属性的初始值。即：</p><ul><li><p>必须要有该属性的<code>set</code>方法（如果这条不满足则会无效果）</p></li><li><p>如果没有传递初始值，那么必须要有该属性的<code>get</code>方法（如果这条不满足则程序直接Crash）</p></li></ul><h3 id="动画不生效时的解决方法"><a href="#动画不生效时的解决方法" class="headerlink" title="动画不生效时的解决方法"></a>动画不生效时的解决方法</h3><p>当有些对象的内部并没有该属性的<code>set</code>方法时，动画会无效果，那么我们有三个方法去解决这个问题：</p><ol><li><p><strong>如果有权限的话，直接给对象加上<code>get</code>和<code>set</code>方法</strong></p><p>很多时候，我们是没有权限的去添加方法的，比如我们给<code>Button</code>或者<code>TextView</code>等等，因为这些都是Android SDK内部实现的，我们无法更改。</p></li><li><p><strong>用一个类来包装原始对象，间隔为其提供<code>get</code>和<code>set</code>方法</strong></p><p>因为属性动画可以对任意对象进行动画，所以我们可以用一个类来包装原始对象，并在该类中为原始对象提供<code>get</code>和<code>set</code>方法。</p><p>然后对该类进行属性动画，即可修改原始对象的属性值。</p></li><li><p><strong>利用<code>ValueAnimator</code>，监听动画过程，自己实现属性的改变</strong></p><p>使用<code>AnimatorUpdateListener</code>接口监听整个动画过程，在其中的<code>onAnimationUpdate</code>方法中，对每一帧通过调用插值器和估值器计算当前的属性值，并通过<code>set</code>方法直接为该属性赋值，实现属性的改变。</p></li></ol><p><strong>注：自己写的<code>set</code>方法中，在对属性值进行修改后，需要调用<code>view.requestLayout()</code>方法重绘界面，否则无法显示更改后的界面。</strong></p><h2 id="属性动画的工作原理"><a href="#属性动画的工作原理" class="headerlink" title="属性动画的工作原理"></a>属性动画的工作原理</h2><p><code>ObjectAnimatior#start</code>方法会调用其父类<code>ValueAnimator#start</code>方法，在父类的<code>start</code>方法中会调用<code>AnimationHandler#start</code>方法，<code>AnimationHandler</code>是一个<code>Runnable</code>，我已属性动画需要运行在有<code>Looper</code>的线程中。</p><p>中间通过一系列的方法调用，然后会使用<code>ValueAnimator#doAnimationFrame</code>方法，在此方法中又调用了<code>animationFrame</code>方法，内部又调用了<code>animateValue</code>方法，其中的<code>calculateValue</code>方法就是计算每帧动画所对应的属性的值，其中的<code>setupValue</code>方法通过反射调用对象的<code>get</code>方法，<code>setAnimationValue</code>方法通过反射的方式调用了对象的<code>set</code>方法。</p><hr><h1 id="使用动画的注意事项"><a href="#使用动画的注意事项" class="headerlink" title="使用动画的注意事项"></a>使用动画的注意事项</h1><p><strong>来源：《Android开发艺术探索》</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/Android动画深入分析.png" style="zoom:75%;" />]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Animation</tag>
      
      <tag>属性动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Drawable 解析</title>
    <link href="/posts/7e6a2308252d/"/>
    <url>/posts/7e6a2308252d/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><code>Drawable</code>是一个抽象类，表示的是一个图像的概念。每一个具体的<code>Drawable</code>都是其子类。</p><p><strong>优点：</strong></p><ol><li>使用简单，比自定义<code>View</code>的成本要低。</li><li>非图片类型的<code>Drawable</code>占用空间较小，可以有效的减少<code>apk</code>的大小。</li></ol><p> <strong>内部宽&#x2F;高：</strong></p><p><code>Drawable</code>有个参数比较重要，就是<strong>内部宽&#x2F;高</strong>，通过<code>getIntrinsicWidth</code>和<code>getIntrinsicHeight</code>方法获得。</p><p>但是并不是所有的<code>Drawable</code>都有这两个参数，比如纯颜色的<code>Drawable</code>就没有内部宽&#x2F;高的概念，它的两个值都为<code>-1</code>，它的大小就是<code>View</code>的大小，而图片类型的<code>Drawable</code>的内部宽&#x2F;高决定了这个图片的固定大小。</p><h1 id="Drawable的分类"><a href="#Drawable的分类" class="headerlink" title="Drawable的分类"></a><code>Drawable</code>的分类</h1><p><code>Drawable</code>的子类有许多，这里简单的说几个，具体的参数参考《Android开发艺术探索》Page 244。</p><ul><li><p><code>BitmapDrawable</code></p><p>表示一张图片。</p></li><li><p><code>NinePatchDrawable</code></p><p>表示一个.9格式的图片。</p></li><li><p><code>ShapeDrawable</code></p><p>表示通过颜色（纯色、渐变色）来表示的图形。</p></li><li><p><code>LayerDrawable</code></p><p><code>XML</code>中的标签为<code>&lt;layer-list&gt;</code>，表示的是一组层次化的<code>Drawable</code>集合，最终的效果是由上到下的<code>Drawable</code>的效果依次叠加。</p></li><li><p><code>StateListDrawable</code></p><p><code>XML</code>中的标签为<code>&lt;selector&gt;</code>，表示一个<code>Drawable</code>集合，每个<code>Drawable</code>对应着<code>View</code>的一种状态，系统会根据<code>View</code>的不同状态更换不同的<code>Drawable</code>。常见的使用场景为<code>Button</code>的按下与弹起。</p></li><li><p><code>LevelListDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;level-list&gt;</code>，表示的是一个<code>Drawable</code>集合，其中的每一个<code>Drawable</code>都有一个等级(<code>level</code>)的概念，系统在不同的<code>level</code>下自动更换为不同的<code>Drawable</code>。</p></li><li><p><code>TransitionDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;transition&gt;</code>，其作用是实现两个<code>Drawable</code>之间的淡入淡出效果。</p></li><li><p><code>InsetDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;inset&gt;</code>，可以将其他的<code>Drawable</code>内嵌到自己的<code>Drawable</code>中，并在四周留出一定的空间。其最终显示效果为内嵌的<code>Drawable</code>的显示范围相较于不使用<code>InsetDrawable</code>时变小。</p></li><li><p><code>ScaleDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;scale&gt;</code>，其可以根据自身<code>Drawable</code>所设置的等级(<code>level</code>)对其内部的<code>Drawable</code>实现缩放的效果。</p><p>当其<code>level</code>为<code>0</code>时，其内部的<code>Drawable</code>为不可见状态；为非<code>0</code>的值时，按照<code>XML</code>中的写入的缩放比例进行显示。</p><p><code>level</code>的值默认为<code>0</code>，需要在代码中自行赋值，**系统内部约定<code>Drawable</code>的等级范围为<code>0</code>-<code>10000</code>**。</p></li><li><p><code>ClipDrawable</code></p><p><code>XML</code>中对应的标签为<code>&lt;clip&gt;</code>，可以根据自己当前的等级(<code>level</code>)来裁剪另一个<code>Drawable</code>，裁剪的方向可以通过<code>android:clipOrientation</code>和<code>android:gravity</code>共同限制。</p><p>当其<code>level</code>的值为<code>0</code>时，表示完全裁剪，即整个<code>Drawable</code>变为不可见的状态；当<code>level</code>的值设置为<code>10000</code>时，表示不裁剪；</p><p>当<code>level</code>的值设置为<code>8000</code>时，表示裁剪了2000的区域，即裁剪<code>20%</code>。</p></li></ul><h1 id="自定义Drawable"><a href="#自定义Drawable" class="headerlink" title="自定义Drawable"></a>自定义<code>Drawable</code></h1><p><code>Drawable</code>的使用场景很少，通常用在<code>View</code>的背景和作为<code>ImageView</code>中的图片两个场景。</p><p>由于自定义的<code>Drawable</code>无法在<code>XML</code>中使用，但是我们可以有其他轻便的方法来自定义<code>Drawable</code>。</p><p>通过<code>View</code>的工作原理可以知道，系统通过<code>Drawable</code>的<code>draw</code>方法来绘制<code>View</code>的背景，所以我们可以继承<code>Drawable</code>并重写<code>Drawable</code>的<code>draw</code>方法来实现自定义<code>Drawable</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Drawable</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal 解析 [转载]</title>
    <link href="/posts/a6b3bf9fb608/"/>
    <url>/posts/a6b3bf9fb608/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/61652864">Android进阶知识：ThreadLocal - Android架构</a></li></ul></blockquote><hr><h3 id="ThreadLocal是什么？"><a href="#ThreadLocal是什么？" class="headerlink" title="ThreadLocal是什么？"></a><code>ThreadLocal</code>是什么？</h3><p><code>ThreadLocal</code> 是一个线程内部数据存储类，通过它可以在指定的线程中存储数据。存储后，只能在指定的线程中获取到存储的数据，对其他线程来说无法获取到数据。</p><h3 id="ThreadLocal的使用场景"><a href="#ThreadLocal的使用场景" class="headerlink" title="ThreadLocal的使用场景"></a><code>ThreadLocal</code>的使用场景</h3><p>日常使用场景不多，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，可以考虑使用<code>ThreadLocal</code>。 <code>Android</code>源码的<code>Lopper</code>、<code>ActivityThread</code>以及<code>AMS</code>中都用到了<code>ThreadLocal</code>。</p><h3 id="ThreadLocal的使用示例"><a href="#ThreadLocal的使用示例" class="headerlink" title="ThreadLocal的使用示例"></a><code>ThreadLocal</code>的使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>    <span class="hljs-keyword">private</span> ThreadLocal&lt;String&gt; name = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_thread_local);<br>        name.set(<span class="hljs-string">&quot;小明&quot;</span>);<br>        Log.d(<span class="hljs-string">&quot;ThreadLocalActivity&quot;</span>, <span class="hljs-string">&quot;Thread:&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; name:&quot;</span> + name.get());<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;thread1&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                name.set(<span class="hljs-string">&quot;小红&quot;</span>);<br>                Log.d(<span class="hljs-string">&quot;ThreadLocalActivity&quot;</span>, <span class="hljs-string">&quot;Thread:&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; name:&quot;</span> + name.get());<br>            &#125;<br>        &#125;.start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-string">&quot;thread2&quot;</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                Log.d(<span class="hljs-string">&quot;ThreadLocalActivity&quot;</span>, <span class="hljs-string">&quot;Thread:&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; name:&quot;</span> + name.get());<br>            &#125;<br>        &#125;.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">D</span><span class="hljs-operator">/</span><span class="hljs-variable">ThreadLocalActivity</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span><span class="hljs-variable">main</span> <span class="hljs-variable">name</span><span class="hljs-operator">:</span>小明  <br><span class="hljs-built_in">D</span><span class="hljs-operator">/</span><span class="hljs-variable">ThreadLocalActivity</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span><span class="hljs-variable">thread1</span> <span class="hljs-variable">name</span><span class="hljs-operator">:</span>小红  <br><span class="hljs-built_in">D</span><span class="hljs-operator">/</span><span class="hljs-variable">ThreadLocalActivity</span><span class="hljs-operator">:</span> <span class="hljs-built_in">Thread</span><span class="hljs-operator">:</span><span class="hljs-variable">thread2</span> <span class="hljs-variable">name</span><span class="hljs-operator">:</span><span class="hljs-variable">null</span><br></code></pre></td></tr></table></figure><p>可以看到虽然访问的是同一个<code>ThreadLocal</code>对象，但是获取到的值却是不一样的。</p><h3 id="ThreadLocal的源码阅读"><a href="#ThreadLocal的源码阅读" class="headerlink" title="ThreadLocal的源码阅读"></a><code>ThreadLocal</code>的源码阅读</h3><p>那么为什么会造成这样的结果呢？这就需要去看看<code>ThreadLocal</code>的源码实现，这里的源码版本为<code>API28</code>。主要看它的<code>get</code>和<code>set</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>set</code>方法中首先获取了当前线程对象，然后通过<code>getMap</code>方法传入当前线程<code>t</code>获取到一个<code>ThreadLocalMap</code>，接下来判断这个<code>map</code>是否为空，不为空就直接将当前<code>ThreadLocal</code>作为<code>key</code>，<code>set</code>方法中传入要保存的值最为<code>value</code>，存放到<code>map</code>中；如果<code>map</code>为空就调用<code>createMap</code>方法创建一个<code>map</code>并同样将当前<code>ThreadLocal</code>和要保存的值作为<code>key</code>和<code>value</code>加入到<code>map</code>中。<br> 接下先看<code>getMap</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocalMap <span class="hljs-title function_">getMap</span><span class="hljs-params">(Thread t)</span> &#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getMap</code>方法比较简单，就是返回从传入的当前线程对象的成员变量<code>threadLocals</code>。 接着是<code>createMap</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> &#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMap</span>(<span class="hljs-built_in">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>createMap</code>方法也很简单就是<code>new</code>了一个<code>ThreadLocalMap</code>并赋给当前线程对象<code>t</code>中的<code>threadLocals</code>。 原来这个<code>Map</code>是存放在<code>Thread</code>类中的。于是进入<code>Thread</code>类中查看。<br> <code>Thread.java</code>第188-190行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span><br><span class="hljs-comment"> * by the ThreadLocal class. */</span><br>ThreadLocal.<span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">threadLocals</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>根据这里的注释可以得知，每个线程<code>Thread</code>中都有一个<code>ThreadLocalMap</code>类型的<code>threadLocals</code>成员变量来保存数据，通过<code>ThreadLocal</code>类来进行维护。这样看来我们每次在不同线程调用<code>ThreadLocal</code>的<code>set</code>方法<code>set</code>的数据是存在不同线程的<code>ThreadLocalMap</code>中的，就像注释说的<code>ThreadLocal</code>只是起了个维护<code>ThreadLocalMap</code>的功能。想到是<code>get</code>方法同样也是到不同线程的<code>ThreadLocalMap</code>去取数据。<br> <code>get</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>        ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure><p>果然，<code>get</code>方法中同样是先获取当前线程对象，然后在拿着这个对象<code>t</code>去获取到<code>t</code>中的<code>ThreadLocalMap</code>，只要<code>map</code>不等于<code>null</code>就调用<code>map.getEntry(this)</code>方法来获取数据，因为<code>ThreadLocalMap</code>里使用一个内部类<code>Entry</code>来存储数据的，所以调用<code>getEntry(this)</code>方法，传入的<code>key</code>是当前的<code>ThreadLocal</code>。这样获取到<code>Entry</code>类型数据<code>e</code>，只要<code>e</code>不为<code>null</code>，返回<code>e.value</code>即先前存储的数据。如果获取到的<code>map</code>为<code>null</code>又或者根据<code>key</code>获取<code>Entry</code>为<code>null</code>，就调用<code>setInitialValue</code>方法初始化一个<code>value</code>返回。<br> <code>setInitialValue</code>和<code>initialValue</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T <span class="hljs-title function_">setInitialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> initialValue();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>)<br>        map.set(<span class="hljs-built_in">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-keyword">protected</span> T <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>setInitialValue</code>方法中首先调用<code>initialValue</code>方法初始化了一个空<code>value</code>，之后的操作和<code>set</code>方法相同，将这个空的<code>value</code>加入到当前线程的<code>ThreadLocalMap</code>中去，<code>ThreadLocalMap</code>为空就创建个<code>Map</code>，最后返回这个空值。<br> 至此，<code>ThreadLocal</code>的<code>get</code>、<code>set</code>方法就都看过了，也理解了<code>ThreadLocal</code>可以在多个线程中操作而互不干扰的原因。但是<code>ThreadLocal</code>还有一个要注意的地方就是<code>ThreadLocal</code>使用不当会造成内存泄漏。</p><h3 id="ThreadLocal内存泄漏的原因"><a href="#ThreadLocal内存泄漏的原因" class="headerlink" title="ThreadLocal内存泄漏的原因"></a><code>ThreadLocal</code>内存泄漏的原因</h3><p>内存泄漏的根本原因是当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，导致本该被回收的对象不能被回收而停留在堆内存中。那么<code>ThreadLocal</code>中是在哪里发生的呢？这就要看到<code>ThreadLocalMap</code>中存储数据的内部类<code>Entry</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-built_in">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/91ef76c6a7efce1b563edc5501a900dbb58f6512.jpeg"></p><p>可以看到这个<code>Entry</code>类，这里的<code>key</code>是使用了个弱引用，所以因为使用弱引用这里的<code>key</code>，<code>ThreadLocal</code>会在<code>JVM</code>下次<code>GC</code>回收时候被回收，而造成了个<code>key</code>为<code>null</code>的情况，而外部<code>ThreadLocalMap</code>是没办法通过<code>null</code> <code>key</code>来找到对应<code>value</code>的。如果当前线程一直在运行，那么线程中的<code>ThreadLocalMap</code>也就一直存在，而<code>map</code>中却存在<code>key</code>已经被回收为<code>null</code>对应的<code>Entry</code>和<code>value</code>却一直存在不会被回收，造成内存的泄漏。<br> 不过，这一点设计者也考虑到了，在<code>get()</code>、<code>set()</code>、<code>remove()</code>方法调用的时候会清除掉线程<code>ThreadLocalMap</code>中所有<code>Entry</code>中<code>Key</code>为<code>null</code>的<code>Value</code>，并将整个<code>Entry</code>设置为<code>null</code>，这样在下次回收时就能将<code>Entry</code>和<code>value</code>回收。<br> 这样看上去好像是因为<code>key</code>使用了弱引用才导致的内存泄漏，为了解决还特意添加了清除<code>null key</code>的功能，那么是不是不用弱引用就可以了呢？<br> 很显然不是这样的。设计者使用弱引用是由原因的。</p><ul><li>如果使用强引用，那么如果在运行的线程中<code>ThreadLocal</code>对象已经被回收了但是<code>ThreadLocalMap</code>还持有<code>ThreadLocal</code>的强引用，若是没有手动删除，<code>ThreadLocal</code>不会被回收，同样导致内存泄漏。</li><li>如果使用弱引用<code>ThreadLocal</code>的对象被回收了，因为<code>ThreadLocalMap</code>持有的是<code>ThreadLocal</code>的弱引用，即使没有手动删除，<code>ThreadLocal</code>也会被回收。<code>nullkey</code>的<code>value</code>在下一次<code>ThreadLocalMap</code>调用<code>set</code>、<code>get</code>、<code>remove</code>的时候会被清除。</li></ul><p>所以，由于<code>ThreadLocalMap</code>和线程<code>Thread</code>的生命周期一样长，如果没有手动删除<code>Map</code>的中的<code>key</code>，无论使用强引用还是弱引用实际上都会出现内存泄漏，但是使用弱引用可以多一层保护，<code>null key</code>在下一次<code>ThreadLocalMap</code>调用<code>set</code>、<code>get</code>、<code>remove</code>的时候就会被清除。 因此，<code>ThreadLocal</code>的内存内泄漏的真正原因并不能说是因为<code>ThreadLocalMap的key</code>使用了弱引用，而是因为<code>ThreadLocalMap</code>和线程<code>Thread</code>的生命周期一样长，没有手动删除<code>Map</code>的中的<code>key</code>才会导致内存泄漏。所以解决<code>ThreadLocal</code>的内存泄漏问题就要每次使用完<code>ThreadLocal</code>，都要记得调用它的<code>remove()</code>方法来清除。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20191223161153316.png" alt="" style="zoom:67%;" /><p>总结一波：</p><p>（1）每个Thread维护着一个<code>ThreadLocalMap</code>的引用</p><p>（2）<code>ThreadLocalMap</code>是<code>ThreadLocal</code>的内部类，用Entry来进行存储</p><p>（3）<code>ThreadLocal</code>创建的副本是存储在自己的<code>threadLocals</code>中的，也就是自己的<code>ThreadLocalMap</code>。</p><p>（4）<code>ThreadLocalMap</code>的键值为<code>ThreadLocal</code>对象，而且可以有多个<code>threadLocal</code>变量，因此保存在<code>map</code>中</p><p>（5）在进行<code>get</code>之前，必须先<code>set</code>，否则会报空指针异常，当然也可以初始化一个，但是必须重写<code>initialValue</code>()方法。</p><p>（6）<code>ThreadLocal</code>本身并不存储值，它只是作为一个<code>key</code>来让线程从<code>ThreadLocalMap</code>获取<code>value</code>。</p><p>OK，现在从源码的角度上不知道你能理解不，对于<code>ThreadLocal</code>来说关键就是内部的<code>ThreadLocalMap</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ThreadLocal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/51f783f2dca4/"/>
    <url>/posts/51f783f2dca4/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
