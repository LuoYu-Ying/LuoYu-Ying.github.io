<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/ab7e3e593cd4/"/>
    <url>/posts/ab7e3e593cd4/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-TCP/IP协议族</title>
    <link href="/posts/6ed3afd2e436/"/>
    <url>/posts/6ed3afd2e436/</url>
    
    <content type="html"><![CDATA[<blockquote><p>   一系列协议所组成的一个网络分层模型。</p></blockquote><hr><h1 id="为什么要分层"><a href="#为什么要分层" class="headerlink" title="为什么要分层"></a>为什么要分层</h1><p>由于现实网络的不稳定性以及不可靠性，所以需要将大数据进行分块传输，才能保障传输效率。但是应用层有许多协议，所有的协议都可能需要分块传输以及稳定传输等众多功能需求，所以为了能够复用一部分相同或者相似的功能，我们使用了分层，方便各个功能模块的解耦和复用。</p><p>如果网络能够稳定的话，那么分成两层也就够了。一层为应用层 HTTP，第二层就直接可以是数据链路层了。</p><hr><h1 id="四层网络模型"><a href="#四层网络模型" class="headerlink" title="四层网络模型"></a>四层网络模型</h1><table><thead><tr><th align="left">层级</th><th>协议</th></tr></thead><tbody><tr><td align="left">应用层</td><td>- <code>HTTP</code><br />- <code>FTP</code><br />- <code>DNS</code></td></tr><tr><td align="left">传输层</td><td>- <code>TCP</code><br />- <code>UDP</code></td></tr><tr><td align="left">网络层</td><td>- <code>IP</code></td></tr><tr><td align="left">数据链路层</td><td>- 以太网<br />- <code>Wi-Fi</code></td></tr></tbody></table><p>应用层负责完成我们所期望的实际的工作的内容。</p><p>但是因为现实网络的不稳定性以及不可靠性，所以有了传输层来用于分块传输。但是由于有些数据在网络不稳定的时候即使丢失了也不需要进行重传，所以在 TCP 之外有了一个 UDP，他们并行存在，都位于传输层。如果所有的协议都不需要重传的话，那么也就不需要这一层了。</p><p>但是为了对他们有一个共同的下位支持，所以分离出来了一个有着 IP 协议的网络层。网络层负责以最小的单位发送和接受上层分块的网络数据以及选址、路由等最下层的网络方面工作。这些工作主要就是 IP 协议做的。</p><p>最下层的数据链路层可以看作是一个物理级别的支持，当然也不止是纯粹的物理设备，比如还有线缆标准，无线网络标准等等用于保障数据的发送和接受不会出现歧义的内容。</p><hr><h1 id="七层网络模型"><a href="#七层网络模型" class="headerlink" title="七层网络模型"></a>七层网络模型</h1><p>由 OSI 制定。较四层模型更加的细致。</p><hr><h1 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a><code>TCP</code> 连接</h1><h2 id="什么是连接"><a href="#什么是连接" class="headerlink" title="什么是连接"></a>什么是连接</h2><p>通信双方建立确认「可以通信」，不会将对方的消息丢弃，即为「建立连接」。</p><p>通过双方建立连接，可以使得双方认识彼此，在以后的通信中可以不用每次确认身份而直接开始交流。</p><p>建立连接后，双方会各自确定一个端口，当使用该端口，发送或接受信息时，就可以直接确认对方的身份了。</p><p>将端口更加具象化后，就成为了 <code>Java</code> 中的 <code>Socket</code>（套接字）类，即 Java 对于 TCP 的端口的一个具体的实现。</p><blockquote><p>  Socket <code>n. 插口</code></p></blockquote><h2 id="TCP-连接的建立与关闭"><a href="#TCP-连接的建立与关闭" class="headerlink" title="TCP 连接的建立与关闭"></a><code>TCP</code> 连接的建立与关闭</h2><p><font size = 4><b>建立：三次握手</b></font></p><ul><li><p>开启双方的认识和交流。</p></li><li><p>开启端口。</p></li></ul><p><font size = 4><b>关闭：四次挥手</b></font></p><ul><li><p>忘记对方，结束双方的交流。</p></li><li><p>释放资源，关闭端口。</p></li></ul><h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><h3 id="为什么要长连接"><a href="#为什么要长连接" class="headerlink" title="为什么要长连接"></a>为什么要长连接</h3><p>因为移动网络并不在 Internet 中，而是在运营商的内网，并不具有真正的公网 IP， 因此当某个 TCP 连接在一段时间不通信之后，网关会出于网络性能考虑而关闭这条 TCP 连接和公网的连接通道，导致这个 TCP 端口不再能收到外部通信消息，即 TCP 连接被动关闭。</p><h3 id="长连接的实现方式：心跳"><a href="#长连接的实现方式：心跳" class="headerlink" title="长连接的实现方式：心跳"></a>长连接的实现方式：心跳</h3><p>在一定的时间间隔之内，不断的使用 TCP 的连接去发送一些超级短的且没有意义的消息到对方。目的是确认双方之间的连接是通畅的，让网关不能将自己定义为「空闲连接」，从而防止网关将自己的连接关闭。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP/IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-登录和授权</title>
    <link href="/posts/e26999fccebc/"/>
    <url>/posts/e26999fccebc/</url>
    
    <content type="html"><![CDATA[<h1 id="登录和授权的区别"><a href="#登录和授权的区别" class="headerlink" title="登录和授权的区别"></a><font size = 5><b>登录和授权的区别</b></font></h1><ul><li>登录：身份认证，即确认「你是你」的过程。 </li><li>授权：由身份或持有的令牌确认享有某些权限（例如获取用户信息）。而登录过程实质上的⽬的也是为了确认权限。</li></ul><hr><h1 id="登录和授权的两种方式"><a href="#登录和授权的两种方式" class="headerlink" title="登录和授权的两种方式"></a><font size = 5><b>登录和授权的两种方式</b></font></h1><ul><li><code>Cookie Header</code></li><li><code>Authorization Header</code></li></ul><hr><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><code>Cookie</code></h1><blockquote><ul><li><p>可以把任何服务器希望存在用户本地的数据都存在用户本地。</p></li><li><p>可以认为是浏览器的缓存。</p></li><li><p>是一个 <code>Header</code>，也是一种信息存储机制。</p></li><li><p>同一个服务器可以用多个 <code>Cookie</code>，只要每个 <code>Cookie</code> 的名字不一样就行了。</p></li></ul></blockquote><h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><ol><li><p>服务器需要客户端保存的内容，放在 <code>Set-Cookie</code> headers 里返回，客户端会<strong>自动</strong>保存。</p></li><li><p>客户端保存的 Cookies，会在之后的所有请求里都 <strong>自动</strong> 携带进 <code>Cookie</code> header 里发回给服务器。</p></li><li><p>客户端保存 <code>Cookie</code> 是按照 <strong>服务器域名</strong> 来分类的，例如 shop.com 发回的 <code>Cookie</code> 保存下来以后，在之后向 games.com 的请求中并不会携带。</p></li><li><p>客户端保存的 <code>Cookie</code> 在超时后会被删除、没有设置超时时间的 <code>Cookie</code> （称作 <code>Session Cookie</code>）在浏览器关闭后就会自动删除；另外，服务器也可以主动删除还未过期的客户端 Cookies。</p></li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>出现 <code>Cookie</code> 的时候还没有 <code>JavaScript</code> 语言，所以不能对 <code>Cookie</code> 进行浏览器本地计算，必须要将 <code>Cookie</code> 传到服务器处理。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li><p>会话管理：登录状态、购物车等</p><p>移动开发通常也只将 Cookie 用于登录状态管理，且现在也越来越少的进行使用了。</p><blockquote><p>  <strong>使用 <code>Cookie</code> 管理登录状态</strong></p><p>  客户端向服务器发送用户名和密码后，当服务器验证用户登录成功后，会通过 <code>Set-Cookie</code> 向客户端传输一个 <code>SessionId</code> 的字段。<code>SessionId</code> 可以是记录了用户此次登录的会话编号。</p><p>  此后客户端每次发送请求的时候通过携带该 <code>Cookie</code> 便可将 <code>HTTP</code> 从无状态变为有状态。</p><p>  当服务器从数据库中发现存在一样的 <code>SessionId</code> 后，便可确认用户的身份信息了。</p></blockquote></li><li><p>个性化：用户篇好、主题等</p><p>如果由服务器网页有多个主题以及其他个性化内容的话，可以通过存储 <code>client_id</code> 等相似字段记录用户的选择，从而记录并显示用户的偏好。</p></li><li><p>Tracking：分析用户行为，追踪用户行为。</p><p>通过记录用户访问的网站信息或者其他信息，可以更加方便得向用户推广广告。</p></li></ol><h2 id="XSS-Cross-site-scripting"><a href="#XSS-Cross-site-scripting" class="headerlink" title="XSS(Cross-site scripting)"></a><code>XSS(Cross-site scripting)</code></h2><p><strong>跨站脚本攻击。</strong>通过 <code>JavaScript</code> 获取客户端浏览器中的 <code>Cookie</code> 并利用其中的信息，如网站登录信息等。</p><p>可以通过 <code>HttpOnly</code> 进行防护，作用是让 <code>Cookie</code> 只能用于发送请求时自动携带，而无法通过 <code>JavaScript</code> 主动获取。添加方法形如 <code>Set-Cookie:session_id=123;HttpOnly</code> 即可。</p><h2 id="XSRF-Cross-site-request-forgery"><a href="#XSRF-Cross-site-request-forgery" class="headerlink" title="XSRF(Cross-site request forgery)"></a><code>XSRF(Cross-site request forgery)</code></h2><p><strong>跨站请求伪造。</strong>在用户不知情的情况下访问了一个用户保存了 <code>Cookie</code> 的网站，以此来进行一些越权操作。</p><p>例如，私自访问用户保存了 <code>Cookie</code> 的银行网站并通过添加 <code>url</code> 参数来进行转账操作等等。</p><p>可以通过 <code>Referer</code> 校验解决，通过在发送请求的时候 <strong>自动且强制</strong> 在 Header 中添加 <code>Referer</code> 参数，其中保存了从哪一个网址跳转进入了该网址。服务器只需要校验 <code>Referer</code> 参数是否在白名单中即可保证访问安全。</p><hr><h1 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a><code>Authorization</code></h1><blockquote><p>  目前较 <code>Cookie</code> 更加流行。</p></blockquote><p><font size = 5><b>两种用法</b></font></p><h2 id="Basic-token"><a href="#Basic-token" class="headerlink" title="Basic token"></a><code>Basic token</code></h2><p>格式：<code>Authorization: Basic &lt;username:password(Base64ed)&gt;</code>。其中，<code>&lt;username:password(Base64ed)&gt;</code> 部分是将 <code>username:password</code> 格式的字符串进行 <code>Base64</code> 处理后重新替换到 <code>Basic</code> 后面。</p><p>服务器对 token 进行校验，如果校验通过，那么授权验证通过，客户端就可以获取到用户信息。如果数据不对，那么就获取不到用户信息，服务器对报 401 错误，即权限不足。</p><h2 id="Bearer-token"><a href="#Bearer-token" class="headerlink" title="Bearer token"></a><code>Bearer token</code></h2><blockquote><p>  Bearer : n. 拿着的人，持票人</p></blockquote><p>格式：<code>Authorization: Bearer &lt;bearer token&gt;</code>。<code>&lt;bearer token&gt;</code> 是授权方发给我们的 <code>access token</code>。</p><h3 id="access-token-获取方法"><a href="#access-token-获取方法" class="headerlink" title="access token 获取方法"></a><code>access token</code> 获取方法</h3><h4 id="OAuth2-流程"><a href="#OAuth2-流程" class="headerlink" title="OAuth2 流程"></a><code>OAuth2</code> 流程</h4><ol start="0"><li><p>第三方网站向授权方网站申请第三方授权合作，拿到 <code>client_id</code> 和 <code>client_secret</code></p><blockquote><p>  <code>client_id</code>：申请授权的 app 的 id。</p><p>  <code>client_secret</code>：需要严格保密，保存在第三方网站服务器中，作为密码的作用，证明是第三方网站自己申请的授权。</p></blockquote></li><li><p>用户在使用第三方网站时，点击「通过 XX (如 <code>GitHub</code>) 授权」按钮，第三方网站将页面跳转到授权方网站，并传入 <code>client_id</code> 作为自己的身份标识。</p></li><li><p>授权方网站根据  <code>client_id</code>  ，将第三方网站的信息和第三方网站需要的用户权限展示给用户，并询问用户是否同意授权</p></li><li><p>用户点击「同意授权」按钮后，授权方网站将页面跳转回第三方网站，并传入 <code>Authorization code</code> 作为用户认可的凭证。</p></li><li><p>第三方网站将 <code>Authorization code</code> 发送回自己的服务器。</p></li><li><p>服务器将 <code>Authorization code</code> 和自己的 <code>client_secret</code> ⼀并发送给授权方的服务器，授权方服务器在验证通过后，返回 <code>access token</code>。OAuth 流程结束。</p></li><li><p>在上面的过程结束之后，第三方网站的服务器（或者有时客户端也会）就可以使用 <code>access token</code> 作为用户授权的令牌，通过 <code>Authorization: Bearer &lt;access token&gt;</code> 向授权方网站发送请求来获取用户信息或操作用户账户。但这已经在 OAuth 流程之外。</p></li></ol><blockquote><p>  为什么 <code>OAuth</code> 要引入 <code>Authorization code</code>，并需要申请授权的第三方将 <code>Authorization code</code> 发送回自己的服务器，再从服务器来获取 <code>access token</code>， 而不是直接返回 <code>access token</code> ？这样复杂的流程意义何在？ </p><p>  为了安全。<code>OAuth</code> 不强制授权流程必须使用 <code>HTTPS</code>，因此需要保证当通信路径中存在窃听者时，依然具有足够高的安全性。</p></blockquote><h4 id="微信登录流程"><a href="#微信登录流程" class="headerlink" title="微信登录流程"></a>微信登录流程</h4><p>第三方 App 通过微信登录的流程，也是一个 OAuth2 流程：</p><ol start="0"><li>第三方 App 向腾讯申请第三方授权合作，拿到 <code>client_id</code> 和 <code>client_secret</code></li><li>用户在使用第三方 App 时，点击「通过微信登录」，第三方 App 将使用微信 SDK 跳转到微信，并传入自己的 <code>client_id</code> 作为自己的身份标识</li><li>微信通过和服务器交互，拿到第三方 App 的信息，并限制在界面中，然后询问用户是否同意授权该 App 使用微信来登录。</li><li>用户点击「使用微信登录」后，微信和服务器交互将授权信息提交，然后跳转回第三方 App，并传入 <code>Authorization code</code> 作为用户认可的凭证。</li><li>第三方 App 调用自己服务器的「微信登录」API，并传入 <code>Authorization code</code>，然后等待服务器的响应。</li><li>服务器在收到登录请求后，拿收到的 <code>Authorization code</code> 去向微信的第三方授权接口发送请求，将 <code>Authorization code</code> 和自己的 <code>client_secret</code> 一起作为参数发送，微信在验证通过后，返回 <code>access token</code>。</li><li>服务器在收到 <code>access token</code> 后，立即拿着 <code>access token</code> 去向微信的用户信息接口发送请求，微信验证通过后，返回用户信息。</li><li>服务器在收到用户信息后，在自己的数据库中为用户创建一个账户，并使用从微信服务器拿来的用户信息填入自己的数据库，以及将用户的 ID 和用户的微信 ID 做关联。</li><li>用户创建完成后，服务器向客户端的请求发送响应，传送回刚创建好的用户信息。</li><li>客户端收到服务器响应，用户登录成功。</li></ol><h4 id="在自家-App-中使用-Bearer-token-登录"><a href="#在自家-App-中使用-Bearer-token-登录" class="headerlink" title="在自家 App 中使用 Bearer token 登录"></a>在自家 App 中使用 <code>Bearer token</code> 登录</h4><p>有的 App 会在 API 的设计中，将登录和授权设计成类似 OAuth2 的过程，但简化掉 <code>Authorization code</code> 概念。</p><p>即：登录接口请求成功时，会直接返回 <code>access token</code>，然后客户端在之后的请求中，就可以使用这个 <code>access token</code> 来当做<br><code>bearer token</code> 进⾏用户操作了。</p><blockquote><p>  <strong>Refresh token</strong></p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;token_type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Bearer&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;access_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxxxx&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;refresh_token&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxxxx&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;expires_time&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxxxx&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>  用法：</p><ul><li><code>access token</code> 有失效时间，在它失效后，调⽤ <code>refresh_token</code> 接口，传入 <code>refresh_token</code> 来获取新的 <code>access token</code>。</li></ul><p>  目的：</p><ul><li>安全。当 <code>access token</code> 失窃，由于它有失效时间，因此坏人只有较短的时间来「做坏事」。</li><li>同时，由于（在标准的 <code>OAuth2</code> 流程中）<code>refresh token</code> 永远只存在与第三方服务的服务器中，因此 <code>refresh token</code> 几乎没有失窃的风险。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP/HTTPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络-HTTPS</title>
    <link href="/posts/0a77f507cef9/"/>
    <url>/posts/0a77f507cef9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>   <code>HTTP Secure</code> &#x2F; <code>HTTP over SSL</code> &#x2F; <code>HTTP over TLS</code></p><p>  即工作在 <code>SSL</code>（或 <code>TLS</code>）上的 <code>HTTP</code>。说白了就是加密通信的 <code>HTTP</code>。</p><ul><li><code>SSL</code> : Secure Socket Layer（安全套接字层）（<code>TLS</code> 前身）</li><li><code>TLS</code> : Transport Layer Security（传输层安全性）</li></ul></blockquote><hr><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在 <code>HTTP</code> 和 <code>TCP</code> 之间增加了一个 <strong>安全层</strong>（安全的加密层），用于保障 <code>HTTP</code> 的加密传输。</p><p>即 <code>HTTP</code> 将数据交给 <code>TCP</code> 之前，先把数据交给 <code>TLS</code>，由 <code>TLS</code> 将数据进行加密后，再往下交给 <code>TCP</code> 进行数据去传输。</p><p>以及对面的接受方在 <code>TCP</code> 层收到数据且拼接好之后，不直接交给 <code>HTTP</code> 层，而是先交给 <code>TCP</code> 层进行解密，解密完后再由 <code>TLS</code> 交给 <code>HTTP</code>。</p><hr><h1 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h1><p>在客户端和服务器之间用 <strong>非对称加密</strong> 协商出一套 <strong>对称密钥</strong> ，每次发送信息之前将内容加密，收到之后解密，达到内容的加密传输。</p><h2 id="为什么不直接用非对称加密"><a href="#为什么不直接用非对称加密" class="headerlink" title="为什么不直接用非对称加密"></a>为什么不直接用非对称加密</h2><p>非对称加密由于使用了复杂了数学原理，因此计算相当复杂，如果完全使用非对称 加密来加密通信内容，会严重影响用络通信的性能</p><hr><h1 id="HTTPS-TLS-的连接"><a href="#HTTPS-TLS-的连接" class="headerlink" title="HTTPS (TLS) 的连接"></a>HTTPS (TLS) 的连接</h1><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><ol><li>客户端请求建立 <code>TLS</code> 连接</li><li>服务器发挥证书</li><li>客户端验证服务器证书</li><li>客户端信任服务器后，和服务器协商对称密钥（此时通过非对称加密的方式协商对称密钥）</li><li>使用对称密码开始通信</li></ol><h2 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h2><blockquote><p>  可以通过 WireShark 进行更加详细的查看。</p></blockquote><ol><li><p>客户端和服务器第一次打招呼。</p><p>客户端向服务器发送 Client Hello（大小为1字节的数据，值为1，这个数据的名字叫做 Client Hello）。</p><p>同时，也会再附加信息中发送服务器可选的 <code>TLS</code> 版本、可选的加密套件（对称加密算法、非对称加密算法、哈希算法）、客户端生成的随机数。</p></li><li><p>服务器收到 Client Hello 后，确定双方可以共同使用的 <code>TLS</code> 版本、加密套件 ，以及服务端自己生成的以及随机数，并将这些信息发回给客户端，称为 Server Hello。Server Hello 也是一个单字节数据，值为2。</p><p>如果没有可以共同使用的内容，那么 <code>HTTPS</code> 就直接建立失败。</p></li><li><p>服务器发送自己的证书。</p><blockquote><p>   <strong>证书中主要包含了</strong>：</p><ol><li>服务器的公钥（其实是个数据）</li><li>服务器的证书的签名（由证书签发机构的私钥对服务器证书的签名）</li><li>证书签发机构的公钥（用户验证这个“公钥签名”的另一个公钥）</li><li>证书签发机构的证书的签名</li><li>证书签发机构的签发机构（根证书机构）的公钥</li><li>服务器主机名</li></ol></blockquote><p>可以让客户端进行信息加密。客户端通过服务器的公钥进行信息加密，服务器可以通过自己的密钥进行信息的解密。</p><blockquote><p>   <strong>服务器公钥的签名</strong></p><p>   用私钥对服务器公钥的 Hash 值版进行一次非对称加密的计算得到的结果数据。这个数据可以被该私钥对应的公钥所解开。</p><p>   如果解开签名之后的值正好等于服务器公钥经过一次 Hash 计算后的结果值，那么就证明这个源数据是没有问题的。</p><p>   注意：用于解开的公钥和被签名的公钥不是同一个，它是由私钥生成的另一个公钥。</p></blockquote></li><li><p>客户端验证公钥的正确性。</p><p>证书签发机构的签发机构的证书，在所有的操作系统中都默认带有一份，被认为是最可信的证书，被称为“根证书”。</p><p>当需要查询这些证书的时候，会从设备中进行查询，如果能够查询的到的话，那么第5个文件内容就是可信的了。</p><p>当证书签发机构的签发机构的公钥是可信的话，我们就可以使用这个公钥去验证第4个内容的正确性。再使用第3个内容的公钥去验证第2个内容的正确性了。</p><p>如果第2个内容是正确的话，那么说明服务器的公钥就是正确的了。</p><blockquote><p>  除了操作系统自带的根证书，我们也可以自行往自己的设备中安装自己需要的根证书。</p></blockquote><p><strong>注：客户端除了验证公钥是否正确，还需要验证服务器主机名是否是我们所需要到达的地址。</strong></p></li><li><p>客户端发送 <code>Pre-master Secret</code> 的数据</p><p>使用的服务器的公钥加密发过去的，也是一个客户端生成的随机数。</p></li><li><p>客户端和服务器都通过上述三个随机数生成一个 <code>Master Secret</code> 的值</p><p>通过 <code>Master Secret</code> 就可以算出双方进行对称加密的密钥等相关的一些信息了。然后双方就可以进行加密通信了。</p><p><code>Master Secret</code> 会生成四个内容：</p><ol><li>客户端加密密钥</li><li>服务端加密密钥</li><li>客户端 <code>MAC Secret</code></li><li>服务端 <code>MAC Secret</code></li></ol><blockquote><p>  <strong>为什么使用三个随机数生成数据，而不是仅使用 <code>Pre-master Secret</code> 来生成数据？</strong></p><p>  为了防止<strong>重放攻击</strong>。通过多个随机数，防止攻击者使用一个以前收到的随机数就可以获取用户的身份认证。</p><blockquote><p>  <strong>重放攻击(Replay Attacks)</strong></p><p>  又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行。</p></blockquote></blockquote><blockquote><p>  为什么客户端和服务器要使用两个加密密钥呢？</p><p>  为了防止出现攻击人将客户端发送的消息重新发送给客户端，使用相同的密钥会使客户端能够解密并认为这个服务器发送的数据，从而导致数据错误。而通过两个不同的密钥，便可以防止客户端和服务器双方无法分辨数据的来源了。</p></blockquote><p>注意：</p><ol><li>客户端向服务端发送对称加密数据时，双方使用客户端加密密钥进行加解密操作。服务端向客户端发送对称加密数据时，双方使用服务端加密密钥进行加解密操作。</li><li><code>MAC Secret</code>。其中 <code>MAC</code> 也即 <code>HMAC</code> (Hash-based Message Authentication Code 哈希运算消息认证码)，可以使数据进行带密码的哈希计算。仅仅只是无密码的哈希算法容易被攻击者碰撞，但是使用带特定的密码的哈希算法就是极大的增加难度。当接收方也使用带该密码的，相同的哈希算法进行计算后，与发送过来的哈希值进行比较，如果两者一样的话，那么就可以证明数据使对方发的且是安全的。</li></ol></li><li><p>客户端向服务器发送1个字节的数据（值为20，名称为 Change Cipher Spec），通知自己将使用加密通信。</p></li><li><p>客户端将前7步得到的数据通过客户端加密密钥以及客户端 <code>MAC Secret</code> 加密，然后发送给服务器。服务器对获得的结果进行验证。</p><p>消息名称为 Encrypted Handshake Message。</p><p><strong>此步之后，客户端就可以通过对称加密发送信息了。</strong></p></li><li><p>服务器向客户端发送1个字节的数据（值为20，名称为 Change Cipher Spec），通知自己将使用加密通信。</p></li><li><p>服务器将前9步得到的数据通过服务器加密密钥以及服务器 <code>MAC Secret</code> 加密，然后发送给客户端。客户端对获得的结果进行验证。</p><p>消息名称为 Encrypted Handshake Message。</p><p><strong>此步之后，服务器也可以通过对称加密发送信息了。</strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
