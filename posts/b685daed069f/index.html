

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/luoyuy-favicon.jpeg">
  <link rel="icon" href="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/luoyuy-favicon.jpeg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="LuoYu-Ying">
  <meta name="keywords" content="">
  
    <meta name="description" content="HashMap 的源码解读、以及 ConcurrentHashMap 的线程安全的原理。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 中 HashMap 的那些事">
<meta property="og:url" content="https://luoyuy.top/posts/b685daed069f/index.html">
<meta property="og:site_name" content="洛语 の Blog">
<meta property="og:description" content="HashMap 的源码解读、以及 ConcurrentHashMap 的线程安全的原理。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/index-img-java-hashmap.png">
<meta property="article:published_time" content="2022-05-18T11:40:20.000Z">
<meta property="article:modified_time" content="2023-03-05T06:30:40.025Z">
<meta property="article:author" content="LuoYu-Ying">
<meta property="article:tag" content="HashMap">
<meta property="article:tag" content="ConcurrentHashMap">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/index-img-java-hashmap.png">
  
  
  
  <title>Java 中 HashMap 的那些事 - 洛语 の Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"luoyuy.top","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>洛语 の Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java 中 HashMap 的那些事"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-05-18 19:40" pubdate>
          2022年5月18日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          10k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          85 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java 中 HashMap 的那些事</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>  答案参考自：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44015043/article/details/105346187">看完还不懂HashMap算我输（附职场面试常见问题）_黛色翩翩的博客-CSDN博客</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39603469/article/details/110639674">hashmap为什么用红黑树_HashMap面试必问的6个点，你知道几个？_weixin_39603469的博客-CSDN博客</a></li>
</ul>
</blockquote>
<h1 id="JDK-1-8-中-HashMap-更改了什么内容？"><a href="#JDK-1-8-中-HashMap-更改了什么内容？" class="headerlink" title="JDK 1.8 中 HashMap 更改了什么内容？"></a><code>JDK 1.8</code> 中 <code>HashMap</code> 更改了什么内容？</h1><ol>
<li>将存储方式更改为了 数组 + 链表&#x2F;<strong>红黑树</strong>。</li>
<li>优化了高位运算的<code>hash</code>算法：<code>h &amp; (h &gt;&gt;&gt; 16)</code>。</li>
<li>扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。</li>
</ol>
<h1 id="HashMap-原理"><a href="#HashMap-原理" class="headerlink" title="HashMap 原理"></a><code>HashMap</code> 原理</h1><p><strong>几个重要的变量</strong></p>
<ul>
<li><p><code>DEFAULT_INITIAL_CAPACITY</code> </p>
<p>Table数组的初始化长度： <code>1 &lt;&lt; 4</code> 。</p>
</li>
<li><p><code>MAXIMUM_CAPACITY</code> </p>
<p>Table数组的最大长度： <code>1 &lt;&lt; 30</code>。</p>
</li>
<li><p><code>DEFAULT_LOAD_FACTOR</code> </p>
<p>负载因子：默认值为<code>0.75</code>。</p>
<p> 当<code>元素的总个数 &gt; (当前数组的长度 * 负载因子)</code>，数组会进行扩容，<strong>扩容为原来的两倍</strong>。</p>
</li>
<li><p><code>TREEIFY_THRESHOLD</code> </p>
<p>链表树化阈值： 默认值为 <code>8</code> 。</p>
<p>表示在一个node（Table）节点下的值的个数大于8时候，会将链表转换成为红黑树。</p>
</li>
<li><p><code>UNTREEIFY_THRESHOLD</code> </p>
<p>红黑树链化阈值： 默认值为 <code>6</code> 。 </p>
<p>表示在进行扩容期间，单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。</p>
</li>
<li><p><code>MIN_TREEIFY_CAPACITY = 64</code> </p>
<p>最小树化阈值，值为 64。</p>
<p>当Table所有元素超过改值，才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突）。</p>
</li>
</ul>
<p><strong>实现原理</strong></p>
<img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220522214849.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" />

<p><code>HashMap</code>采⽤<code>Entry</code>数组来存储<code>key-value</code>对，每⼀个键值对组成了⼀个<code>Entry</code>实体，<code>Entry</code>类实际上是⼀个单向的链表结构，它具有<code>Next</code>指针，可以连接下⼀个<code>Entry</code>实体。 只是在<code>JDK1.8</code>中，链表⻓度⼤于<code>8</code>的时候，链表会转成<strong>红黑树</strong>。</p>
<h1 id="为什么使用-链表-数组-的存储方式？"><a href="#为什么使用-链表-数组-的存储方式？" class="headerlink" title="为什么使用 链表 + 数组 的存储方式？"></a>为什么使用 <code>链表</code> + <code>数组</code> 的存储方式？</h1><p>由于我们的数组的值是限制死的，我们在对<code>key</code>值进行散列取到下标以后，放入到数组中时，难免出现两个<code>key</code>值不同，但是却放入到下标相同的<strong>格子</strong>中，此时我们就可以使用链表来对其进行链式的存放。</p>
<h1 id="用LinkedList代替数组结构可以吗？"><a href="#用LinkedList代替数组结构可以吗？" class="headerlink" title="用LinkedList代替数组结构可以吗？"></a>用<code>LinkedList</code>代替<code>数组</code>结构可以吗？</h1><p>可以的。</p>
<h1 id="既然可以使用进行替换处理，为什么偏偏使用到数组呢？"><a href="#既然可以使用进行替换处理，为什么偏偏使用到数组呢？" class="headerlink" title="既然可以使用进行替换处理，为什么偏偏使用到数组呢？"></a>既然可以使用进行替换处理，为什么偏偏使用到<code>数组</code>呢？</h1><p>因为使用数组效率最高。</p>
<p> 在<code>HashMap</code>中，定位节点的位置是通过 <code>i = (n - 1) &amp; hash</code> 得到。此时，我们已得到节点的位置。显然数组的查找效率比<code>LinkedList</code>更优（底层是链表结构）。</p>
<p>那<code>ArrayList</code>，底层也是数组，查找也快啊，为啥不⽤<code>ArrayList</code>? </p>
<p>因为采用基本数组结构，扩容机制可以自己定义，<code>HashMap</code>中数组扩容刚好是<strong>2的次幂</strong>，方便原数组中的元素的位置变动， 而<code>ArrayList</code>的扩容机制是1.5倍扩容。</p>
<h1 id="HashMap中如何计算出存放位置的？hash函数怎么实现的"><a href="#HashMap中如何计算出存放位置的？hash函数怎么实现的" class="headerlink" title="HashMap中如何计算出存放位置的？hash函数怎么实现的?"></a><code>HashMap</code>中如何计算出存放位置的？<code>hash</code>函数怎么实现的?</h1><p><strong>该问题解析同下问。</strong></p>
<h1 id="为什么不直接将hashcode作为哈希值去做取模-而是要先高16位异或低16位"><a href="#为什么不直接将hashcode作为哈希值去做取模-而是要先高16位异或低16位" class="headerlink" title="为什么不直接将hashcode作为哈希值去做取模,而是要先高16位异或低16位"></a>为什么不直接将<code>hashcode</code>作为哈希值去做取模,而是要先高16位异或低16位</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HashMap#putVal 计算位置并存放</span><br><span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)<br>            tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure>

<p><strong>通过图做进一步的了解 <code>i = (n - 1) &amp; hash</code>：</strong></p>
<p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220522214907.png" srcset="/img/loading.gif" lazyload alt="img"></p>
<p>这里我们也就得知为什么<code>Table</code>数组的长度要一直都为 $2^n$，只有这样，减一进行<strong>与操作</strong>时候，才能够达到最大的<code>n-1</code>值。</p>
<p><strong>通过反例验证一下：</strong></p>
<p>我们现 数组的长度为 15 ，减一为 14 ，二进制表示 <code>0000 1110</code> 。进行<strong>与操作</strong>时候，最后一位永远是0，这样就可能导致不能够完完全全的进行Table数组的使用。违背了我们最开始的想要对Table数组进行<strong>最大限度的无序使用</strong>的原则，因为HashMap为了能够存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表⻓度⼤致相同。</p>
<p><strong>此时还有一点需要注意的是： 我们对key值进行hashcode以后，进行相与时候都是只用到了后四位，前面的很多位都没有能够得到使用,这样也可能会导致我们所生成的下标值不能够完全散列。</strong></p>
<p><strong>解决方案：</strong></p>
<p>将生成的<code>hashcode</code>值的高16位于低16位进行异或运算，这样得到的值再进行<strong>与操作</strong>，得散列的下标值，异或的1或0的结果都是1&#x2F;2，使得散列更均匀。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="还有哪些hash函数的实现方式？"><a href="#还有哪些hash函数的实现方式？" class="headerlink" title="还有哪些hash函数的实现方式？"></a>还有哪些<code>hash</code>函数的实现方式？</h1><p>先说⼀下<code>hash</code>算法⼲嘛的，<code>hash</code>函数是指把⼀个⼤范围映射到⼀个⼩范围。把⼤范围映射到⼀个⼩范围的⽬的往往是为了 节省空间，使得数据容易保存。</p>
<p>⽐较出名的有<code>MurmurHash</code>、<code>MD4</code>、<code>MD5</code>等等。</p>
<p><strong><code>String</code>中<code>hashcode</code>的实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hash;<br>    <span class="hljs-keyword">if</span> (h == <span class="hljs-number">0</span> &amp;&amp; value.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">char</span> val[] = value;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; value.length; i++) &#123;<br>            h = <span class="hljs-number">31</span> * h + val[i];<br>        &#125;<br>        hash = h;<br>    &#125;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="hash冲突有哪些解决办法"><a href="#hash冲突有哪些解决办法" class="headerlink" title="hash冲突有哪些解决办法"></a>hash冲突有哪些解决办法</h1><blockquote>
<p>  答案参考自：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_48241564/article/details/118613312">解决哈希冲突（四种方法）_君诀的博客-CSDN博客_解决哈希冲突的方法</a></li>
</ul>
</blockquote>
<p>有三个方法：</p>
<ol>
<li>开放定址法</li>
<li>再哈希法</li>
<li>链地址法</li>
</ol>
<h1 id="解决hash冲突的时候，为什么用红黑树？"><a href="#解决hash冲突的时候，为什么用红黑树？" class="headerlink" title="解决hash冲突的时候，为什么用红黑树？"></a>解决<code>hash</code>冲突的时候，为什么用红黑树？</h1><p>当链表过长的时候，如果仍旧使用链表进行搜索和删改，时间复杂度为$O(n)$，所消耗的时间叫较大。</p>
<p>如果采用了红黑树的设计，则可以使得在数据量较大的情况下，以$O(logn)$的时间复杂度进行搜索和删改，大幅减少使用的时间。</p>
<h1 id="红黑树的效率高，为什么一开始不用红黑树存储？"><a href="#红黑树的效率高，为什么一开始不用红黑树存储？" class="headerlink" title="红黑树的效率高，为什么一开始不用红黑树存储？"></a>红黑树的效率高，为什么一开始不用红黑树存储？</h1><blockquote>
<p>  答案参考自：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_37147070/article/details/98785367">JDK1.8以后的hashmap为什么在链表长度为8的时候变为红黑树_向日葵班学霸的博客-CSDN博客</a></li>
</ul>
</blockquote>
<p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。</p>
<p>源码中的注释写的很清楚，因为树节点所占空间是普通节点的两倍，所以只有当节点足够多的时候，才会使用树节点。也就是说，节点少的时候，尽管时间复杂度上，红黑树比链表好一点，但是红黑树所占空间比较大，综合考虑，认为只能在节点太多的时候，红黑树占空间大这一劣势不太明显的时候，才会舍弃链表，使用红黑树。</p>
<h1 id="不用红黑树，用二叉查找树可以不？"><a href="#不用红黑树，用二叉查找树可以不？" class="headerlink" title="不用红黑树，用二叉查找树可以不？"></a>不用<a target="_blank" rel="noopener" href="https://luoyu-ying.github.io/posts/59c5aea57d8c/">红黑树</a>，用二叉查找树可以不？</h1><p>可以。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。</p>
<h1 id="为什么阈值是8才转为红黑树"><a href="#为什么阈值是8才转为红黑树" class="headerlink" title="为什么阈值是8才转为红黑树"></a>为什么阈值是8才转为红黑树</h1><blockquote>
<p>   答案参考自：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_37147070/article/details/98785367">JDK1.8以后的hashmap为什么在链表长度为8的时候变为红黑树_向日葵班学霸的博客-CSDN博客</a></li>
</ul>
</blockquote>
<p>源码上说，为了配合使用分布良好的hashCode，树节点很少使用。并且在理想状态下，受随机分布的hashCode影响，链表中的节点<strong>遵循泊松分布</strong>，而且根据统计，<strong>链表中节点数</strong>是8的概率已经接近千分之一，而且此时链表的性能已经很差了。</p>
<p>所以在这种比较罕见和极端的情况下，才会把链表转变为红黑树。因为链表转换为红黑树也是需要消耗性能的，特殊情况特殊处理，为了挽回性能，权衡之下，才使用红黑树，提高性能。</p>
<p>也就是大部分情况下，hashmap还是使用的链表，如果是理想的均匀分布，节点数不到8，hashmap就自动扩容了。为什么这么说呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;<br>    <span class="hljs-type">int</span> n, index; Node&lt;K,V&gt; e;<br>    <br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        resize();<br>	<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <br>   	<span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在链表转变为红黑树方法中，有这样一个判断，数组长度小于<code>MIN_TREEIFY_CAPACITY = 64</code>，就会扩容，而不是直接转变为红黑树，可不是什么链表长度为8就变为红黑树，要仔细看代码，还有别的条件。</p>
<p>现在回头想想，为啥用8？</p>
<p><strong>因为通常情况下，链表长度很难达到8，但是特殊情况下链表长度为8，哈希表容量又很大，造成链表性能很差的时候，只能采用红黑树提高性能，这是一种应对策略。</strong></p>
<h1 id="为什么退化为链表的阈值是6"><a href="#为什么退化为链表的阈值是6" class="headerlink" title="为什么退化为链表的阈值是6"></a>为什么退化为<a target="_blank" rel="noopener" href="https://luoyu-ying.github.io/posts/59c5aea57d8c/">链表</a>的阈值是6</h1><blockquote>
<p>  答案参考自：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a7a76c5b8435">HashMap系列：树化阀值8，退化阀值6 - 简书 (jianshu.com)</a></li>
</ul>
</blockquote>
<p>如果不设退化阀值，只以8来树化与退化：<br> 那么8将成为一个临界值，时而树化，时而退化，此时会非常影响性能，因此，我们需要一个比8小的退化阀值；</p>
<p>UNTREEIFY_THRESHOLD &#x3D; 7<br> 同样，与上面的情况没有好多少，仅相差1个元素，仍旧会在链表与树之间反复转化；</p>
<p>那为什么是6呢？<br> 源码中也说了，考虑到内存（树节点比普通节点内存大2倍，以及避免反复转化），所以，退化阀值最多为6。</p>
<h1 id="HashMap中put如何实现的"><a href="#HashMap中put如何实现的" class="headerlink" title="HashMap中put如何实现的"></a><code>HashMap</code>中<code>put</code>如何实现的</h1><p><code>put</code> 方法中会实现以下的过程：</p>
<ol>
<li>如果 <code>table</code> 没有初始化，就先进行初始化（<code>resize</code>）操作。</li>
<li>对 <code>key</code> 进行 <code>hash</code>，并计算出存放位置 <code>index</code> (<code>i = (n - 1) &amp; hash</code>)。</li>
<li>如果没碰撞直接放到<code>bucket</code>中。</li>
<li>如果发生碰撞了，就遍历链表：<ol>
<li>如果出现了key相同，value不同的节点，就替换该value(保证key的唯⼀性)。</li>
<li>否则直接加入到链表的结尾（<strong>尾插法</strong>）。</li>
</ol>
</li>
<li>如果链表过长(大于等于<code>TREEIFY_THRESHOLD</code>)，就把链表转换成红黑树(<code>JDK1.8</code>中的改动)。</li>
<li>如果<code>bucket</code>满了(超过<code>DEFAULT_LOAD_FACTOR</code> * <code>CAPACITY</code>)，就要<code>resize</code>。</li>
</ol>
<h1 id="HashMap中get如何实现的"><a href="#HashMap中get如何实现的" class="headerlink" title="HashMap中get如何实现的"></a><code>HashMap</code>中<code>get</code>如何实现的</h1><p><code>get</code> 方法中会实现以下的过程：</p>
<ol>
<li>判断<code>table</code>是否为<code>null</code>，若为<code>null</code>，则直接返回<code>null</code>。</li>
<li>计算<code>key</code>的<code>hash</code>，并计算存放位置。</li>
<li>直接判断第一个元素是否为自己所需要的元素。如果是，则直接返回该节点。</li>
<li>如果有冲突，则通过<code>key.equals(k)</code>去查找对应的<code>Entry</code>。<ol>
<li>若为树，则<strong>在树中</strong>通过<code>key.equals(k)</code>查找，时间复杂度为 $O(logn)$。</li>
<li>若为链表，则<strong>在链表中</strong>通过<code>key.equals(k)</code>查找，时间复杂度为 $O(n)$。</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title function_">getNode</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, Object key)</span> &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-type">int</span> n; K k;<br>    <span class="hljs-comment">// 判断 表是否为空，表重读是否大于零，并且根据此 key 对应的表内是否存在 Node节点。    </span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-comment">// 检查第一个Node 节点，若是命中则不需要进行do... whirle 循环。</span><br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-comment">//树形结构，采用 对应的检索方法，进行检索。</span><br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">//链表方法 做while循环，直到命中结束或者遍历结束。</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="链表的查找的时间复杂度是多少"><a href="#链表的查找的时间复杂度是多少" class="headerlink" title="链表的查找的时间复杂度是多少"></a>链表的查找的时间复杂度是多少</h1><p>时间复杂度为 $O(n)$。</p>
<h1 id="HashMap在什么条件下扩容"><a href="#HashMap在什么条件下扩容" class="headerlink" title="HashMap在什么条件下扩容"></a><code>HashMap</code>在什么条件下扩容</h1><blockquote>
<p>  答案参考自：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yanzige/p/8392142.html">深入理解HashMap的扩容机制 - 颜子歌 - 博客园 (cnblogs.com)</a></li>
</ul>
</blockquote>
<p>Java8不再像Java7中那样需要满足两个条件，Java8中扩容只需要满足一个条件：</p>
<p><strong>当前存放新值<em>（注意不是替换已有元素位置时）</em>的时候已有元素的个数大于等于阈值（已有元素等于阈值，下一个存放后必然触发扩容机制）</strong></p>
<p>注：</p>
<ol>
<li>扩容一定是放入新值的时候，该新值不是替换以前位置的情况下（说明：<code>put(&quot;name&quot;,&quot;zhangsan&quot;)</code>，而map里面原有数据<code>&lt;&quot;name&quot;,&quot;lisi&quot;&gt;</code>，则该存放过程就是替换一个原有值，而不是新增值，则不会扩容）。</li>
<li>扩容发生在存放后，即是数据存放后（先存放后扩容），判断当前存入对象的个数，如果大于阈值则进行扩容。</li>
</ol>
<h1 id="为什么扩容是2的次幂"><a href="#为什么扩容是2的次幂" class="headerlink" title="为什么扩容是2的次幂"></a>为什么扩容是<strong>2的次幂</strong></h1><blockquote>
<p>  答案参考自：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44273302/article/details/113733422">HashMap初始容量为什么是2的n次幂及扩容为什么是2倍的形式？_喜欢敲代码的Apollo的博客-CSDN博客</a></li>
</ul>
</blockquote>
<ol>
<li><p>得到的新的数组索引和老数组索引只有最高位区别，更快地得到新索引。</p>
</li>
<li><p>rehash 时的取余操作，<code>hash % length == hash &amp; (length - 1)</code> 这个关系只有在 length 等于二的幂次方时成立，位运算能比%高效得多。</p>
</li>
</ol>
<p><strong>HashMap#resize 源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HashMap#resize</span><br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> newCapacity)</span> &#123;<br>    HashMapEntry[] oldTable = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> oldTable.length;<br>    <span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;<br>        threshold = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    HashMapEntry[] newTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMapEntry</span>[newCapacity]; <span class="hljs-comment">// 新建一个数组</span><br>    transfer(newTable); <span class="hljs-comment">// 完成新旧数组拷贝</span><br>    table = newTable;<br>    threshold = (<span class="hljs-type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);<br>&#125;<br><br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(HashMapEntry[] newTable)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> newTable.length;<br>    <span class="hljs-keyword">for</span> (HashMapEntry&lt;K,V&gt; e : table) &#123; <span class="hljs-comment">// 遍历整个数组</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">null</span> != e) &#123; <span class="hljs-comment">// 将同一个位置的元素按链表顺序取出</span><br>            HashMapEntry&lt;K,V&gt; next = e.next; <span class="hljs-comment">// 先将当前元素指向的下一个元素存起来，一个一个存放到新表的位置中，记住不一定是同一位置，因为长度变了</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(e.hash, newCapacity); <span class="hljs-comment">// 根据新数组长度，重新生成数组索引</span><br>            e.next = newTable[i]; <span class="hljs-comment">// 将当前位置的元素链表头指向即将新加入的元素，</span><br>            newTable[i] = e; <span class="hljs-comment">// 然后放入数组中，完成同一位置元素链表的拼接，最先添加的元素总在链表末尾</span><br>            e = next; <span class="hljs-comment">// 然后继续循环，拿出下一个元素</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="为什么HashMap线程不安全"><a href="#为什么HashMap线程不安全" class="headerlink" title="为什么HashMap线程不安全"></a>为什么<code>HashMap</code>线程不安全</h1><p>HashMap 没有通过锁的方式使得同一时间只有一个线程可以访问，如果多个线程同一时间对同一个元素进行修改，便会出现结果错误的情况。</p>
<h1 id="处理HashMap线程不安全"><a href="#处理HashMap线程不安全" class="headerlink" title="处理HashMap线程不安全"></a>处理<code>HashMap</code>线程不安全</h1><ol>
<li>在之前使用<code>HashTable</code>。 在每一个函数前面都加上了 <code>synchronized</code> 但是<strong>效率太低</strong>我们现在不常用了。</li>
<li>使用 <code>ConcurrentHashmap</code>。用于提高效率。</li>
</ol>
<hr>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a><code>ConcurrentHashMap</code></h1><blockquote>
<p>  答案参考自：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1873182">ConcurrentHashMap（JDK8） - 云+社区 - 腾讯云 (tencent.com)</a></li>
</ul>
</blockquote>
<p><font size="5"><strong>对比</strong></font></p>
<p><font size="4"><strong>与 HashMap 的区别是什么？</strong></font></p>
<p>ConcurrentHashMap 是 HashMap 的升级版，HashMap 是线程不安全的，而 ConcurrentHashMap 是线程安全。而其他功能和实现原理和 HashMap 类似。</p>
<p><font size="4"><strong>与 Hashtable 的区别是什么？</strong></font></p>
<p>Hashtable 也是线程安全的，但每次要锁住整个结构，并发性低。相比之下，ConcurrentHashMap 获取 size 时才锁整个对象。</p>
<p>Hashtable 对 get&#x2F;put&#x2F;remove 都使用了同步操作。ConcurrentHashMap 只对 put&#x2F;remove 同步。</p>
<p>Hashtable 是快速失败的，遍历时改变结构会报错 ConcurrentModificationException。ConcurrentHashMap 是安全失败，允许并发检索和更新。</p>
<p><font size="4"><strong>JDK8 的 ConcurrentHashMap 和 JDK7 的 ConcurrentHashMap 有什么区别？</strong></font></p>
<ol>
<li>JDK8 中新增了红黑树 </li>
<li>JDK7 中使用的是头插法，JDK8 中使用的是尾插法 </li>
<li>JDK7 中使用了分段锁，而 JDK8 中没有使用分段锁了 </li>
<li>JDK7 中使用了ReentrantLock，JDK8 中没有使用 ReentrantLock 了，而使用了 Synchronized </li>
<li>JDK7 中的扩容是每个 Segment 内部进行扩容，不会影响其他 Segment，而 JDK8 中的扩容和 HashMap 的扩容类似，只不过支持了多线程扩容，并且保证了线程安全</li>
</ol>
<p><font size="5"><strong>特性</strong></font></p>
<p><font size="4"><strong>ConcurrentHashMap 是如何保证并发安全的？</strong></font></p>
<p>JDK7 中 ConcurrentHashMap 是通过 <strong>ReentrantLock+CAS+分段思想</strong> 来保证的并发安全的，ConcurrentHashMap 的 put 方法会通过 CAS 的方式，把一个 Segment 对象存到 Segment 数组中，一个 Segment 内部存在一个 HashEntry 数组，相当于分段的 HashMap，Segment 继承了 ReentrantLock，每段 put 开始会加锁。</p>
<p>在 JDK7 的 ConcurrentHashMap 中，首先有一个 Segment 数组，存的是 Segment 对象，Segment 相当于一个小 HashMap，Segment 内部有一个 HashEntry 的数组，也有扩容的阈值，同时 Segment 继承了 ReentrantLock 类，同时在 Segment 中还提供了 put、get 等方法，比如 Segment 的 put 方法在一开始就会去加锁，加到锁之后才会把 key、value 存到 Segment 中去，然后释放锁。同时在ConcurrentHashMap 的 put 方法中，会通过 CAS 的方式把一个 Segment 对象存到 Segment 数组的某个位置中。同时因为一个 Segment 内部存在一个 HashEntry 数组，所以和 HashMap 对比来看，相当于分段了，每段里面是一个小的 HashMap，每段公用一把锁，同时在ConcurrentHashMap 的构造方法中是可以设置分段的数量的，叫做并发级别 concurrencyLevel。</p>
<p>JDK8 中 ConcurrentHashMap 是通过 <strong>synchronized+CAS</strong> 来实现了。在 JDK8 中只有一个数组，就是 Node 数组，Node 就是 key、value、hashcode 封装出来的对象，和 HashMap 中的 Entry 一样，在 JDK8 中通过对 Node 数组的某个 index 位置的元素进行同步，达到该 index 位置的并发安全。同时内部也利用了 CAS 对数组的某个位置进行并发安全的赋值。</p>
<p><font size="4"><strong>JDK8 中的 ConcurrentHashMap 为什么使用 synchronized 来进行加锁？</strong></font></p>
<p>JDK8 中使用 synchronized 加锁时，是对链表头结点和红黑树根结点来加锁的，而 ConcurrentHashMap 会保证，数组中某个位置的元素一定是链表的头结点或红黑树的根结点，所以 JDK8 中的 ConcurrentHashMap 在对某个桶进行并发安全控制时，只需要使用 synchronized 对当前那个位置的数组上的元素进行加锁即可，对于每个桶，只有获取到了第一个元素上的锁，才能操作这个桶，不管这个桶是一个链表还是红黑树。</p>
<p>相比于 JDK7 中使用 ReentrantLock 来加锁，因为 JDK7 中使用了分段锁，所以对于一个 ConcurrentHashMap 对象而言，分了几段就得有几个 ReentrantLock 对象，表示得有对应的几把锁。</p>
<p>而 JDK8 中使用 synchronized 关键字来加锁就会更节省内存，并且 JDK 也已经对 synchronized 的底层工作机制进行了优化，效率更好。</p>
<p><font size="4"><strong>JDK7 中的 ConcurrentHashMap 是如何扩容的？</strong></font></p>
<p>JDK7 中的 ConcurrentHashMap 和 JDK7 的 HashMap 的扩容是不太一样的。首先 JDK7 中也是支持多线程扩容的，原因是 JDK7 中的 ConcurrentHashMap 分段了，每一段叫做 Segment 对象，每个 Segment 对象相当于一个 HashMap，分段之后，对于 ConcurrentHashMap 而言，能同时支持多个线程进行操作，前提是这些操作的是不同的 Segment，而 ConcurrentHashMap 中的扩容是仅限于本 Segment，也就是对应的小型 HashMap 进行扩容，所以是可以多线程扩容的。</p>
<p>每个 Segment 内部的扩容逻辑和 HashMap 中一样。</p>
<p><font size="4"><strong>JDK8 中的 ConcurrentHashMap 是如何扩容的？</strong></font></p>
<p>首先，JDK8 中是支持多线程扩容的，JDK8 中的 ConcurrentHashMap 不再是分段，或者可以理解为每个桶为一段，在需要扩容时，首先会生成一个双倍大小的数组，生成完数组后，线程就会开始转移元素，在扩容的过程中，如果有其他线程在 put，那么这个 put 线程会帮助去进行元素的转移，虽然叫转移，但是其实是基于原数组上的 Node 信息去生成一个新的 Node 的，也就是原数组上的 Node 不会消失，因为在扩容的过程中，如果有其他线程在 get 也是可以的。</p>
<p><font size="4"><strong>JDK8 中的 ConcurrentHashMap 有一个 CounterCell，你是如何理解的？</strong></font></p>
<p>CounterCell 是 JDK8 中用来统计 ConcurrentHashMap 中所有元素个数的，在统计 ConcurentHashMap 时，不能直接对 ConcurrentHashMap 对象进行加锁然后再去统计，因为这样会影响 ConcurrentHashMap 的 put 等操作的效率，在 JDK8 的实现中使用了 <strong>CounterCell+baseCount</strong> 来辅助进行统计，baseCount 是 ConcurrentHashMap 中的一个属性，某个线程在调用 ConcurrentHashMap 对象的 put 操作时，会先通过 CAS 去修改 baseCount 的值，如果 CAS 修改成功，就计数成功，如果 CAS 修改失败，则会从 CounterCell 数组中随机选出一个 CounterCell 对象，然后利用 CAS 去修改 CounterCell 对象中的值，因为存在 CounterCell 数组，所以，当某个线程想要计数时，先尝试通过 CAS 去修改 baseCount 的值，如果没有修改成功，则从 CounterCell 数组中随机取出来一个 CounterCell 对象进行 CAS 计数，这样在计数时提高了效率。</p>
<p>所以 ConcurrentHashMap 在统计元素个数时，就是 baseCount 加上所有 CountCeller 中的 value 值，所得的和就是所有的元素个数。</p>
<h1 id="key-可以是-null-吗，value-可以是-null-吗"><a href="#key-可以是-null-吗，value-可以是-null-吗" class="headerlink" title="key 可以是 null 吗，value 可以是 null 吗"></a>key 可以是 <code>null</code> 吗，<code>value</code> 可以是 <code>null</code> 吗</h1><p>当然都是可以的，但是对于 <code>key</code>来说只能运行出现一个<code>key</code>值为<code>null</code>，但是可以出现多个<code>value</code>值为<code>null</code>。</p>
<h1 id="一般用什么值作为key值？"><a href="#一般用什么值作为key值？" class="headerlink" title="一般用什么值作为key值？"></a>一般用什么值作为<code>key</code>值？</h1><p>一般用 Integer、String 这种不可变类当 HashMap 当 key，⽽且 String 最为常用。</p>
<ol>
<li>因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。 这就使得字符串很适合作为 Map 中的键，字符串的处理速度要快过其它的键对象。 这就是 HashMap 中的键往往都使用字符串。</li>
<li>因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是⾮常重要的，这些类已经很规范的覆写了 hashCode() 以及 equals() 方法。</li>
</ol>
<h1 id="用可变类当-Hashmap-的-key-会有什么问题"><a href="#用可变类当-Hashmap-的-key-会有什么问题" class="headerlink" title="用可变类当 Hashmap 的 key 会有什么问题"></a>用可变类当 <code>Hashmap</code> 的 <code>key</code> 会有什么问题</h1><p><code>hashcode</code> 可能会发生变化，导致 <code>put</code> 进行的值，无法 <code>get</code> 出来。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86-2022/" class="category-chain-item">面试整理-2022</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/HashMap/">#HashMap</a>
      
        <a href="/tags/ConcurrentHashMap/">#ConcurrentHashMap</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java 中 HashMap 的那些事</div>
      <div>https://luoyuy.top/posts/b685daed069f/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>LuoYu-Ying</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年5月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/7d753510ecee/" title="ArrayList 你了解这些吗？">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ArrayList 你了解这些吗？</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/d91279475fe0/" title="View 事件分发的那些问题">
                        <span class="hidden-mobile">View 事件分发的那些问题</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/fluid-js/duration.js"></script> </div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<!-- hexo injector body_end start --><script src="/fluid-js/postTimeleness.js"></script><!-- hexo injector body_end end --></body>
</html>
