<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洛语 の Blog</title>
  
  
  <link href="https://luoyu-ying.github.io/atom.xml" rel="self"/>
  
  <link href="https://luoyu-ying.github.io/"/>
  <updated>2022-08-05T14:06:25.000Z</updated>
  <id>https://luoyu-ying.github.io/</id>
  
  <author>
    <name>LuoYu-Ying</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode 3.无重复字符的最长子串 [双指针法]</title>
    <link href="https://luoyu-ying.github.io/posts/71a9e5aa5923/"/>
    <id>https://luoyu-ying.github.io/posts/71a9e5aa5923/</id>
    <published>2022-08-05T14:06:25.000Z</published>
    <updated>2022-08-05T14:06:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：</p><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串 - 力扣（LeetCode）</a></p></blockquote><h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h1><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</p><h1 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h1><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h1 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= s.length &lt;= 5 * 104`</span><br><span class="line"></span><br><span class="line">s 由英文字母、数字、符号和空格组成</span><br></pre></td></tr></table></figure><hr /><h1 id="解析"><a class="markdownIt-Anchor" href="#解析"></a> 解析</h1><blockquote><p>参考文章：</p><ul><li><a href="https://www.luogu.com.cn/blog/Nero-Yuzurizaki/chi-qu-fa-xiao-jie">尺取法小结 - Fuko_Ibuki 的博客 - 洛谷博客 (luogu.com.cn)</a></li></ul></blockquote><p>使用双指针法，通过 <code>Map</code> 数据结构存储每个字符在字串中出现的次数，保证每个字串中的每个字符都只出现 1 次。</p><hr /><h1 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h1><h2 id="c"><a class="markdownIt-Anchor" href="#c"></a> C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; used;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">1</span>, ans = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> size = s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        used[s[l]]++;</span><br><span class="line">        used[s[r]]++;</span><br><span class="line">        <span class="keyword">while</span> (r &lt; size) &#123;</span><br><span class="line">            <span class="keyword">while</span> (used[s[r]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                used[s[l]]--;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (r &gt;= size) ? (r - l) : (r - l + <span class="number">1</span>));</span><br><span class="line">            r++;</span><br><span class="line">            used[s[r]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="kotlin-ver1"><a class="markdownIt-Anchor" href="#kotlin-ver1"></a> KOTLIN ver1</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> HashMap<span class="type">&lt;Char, Int&gt;</span>.<span class="title">addOrMinusOne</span><span class="params">(key: <span class="type">Char</span>, isAdd: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>[key] == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">this</span>[key] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">when</span>(isAdd) &#123;</span><br><span class="line">        <span class="literal">true</span> -&gt; <span class="keyword">this</span>[key] = <span class="keyword">this</span>[key]!! + <span class="number">1</span></span><br><span class="line">        <span class="literal">false</span> -&gt; <span class="keyword">this</span>[key] = <span class="keyword">this</span>[key]!! - <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">       <span class="keyword">when</span>(s.length) &#123;</span><br><span class="line">           <span class="number">0</span> -&gt; <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">           <span class="number">1</span> -&gt; <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> l = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> r = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> used = HashMap&lt;<span class="built_in">Char</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">        used.addOrMinusOne(s[l], <span class="literal">true</span>)</span><br><span class="line">        used.addOrMinusOne(s[r], <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">while</span> (r &lt; s.length) &#123;</span><br><span class="line">            <span class="keyword">while</span> (used[s[r]]!! &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                used.addOrMinusOne(s[l], <span class="literal">false</span>)</span><br><span class="line">                l++</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, <span class="keyword">if</span>(r &gt;= s.length) (r - l) <span class="keyword">else</span> (r - l + <span class="number">1</span>))</span><br><span class="line">            r++</span><br><span class="line">            <span class="keyword">if</span> (r &lt; s.length)</span><br><span class="line">                used.addOrMinusOne(s[r], <span class="literal">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kotlin-ver2"><a class="markdownIt-Anchor" href="#kotlin-ver2"></a> KOTLIN ver2</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">when</span>(s.length) &#123;</span><br><span class="line">           <span class="number">0</span> -&gt; <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">           <span class="number">1</span> -&gt; <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> l = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> r = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> used = HashMap&lt;<span class="built_in">Char</span>, <span class="built_in">Int</span>&gt;()</span><br><span class="line"></span><br><span class="line">        used[s[l]] = (used[s[l]] ?: <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        used[s[r]] = (used[s[r]] ?: <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt; s.length) &#123;</span><br><span class="line">            <span class="keyword">while</span> (used[s[r]]!! &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                used[s[l]] = used[s[l]]!! - <span class="number">1</span></span><br><span class="line">                l++</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, <span class="keyword">if</span>(r &gt;= s.length) (r - l) <span class="keyword">else</span> (r - l + <span class="number">1</span>))</span><br><span class="line">            r++</span><br><span class="line">            <span class="keyword">if</span> (r &lt; s.length)</span><br><span class="line">                used[s[r]] = (used[s[r]] ?: <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">使用 双指针法 解决该题。</summary>
    
    
    
    <category term="双指针法" scheme="https://luoyu-ying.github.io/categories/%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://luoyu-ying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>英语 横屏与竖屏</title>
    <link href="https://luoyu-ying.github.io/posts/225ab1cafae6/"/>
    <id>https://luoyu-ying.github.io/posts/225ab1cafae6/</id>
    <published>2022-07-30T02:45:44.000Z</published>
    <updated>2022-07-30T02:45:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>在公司实习的时候，看到代码中的 <code>landscape</code> 以及  <code>portrait</code> 两个单词的时候，并没有意识到这两个单词的含义 。</p><p>还是英语单词的储备量太少了 (´。＿。｀)。</p><hr /><h1 id="landscape"><a class="markdownIt-Anchor" href="#landscape"></a> <code>LANDSCAPE</code></h1><p>手机横屏。代码中可以简写成 <code>land</code>。</p><p>本意为风景、风景画等。</p><p>可能因为这类画作通常以横幅的形式展现，所以便使用了 <code>landscape</code> 这个英语单词表示手机的横屏。</p><hr /><h1 id="portrait"><a class="markdownIt-Anchor" href="#portrait"></a> <code>PORTRAIT</code></h1><p>手机竖屏。代码中可以简写成 <code>port</code>。</p><p>本意为肖像、肖像画等。</p><p>可能因为这类画作基本以竖幅的形式展现，所以使用了 <code>portrait</code> 这个单词表示了手机的竖屏。</p>]]></content>
    
    
    <summary type="html">记录一下英语中手机横屏与竖屏的表达。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Android Gradle 学习笔记一</title>
    <link href="https://luoyu-ying.github.io/posts/a3b80f176756/"/>
    <id>https://luoyu-ying.github.io/posts/a3b80f176756/</id>
    <published>2022-07-23T14:10:28.000Z</published>
    <updated>2022-07-24T06:10:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要讨论 Gradle 构建项目中的细节，而非构建 Gradle 的语言 Groovy 本身。</p></blockquote><hr /><blockquote><p>建议配合以下文章阅读：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/139685763">理解Android Studio中的Gradle - 知乎 (zhihu.com)</a></li></ul></blockquote><hr /><h1 id="gradle-是什么"><a class="markdownIt-Anchor" href="#gradle-是什么"></a> Gradle 是什么</h1><ol><li><p>Gradle 是一个构建工具。</p><p>Android Studio 构建系统以 Gradle 为基础，并且 Android Gradle 插件添加了几项专用于构建 Android 应用的功能。</p><p><strong>要注意的是</strong>，Gradle 它并不是独属于 Android。Gradle 本身也没有提供多少对 Android 程序构建的功能。</p><p>Gradle 是 Android Studio 默认的构建工具，它提高了 Android 的开发效率，它的作用就是管理项目中的依赖、打包、编译……</p></li><li><p>Gradle 并非一门语言，它是使用了 Groovy 语言创造出的一个 DSL。</p></li></ol><h1 id="gradle-如何构建"><a class="markdownIt-Anchor" href="#gradle-如何构建"></a> Gradle 如何构建</h1><p>我们通过 Gradle 的语法，在下列文件中指定 Gradle 的规则：</p><ol><li><code>build.gradle</code></li><li><code>settings.gradle</code></li><li><code>gradle-warpper</code></li><li>……</li></ol><hr /><h1 id="groovy-语言部分特性"><a class="markdownIt-Anchor" href="#groovy-语言部分特性"></a> Groovy 语言部分特性</h1><ol><li><p>使用函数时，函数名称后面的括号可以不写。</p></li><li><p>可以通过闭包传递函数以及其他的属性。</p><blockquote><p>闭包</p><ol><li>可以理解为 Groovy 中的 Lambda 表达式。</li><li>在功能上，和 Kotlin 的 Lambda ⽐较相似，都是⼀个「可以传递的代码块」，但是具体的功能⽐ Kotlin 的 Lambda 更强⼀些，但基本的概念是⼀样的。都是由大括号包含代码块组成。</li></ol></blockquote></li><li><p>如果函数定义的最后一个参数为闭包，那么闭包便可以写在括号外面；如果该函数只有一个参数且该参数为闭包，那么小括号可以省略。</p></li><li><p>可以在每个类中定义 <code>methodMissing</code> 函数，如果在脚本中执行了一个未在该类中定义的一个函数，Groovy 便会调用该类的 <code>methodMissing</code> 函数，并在该函数中寻找我们写入的解决方案。</p><blockquote><p>例如，<code>build.gradle</code> 中的 <code>classpath</code> 便是通过调用 <code>methodMissing</code> 函数实现依赖添加的功能。</p></blockquote></li><li><p>单引号和双引号都可以表达字符串的概念。</p></li></ol><h1 id="为什么-groovy-可以写出类似-json-格式的配置"><a class="markdownIt-Anchor" href="#为什么-groovy-可以写出类似-json-格式的配置"></a> 为什么 Groovy 可以写出类似 JSON 格式的配置？</h1><p>因为它们其实都是方法调用，只是省略了括号，以及用闭包来写成了看起来像是 JSON 型的格式。</p><hr /><h1 id="buildgradle"><a class="markdownIt-Anchor" href="#buildgradle"></a> <code>build.gradle</code></h1><h2 id="buildtypes"><a class="markdownIt-Anchor" href="#buildtypes"></a> <code>buildTypes</code></h2><p>通常有 <code>release</code>、<code>debug</code>、<code>develop</code>等等版本，也可以自定义版本。</p><p>通过 Project 形式查看文件结构，可以清楚的发现，当我们在 <code>src</code> 文件夹下面，创建类似 <code>main</code> 的层级文件夹 <code>debug</code> ，并在 <code>Build Varians</code> 选项卡中，选择 <code>debug</code> 构建模式时，AS 便会将 <code>main</code> 下方的文件以及 <code>debug</code> 下方的文件整合到一起执行，其他版本同理。</p><p>所以我们可以通过创建不同版本特有的文件夹，以达到不同版本使用、开发人员的差异化显示以及功能等区别。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220724160910544.png" alt="image" style="zoom: 80%;" /><h2 id="productflavors"><a class="markdownIt-Anchor" href="#productflavors"></a> <code>productFlavors</code></h2><p>为我们软件的版本提供更多的分类与维度，需要与 <code>flavorDimensions</code> 函数配合使用。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions <span class="string">&#x27;dimension1&#x27;</span>, <span class="string">&#x27;dimension2&#x27;</span> <span class="comment">// 确认具体的分类项</span></span><br><span class="line"></span><br><span class="line">productFlavors &#123;</span><br><span class="line">    flavor1 &#123;                              <span class="comment">// 每个具体的属性</span></span><br><span class="line">        dimension <span class="string">&#x27;dimension1&#x27;</span>             <span class="comment">// 属性所属的分类项</span></span><br><span class="line">    &#125;</span><br><span class="line">    flavor2 &#123;</span><br><span class="line">        dimension <span class="string">&#x27;dimension1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    flavor3 &#123;</span><br><span class="line">        dimension <span class="string">&#x27;dimension2&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    flavor4 &#123;</span><br><span class="line">        dimension <span class="string">&#x27;dimension2&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的示例代码，我们可以发现共有 4 种组合方式：</p><ol><li><code>flavor1</code> + <code>flavor3</code></li><li><code>flavor1</code> + <code>flavor4</code></li><li><code>flavor2</code> + <code>flavor3</code></li><li><code>flavor2</code> + <code>flavor4</code></li></ol><p>若结合上面 <code>buildTypes</code> 种的版本数量，最终共有 8 种组合方式（2 种 <code>dimension1</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 2 种 <code>dimension2</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 2 种 <code>buildTypes</code>），需要使用到某种版本时，同样可以在 <code>Build Varians</code> 选项卡中进行更改。</p><p>如果文件夹创建齐全，则上述 <code>flavor2Flavor3Debug</code> 版本的软件就会将所有与该版本有关的文件夹：</p><ol><li><code>main</code></li><li><code>debug</code></li><li><code>flavor2</code></li><li><code>flavor3</code></li><li><code>flavor2Debug</code></li><li><code>flavor3Debug</code></li><li><code>flavor2Flavor3</code></li><li><code>flavor2Flavor3Debug</code></li></ol><p>这 8 个文件夹下面的所有代码文件全部汇总后编译出最终的文件。如果存在没有创建的文件夹则忽略。</p><hr /><h1 id="compile-implementation-和-api"><a class="markdownIt-Anchor" href="#compile-implementation-和-api"></a> <code>compile</code>、<code>implementation</code> 和 <code>api</code></h1><blockquote><p>以下内容：</p><p>| 0 级项目 | --依赖–&gt; | 1 级依赖 | --依赖–&gt; | 2 级依赖 |</p></blockquote><ul><li><p><code>implementation</code>：</p><ol><li>不会传递依赖 。</li><li>0 级项目只能使用 1 级依赖提供的内容。</li></ol></li><li><p><code>compile</code> / <code>api</code>：</p><ol><li>会传递依赖；<code>api</code> 是 <code>compile</code> 的替代品，效果完全等同。</li><li>0 级项目可以直接使用 2 级依赖中的代码内容。</li></ol></li><li><p>0 级项目的修改不会影响其他项目，所以 <code>| 0 级项目 | --依赖--&gt; | 1 级依赖 |</code> 时可以使用任意函数。</p><p>推荐仍使用 <code>implementation</code> ，因为 0 级项目不需要传递依赖。</p></li><li><p><code>| 1 级依赖 | --依赖--&gt; | 2 级依赖 |</code> 中的依赖关系需要仔细考虑：</p><ul><li><p>当依赖被传递时(<code>compile</code> / <code>api</code>)，认为 0 级项目同样直接依赖 2 级依赖，2 级依赖的。改动会导致 0 级项目重新编译。</p></li><li><p>当依赖不传递时(<code>implementation</code>)，2 级依赖的改动不会导致 0 级项目重新编译，常用于本地项目，方便短时间对 0 级项目快速重写编译，减少打包时间。</p><blockquote><p>编译只是打包过程中的其中一个步骤。</p></blockquote></li></ul></li></ul><hr /><h1 id="gradle-wrapper"><a class="markdownIt-Anchor" href="#gradle-wrapper"></a> <code>Gradle Wrapper</code></h1><p>即 <code>gradlew</code>，用于 gradle 自动配置。</p><p>使用 <code>gradlew</code> 发现如果我们的电脑里有了已经配置好的 gradle ，那么就会直接使用，否则的话，就会通过互联网下载我们需要的 gradle 并使用。</p><p>如果我们的项目中有多个模块需要一样的 gradle 配置，那么我们就可以通过 gradlew 让所有的模块都去使用同一个 gradle 而不是为每个模块单独、分别下载一份一模一样的文件。</p><p>通过「只同步版本，不同步文件」的方式来减小协作项目的大小。我们可以通过指定 gradle 版本的方式，让对方的电脑主动下载我们需要的版本的 gradle，而不是我们将自己电脑的 gradle 打包进项目中，减少了项目的大小。</p><p>每个⼈电脑上的 Gradle 存放在固定位置，然后使用 Gradle Wrapper 的配置来取用对应的版本就行了。</p><p>使用方式：命令行中：<code>./gradlew</code>。</p><h2 id="gradle-wrapperproperties"><a class="markdownIt-Anchor" href="#gradle-wrapperproperties"></a> gradle-wrapper.properties</h2><p>是对 gradle wrapper 的配置文件，用于显示的表示 gradle wrapper 的存放位置，以及找不到对应的 gradle wrapper ，从而去网络下载的网络地址。</p><hr /><h1 id="settingsgradle"><a class="markdownIt-Anchor" href="#settingsgradle"></a> <code>settings.gradle</code></h1><p>整个项目的结构，说明我们整个项目中有哪几个子项目。</p><hr /><h1 id="task"><a class="markdownIt-Anchor" href="#task"></a> <code>task</code></h1><ul><li><p>使用方法： <code>./gradlew taskName</code></p></li><li><p><code>task</code> 的结构：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">task taskName &#123;</span><br><span class="line">    初始化代码</span><br><span class="line">    doFirst &#123;</span><br><span class="line">        task 代码</span><br><span class="line">    &#125;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        task 代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>doFirst</code> 以及 <code>doLast</code> 和普通代码段的区别：</p><ul><li><p>普通代码段：在 <code>task</code> 创建过程中就会被执⾏，发⽣在 configuration 阶段。</p></li><li><p><code>doFirst</code> 和 <code>doLast</code>：在 task 执行过程中被执⾏，发生在 execution 阶段。</p><p>如果用户没有直接或间接执行 <code>task</code>，那么它的 <code>doLast</code>、 <code>doFirst</code> 代码不会被执行。</p></li><li><p><code>doFirst</code> 和 <code>doLast</code> 都是 <code>task</code> 代码，其中 <code>doFirst</code> 是往队列的前面插⼊代码，<code>doLast</code> 是往队列的后面插⼊代码。</p><p>一个 <code>task</code> 里面可以写入多个 <code>doFirst</code> 以及 <code>doLast</code>。</p></li></ul></li><li><p><code>task</code> 的依赖：</p><p>可以使用 <code>task taskA(dependsOn: taskB)</code> 的形式来指定依赖。 指定依赖后，<code>taskA</code> 会在自己执行前先执行自己依赖的 <code>taskB</code>。</p><p>将所有的 task 通过一条有向边连接到其依赖 task 后，可以得到一个由所有 task 所组成的有向无环图。</p></li></ul><hr /><h1 id="gradle-执行的生命周期"><a class="markdownIt-Anchor" href="#gradle-执行的生命周期"></a> Gradle 执行的生命周期</h1><h2 id="三个阶段"><a class="markdownIt-Anchor" href="#三个阶段"></a> 三个阶段</h2><p>Gradle 执行的生命周期一共有三个阶段：</p><ol><li><p>初始化阶段</p><p>执行 settings.gradle，确定主 project 和子 project。</p></li><li><p>定义阶段（配置阶段）：</p><p>配置每个 project 的 bulid.gradle，确定出所有 task 所组成的有向无环图。</p></li><li><p>执行阶段：</p><p>按照上一阶段所确定出的有向无环图来执行指定的 task。</p></li></ol><h2 id="在阶段之间插入代码"><a class="markdownIt-Anchor" href="#在阶段之间插入代码"></a> 在阶段之间插⼊代码</h2><p>一二阶段之间：</p><ul><li>在 <code>settings.gradle</code> 的末尾写入插入的代码。</li></ul><p>二三阶段之间：</p><ul><li><p>在 <code>build.gradle</code> 文件中使用 <code>afterEvaluate</code> 函数：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">afterEvaluate &#123;</span><br><span class="line">    <span class="comment">// 插入的代码，例如网络、文件相关的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">Android 中 Gradle 配置文件浅淡</summary>
    
    
    
    <category term="Gradle" scheme="https://luoyu-ying.github.io/categories/Gradle/"/>
    
    
    <category term="Gradle" scheme="https://luoyu-ying.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>AutoHotKey 变量和字符串</title>
    <link href="https://luoyu-ying.github.io/posts/82303f29c0e9/"/>
    <id>https://luoyu-ying.github.io/posts/82303f29c0e9/</id>
    <published>2022-07-23T08:23:08.000Z</published>
    <updated>2022-07-23T08:23:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Variables.htm">变量和表达式 | AutoHotkey (autoahk.com)</a></li><li><a href="https://www.autohotkey.com/boards/viewtopic.php?t=14633">String literal that spans multiple lines? - AutoHotkey Community</a></li></ul></blockquote><hr /><blockquote><p>下文中的链接皆指向 AHK 技术文档，可放心查看。</p></blockquote><hr /><h1 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h1><p>有关一般说明和变量如何工作的详细信息, 请参阅<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Concepts.htm#variables">变量</a>.</p><h2 id="给变量赋值"><a class="markdownIt-Anchor" href="#给变量赋值"></a> <strong>给变量赋值</strong></h2><p>要将字符串或数字存储在变量中, 有两种方法: <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#legacy-syntax">传统方式</a>和<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#expressions">表达式</a>. 传统方法使用<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/SetEnv.htm">等号运算符(=)</a> 来指定<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#unquoted-text"><strong>不加引号的</strong>原义字符串</a>或用百分号括起来的变量. 例如:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyNumber = <span class="number">123</span></span><br><span class="line">MyString = This is a literal string.</span><br><span class="line">CopyOfVar = <span class="variable">%Var%</span>  <span class="comment">; 和 = 运算符一起使用时, 需要使用百分号来获取变量的内容.</span></span><br></pre></td></tr></table></figure><p>与之相比, 表达式方法使用<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/SetExpression.htm">冒号等号运算符(:=)</a> 来保存数字, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#strings"><strong>加引号的</strong>字符串</a>和其他类型的<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#expressions">表达式</a>. 以下示例在功能上与前面的例子相同:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyNumber := <span class="number">123</span></span><br><span class="line">MyString := <span class="string">&quot;This is a literal string.&quot;</span></span><br><span class="line">CopyOfVar := Var  <span class="comment">; 和前面段落中与其作用相同的语句不同, 百分号不和 := 运算符一起使用.</span></span><br></pre></td></tr></table></figure><p><strong>后一种方法由于其更清晰并且与其他许多语言几乎一致的<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#expressions">表达式语法</a>成为大多数人的首选方法.</strong></p><p>从上面的例子中您可能已经想到了有两种方法来清除变量的内容(即让变量为空):</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyVar =</span><br><span class="line">MyVar := <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>上面的这对空引号只能和 := 运算符一起使用, 因为和 = 运算符一起使用时, 则会在变量中保存两个原义的引号字符.</p><h2 id="获取变量的内容"><a class="markdownIt-Anchor" href="#获取变量的内容"></a> <strong>获取变量的内容</strong></h2><p>如同赋值有两种方法, 获取变量的内容也有两种方法: <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#legacy-syntax">传统方法</a>和<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#variables">表达式方法</a>. 传统方法需要将变量名包围在百分号中来获取变量的内容. 例如:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MsgBox The value in the variable named Var is <span class="variable">%Var%</span>.</span><br><span class="line">CopyOfVar = <span class="variable">%Var%</span></span><br></pre></td></tr></table></figure><p>与之相比, 表达式方法省去了变量名两边的百分号, 但<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#strings">原义的字符串</a>必须包围在双引号中. 所以, 下面的表达式作用等同于上面的例子:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MsgBox %</span> <span class="string">&quot;The value in the variable named Var is &quot;</span> . Var . <span class="string">&quot;.&quot;</span>  <span class="comment">; 使用句点连接(join 拼接) 两个字符串.</span></span><br><span class="line">CopyOfVar := Var</span><br></pre></td></tr></table></figure><p>在上面的 MsgBox 这行, 通过使用<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#-expression">百分号和空格</a>把参数从传统模式改变为表达式模式. 因为所有的命令默认情况下使用传统模式(除了另外注明的那些), 所以这是必须的.</p><h2 id="变量的比较"><a class="markdownIt-Anchor" href="#变量的比较"></a> <strong>变量的比较</strong></h2><p>请阅读下面表达式部分中关于不同类型变量比较的重要提示, 尤其是关于何时使用小括号的内容.</p><hr /><h1 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h1><h2 id="保存带有引号的字符串"><a class="markdownIt-Anchor" href="#保存带有引号的字符串"></a> 保存带有引号的字符串</h2><p>如果我们想用变量保存一个带有双引号的字符串，需要使用 = 操作符：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var = this is <span class="string">&quot; ; 输出的字符串中包含双引号</span></span><br></pre></td></tr></table></figure><h2 id="保存多行字符串"><a class="markdownIt-Anchor" href="#保存多行字符串"></a> 保存多行字符串</h2><p>如果我们想要保存多行的字符串，可以使用 <code>()</code> 包含文本内容并使用 <code>=</code> 且 <strong>不加 <code>&quot;&quot;</code></strong> 的方式（文本中每行的字符串形式与使用 <code>=</code> 操作符保存单行字符串的形式相同）：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var = string</span><br><span class="line"></span><br><span class="line">exampleString =</span><br><span class="line">(                      <span class="comment">; 左括号右侧的字符会被自动忽略，正文从下行开始</span></span><br><span class="line">    multiple</span><br><span class="line">        lines          <span class="comment">; 该行字符的所有字符（包括空格）会全部输出</span></span><br><span class="line">                       <span class="comment">; 空行也会如实输出  </span></span><br><span class="line"><span class="built_in">    of</span></span><br><span class="line"><span class="built_in">        %</span>var%</span><br><span class="line">)                      <span class="comment">; 右括号左侧不能有其他字符，否则将报错</span></span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">MsgBox,</span> % exampleString</span><br></pre></td></tr></table></figure><p>输出结果截图（第一个非空字符前的空格将忽略）：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220723170233064.png" alt="image-20220723170233064" style="zoom: 50%;" /><p><strong>注意：</strong></p><ol><li>该方式中的 <code>()</code> 必须分别、单独在一行，不能接在其他语句末尾。且文本将严格按照输入形式输出，两个括号之间的空行和空格也会如实输出，但是第一个非空字符前的空格将忽略。</li><li>左括号右侧的字符会被自动忽略，正文从下行开始；右括号左侧不能有其他字符，否则将报错。</li><li>如果需要使用 <code>:=</code> 操作符进行多行字符串保存，请使用 `n 转义字符进行换行操作。</li></ol>]]></content>
    
    
    <summary type="html">记录了 AutoHotKey 中变量以及字符串的基本概念与使用方法。</summary>
    
    
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/categories/AutoHotKey/"/>
    
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/tags/AutoHotKey/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 标准函数</title>
    <link href="https://luoyu-ying.github.io/posts/d15d647b4c31/"/>
    <id>https://luoyu-ying.github.io/posts/d15d647b4c31/</id>
    <published>2022-07-13T05:26:11.000Z</published>
    <updated>2022-07-13T05:26:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 标准函数 <code>Standard.kt</code> 源码  <code>GitHub</code> 仓库地址:</p><ul><li><a href="https://github.com/JetBrains/kotlin/blob/1.5.30/libraries/stdlib/src/kotlin/util/Standard.kt">kotlin/Standard.kt at 1.5.30 · JetBrains/kotlin (github.com)</a></li></ul></blockquote><hr /><h1 id="初始代码"><a class="markdownIt-Anchor" href="#初始代码"></a> 初始代码</h1><blockquote><p>下方给出一份初始代码，并在接下来的部分标准函数中给出使用该标准函数的修改后代码。</p><p>初始代码摘自《第一行代码 Android 第3版》。</p></blockquote><p>比如有一个水果列表，现在我们想吃完所有水果，并将结果打印出来，就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">builder.append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">    builder.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">builder.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = builder.toString()</span><br><span class="line">println(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行的结果为：</span></span><br><span class="line">Start eating fruits.</span><br><span class="line">Apple</span><br><span class="line">Banana</span><br><span class="line">Orange</span><br><span class="line">Pear</span><br><span class="line">Grape</span><br><span class="line">Ate all fruits.</span><br></pre></td></tr></table></figure><hr /><h1 id="run"><a class="markdownIt-Anchor" href="#run"></a> <code>run</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] and returns its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">run</span><span class="params">(block: () -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = run &#123;</span><br><span class="line">    <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">    builder.append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        builder.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    builder.toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><hr /><h1 id="trun"><a class="markdownIt-Anchor" href="#trun"></a> <code>T.run</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with `this` value as its receiver and returns its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = StringBuilder().run &#123;</span><br><span class="line">    append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><hr /><h1 id="with"><a class="markdownIt-Anchor" href="#with"></a> <code>with</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> receiver.block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = with(StringBuilder()) &#123;</span><br><span class="line">    append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        append(fruit).append(<span class="string">&quot;\n&quot;</span>)          </span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><hr /><h1 id="tapply"><a class="markdownIt-Anchor" href="#tapply"></a> <code>T.apply</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with `this` value as its receiver and returns `this` value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = StringBuilder().apply &#123;</span><br><span class="line">    append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(result.toString())</span><br></pre></td></tr></table></figure><hr /><h1 id="talso"><a class="markdownIt-Anchor" href="#talso"></a> <code>T.also</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with `this` value as its argument and returns `this` value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">also</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = StringBuilder().also &#123;</span><br><span class="line">    it.append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        it.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    it.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(result.toString())</span><br></pre></td></tr></table></figure><hr /><h1 id="tlet"><a class="markdownIt-Anchor" href="#tlet"></a> <code>T.let</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with `this` value as its argument and returns its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = StringBuilder().let &#123;</span><br><span class="line">    it.append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        it.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    it.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    it.toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><hr /><h1 id="ttakeif"><a class="markdownIt-Anchor" href="#ttakeif"></a> <code>T.takeIf</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn&#x27;t.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">takeIf</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (predicate(<span class="keyword">this</span>)) <span class="keyword">this</span> <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="ttakeunless"><a class="markdownIt-Anchor" href="#ttakeunless"></a> <code>T.takeUnless</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">takeUnless</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (!predicate(<span class="keyword">this</span>)) <span class="keyword">this</span> <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="trepeat"><a class="markdownIt-Anchor" href="#trepeat"></a> <code>T.repeat</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the given function [action] specified number of [times].</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A zero-based index of current iteration is passed as a parameter to [action].</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@sample</span> samples.misc.ControlFlow.repeat</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">repeat</span><span class="params">(times: <span class="type">Int</span>, action: (<span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    contract &#123; callsInPlace(action) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until times) &#123;</span><br><span class="line">        action(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="部分函数比较"><a class="markdownIt-Anchor" href="#部分函数比较"></a> 部分函数比较</h1><table><thead><tr><th style="text-align:center">标准函数 形参</th><th style="text-align:center">Lambda 形参</th><th style="text-align:center">Lambda 返回值</th><th style="text-align:center">标准函数 返回值</th><th style="text-align:center">作用域 参数</th></tr></thead><tbody><tr><td style="text-align:center"><code>run &#123;&#125;</code></td><td style="text-align:center"><code>()</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>\</code></td></tr><tr><td style="text-align:center"><code>T.run &#123;&#125;</code></td><td style="text-align:center"><code>T.()</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>(this.)</code></td></tr><tr><td style="text-align:center"><code>with(obj : T) &#123;&#125;</code></td><td style="text-align:center"><code>T.()</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>(this.)</code></td></tr><tr><td style="text-align:center"><code>T.apply &#123;&#125;</code></td><td style="text-align:center"><code>T.()</code></td><td style="text-align:center"><code>Unit</code></td><td style="text-align:center"><code>T</code></td><td style="text-align:center"><code>(this.)</code></td></tr><tr><td style="text-align:center"><code>T.also &#123;&#125;</code></td><td style="text-align:center"><code>(T)</code></td><td style="text-align:center"><code>Unit</code></td><td style="text-align:center"><code>T</code></td><td style="text-align:center"><code>it.</code></td></tr><tr><td style="text-align:center"><code>T.let &#123;&#125;</code></td><td style="text-align:center"><code>(T)</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>it.</code></td></tr></tbody></table><p>使用时可以通过简单的规则作出⼀些判断：</p><ol><li><p>返回自身 -&gt; 从 <code>apply</code> 和 <code>also</code> 中选</p><ul><li>作用域中使用 <code>this</code> 作为参数 -&gt; 选择 <code>apply</code></li><li>作用域中使用 <code>it</code> 作为参数 -&gt; 选择 <code>also</code></li></ul></li><li><p>不需要返回自身（可以返回任意类型） -&gt; 从 <code>run</code> 和 <code>let</code> 中选择</p><ul><li>作用域中使用 <code>this</code> 作为参数 -&gt; 选择 <code>run</code></li><li>作用域中使用 <code>it</code> 作为参数 -&gt; 选择 <code>let</code></li></ul></li><li><p><code>apply</code> 适合对一个对象做附加操作的时候</p></li><li><p><code>let</code> 适合配合空判断的时候 (最好是成员变量，⽽不是局部变量，局部变量更适合用 <code>if</code> )</p></li><li><p><code>with</code> 适合对同一个对象进行多次操作的时候</p></li></ol>]]></content>
    
    
    <summary type="html">整理了 Kotlin 中的标准函数。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>AutoHotKey 类的定义与部分使用技巧</title>
    <link href="https://luoyu-ying.github.io/posts/61bd48ea70cc/"/>
    <id>https://luoyu-ying.github.io/posts/61bd48ea70cc/</id>
    <published>2022-07-12T09:33:37.000Z</published>
    <updated>2022-07-12T09:33:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文所使用的AHK版本为 AutoHotKey_v1 。</p></blockquote><hr /><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>本人想在 AHK 中使用面向对象的方式编写代码，但是发现在官方文档中仅有较少关于 class` 的操作代码示例，所以根据自己这两天的代码编写过程，整理出常用的一些使用技巧供大家参考。</p><hr /><h1 id="类的创建和使用"><a class="markdownIt-Anchor" href="#类的创建和使用"></a> 类的创建和使用</h1><p>类的创建使用 <code>class</code>  关键字。可以显式定义构造方法以及析构方法：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 类的创建</span></span><br><span class="line">class A &#123;</span><br><span class="line">    <span class="comment">; 静态变量的创建</span></span><br><span class="line">    static var1 := Expression1</span><br><span class="line">    <span class="comment">; 类字段的创建</span></span><br><span class="line">    var2 := Expression2</span><br><span class="line">    </span><br><span class="line">    <span class="comment">; 构造方法，可传入任意参数，也可不传入参数</span></span><br><span class="line">    __New(...) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">; 方法的创建</span></span><br><span class="line">    <span class="comment">; 可传入任意参数，参数支持默认参数值</span></span><br><span class="line">    <span class="comment">; 根据需要可不写 return</span></span><br><span class="line">    methodName(...) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">; 析构方法</span></span><br><span class="line">    __Delete() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的使用：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="keyword">new</span> A(...)   <span class="comment">; 类的实例化，根据构造方法传入对应的参数</span></span><br><span class="line">a.methodName(...) <span class="comment">; 使用变量的方法</span></span><br></pre></td></tr></table></figure><hr /><h1 id="在类中创建热键并绑定类方法"><a class="markdownIt-Anchor" href="#在类中创建热键并绑定类方法"></a> 在类中创建热键并绑定类方法</h1><p>使用面向对象的思想编写代码的话，我们或许需要在类中创建热键及其响应逻辑的方法：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    <span class="comment">; 自定义的一个方法，用于加载类中所有的热键</span></span><br><span class="line">    loadHotKey() &#123;</span><br><span class="line">        <span class="comment">; 创建响应方法的方法引用</span></span><br><span class="line">        varFunctionA := ObjBindMethod(this, <span class="string">&quot;functionA&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">; 创建 Alt + A 的热键以及绑定其响应方法</span></span><br><span class="line"><span class="built_in">        HotKey,</span> !A, % varFunctionA, On</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    functionA() &#123;</span><br><span class="line">    <span class="comment">; 热键的响应逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码便在类中创建了一个使用类中方法作为响应逻辑的热键。其中：</p><ol><li><code>varFunctionA := ObjBindMethod(this, &quot;functionA&quot;)</code> 部分：<ol><li><code>&quot;functionA&quot;</code> 中双引号必须保留，双引号中间内容为对应的方法名。</li><li><code>varFunctionName</code> 为自定义的变量名称，与第7行第3个参数相对应。</li></ol></li><li><code>HotKey, !A, % varFunctionA, On</code> 部分：<ol><li><code>!A</code> 为热键的内容，具体可以参考文档中 <strong>热键</strong> 部分内容。</li><li><code>% varFunctionA</code> 中百分号必须保留，后面的内容对应上面一行自定义的变量名。</li></ol></li></ol><p>热键的使用：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> A().loadHotKey()</span><br></pre></td></tr></table></figure><p>通过对该类的实例化并调用实例化对象的 <code>loadHotKey</code> 方法即可。</p><hr /><h1 id="在类中绘制-ui-并绑定类方法"><a class="markdownIt-Anchor" href="#在类中绘制-ui-并绑定类方法"></a> 在类中绘制 <code>UI</code> 并绑定类方法</h1><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class B &#123;</span><br><span class="line">    <span class="comment">; 自定义的一个方法，用于绘制 UI 以及绑定响应的方法</span></span><br><span class="line">    loadView() &#123;</span><br><span class="line">        <span class="comment">; 绘制了一个按钮</span></span><br><span class="line"><span class="built_in">        Gui,</span> Add, Button, w200 h35 hwndHFuncB, This is a button.</span><br><span class="line"></span><br><span class="line">        <span class="comment">; 创建了响应方法的方法引用</span></span><br><span class="line">        varFuncB := ObjBindMethod(this, <span class="string">&quot;functionB&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">; 通过 HWND 将按钮与方法绑定</span></span><br><span class="line"><span class="built_in">        GuiControl,</span> +g, <span class="variable">%HFuncB%</span>, % varFuncB</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    functionB() &#123;</span><br><span class="line">        <span class="comment">; 按钮的响应逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>Gui, Add, Button, w200 h35 hwndHFuncB, This is a button.</code> 中 <code>hwndHFuncB</code> 部分：<ol><li>形式为 <code>hwnd + 自定义变量名</code></li><li>自定义变量名与第9行中第3个参数相对应。</li></ol></li><li><code>varFuncB := ObjBindMethod(this, &quot;functionB&quot;)</code> 部分：<ol><li><code>varFuncB</code> 为另一个自定义变量名，与第9行中第4个变量名相对应。</li><li><code>&quot;functionB&quot;</code> 中双引号必须保留，双引号中间内容为对应的方法名。</li></ol></li><li><code>GuiControl, +g, %HFuncB%, % varFuncB</code> 中第3、4个参数分别为上述的两个自定义变量名。</li></ol><hr /><h1 id="代码示例"><a class="markdownIt-Anchor" href="#代码示例"></a> 代码示例</h1><blockquote><p>使用面向对象思想重构 <a href="https://luoyu-ying.github.io/posts/050a11a7817a/">通过 AutoHotKey 简化 Hexo 操作 | 洛语 の Blog (luoyu-ying.github.io)</a> 中 Deploy 部分的操作。</p></blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 加载类的 UI 以及热键</span></span><br><span class="line"><span class="keyword">new</span> Deploy().load()</span><br><span class="line"></span><br><span class="line"><span class="comment">; -------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 类的创建</span></span><br><span class="line">class Deploy &#123;</span><br><span class="line"></span><br><span class="line">    load() &#123;</span><br><span class="line">        this.loadView()</span><br><span class="line">        this.loadHotKey()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">; 本代码中 GAD -&gt; generate and deploy</span></span><br><span class="line">    </span><br><span class="line">    loadView() &#123;</span><br><span class="line"><span class="built_in">        Gui,</span> Add, Button, w200 h35 hwndHGAD, Generate &amp;&amp; Deploy</span><br><span class="line">        </span><br><span class="line">        varGAD := ObjBindMethod(this, <span class="string">&quot;generateDeploy&quot;</span>)</span><br><span class="line"><span class="built_in">        </span></span><br><span class="line"><span class="built_in">        GuiControl,</span> +g, <span class="variable">%HGAD%</span>, % varGAD</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadHotKey() &#123;</span><br><span class="line">        varGAD := ObjBindMethod(this, <span class="string">&quot;generateDeploy&quot;</span>)</span><br><span class="line"><span class="built_in">        </span></span><br><span class="line"><span class="built_in">        Hotkey,</span> CapsLock &amp; G, % varGAD, On</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    generateDeploy() &#123;</span><br><span class="line"><span class="built_in">        Run,</span> <span class="variable">%comSpec%</span> /c hexo g &amp;&amp; hexo d, , Min</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录一下自己在使用 AutoHotKey_v1 中类的方法绑定类中定义的热键以及 GUI 的方法。</summary>
    
    
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/categories/AutoHotKey/"/>
    
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/tags/AutoHotKey/"/>
    
  </entry>
  
  <entry>
    <title>AutoHotHey 问题解决记录</title>
    <link href="https://luoyu-ying.github.io/posts/8f286d636eff/"/>
    <id>https://luoyu-ying.github.io/posts/8f286d636eff/</id>
    <published>2022-07-11T06:41:25.000Z</published>
    <updated>2022-07-11T06:41:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>更多的资料请参考 AHK 官方技术文档以及 AHK 社区。</p></blockquote><hr /><h1 id="代码中有些代码总是无法运行"><a class="markdownIt-Anchor" href="#代码中有些代码总是无法运行"></a> 代码中有些代码总是无法运行</h1><blockquote><p>处理方法参考自：</p><ul><li><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Scripts.htm#auto">脚本 - 定义与使用 | AutoHotkey (autoahk.com)</a></li></ul></blockquote><blockquote><p>下文中的所有链接皆为 AHK 技术文档中该词条的链接，可正常使用。</p></blockquote><p><strong><font size="4"><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Scripts.htm#auto">脚本顶部(自动执行段)</a></font></strong></p><p>脚本加载完成后, 它会从顶行开始执行, 直到遇到 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Return.htm">Return</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Exit.htm">Exit</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Hotkeys.htm">热键/热字串标签</a> 或脚本的底部(无论最先遇到哪个). 脚本的这个顶端部分被称为 <em>自动执行段</em>.</p><blockquote><p><strong>注意:</strong> 虽然脚本的 <em>第一个</em> 热键/热字串标签与 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Return.htm">return(返回)</a> 的效果相同, 但其他热键和标签却没有.</p></blockquote><p>如果脚本不是<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/_Persistent.htm">持续运行的</a>, 它将在自动执行部分完成后终止. 否则, 它会以空闲状态持续运行, 从而对诸如<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Hotkeys.htm">热键</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Hotstrings.htm">热字串</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Gui.htm#label">GUI 事件</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Menu.htm">自定义菜单项</a>和<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/SetTimer.htm">计时器</a>等事件做出响应. 如果一个脚本包含了热键, 热字串, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/OnMessage.htm">OnMessage()</a> 或 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Gui.htm">GUI</a>, 以及一些其他情况, 它就会自动变为持续运行的. 也可以用 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/_Persistent.htm">#Persistent</a> 指令来显式地使脚本持续运行.</p><hr /><h1 id="通过函数创建热键"><a class="markdownIt-Anchor" href="#通过函数创建热键"></a> 通过函数创建热键</h1><p>通过 <code>HotKey</code> 函数动态的创建一个热键。</p><blockquote><p>具体参数可以查看文档：<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Hotkey.htm">Hotkey | AutoHotkey (autoahk.com)</a></p></blockquote><p>示例：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 创建一个 CapsLock + K 的一个热键，效果为 Sfunction Lable 中的内容</span></span><br><span class="line"><span class="built_in">HotKey,</span> CapsLocks &amp; K, function</span><br><span class="line"></span><br><span class="line">function() &#123;</span><br><span class="line"><span class="built_in">MsgBox,</span> <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="通过函数创建热字串"><a class="markdownIt-Anchor" href="#通过函数创建热字串"></a> 通过函数创建热字串</h1><p>通过 <code>HotString</code> 函数动态的创建一个热字串。</p><blockquote><p>具体的参数可以查看文档：<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Hotstring.htm">Hotstring() | AutoHotkey (autoahk.com)</a></p></blockquote><hr /><h1 id="无法正常使用分号注释符号"><a class="markdownIt-Anchor" href="#无法正常使用分号注释符号"></a> 无法正常使用分号（注释符号）</h1><p>当我们想要使用 分号 作为热键中的一部分时，我们可以使用 <code>SC027</code> 替换分号的位置，以达到分号的作用、</p><p>示例：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 创建一个 CapsLock + K 的一个热键，效果为 function Lable 中的内容</span></span><br><span class="line"><span class="built_in">HotKey,</span> CapsLocks &amp; SC027, function </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录了一些在编写 AutoHotKey 代码中遇到的问题以及解决的方案。</summary>
    
    
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/categories/AutoHotKey/"/>
    
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/tags/AutoHotKey/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Butterfly 添加相册</title>
    <link href="https://luoyu-ying.github.io/posts/aae775e24f21/"/>
    <id>https://luoyu-ying.github.io/posts/aae775e24f21/</id>
    <published>2022-07-10T14:33:28.000Z</published>
    <updated>2022-07-10T14:33:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://butterfly.js.org/posts/dc584b87/">Butterfly 安裝文檔(二) 主題頁面 | Butterfly</a></li></ul></blockquote><hr /><h1 id="gallery-相册图库"><a class="markdownIt-Anchor" href="#gallery-相册图库"></a> <code>Gallery</code> 相册图库</h1><p>图库页面只是普通的页面，你只需要：</p><ol><li><p><code>hexo n page xxxxx</code> 创建你的页面。</p></li><li><p>在 <code>index.md</code> 使用标签外挂 <code>galleryGroup</code>。</p></li></ol><h2 id="gallerygroup-模板"><a class="markdownIt-Anchor" href="#gallerygroup-模板"></a> <code>galleryGroup</code> 模板</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p>name：图库名字</p></li><li><p>description：图库描述</p></li><li><p>link：连接到对应相册的地址</p></li><li><p>img-url：图库封面的地址</p></li></ul><h2 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span><br><span class="line">&#123;% galleryGroup &#x27;封面图&#x27; &#x27;已发布文章的封面图&#x27; &#x27;/gallery/wallpaper&#x27; images/389.jpg %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/389.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">封面图</div>  <p>已发布文章的封面图</p>  <a href='/gallery/wallpaper'></a>  </figcaption>  </figure>  </div><hr /><h1 id="gallery-相册子页面"><a class="markdownIt-Anchor" href="#gallery-相册子页面"></a> <code>Gallery</code> 相册子页面</h1><p>子页面也是普通的页面，你只需要：</p><ol><li><code>hexo n page xxxxx</code> 创建你的页面。</li><li>然后使用标签外挂 <code>gallery</code>。</li></ol><h2 id="gallery-模板"><a class="markdownIt-Anchor" href="#gallery-模板"></a> <code>gallery</code> 模板</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>markdown 图片格式： <code>![]()</code> 或者 <code>&lt;img src = &quot;&quot;&gt;</code> 的格式皆可。</li></ul><h2 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](images/389.jpg)</span><br><span class="line">![](images/166.jpg)</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/250.jpg&quot;</span>&gt;</span></span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><div class="fj-gallery"><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/389.jpg" alt="" /></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/166.jpg" alt="" /></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/250.jpg">          </div><hr /><h1 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h1><p>如果你想要使用 <code>/gallery/wallpaper</code> 这样的链接显示你的图片内容。你可以把创建好的 <code>wallpaper</code> 整个文件夹移到 <code>gallery</code> 文件夹里中。</p>]]></content>
    
    
    <summary type="html">记录一下在 Hexo Butterfly 中相册的添加方法。</summary>
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Lambda 表达式</title>
    <link href="https://luoyu-ying.github.io/posts/0ca5222da5ff/"/>
    <id>https://luoyu-ying.github.io/posts/0ca5222da5ff/</id>
    <published>2022-07-10T03:19:09.000Z</published>
    <updated>2022-07-10T03:19:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li>《第一行代码 Android 第3版》</li><li><a href="https://time.geekbang.org/course/intro/100009801">快速上手 Kotlin 开发 (geekbang.org)</a></li><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li></ul></blockquote><hr /><h1 id="lambda-定义"><a class="markdownIt-Anchor" href="#lambda-定义"></a> <code>Lambda</code> 定义</h1><p><code>Lambda</code> 就是一小段可以作为参数传递的代码，也可以认为是函数的简写形式。</p><hr /><h1 id="lambda-表达式的语法结构"><a class="markdownIt-Anchor" href="#lambda-表达式的语法结构"></a> <code>Lambda</code> 表达式的语法结构</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;参数名<span class="number">1</span>: 参数类型, 参数名<span class="number">2</span>: 参数类型, ..., 参数名n: 参数类型 -&gt; 函数体&#125;</span><br></pre></td></tr></table></figure><p>这是 <code>Lambda</code> 表达式最完整的语法结构定义。</p><p>首先最外层是一对大括号，如果有参数传入到 <code>Lambda</code> 表达式中的话，我们还需要声明参数列表，参数列表的结尾使用一个 <code>-&gt;</code> 符号，表示参数列表的结束以及函数体的开始。</p><p>函数体中可以编写任意行代码（虽然不建议编写太长的代码)，<strong>并且最后一行代码会自动作为 <code>Lambda</code> 表达式的返回值</strong>，即 <code>return 最后一行代码</code>。</p><p>所以我们也可以用变量获取 <code>Lambda</code> 表达式的结果，即 <code>val result = &#123;... -&gt; ...&#125;</code> 。</p><hr /><h1 id="lambda-表达式的特点"><a class="markdownIt-Anchor" href="#lambda-表达式的特点"></a> <code>Lambda</code> 表达式的特点</h1><ol><li>最后一行代码会自动作为 <code>Lambda</code> 表达式的返回值（隐式 <code>return</code>）。</li><li>如果 <code>Lambda</code> 没有参数，那么可以省略箭头符号 <code>-&gt;</code>。</li><li>如果 <code>Lambda</code> 是函数的最后一个参数，那么可以将大括号放在小括号的外面。</li><li>如果函数只有一个参数并且这个参数就是 <code>Lambda</code> ，则可以省略小括号。</li></ol><hr /><h1 id="sam-转换"><a class="markdownIt-Anchor" href="#sam-转换"></a> <code>SAM</code> 转换</h1><blockquote><p>当一个函数的参数是 SAM 的情况下，我们同样也可以使用 Lambda 作为参数。</p><p>通过 SAM 转换，我们就可以在 Kotlin 中便携的编写如 setOnClickListener 之类的方法了。</p></blockquote><p><code>SAM</code> 是 Single Abstract Method 的缩写，意思就是只有一个抽象方法的类或者接口。但在 Kotlin 和 Java 8 里，<strong>SAM 代表着只有一个抽象方法的接口</strong>。只要是符合 SAM 要求的接口，编译器就能进行 SAM 转换，也就是我们可以使用 Lambda 表达式，来简写接口类的参数。</p><p>注意，Java 8 中的 SAM 有明确的名称，叫做函数式接口（FunctionalInterface）。FunctionalInterface 的限制如下，缺一不可：</p><ol><li>必须是接口，抽象类不行；</li><li>该接口有且仅有一个抽象的方法，抽象方法个数必须是 1，默认实现的方法可以有多个。</li></ol><p>也就是说，对于 View.java 来说，它虽然是 Java 代码，但 Kotlin 编译器知道它的参数 OnClickListener 符合 SAM 转换的条件，所以会自动做以下转换。</p><p>转换前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnClickListener</span><span class="params">(OnClickListener l)</span></span><br></pre></td></tr></table></figure><p>转换后：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(l: (<span class="type">View</span>) -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="comment">// 实际上是这样：</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(l: ((<span class="type">View</span>!) -&gt; <span class="type">Unit</span>)?)</span></span></span><br></pre></td></tr></table></figure><p>其中，((View!) -&gt; Unit)? 代表的是这个参数可能为空。</p><hr /><h1 id="lambda-表达式的写法"><a class="markdownIt-Anchor" href="#lambda-表达式的写法"></a> <code>Lambda</code> 表达式的写法</h1><p>当一个函数的参数是 <code>SAM</code> 的情况下，我们同样也可以使用 <code>Lambda</code> 作为参数。所以，我们既可以用匿名内部类的方式传参，也可以使用 <code>Lambda</code> 的方式传参。</p><p>从匿名内部类的写法到 <code>Lambda</code> 表达式最终的精简形式，在这两种写法的中间，还有 6 种“过渡状态”的写法。</p><p>下面将从匿名内部类的写法开始，一步步的过渡到 <code>Lambda</code> 的写法。</p><p><strong><font size="4">第 1 种写法</font></strong></p><p>这是原始代码，它的本质是用 <code>object</code> 关键字定义了一个匿名内部类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(<span class="keyword">object</span>: View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        gotoPreview(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 2 种写法</font></strong></p><p>在这种情况下，<code>object</code> 关键字可以被省略。这时候它在语法层面就不再是匿名内部类了，它更像是 <code>Lambda</code> 表达式了，因此它里面 <code>override</code> 的方法也要跟着删掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(View.OnClickListener &#123; v: View? -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的 <code>View.OnClickListener</code> 被称为 <code>SAM Constructor</code>（SAM 构造器），它是编译器为我们生成的。</p><p>这段代码明显简化了很多，既可以实现同样的功能，又不会造成任何歧义。因为 <code>View.OnClickListener</code> 中只有一个待实现方法,即使这里没有显式地重写 onClick() 方法，<code>Kotlin</code> 也能自动明白 <code>View.OnClickListener</code> 后面的 <code>Lambda</code> 表达式就是要在 <code>onClick()</code> 方法中实现的内容。</p><p><strong><font size="4">第 3 种写法</font></strong></p><p>如果一个 <code>Java</code> 方法的参数列表中不存在一个以上 <code>Java</code> 单抽象方法接口参数，我们还可以将接口名进行省略（且<code>Kotlin</code> 的 <code>Lambda</code> 表达式是不需要 <code>SAM Constructor</code> 的），所以它也可以被删掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123; v: View? -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 4 种写法</font></strong></p><p>由于 <code>Kotlin</code> 支持类型推导，所以 <code>View</code> 可以被删掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123; v -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 5 种写法</font></strong></p><p>当 <code>Kotlin</code> <code>Lambda</code> 表达式只有一个参数的时候，它可以被写成 <code>it</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123; it -&gt;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 6 种写法</font></strong></p><p><code>Kotlin</code> <code>Lambda</code> 的 <code>it</code> 是可以被省略的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 7 种写法</font></strong></p><p>当 <code>Kotlin</code> <code>Lambda</code> 作为函数的最后一个参数时，<code>Lambda</code> 可以被挪到外面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener() &#123;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 8 种写法</font></strong></p><p>当 <code>Kotlin</code> 只有一个 <code>Lambda</code> 作为函数参数时，<code>()</code> 可以被省略：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener &#123;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，将这 8 种写法的演进过程以动图的形式展现了出来，让你对 <code>Lambda</code> 这几种写法的差异有一个更加直观的认识。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/e441323968c0c061898257fd06db37bf.gif" alt="img" style="zoom: 50%;" />]]></content>
    
    
    <summary type="html">学习并整理了 Kotlin 中 Lambda 表达式的使用方法。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 函数嵌套</title>
    <link href="https://luoyu-ying.github.io/posts/47063eb1b5ed/"/>
    <id>https://luoyu-ying.github.io/posts/47063eb1b5ed/</id>
    <published>2022-07-09T15:24:11.000Z</published>
    <updated>2022-07-10T04:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li><li><a href="https://www.cnblogs.com/Anker/archive/2013/03/04/2943498.html">递归与尾递归总结 - Rabbit_Dale - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/zsp765098084/article/details/90901260">kotlin学习笔记之尾递归优化（tailrec）_mictoy_朱的博客-CSDN博客_kotlin tailrec</a></li></ul></blockquote><hr /><h1 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h1><p>在 <code>Kotlin</code> 中，我们可以在函数的代码块中创建另一个新的函数并使用该函数。并且该函数可以使用外部函数的变量。</p><p>如下方的代码；</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">outerMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算 1 + 2 + 3 + ...</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">innerMethod</span><span class="params">(c: <span class="type">Int</span> = <span class="number">10</span>)</span></span> &#123;</span><br><span class="line">        sum += c</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span>)</span><br><span class="line">        innerMethod(c - <span class="number">1</span>)</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    innerMethod()</span><br><span class="line">  println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    outerMethod()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h1><p>函数嵌套在工程中应尽量少的使用，容易造成代码可读性的降低。</p><p>但是在两种情况下可以创建内部函数：</p><ol><li>在某些情况下需要临时使用 <strong>递归</strong> 函数，如上文中的代码。</li><li>不希望被外部函数访问到的函数。</li></ol><hr /><h1 id="尾递归"><a class="markdownIt-Anchor" href="#尾递归"></a> 尾递归</h1><p>实际上，在函数式编程当中，我们有时候也会使用递归来替代循环。</p><p>我们知道，递归都是有调用栈开销的，所以我们应该尽量使用 <strong>尾递归</strong>。对于这种类型的递归，在经过栈复用优化以后，它的开销就可以忽略不计了，我们可以认为它的空间复杂度是 O(1)。</p><blockquote><p>尾递归就是从最后开始计算，每递归一次就算出相应的结果，也就是说, 函数调用出现在调用者函数的尾部，因为是尾部，所以根本没有必要去保存任何局部变量，直接让被调用的函数返回时越过调用者，返回到调用者的调用者去。</p><p><strong>尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数</strong>，深层函数所面对的不是越来越简单的问题，而是越来越复杂的问题，因为参数里带有前面若干步的运算路径。</p><p>尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。</p></blockquote><h2 id="尾递归的特点"><a class="markdownIt-Anchor" href="#尾递归的特点"></a> 尾递归的特点</h2><ul><li>递归的一种特殊形式</li><li>调用自身后无其他操作</li><li><code>tailrec</code> 关键字提示编译器尾递归优化</li></ul><p>示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>(<span class="keyword">val</span> value:<span class="built_in">Int</span>,<span class="keyword">var</span> next:ListNode? = <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findListNode</span><span class="params">(head:<span class="type">ListNode</span>?,value:<span class="type">Int</span>)</span></span>:ListNode?&#123; <span class="comment">//定义一个递归函数</span></span><br><span class="line">    head?:<span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (head.value == value) <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">return</span> findListNode(head.next,value)    <span class="comment">//return除了调用自己，没有多余的操作，所以是尾递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾递归优化的使用"><a class="markdownIt-Anchor" href="#尾递归优化的使用"></a> 尾递归优化的使用</h2><p>在 <code>Kotlin</code> 语言中，我们即使写出了符合尾递归的递归函数，编译器也不会自动帮我们进行优化。</p><p>我们需要在 <code>fun</code> 关键字前面加上 <code>tailrec</code> 关键字以表示我们需要进行尾递归优化。</p><p>示例代码1：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>(<span class="keyword">val</span> value:<span class="built_in">Int</span>,<span class="keyword">var</span> next:ListNode? = <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">findListNode</span><span class="params">(head:<span class="type">ListNode</span>?,value:<span class="type">Int</span>)</span></span>:ListNode?&#123; <span class="comment">//定义一个递归函数</span></span><br><span class="line">    head?:<span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (head.value == value) <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">return</span> findListNode(head.next,value)    <span class="comment">//return除了调用自己，没有多余的操作，所以是尾递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码2：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">recursionLoop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="comment">// 变化在这里</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line">    <span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">go</span><span class="params">(i: <span class="type">Int</span>, sum: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">10</span>) sum <span class="keyword">else</span> go(i + <span class="number">1</span>, sum + i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> go(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾递归优化的实质"><a class="markdownIt-Anchor" href="#尾递归优化的实质"></a> 尾递归优化的实质</h2><p>通过对上文中的 <code>findListNode</code> 方法对 <strong>加了 <code>tailrec</code> 关键字</strong> 与 <strong>去除 <code>tailrec</code> 关键字</strong> 的两份代码分别进行反编译，我们发现：</p><ul><li><p>没有优化的 <code>findListNode</code> 对应的 <code>Java</code> 代码依然是递归函数，并且递归运行次数较大时出现了 <code>StackOverflowError</code> 错误；</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135701617.png" alt="img" style="zoom: 90%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135611929.png" alt="img" style="zoom:87%;" /></li><li><p>优化后（即添加了 <code>tailrec</code> 关键字）的 <code>findListNode</code> 方法对应的 <code>Java</code> 代码已经不再是递归函数，而是通过循环来实现功能，这样就不会再出现 <code>stackoverflowerror</code> 了。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135710491.png" alt="img" style="zoom:90%;" /></li></ul><p>这样我们就在 <code>Kotlin</code> 中既实现了递归函数代码简洁的优势，又规避了在 <code>Java</code> 中使用递归函数容易出出现的问题。</p>]]></content>
    
    
    <summary type="html">学习了 Kotlin 中函数嵌套的使用方法。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 空指针检查</title>
    <link href="https://luoyu-ying.github.io/posts/4c7d77851d24/"/>
    <id>https://luoyu-ying.github.io/posts/4c7d77851d24/</id>
    <published>2022-07-09T11:32:31.000Z</published>
    <updated>2022-07-09T11:32:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li>《第一行代码 Android 第3版》</li></ul></blockquote><hr /><h1 id="可空类型系统"><a class="markdownIt-Anchor" href="#可空类型系统"></a> 可空类型系统</h1><p>因为 <code>Kotlin</code> 默认所有的参数和变量都不可为空，所以我们直接使用定义任何变量和参数并使用的话，是没有任何的空指针风险的。</p><p>例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>)</span></span> &#123;</span><br><span class="line">    study.readBooks()</span><br><span class="line">    study.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码是没有空指针异常的，如果我们尝试向 <code>doStudy</code> 函数中传递 <code>null</code> 参数，便会直接提示错误：<code>Null can not be a value of a non-null type Study</code>。</p><p>也就是说，<code>Kotlin</code> 将空指针异常的检查提前到了编译时期，如果我们的程序存在空指针异常的风险，那么在编译的时候会直接报错，修正之后才能成功运行，这样就可以保证程序在运行时期不会出现空指针异常了。</p><p>那么如何使得这些类型变为可为空的类型系统呢？</p><p><strong>很简单，就是在类名的后面加上一个问号。</strong></p><p>比如说，<code>Int</code> 表示不可为空的整形，而 <code>Int?</code> 则表示可为空的整形；<code>String</code> 表示不可为空的字符串，而 <code>String?</code> 就表示可以为空的字符串。</p><p>当我们希望上述的代码可以传入 <code>null</code> 参数，那么我们就需要将 <code>Study</code> 改成 <code>Study?</code> ，如下文所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    study.readBooks()</span><br><span class="line">    study.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上述的代码仍然有些许错误，即使我们能够正常的传入 <code>null</code> 参数，但是 <code>null</code> 是无法调用 <code>readBooks()</code> 以及 <code>doHomework()</code> 函数的。所以我们仍需要对 <code>study</code> 进行进一步的判断：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (study != <span class="literal">null</span>) &#123;</span><br><span class="line">        study.readBooks()</span><br><span class="line">        study.doHomework()    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样的写法，我们可能会在代码中写入大量的 <code>if</code> 语句仅仅只是为了判断变量或者参数是否为空，这样会让代码变得比较啰嗦。为此，<code>Kotlin</code> 专门提供了一系列的辅助工具，方便我们更加轻松以及快速地进行判空处理。</p><hr /><h1 id="判空辅助工具"><a class="markdownIt-Anchor" href="#判空辅助工具"></a> 判空辅助工具</h1><h2 id="操作符"><a class="markdownIt-Anchor" href="#操作符"></a> <code>?.</code> 操作符</h2><p><code>?.</code> 操作符的作用就是当对象不为空的时候正常调用相应的函数，当对象为空时则什么都不做。</p><p>如下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">    a.doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 <code>?.</code> 操作符，我们便可以将其简化成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a?.doSomething()</span><br></pre></td></tr></table></figure><p>现在我们便可以对上文中的代码进行优化了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    study?.readBooks()</span><br><span class="line">    study?.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作符-2"><a class="markdownIt-Anchor" href="#操作符-2"></a> <code>?:</code> 操作符</h2><p><code>?:</code> 操作符的左右两边都接受一个表达式，如果左边表达式的结果不为空就返回左边表达式的结果，否则就返回右边表达式的结果。</p><p>如下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = <span class="keyword">if</span> (a != <span class="literal">null</span>) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><p>便可以简化成为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = a ?: b</span><br></pre></td></tr></table></figure><h2 id="操作符-3"><a class="markdownIt-Anchor" href="#操作符-3"></a> <code>!!.</code> 操作符</h2><p>如果我们想要一遍变量在使用的过程中不进行空指针检查，并在遇到空指针的时候主动的抛出空指针异常（有的时候我们可能从逻辑上已经将空指针异常处理了，但是 <code>Kotlin</code> 的编译器并不知道，这个时候它还是会编译失败），那么我们可以通过使用 <code>!!.</code> 操作符（非空断言工具）强行通过编译。写法是在对象的后面加上 <code>!!.</code>。</p><p>例如以下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg: String? = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">        printUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printUpperCase</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> upperCase = msg!!.toUpperCase()</span><br><span class="line">    println(upperCase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上文中，<code>printUpperCase</code> 函数的调用一定发生在 <code>msg</code> 不为空的情况，所以我们可以使用非空断言工具让其不进行空指针判断。</p><p>这是一种有风险的写法，意在告诉 <code>Kotlin</code>，我非常确信这里的对象不会为空，所以不用你来帮我做空指针检查了，如果出现问题，你可以直接抛出空指针异常，后果由我自己承担。</p><p>虽然这样编写代码确实可以通过编译，但是当你想要使用非空断言工具的时候，最好提醒一下自己，是不是还有更好的实现方式。</p><p><strong>你最自信这个对象不会为空的时候，其实可能就是一个潜在空指针异常发生的时候。</strong></p><hr /><h1 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h1><p>标准函数中 <code>let</code> 函数是可以处理全局变量的判空问题的，而 <code>if</code> 语句则无法做到这一点。</p><p>比如我们将 <code>doStudy()</code> 中的参数变成一个全局变量，使用 <code>let</code> 函数仍然可以正常工作，但是使用 <code>if</code> 语句则会提示错误：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220709203415002.png" alt="image" style="zoom:80%;" /><p>之所以这里会报错，是因为全局变量的值随时都有可能被其他线程所修改，即使做了判空处理，仍然无法保证 <code>if</code> 语句中的<code>study</code> 变量没有空指针风险。从这一点上也能体现出 <code>let</code> 函数的优势。</p>]]></content>
    
    
    <summary type="html">学习了 Kotlin 中空指针相关的运算符。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 扩展函数与扩展属性</title>
    <link href="https://luoyu-ying.github.io/posts/ffb71c4ce53a/"/>
    <id>https://luoyu-ying.github.io/posts/ffb71c4ce53a/</id>
    <published>2022-07-09T04:22:03.000Z</published>
    <updated>2022-07-09T04:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li></ul></blockquote><hr /><p><code>Kotlin</code> 的扩展（<code>Extension</code>），主要分为两种语法：第一个是扩展函数，第二个是扩展属性。从语法上看，扩展看起来就像是我们从类的外部为它扩展了新的成员。</p><p>这在实际编程当中是非常有用的功能。我们可以来想象一个场景：我们想修改 <code>JDK</code> 当中的 <code>String</code>，想在它的基础上增加一个方法 <code>lastElement()</code> 来获取末尾元素，如果使用 <code>Java</code>，我们是无法通过常规手段实现的，因为我们没办法修改 <code>JDK</code> 的源代码。<strong>任何第三方提供的 <code>SDK</code>，我们都无权修改。</strong></p><p>不过，借助 <code>Kotlin</code> 的扩展函数，我们就完全可以在语义层面，来为第三方 <code>SDK</code> 的类扩展新的成员方法和成员属性。不管是为 <code>JDK</code> 的 <code>String</code> 增加新的成员方法，还是为 <code>Android SDK</code> 的 <code>View</code> 增加新成员属性，我们都可以实现。</p><hr /><h1 id="扩展函数"><a class="markdownIt-Anchor" href="#扩展函数"></a> 扩展函数</h1><p>扩展函数，就是从类的外部扩展出来的一个函数，这个函数看起来就像是类的成员函数一样。这里，我们就以 <code>JDK</code> 当中的 <code>String</code> 为例，来看看如何通过 <code>Kotlin</code> 的扩展特性，为它新增一个 <code>lastElement()</code> 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ext.kt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ①    ②       ③           ④</span></span><br><span class="line"><span class="comment"> ↓     ↓       ↓            ↓      */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;</span><br><span class="line">    <span class="comment">//    ⑤</span></span><br><span class="line">    <span class="comment">//    ↓</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用扩展函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> msg = <span class="string">&quot;Hello Wolrd&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// lastElement就像String的成员方法一样可以直接调用</span></span><br><span class="line">    <span class="keyword">val</span> last = msg.lastElement() <span class="comment">// last = d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先是定义了一个 <code>String</code> 的扩展函数 <code>lastElement()</code> ，然后在 <code>main</code> 函数当中调用了这个函数。并且，这个扩展函数是直接定义在 <code>Kotlin</code> 文件里的，而不是定义在某个类当中的。这种扩展函数，我们称之为**“顶层扩展”**，这么叫它是因为它并没有嵌套在任何的类当中，它自身就在最外层。</p><p>现在，我们依次来看看上面的五处注释：</p><ol><li><p>注释①，<code>fun</code> 关键字</p><p>代表我们要定义一个函数。也就是说，不管是定义普通 <code>Kotlin</code> 函数，还是定义扩展函数，我们都需要 <code>fun</code> 关键字。</p></li><li><p>注释②，“<code>String.</code>”</p><p>代表我们的扩展函数是为 <code>String</code> 这个类定义的。在 <code>Kotlin</code> 当中，它有一个名字，叫做接收者（<code>Receiver</code>），也就是扩展函数的接收方。</p></li><li><p>注释③，<code>lastElement()</code></p><p>是我们定义的扩展函数的名称。</p></li><li><p>注释④，“<code>Char?</code>”</p><p>代表扩展函数的返回值是可能为空的 <code>Char</code> 类型。</p></li><li><p>注释⑤，“<code>this.</code>”</p><p>代表“具体的 <code>String</code> 对象”，当我们调用 <code>msg.lastElement()</code> 的时候，<code>this</code> 就代表了 <code>msg</code>。</p></li></ol><p>需要注意的是，<strong>在整个扩展函数的方法体当中，<code>this</code> 都是可以省略的</strong>。这一点，<code>Kotlin</code> 和 <code>Java</code> 是一样的，<code>this</code> 代表当前作用域，它可写可不写。即例如以下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span> : <span class="built_in">Char</span>? = <span class="keyword">if</span> (isEmpty()) <span class="literal">null</span> <span class="keyword">else</span> <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">    println(str.lastElement())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，<code>Kotlin</code> 的扩展是允许我们为“<strong>可为空的类型</strong>”进行扩展的。比如说：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不为空的接收者类型</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可为空的接收者类型</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String?.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;&#125;</span><br></pre></td></tr></table></figure><p>接受者可空的扩展在遇到空对象调用时不会抛异常，并且允许可空对象调用。</p><hr /><h1 id="扩展属性"><a class="markdownIt-Anchor" href="#扩展属性"></a> 扩展属性</h1><p>在学习了 <code>Kotlin</code> 的扩展函数以后，扩展属性就很好理解了。</p><p>扩展函数，是在类的外部为它定义一个<strong>新的成员方法</strong>；而扩展属性，则是在类的外部为它定义一个<strong>新的成员属性</strong>。</p><p>那么，在研究了扩展的实现原理后，我们知道，我们从外部定义的成员方法和属性，都只是语法层面的，并没有实际修改那个类的源代码。</p><p>还是以 <code>lastElement</code> 为例，在之前的案例当中，我们是通过扩展函数来实现的，这次我们以扩展属性的方式来实现。扩展函数的定义对比普通函数，其实就只是多了一个“接收者类型”。类似的，扩展属性，也就是在普通属性定义的时候多加一个“接收者类型”即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收者类型</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="keyword">val</span> String.lastElement: <span class="built_in">Char</span>?</span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 this 关键字也可以写成：</span></span><br><span class="line"><span class="comment">val String.lastElement : Char?</span></span><br><span class="line"><span class="comment">    get() = if (isEmpty()) null else this[length - 1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> msg = <span class="string">&quot;Hello Wolrd&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// lastElement就像String的成员属性一样可以直接调用</span></span><br><span class="line">    <span class="keyword">val</span> last = msg.lastElement <span class="comment">// last = d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段的代码中，我们为 String 类型扩展了一个新的成员属性“<code>lastElement</code>”。然后在 <code>main</code> 函数当中，我们直接通过“<code>msg.lastElement</code>”方式使用了这个扩展属性，就好像它是一个成员一样。</p><hr /><h1 id="扩展与其反编译代码"><a class="markdownIt-Anchor" href="#扩展与其反编译代码"></a> 扩展与其反编译代码</h1><p>为了看得更加清晰，我们用一张图来描述它们之间的关系。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/2a38487b61ec06e437c1425b2a69ffed.png" alt="img" /></p><p>上面的两个箭头，说明了扩展函数与扩展属性，它们最终会被 <code>Kotlin</code> 编译器转换成静态方法；下面两个箭头，说明了扩展函数和扩展属性的调用代码，最终会被 <code>Kotlin</code> 编译器转换成静态方法的调用。</p><p>所以也就是说，<code>Kotlin</code> 的扩展表面上看起来是为一个类扩展了新的成员，<strong>但是本质上，它还是静态方法</strong>。而且，不管是扩展函数还是扩展属性，它本质上都会变成一个静态的方法。</p><p><strong>那么，到底什么时候该用扩展函数，什么时候该用扩展属性呢？</strong></p><p>其实，我们只需要看扩展在语义上更适合作为函数还是属性就够了。比如这里的 <code>lastElement</code>，它更适合作为一个扩展属性。这样设计的话，在语义上，<code>lastElement</code> 就像是 <code>String</code> 类当中的属性一样，它代表了字符串里的最后一个字符。</p><hr /><h1 id="扩展的优势与局限性"><a class="markdownIt-Anchor" href="#扩展的优势与局限性"></a> 扩展的优势与局限性</h1><h2 id="扩展的优势"><a class="markdownIt-Anchor" href="#扩展的优势"></a> 扩展的优势</h2><p>当我们想要从外部为一个类扩展一些方法和属性的时候，我们就可以通过扩展来实现了。<strong>在 <code>Kotlin</code> 当中，几乎所有的类都可以被扩展</strong>，包括普通类、单例类、密封类、枚举类、伴生对象，甚至还包括第三方提供的 <code>Java</code> 类。</p><p>唯有匿名内部类，由于它本身不存在名称，我们无法指定“接收者类型”，所以不能被扩展，当然了，它也没必要被扩展。</p><p>可以说，<code>Kotlin</code> 扩展的应用范围还是非常广的。它最主要的用途，就是用来取代 <code>Java</code> 当中的各种工具类，比如 <code>StringUtils</code>、<code>DateUtils</code> 等等。</p><p>所有 <code>Java</code> 工具类能做的事情，<code>Kotlin</code> 扩展函数都可以做，并且可以做得更好。扩展函数的优势在于，开发工具可以在编写代码的时候智能提示。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/239e540b768560c6cd119b1bb9e1eb9c.gif" alt="img" style="zoom: 40%;" /><h2 id="扩展的局限性"><a class="markdownIt-Anchor" href="#扩展的局限性"></a> 扩展的局限性</h2><p><code>Kotlin</code> 的扩展，由于它本质上并没有修改接收类型的源代码，所以它的行为是无法与“类成员”完全一致的。那么它对比普通的类成员，就会有以下几个限制。</p><p><strong>第一个限制，<code>Kotlin</code> 扩展不是真正的类成员，因此它无法被它的子类重写。</strong></p><p>举个例子，我们定义一个这样的 <code>Person</code> 类，并且分别为它扩展了一个 <code>isAdult</code> 属性和 <code>walk()</code> 方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> Person.isAdult: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = age &gt;= <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.<span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;walk&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>Person</code> 类有 <code>open</code> 关键字修饰，所以我们可以继承这个 <code>Person</code> 类。</p><p>不过，当我们尝试去重写它的成员时，会发现 <code>isAdult</code> 和 <code>walk()</code> 是无法被重写的，因为它们压根就不属于 <code>Person</code> 这个类。</p><p><strong>第二个限制，扩展属性无法存储状态。</strong></p><p>就如前面代码当中的 <code>isAdult</code> 属性一般，它的值是由 <code>age</code> 这个成员属性决定的，它本身没有状态，也无法存储状态。背后的根本原因，还是因为它们都是静态方法。</p><p><strong>第三个限制，扩展的<em>访问作用域</em>仅限于两个地方。</strong></p><ol><li><p>如果扩展是顶层的扩展。</p><p>那么扩展的访问域仅限于该 <code>Kotlin</code> 文件当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展是可以被全局使用的。</p></li><li><p>如果扩展是被定义在某个类当中的。</p><p>那么该扩展的访问域仅限于该类当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展仅能在该类当中使用。</p></li></ol><hr /><h1 id="扩展的使用场景"><a class="markdownIt-Anchor" href="#扩展的使用场景"></a> 扩展的使用场景</h1><p><strong><code>Kotlin</code> 扩展的第一个典型使用场景：关注点分离。主动使用扩展，通过它来优化软件架构。</strong></p><p>所谓关注点分离，就是将我们程序的逻辑划分成不同的部分，每一个部分，都只关注自己那部分的职责。以 <code>Kotlin</code> 源码中的 <code>String</code> 类为例，<code>String.kt</code> 这个类，只关注 <code>String</code> 的核心逻辑；而 <code>Strings.kt</code> 则只关注 <code>String</code> 的操作符逻辑。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String.kt (一共只有13行代码)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> : <span class="type">Comparable</span>&lt;<span class="type">String</span>&gt;, <span class="type">CharSequence &#123;</span></span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">val</span> length: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: <span class="built_in">Char</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">subSequence</span><span class="params">(startIndex: <span class="type">Int</span>, endIndex: <span class="type">Int</span>)</span></span>: CharSequence</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Strings.kt 部分代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CharSequence.<span class="title">trim</span><span class="params">()</span></span>: CharSequence = trim(<span class="built_in">Char</span>::isWhitespace)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">expect</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">lowercase</span><span class="params">()</span></span>: String</span><br></pre></td></tr></table></figure><p><strong>扩展的第二个核心使用场景：被动使用扩展，提升可读性与开发效率。</strong></p><p>当我们无法修改外部的 <code>SDK</code> 时，对于重复的代码模式，我们将其以扩展的方式封装起来，提供给对应的接收者类型。</p><hr /><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><ol><li><code>Kotlin</code> 的扩展，从 <strong>语法角度</strong> 来看，分为扩展函数和扩展属性。定义扩展的方式，只是比普通函数、属性多了一个“扩展接收者”而已。</li><li>从 <strong>作用域</strong> 角度来看，分为顶层扩展和类内扩展。</li><li>从 <strong>本质</strong> 上来看，扩展函数和扩展属性，它们都是 <code>Java</code> 静态方法，与 <code>Java</code> 当中的工具类别无二致。对比 <code>Java</code> 工具类，扩展最大的优势就在于，<code>IDE</code> 可以为我们提供代码补全功能。</li><li>从 <strong>能力</strong> 的角度来看，<code>Kotlin</code> 扩展一共有三个限制，分别是：扩展无法被重写；扩展属性无法存储状态；扩展的作用域有限，无法访问私有成员。</li><li>从 <strong>使用场景</strong> 的角度来看，<code>Kotlin</code> 扩展主要有两个使用场景，分别是：关注点分离，优化代码架构；消灭模板代码，提高可读性和开发效率。</li></ol><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/b4a3ce7c3e0b2228161faa4769618a10.jpg" alt="img" /></p>]]></content>
    
    
    <summary type="html">学习了 Kotlin 中扩展函数与扩展属性的使用方式。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 类的创建与继承</title>
    <link href="https://luoyu-ying.github.io/posts/8aab3d7fde77/"/>
    <id>https://luoyu-ying.github.io/posts/8aab3d7fde77/</id>
    <published>2022-07-08T04:41:57.000Z</published>
    <updated>2022-07-08T04:41:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Kotlin</code> 官方在线编程网址：</p><ul><li><a href="https://play.kotlinlang.org/">https://play.kotlinlang.org/</a></li></ul></blockquote><hr /><blockquote><p>本文参考自：</p><ul><li>《第一行代码  Android 第3版》</li><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li><li><a href="https://blog.csdn.net/c1392851600/article/details/80990570">Kotlin之类的继承及属性和方法的重写_c1392851600的博客-CSDN博客</a></li></ul></blockquote><hr /><h1 id="基本写法"><a class="markdownIt-Anchor" href="#基本写法"></a> 基本写法</h1><h2 id="创建"><a class="markdownIt-Anchor" href="#创建"></a> 创建</h2><p>通过 <code>class</code> 关键字创建一个类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is eating.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化方式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> person = Person()</span><br></pre></td></tr></table></figure><h2 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h2><p><strong>默认所有非抽象类都是不可以被继承的</strong>。</p><p>如果需要将其变为父类，则需要在 <code>class</code> 前使用 <code>open</code> 关键字。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is eating.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要继承另一个类，则使用 <code>:</code> 符号：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> grade = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重写"><a class="markdownIt-Anchor" href="#重写"></a> 重写</h2><h3 id="重写父类的方法"><a class="markdownIt-Anchor" href="#重写父类的方法"></a> 重写父类的方法</h3><p>需要注意的是如果父类的方法没有 <code>open</code> 声明，那么该方法是不允许被重写的。重写方法的时候需要使用 <code>override</code> 关键字注明。还有一点就是子类可以选择不重写父类的方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">shout</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;汪汪&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;萌萌哒&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Husky</span> : <span class="type">Dog</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 由于父类的shout方法没有写open, 也就是默认是final的, 所以这里不能重写shout方法</span></span><br><span class="line">    <span class="comment">// Error:(15, 5) Kotlin: &#x27;shout&#x27; in &#x27;Dog&#x27; is final and cannot be overridden  不能重写shout因为默认是final的</span></span><br><span class="line">    <span class="comment">/* override fun shout() &#123;</span></span><br><span class="line"><span class="comment">        println(&quot;玩明汪&quot;)</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重写父类方法的时候要加上override关键字, show方法也可以选择不进行重写</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;喵喵&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> husky =  Husky()</span><br><span class="line">    husky.shout()</span><br><span class="line">    husky.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次需要注意的是，如果一个类集成了多个类/接口，并且父类/接口中有相同名字的方法需要重写的时候，那么子类这时候必须重写该方法，并且如果子类想区分开父类的方法的时候，可以使用 <code>super</code> 关键字调用不同父类的方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">shout</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;汪汪&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;萌萌哒&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">WatchDog</span> </span>&#123;</span><br><span class="line">    <span class="comment">// interface里不用写open, 因为默认就是open的</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;看门电子狗&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用接口的时候不用写(), 是因为接口是没有构造函数的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Husky</span> : <span class="type">Dog</span></span>(), WatchDog &#123;</span><br><span class="line">    <span class="comment">// 由于父类的shout方法没有写open, 也就是默认是final的, 所以这里不能重写父类的方法</span></span><br><span class="line">    <span class="comment">// Error:(15, 5) Kotlin: &#x27;shout&#x27; in &#x27;Dog&#x27; is final and cannot be overridden  不能重写shout因为默认是final的</span></span><br><span class="line">    <span class="comment">/*override fun shout() &#123;</span></span><br><span class="line"><span class="comment">        println(&quot;玩明汪&quot;)</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重写父类方法的时候要加上override关键字</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 当重写的方法在父类中有多个实现的时候, 如果继承的多个类中, 有相同的方法需要重写的时候, 则子类必须重写该方法, 并且, 为了区分, 可以使用super关键字来调用不同的父类中的方法</span></span><br><span class="line">        <span class="keyword">super</span>&lt;WatchDog&gt;.show()  <span class="comment">// 看萌电子狗</span></span><br><span class="line">        <span class="keyword">super</span>&lt;Dog&gt;.show() <span class="comment">// 萌萌哒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> husky =  Husky()</span><br><span class="line">    husky.shout()   <span class="comment">// 汪汪</span></span><br><span class="line">    husky.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写父类的变量"><a class="markdownIt-Anchor" href="#重写父类的变量"></a> 重写父类的变量</h3><p>父类变量的重写的时候有几个需要注意的地方：</p><ol><li><p>被重写的变量也要有 <code>open</code> 的声明。</p></li><li><p>子类可以使用 <code>var</code> 类型的变量去重写父类 <code>val</code> 类型的变量，但是不能使用 <code>val</code> 类型的变量去重写父类 <code>var</code> 类型的变量。</p><p>如果使用 <code>val</code> 类型的变量去重写父类的 <code>var</code> 类型的变量, 那么子类这个 <code>val</code> 类型的变量会多一个 <code>set</code> 方法, 而 <code>val</code> 类型的变量是不允许有 <code>set</code> 方法的。</p></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> y : String = <span class="string">&quot;a&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> : <span class="type">A</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> y: String = <span class="string">&quot;b&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> : <span class="type">A</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span>  <span class="keyword">var</span> x : <span class="built_in">Int</span> = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> y : String = <span class="string">&quot;c&quot;</span> <span class="comment">// Error: Var-property public open val y: String defined in C cannot be overridden by val-property public open var y: String defined in A</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h1><p><code>Kotlin</code> 将构造函数分为了两种：主构造函数和次构造函数。</p><h2 id="主构造函数"><a class="markdownIt-Anchor" href="#主构造函数"></a> 主构造函数</h2><p>主构造函数是最常使用的构造函数，每个类默认都会有一个不带参数的主构造函数。</p><p>（特殊情况：如果在没有实现主构造函数的情况下实现了次构造函数，则会失去该不带参数的主构造函数。）</p><p>当然也是可以显式地为其指明参数。主构造函数的特点就是没有函数体，直接定义在类名的后面即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> studentNo: String, <span class="keyword">var</span> grade: <span class="built_in">Int</span>) : Person() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者可以写成</span></span><br><span class="line"><span class="comment">// class Student constructor(val studentNo: String, var grade: Int) : Person() &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>我们在实例化的时候需要传入构造函数中的所有的参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> student = Student(<span class="string">&quot;123456789&quot;</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>由于主构造函数没有函数体，所以我们无法直接在其中编写一些逻辑。但是 <code>Kotlin</code> 给我们提供了一个 <code>init</code> 结构体，所有主构造函数的逻辑都可以写在里面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> studentNo: String, <span class="keyword">var</span> grade: <span class="built_in">Int</span>) : Person() &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Student No is <span class="variable">$studentNo</span> AND grade is <span class="variable">$grade</span>.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 <code>Java</code> 语言继承特性中的一个规定：子类的构造函数必须调用父类中的构造函数。这个规定在 <code>Kotlin</code> 中也要遵守。</p><p>所以在上文中 <code>class Student : Person()</code> 以及 <code>class Student(val studentNo: String, var grade: Int) : Person()</code> 中 <code>Person</code> 类后面的一对空括号表示 <code>Student</code> 类的主构造函数在初始化的时候会调用 <code>Person</code> 类的无参数构造函数，即使在自身的主构造函数为默认的无参数的时候也是不能省略的。</p><p>现在我们将 <code>Person</code> 类改造一下，将姓名和年龄都放到主构造函数中，即：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is eating.&quot;</span>)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们自定义了主构造函数，所以默认提供的无参数的主构造函数就不存在了，所以我们也需要修改一下 <code>Student</code> 类的表示方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> studentNo: String, <span class="keyword">var</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>) :</span><br><span class="line">        Person(name, age) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Student No is <span class="variable">$studentNo</span> AND grade is <span class="variable">$grade</span>.&quot;</span>)</span><br><span class="line">    &#125;    </span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我们在 <code>Student</code> 类的主构造函数中增加 <code>name</code> 和 <code>age</code> 这两个字段时，不能再将它们声明成 <code>val</code>，因为在主构造函数中声明成 <code>val</code> 或者 <code>var</code> 的参数将自动成为该类的字段,这就会导致和父类中同名的 <code>name</code> 和 <code>age</code> 字段造成冲突。因此，<strong>这里的 <code>name</code> 和 <code>age</code> 参数前面我们不用加任何关键字,让它的作用域仅限定在主构造函数当中即可</strong> 。</p><p>现在就可以通过如下的代码来创建一个 <code>Student</code> 类的实例并使用了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> student = Student(<span class="string">&quot;123456789&quot;</span>, <span class="number">3</span>, <span class="string">&quot;LiHua&quot;</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><h2 id="次构造函数"><a class="markdownIt-Anchor" href="#次构造函数"></a> 次构造函数</h2><p>其实你几乎是用不到次构造函数的，<code>Kotlin</code> 提供了一个给函数设定参数默认值的功能，基本上可以替代次构造函数的作用。</p><p>任何一个类只能有一个主构造函数，但是可以有多个次构造函数。次构造函数也可以用于实例化一个类，这一点和主构造函数没有什么不同，只不过它是有函数体的。</p><p><code>Kotlin</code> 规定，当一个类既有主构造函数又有次构造函数时，所有的次构造函数都必须调用主构造函数（包括间接调用)。</p><p>比如以下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(name: String, age: <span class="built_in">Int</span>, <span class="keyword">val</span> studentNo: String, <span class="keyword">var</span> grade: <span class="built_in">Int</span>) : Person(name, age) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;name : <span class="variable">$name</span> AND age : <span class="variable">$age</span> AND studentNo : <span class="variable">$studentNo</span> AND grade : <span class="variable">$grade</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(name: String , age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(name, age, <span class="string">&quot;12345&quot;</span>, <span class="number">2</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="string">&quot;XiaoMei&quot;</span>, <span class="number">19</span>, <span class="string">&quot;1234567&quot;</span>, <span class="number">1</span>) &#123;&#125; <span class="comment">// 如果 &#123;&#125; 内没有内容的话，可以省略大括号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student1 = Student(<span class="string">&quot;LiHua&quot;</span>, <span class="number">20</span>, <span class="string">&quot;123456&quot;</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> student2 = Student(<span class="string">&quot;XiaoMing&quot;</span>, <span class="number">21</span>)</span><br><span class="line">    <span class="keyword">val</span> student3 = Student()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">name : LiHua AND age : <span class="number">20</span> AND studentNo : <span class="number">123456</span> AND grade : <span class="number">3</span></span><br><span class="line">name : XiaoMing AND age : <span class="number">21</span> AND studentNo : <span class="number">12345</span> AND grade : <span class="number">2</span></span><br><span class="line">name : XiaoMei AND age : <span class="number">19</span> AND studentNo : <span class="number">1234567</span> AND grade : <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>特殊情况：</strong></p><p>那么接下来我们就再来看一种非常特殊的情况：类中只有次构造函数，没有主构造函数。</p><p>这种情况真的十分少见，但在 <code>Kotlin</code> 中是允许的。</p><p><strong>当一个类没有显式地定义主构造函数且定义了次构造函数时，它就是没有主构造函数的。</strong></p><p>我们结合代码来看一下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person &#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">super</span>(name, age) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的代码变化，首先 <code>Student</code> 类的后面没有显式地定义主构造函数，同时又因为定义了次构造函数，所以现在 <code>Student</code> 类是没有主构造函数的。那么既然没有主构造函数，继承 <code>Person</code> 类的时候也就不需要再加上括号了（因为主构造函数会调用父类的构造函数）。</p><p>另外，由于没有主构造函数，次构造函数只能直接调用父类的构造函数，上述代码也是将 <code>this</code> 关键字换成了 <code>super</code> 关键字，这部分就很好理解了，因为和 <code>Java</code> 比较像，也就不再多说了。</p><hr /><h1 id="函数的命名参数以及参数默认值"><a class="markdownIt-Anchor" href="#函数的命名参数以及参数默认值"></a> 函数的命名参数以及参数默认值</h1><blockquote><p>类的构造函数同样适用于命名参数以及参数默认值，所以我们在极大多数的情况下通过这两个特性配合主构造函数来可以实现次构造函数的功能。</p></blockquote><h2 id="命名参数"><a class="markdownIt-Anchor" href="#命名参数"></a> 命名参数</h2><p>简单理解，就是它允许我们在调用函数的时候传入“形参的名字”。</p><p>如同以下形式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helloFunction(name = <span class="string">&quot;Kotlin&quot;</span>)</span><br></pre></td></tr></table></figure><p>让我们看一个更具体的使用场景：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createUser</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    age: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    gender: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    friendCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    feedCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    likeCount: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    commentCount: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过如下的方法使用函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">createUser(</span><br><span class="line">    name = <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    age = <span class="number">30</span>,</span><br><span class="line">    gender = <span class="number">1</span>,</span><br><span class="line">    friendCount = <span class="number">78</span>,</span><br><span class="line">    feedCount = <span class="number">2093</span>,</span><br><span class="line">    likeCount = <span class="number">10937</span>,</span><br><span class="line">    commentCount = <span class="number">3285</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到，在这段代码中，我们把函数的形参加了进来，形参和实参用 <code>=</code> 连接，建立了两者的对应关系。对比前面 <code>Java</code> 风格的写法，这样的代码可读性更强了。如果将来你想修改 <code>likeCount</code> 这个参数，也可以轻松做到。这其实就体现出了 <code>Kotlin</code> 命名参数的可读性与易维护性两个优势。</p><h2 id="参数默认值"><a class="markdownIt-Anchor" href="#参数默认值"></a> 参数默认值</h2><p>而除了命名参数这个特性，<code>Kotlin</code> 还支持参数默认值，这个特性在参数较多的情况下同样有很大的优势：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createUser</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    age: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    gender: <span class="type">Int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    friendCount: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    feedCount: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    likeCount: <span class="type">Long</span> = <span class="number">0</span>L,</span></span></span><br><span class="line"><span class="params"><span class="function">    commentCount: <span class="type">Int</span> = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，<code>gender</code>、<code>friendCount</code>、<code>feedCount</code>、<code>likeCount</code>、<code>commentCount</code> 这几个参数都被赋予了默认值。这样做的好处就在于，我们在调用的时候可以省很多事情。比如说，下面这段代码就只需要传 3 个参数，剩余的 4 个参数没有传，但是 <code>Kotlin</code> 编译器会自动帮我们填上默认值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">createUser(</span><br><span class="line">    name = <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    age = <span class="number">30</span>,</span><br><span class="line">    commentCount = <span class="number">3285</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于无默认值的参数，编译器会强制要求我们在调用处传参；对于有默认值的参数，则可传可不传。<code>Kotlin</code> 这样的特性，在一些场景下就可以极大地提升我们的开发效率。而如果是在 <code>Java</code> 当中要实现类似的事情，我们就必须手动定义“3 个参数的 <code>createUser</code> 函数”，或者是使用 <code>Builder</code> 设计模式。</p><h2 id="在构造函数中的使用案例"><a class="markdownIt-Anchor" href="#在构造函数中的使用案例"></a> 在构造函数中的使用案例</h2><p>通过写出如下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(</span><br><span class="line">    name: String = <span class="string">&quot;&quot;</span>, </span><br><span class="line">    age: <span class="built_in">Int</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="keyword">val</span> studentNo: String = <span class="string">&quot;&quot;</span>, </span><br><span class="line">    <span class="keyword">val</span> grade: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : Person(name, age) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在给主构造函数的每个参数都设定了默认值之后，我们就可以使用任何传参组合的方式来对 <code>Student</code> 类进行实例化，当然也包含了上文中的两种次构造函数的使用场景。</p><hr /><h1 id="函数的可见性修饰符"><a class="markdownIt-Anchor" href="#函数的可见性修饰符"></a> 函数的可见性修饰符</h1><p>熟悉 <code>Java</code> 的人一定知道，<code>Java</code> 中有 <code>public</code>、 <code>private</code>、 <code>protected</code> 和 <code>default</code>(什么都不写）这4种函数可见性修饰符。</p><p><code>Kotlin</code>中也有4种，分别是 <code>public</code>、 <code>private</code>、<code>protected</code> 和 <code>internal</code>，需要使用哪种修饰符时，直接定义在 <code>fun</code> 关键字的前面即可。</p><p>下面将详细介绍一下 <code>Java</code> 和 <code>Kotlin</code> 中这些函数可见性修饰符的异同。</p><ol><li><p><code>private</code> 修饰符在两种语言中的作用是一模一样的，都表示只对当前类内部可见。</p></li><li><p><code>public</code> 修饰符的作用虽然也是一致的，表示对所有类都可见，但是在 <code>Kotlin</code>中 <code>public</code> 修饰符是默认项，而在 <code>Java</code> 中 <code>default</code> 才是默认项。前面我们定义了那么多的函数，都没有加任何的修饰符，所以它们默认都是 <code>public</code> 的。</p></li><li><p><code>protected</code> 关键字在 <code>Java</code> 中表示对当前类、子类和同一包路径下的类可见，在 <code>Kotlin</code> 中则表示只对当前类和子类可见。</p></li><li><p><code>Kotlin</code> 抛弃了 <code>Java</code> 中的 <code>default</code> 可见性（同一包路径下的类可见），引人了一种新的可见性概念，只对同一模块中的类可见，使用的是 <code>internal</code> 修饰符。比如我们开发了一个模块给别人使用，但是有一些函数只允许在模块内部调用，不想暴露给外部，就可以将这些函数声明成 <code>internal</code> 。</p></li></ol><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220708221406391.png" alt="image" /></p><p>所以，我们可以通过 <code>private</code> 关键字将类的构造函数定义为私有属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 私有的主构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">val</span> studentNo: String, </span><br><span class="line">    <span class="keyword">var</span> grade: <span class="built_in">Int</span></span><br><span class="line">) : Person() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有的次构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>(grade: <span class="built_in">Int</span>) : <span class="keyword">this</span>(<span class="string">&quot;123&quot;</span>, grade) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录了 Kotlin 中类的创建与继承的语法。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统 练习题整理</title>
    <link href="https://luoyu-ying.github.io/posts/a88955f1c30b/"/>
    <id>https://luoyu-ying.github.io/posts/a88955f1c30b/</id>
    <published>2022-06-25T12:03:26.000Z</published>
    <updated>2022-06-30T12:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>整理并分析了上课时的部分练习题。</p><p>题目持续更新中~</p></blockquote><h1 id="第一章"><a class="markdownIt-Anchor" href="#第一章"></a> 第一章</h1><hr /><blockquote><p>一个程序的原来使用单线程的CPU的总运行时间为1。程序中不能并行执行的部分占比40%，可以并行执行的部分为60%。如果使用一个2线程的CPU执行该程序（不考虑其他额外开销），程序运行时间为（  A  ）</p><p>A. 0.7</p><p>B. 0.6</p><p>C. 0.9</p><p>D. 0.4</p></blockquote><p>Amdahl 定律：</p><p>若系统执行某应用程序需要时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。 假设系统某部分所需执行时间与该时间的比例为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>, 而该部分性能提升比例为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>。即该部分初始所需时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>×</mo><msub><mi>T</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a \times T_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 现在所需时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>a</mi><mo>×</mo><msub><mi>T</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><mi>k</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{a \times T_{old}}{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.239191em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.894191em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.41586em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。则加速比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mfrac><msub><mi>T</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><msub><mi>T</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo>+</mo><mfrac><mi>a</mi><mi>k</mi></mfrac></mrow></mfrac></mrow><annotation encoding="application/x-tex">S = \frac{T_{old}}{T_{new}} = \frac{1}{(1-a)+ \frac{a}{k}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.35244em;vertical-align:-1.0310000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0310000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mn>0.6</mn><mo separator="true">,</mo><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">a = 0.6, k = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 带入公式中，即可得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的值为 0.7。答案为A。</p><hr /><blockquote><p>接上题，如果使用一个5线程的CPU执行该程序，计算加速比为(  B  )</p><p>A. 1/0.73</p><p>B. 1/0.52</p><p>C. 1/0.84</p><p>D. 1/0.41</p></blockquote><p>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mn>0.6</mn><mo separator="true">,</mo><mi>k</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">a = 0.6, k = 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 带入上述公式中，即可得到选项 B。</p><hr /><blockquote>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a= <span class="number">1e20</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f + %f - %f = %f\n&quot;</span>, a, b, a, a + b - a);</span><br></pre></td></tr></table></figure><p>的执行结果为(  B  )</p><p>A. 3.14</p><p>B. 0</p><p>C. 3</p><p>D. 0.01</p></blockquote><ol><li><code>float</code> 有效数字位为8位，超过第8位的数字将四舍五入。</li><li>浮点数加法第一步为调整两个浮点数的阶数，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mn>1.00</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>20</mn></msup><mo separator="true">,</mo><mtext> </mtext><mi>b</mi><mo>=</mo><mo stretchy="false">(</mo><mn>3.14</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>20</mn></mrow></msup><mo stretchy="false">)</mo><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>20</mn></msup><mo>≈</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a = 1.00 \times 10^{20}, \space b = (3.14 \times 10^{-20}) \times 10^{20} \approx 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mord">.</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1.00</mn><mo>+</mo><mn>3.14</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>20</mn></mrow></msup><mo stretchy="false">)</mo><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>20</mn></msup><mo>≈</mo><mn>1</mn><mi>e</mi><mn>20</mn></mrow><annotation encoding="application/x-tex">a + b = (1.00 + 3.14 \times 10^{-20}) \times 10^{20} \approx 1e20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">.</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">2</span><span class="mord">0</span></span></span></span>。</li><li>故 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a + b - a = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</li></ol><hr /><blockquote>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f + %f - %f = %f\n&quot;</span>, a, b, a, a + b - a);</span><br></pre></td></tr></table></figure><p>的执行结果为(  A  )</p><p>A. 3.14</p><p>B. 0</p><p>C. 3</p><p>D. 0.01</p></blockquote><p>a 的值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>e</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">1e5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">5</span></span></span></span>，小于 <code>float</code> 的有效位数，所以可以正常进行数值运算。</p><hr /><blockquote><p>单CPU中可以通过线程进行并行操作。(  A  )</p><p>A. 错误</p><p>B. 正确</p></blockquote><hr /><h1 id="第二章"><a class="markdownIt-Anchor" href="#第二章"></a> 第二章</h1><hr /><blockquote><p>十进制数：136 对应的十六进制数为（ A ）</p><p>A. 0x88</p><p>B. 0x66</p><p>C. 0x96</p><p>D. 0x78</p></blockquote><p>可以通过 <strong>除k取余法</strong> 计算 十进制转k进制问题。</p><hr /><blockquote>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">0x12345678</span>;</span><br><span class="line">byte_pointer valp = (byte_pointer) &amp; val; </span><br><span class="line">show_bytes(valp, <span class="number">1</span>); </span><br></pre></td></tr></table></figure><p>上述程序在小端法机器上调用show_bytes的输出值为（ C ）</p><p>A. 56</p><p>B. 34</p><p>C. 78</p><p>D. 12</p></blockquote><p><code>show_bytes(byte_pointer, int x)</code> 函数的作用为输出 <code>byte_pointer</code> 的第 <code>x</code> 个字节。</p><hr /><blockquote><p>已知x和y的字节值分别为0x69和0x55。计算C表达式 x &amp; y 的字节值为（  B ）</p><p>A. 0x00</p><p>B. 0x41</p><p>C. 0x01</p><p>D. 0x20</p></blockquote><p>通过计算便可得到结果。</p><hr /><blockquote><p>接上题，计算C表达式 x &amp;&amp; y 的字节值为(  C  )</p><p>A. 0x00</p><p>B. 0x41</p><p>C. 0x01</p><p>D. 0x20</p></blockquote><p><code>&amp;&amp;</code> 为逻辑判断符号，结果只能为 0 或 1。</p><hr /><blockquote><p>假设一个8位整数的补码表示为 0xef，则这个整数的真值为 (  A  )</p><p>A. -17</p><p>B. -239</p><p>C. 17</p><p>D. 239</p></blockquote><p>0xef 的二进制表示为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1110</mn><mtext> </mtext><mn>1111</mn></mrow><annotation encoding="application/x-tex">1110\space 1111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span>，高一位为符号位，表示负数，低7位通过 <strong>反码+1</strong> 可以得出值为 17。所以这个补码的真值为 -17。</p><hr /><blockquote><p>假设一个整数数据类型为4位，已知x = -5 ，函数 T2U = (  A  )</p><p>A. 11</p><p>B. -5</p><p>C. 16</p><p>D. 5</p></blockquote><p>-5 的补码为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1011</mn></mrow><annotation encoding="application/x-tex">1011</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span></span></span></span>，无符号数为 11，选项 A 正确。</p><hr /><blockquote><p>在采用补码运算的32位机器上对表达式： -2147483647-1U &gt; 2147483647   的求值结果为(  D  )</p><p>A. -1</p><p>B. 0</p><p>C. 不确定</p><p>D. 1</p></blockquote><p>由于强制类型转换，-2147483647 和 2147483647 都会处理成 无符号数。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>2147483647</mn><mo>−</mo><mn>1</mn><mi>U</mi></mrow><annotation encoding="application/x-tex">-2147483647 - 1U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span><span class="mord">7</span><span class="mord">4</span><span class="mord">8</span><span class="mord">3</span><span class="mord">6</span><span class="mord">4</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> 的值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1110</mn></mrow><annotation encoding="application/x-tex">1111\space 1111\space 1111\space 1111\space 1111\space 1111\space 1111\space 1110</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span></span></span></span>；</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2147483647</mn></mrow><annotation encoding="application/x-tex">2147483647</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span><span class="mord">7</span><span class="mord">4</span><span class="mord">8</span><span class="mord">3</span><span class="mord">6</span><span class="mord">4</span><span class="mord">7</span></span></span></span> 的值为  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn></mrow><annotation encoding="application/x-tex">0111\space 1111\space 1111\space 1111\space 1111\space 1111\space 1111\space 1111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span>。</p><p>可以得出选项 D。</p><hr /><blockquote><p>已知x = -15，y = -12，计算字长 w = 5 的补码加法：x + y = (  D  )</p><p>A. -5</p><p>B. -27</p><p>C. 27</p><p>D. 5</p></blockquote><p>x + y = -27，其补码为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><mtext> </mtext><mn>0101</mn></mrow><annotation encoding="application/x-tex">10\space 0101</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span></span></span></span>，由于 w = 5，所以截取低5位，得到的结果为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mtext> </mtext><mn>0101</mn></mrow><annotation encoding="application/x-tex">0\space 0101</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span></span></span></span>，值为 5 ，选项 D 正确。</p><hr /><blockquote>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">2</span>; </span><br><span class="line"><span class="type">int</span> y = <span class="number">2</span>; </span><br><span class="line">x &lt;&lt;= <span class="number">6</span>; </span><br><span class="line">x -= y; </span><br><span class="line">y &lt;&lt;= <span class="number">3</span>; </span><br><span class="line">x -= y; </span><br></pre></td></tr></table></figure><p>上述程序 x 的输出值为（  B  ）</p><p>A. 128</p><p>B. 110</p><p>C. 55</p><p>D. 64</p></blockquote><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><msup><mn>2</mn><mn>6</mn></msup><mo>−</mo><mn>2</mn><mo>−</mo><mn>2</mn><mo>×</mo><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>110</mn></mrow><annotation encoding="application/x-tex">2 \times 2^6 - 2 - 2 \times 2^3 = 110</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span></span></span></span>，选项 B 正确。</p><hr /><blockquote><p>二进制小数 11.0011 对应的十进制数为（  C  ）</p><p>A. 3.3</p><p>B. 11.1875</p><p>C. 3.1875</p><p>D. 11.3</p></blockquote><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mn>0</mn></msup><mo>+</mo><mn>0</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>0</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>4</mn></mrow></msup><mo>=</mo><mn>3.1875</mn></mrow><annotation encoding="application/x-tex">1 \times 2^1 + 1 \times 2^0 + 0 \times 2^{-1} + 0 \times 2^{-2} + 1 \times 2^{-3} + 1 \times 2^{-4} = 3.1875</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">.</span><span class="mord">1</span><span class="mord">8</span><span class="mord">7</span><span class="mord">5</span></span></span></span>，选项 C 正确。</p><hr /><h1 id="第三章"><a class="markdownIt-Anchor" href="#第三章"></a> 第三章</h1><hr /><blockquote><p>算术右移指令是（ A ）</p><p>A. sar</p><p>B. shl</p><p>C. shr</p><p>D. sal</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625211226169.png" alt="image-20220625211226169" style="zoom:80%;" /><hr /><blockquote><p>假设<code>%rax holds x</code>,   <code>%rcx holds y</code>，则<code>leaq (%rax, %rcx, 4), %rdx</code>的结果为（  D ）</p><p>A. <code>( x + y ) * 4</code></p><p>B. <code>4 * x + y</code></p><p>C. <code>x + y + 4</code></p><p>D. <code>x + 4 * y</code></p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625211452247.png" alt="image-20220625211452247" style="zoom: 67%;" /><hr /><blockquote><p>关于条件码，下面描述错误的是 (  C  )</p><p>A.这些位描述和记录了最近算术运算或者逻辑运算的操作结果状态。</p><p>B.该序列在专门的状态寄存器FLAGS 或者EFLAGS。</p><p>C.以8086的状态寄存器FLAGS寄存器共8位。</p><p>D.一些bit位构成的序列</p></blockquote><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/weixin_42109012/article/details/100148721">8086标志寄存器（Flag Register）_有人_295的博客-CSDN博客_8086标志寄存器</a></li></ul></blockquote><p>标志寄存器设计为16位，实际使用9位，其中6位用以存放算术逻辑单元运算后的结果特征，称为<strong>状态标志</strong>；另外3位通过人为设置，用以控制8086的三种特定操作，称为<strong>控制标志</strong>。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190829223517134.png" alt="在这里插入图片描述" style="zoom:67%;" /><p>6个状态标志位定义如下：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190830001628834.png" alt="在这里插入图片描述" style="zoom:67%;" /><p><strong>进位标志：</strong> 用于反映运算是否产生进位或借位。如果运算结果的最高位产生一个进位或借位，则CF置1，否则置0。运算结果的最高位包括字操作的第15位和字节操作的第7位。移位指令也会将操作数的最高位或最低位移入CF。</p><p><strong>奇偶标志：</strong> 用于反映运算结果低8位中“1”的个数。“1”的个数为偶数，则PF置1，否则置0。</p><p><strong>辅助进位标志：</strong> 算数操作结果的第三位（从0开始计数）如果产生了进位或者借位则将其置为1，否则置为0，常在BCD(binary-code decimal)算术运算中被使用。</p><p><strong>零标志：</strong> 用于判断结果是否为0。运算结果0，ZF置1，否则置0。</p><p><strong>符号标志：</strong> 用于反映运算结果的符号，运算结果为负，SF置1，否则置0。因为有符号数采用补码的形式表示，所以SF与运算结果的最高位相同。</p><p><strong>溢出标志：</strong> 反映有符号数加减运算是否溢出。如果运算结果超过了8位或者16位有符号数的表示范围，则OF置1，否则置0。</p><hr /><blockquote><p>关于C语言的跳转及分支，下面描述正确的是(   D   )</p><p>A. 稀疏的 switch 语句使用跳转表</p><p>B. C语言不允许 switch 语句根据一个整数索引值进行多重分支</p><p>C. 大的 switch 语句使用决策树</p><p>D. C允许使用 goto 语句</p></blockquote><p>GCC 根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句。当开关情况数量比较多（例如 4 个以上），并且值的范围跨度比较小时，就会使用跳转表。情况数量较少或者值的范围跨度比较大时，会使用非常多的 <code>CMP</code> 指令，其实在这种情况下和使用多个 <code>if-else if</code> 一样。</p><hr /><blockquote><p>对指令 <code>linux&gt; objdump -d mstore.o</code>，说法最正确的是 (  C  )</p><p>A. 与mstore.exe等价的汇编语言代码</p><p>B. 与mstore.c等价的汇编语言代码</p><p>C. 与mstore.o等价的汇编语言代码</p><p>D. 以上说法都不对</p></blockquote><hr /><blockquote><p><code>xorl</code> 指令对条件码的影响描述正确的是(  B  )</p><p>A. CF被设置为移出的最后一位</p><p>B. CF和OF置零</p><p>C. ZF和OF置零</p><p>D. 对条件码无影响</p></blockquote><hr /><blockquote><p>对于x86,指令 <code>pushq %rax</code>，描述错误的是：(  A  )</p><p>A.该指令能一次压入4个bytes</p><p>B.该指令的功能是将寄存器ax的值存在堆栈中</p><p>C.与 <code>popq %rax</code>指令操作方向相反</p><p>D.该指令能增大堆栈</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621113704881.png" alt="image-20220621113704881" style="zoom: 33%;" /><p><code>pushq</code> 能一次压入 8 个 bytes。</p><hr /><blockquote><p>下列汇编指令，错误的是(  C  )</p><p>A. movb   (%rdi, %rcx), %al</p><p>B. movw  %bp, %sp</p><p>C. movb  (%rbx), (%rsp)</p><p>D. movl    $0x4050, %eax</p></blockquote><p><code>MOV</code> 指令中源操作数和目的操作数不能同时为寄存器地址。</p><hr /><blockquote><p>对命令行：<code>linux&gt;gcc -Og -S mstore.c</code>，使用 -S 选项的作用是（ D ）</p><p>A. GCC运行编译器，并进行反汇编</p><p>B. GCC运行编译器，产生一个汇编文件 mstore.s，且会产生目标文件</p><p>C. GCC运行编译器，并进行一个标准优化</p><p>D. GCC运行编译器，产生一个汇编文件 mstore.s，但是不做其他进一步的工作</p></blockquote><hr /><blockquote><p>用C语言调用有参函数，关于其机器级代码中的参数传递，以下描述正确的是（ A ）</p><p>A. 参数传递遵循调用约定，与目标机CPU和编译器都相关</p><p>B. 参数全部用栈传送，传递顺序只能由右向左进栈</p><p>C. 参数传递只与CPU相关，与编译器没有关系</p><p>D. 参数全部用固定的寄存器传递</p></blockquote><p>x8086 架构中，前6个参数存放在寄存器中，后所有参数都存放在栈中。</p><p>参数传递遵循调用约定，与目标机CPU和编译器都相关。</p><hr /><blockquote><p>x86-64的机器代码和原始的C代码差别非常大。一些通常对C语言程序员隐藏的处理器状态都是可见的，下面描述正确的是 ( A B C D )</p><p>A. 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现if和 while语句。</p><p>B. 整数寄存器文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址(对应于C语言的指针)或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。</p><p>C. 一组向量寄存器可以存放一个或多个整数或浮点数值。</p><p>D. 程序计数器(通常称为 “PC”，在x86-64中用 %rip 表示)给出将要执行的下一条指令在内存中的地址。</p></blockquote><hr /><blockquote><p>关于C语言函数对应机器代码中寄存器，正确的是（ A D ）</p><p>A. 有的寄存器调用函数不保护，由被调用函数负责保护</p><p>B. 所有寄存器都由调用函数保护，被调用函数可以自由使用</p><p>C. 所有寄存器都由被调用函数保护，调用函数可以自由使用</p><p>D. 有的寄存器由调用函数保护，被调用函数可以自由使用</p></blockquote><p>寄存器分为调用者寄存器和被调用者寄存器。</p><hr /><blockquote><p>对命令行：<code>linux&gt; gcc -Og -c mstore.c</code>，说法正确的是（ C D ）</p><p>A. 会产生exe文件，可执行文件是汇编格式的</p><p>B. 目标代码文件在机器中是十六进制的</p><p>C. GCC会编译并汇编该代码</p><p>D. 这会产生目标代码文件mstore.o</p></blockquote><p>可执行文件是二进制文件。</p><hr /><blockquote><p>C语言的一次函数调用包含的操作有（ A B C D ）</p><p>A. 跳转到被调函数的入口</p><p>B. 从栈中弹出调用函数的返回地址</p><p>C. 跳转到调用函数的返回地址</p><p>D. 保存调用函数的返回地址到栈中</p></blockquote><hr /><h1 id="第四章"><a class="markdownIt-Anchor" href="#第四章"></a> 第四章</h1><hr /><blockquote><p>能够被硬件识别并执行的程序是（   D  ）</p><p>A. 汇编语言程序</p><p>B. 高级语言程序</p><p>C. 人工智能语言程序</p><p>D. 机器指令程序</p></blockquote><hr /><blockquote><p>从计算机系统结构上讲，机器语言程序员能看到的机器属性是（  A ）</p><p>A. 编程要用到的硬件组织</p><p>B. 计算机各部件的硬件实现</p><p>C. 计算机软件所要完成的功能</p><p>D. 计算机硬件的全部组成</p></blockquote><hr /><blockquote><p>在CPU执行指令的过程中，数据的地址由什么给出？(   B   )</p><p>A. 操作系统</p><p>B. 指令的地址码字段</p><p>C. 程序员</p><p>D. 程序计数器PC</p></blockquote><hr /><blockquote><p>下列关于指令的功能及分类叙述正确的是 (  B  )</p><p>A. 转移指令，子程序调用与返回指令，用于解决数据调用次序的需要</p><p>B. 移位操作指令，通常用于把目的操作数DEST左移或右移OPRD位</p><p>C. 特权指令，通常仅用于系统软件，这类指令一般不提供给用户</p><p>D. 算术与逻辑运算指令，通常完成算术运算或逻辑运算，都需要两个数据</p></blockquote><p>特权指令指具有特殊权限的指令。. 这类指令只用于操作系统或其他系统软件，一般不直接提供给用户使用。</p><p>转移指令是指不按程序的语句流程执行的指令，如跳转指令， call 指令、 jmp 指令等。</p><hr /><blockquote><p>关于Y86-64指令的叙述中，不正确的是 (   A   )</p><p>A. 每条指令都有寄存器指示符</p><p>B. 指令的第1个字节高4位是指令代码，低4位是功能码</p><p>C. 有些指令有一个附加的8字节常数字</p><p>D. 每条指令的第1个字节表示指令的类型</p></blockquote><p><code>ret</code>、<code>nop</code>、<code>halt</code> 指令无需操作数。</p><hr /><blockquote><p>以下关于CISC和RISC的叙述中，不正确的是(   B   )</p><p>A. CISC有些指令的延迟很差，RISC没有较长延迟的指令</p><p>B. CISC和RISC都是可变长度</p><p>C. CISC有条件码，RISC没有条件码</p><p>D. CISC指令数量多，RISC指令数量少</p></blockquote><blockquote><p>答案参考自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/346864380">简述risc和cisc的区别（转发） - 知乎 (zhihu.com)</a></li><li>《深入理解计算机系统》</li></ul></blockquote><p>CISC的英文全称为“Complex Instruction Set Computer”，即“复杂指令系统计算机”，从计算机诞生以来，人们一直沿用CISC指令集方式。目前，桌面计算机流行的x86体系结构即使用CISC。在CISC微处理器中，程序的各条指令是按顺序串行执行的，每条指令中的各个操作也是按顺序串行执行的。顺序执行的优点是控制简单，但计算机各部分的利用率不高，执行速度慢。</p><p>RISC的英文全称为“Reduced Instruction Set Computer”，即“精简指令集计算机”，是一种执行较少类型计算机指令的微处理器，RISC机中采用的微处理器统称RISC处理器。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220626154912809.png" alt="image-20220626154912809" style="zoom:67%;" /><hr /><blockquote><p>Y86-64中用十六进制表示指令 <code>rmmovq %rsp, 0x123456789abcd(%rdx)</code>的字节编码(   C   )</p><p>A. 4042000123456789abcd</p><p>B. 40420123456789abcd</p><p>C. 4042cdab896745230100</p><p>D. 4042cdab8967452301</p></blockquote><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/Chauncyxu/article/details/121943734"> CSPP学习笔记-Ch4 借助 Y86-64 理解处理器是如何工作的_Life Commander的博客-CSDN博客_硬件寄存器和程序寄存器</a></li></ul></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/B1TZjXLRgPqYd2x.png" alt="img" style="zoom: 13%;" /><p>程序寄存器存在CPU中的一个寄存器文件中。<br />在指令编码中以及在硬件设计中，当需要指明不应访问任何寄存器时，就用 ID 值 0xF 来表示。</p><table><thead><tr><th>数字</th><th>寄存器名字</th><th>数字</th><th>寄存器名字</th></tr></thead><tbody><tr><td>0</td><td><code>%rax</code></td><td>8</td><td><code>%r8</code></td></tr><tr><td>1</td><td><code>%rcx</code></td><td>9</td><td><code>%r9</code></td></tr><tr><td>2</td><td><code>%rdx</code></td><td>A</td><td><code>%r10</code></td></tr><tr><td>3</td><td><code>%rbx</code></td><td>B</td><td><code>%r11</code></td></tr><tr><td>4</td><td><code>%rsp</code></td><td>C</td><td><code>%.r12</code></td></tr><tr><td>5</td><td><code>%rbp</code></td><td>D</td><td><code>%r13</code></td></tr><tr><td>6</td><td><code>%rsi</code></td><td>E</td><td><code>%r14</code></td></tr><tr><td>7</td><td><code>%rdi</code></td><td>F</td><td>No register</td></tr></tbody></table><p>从图可以看到，<code>rmmovq</code> 的第一个字节为 <code>40</code>。源寄存器 <code>%rsp</code> 应该编码放在 <code>rA</code> 字段中，而基址寄存器 <code>%rdx</code> 应该编码放在 <code>rB</code> 字段中。</p><p>根据表中的寄存器编号，得到寄存器指示符字节 4 和 2。</p><p>偏移量编码放在 8 字节的常数中：首先在 <code>0x123456789abcd</code> 的前面填充上 0 变成 8 个字节，变成字节序列 <code>00 01 23 45 67 89 ab cd</code>，由于<strong>小端法编码</strong>，写成按字节反序就是 <code>cd ab 89 67 45 23 01 00</code>。</p><p>最后，将它们都连接起来就得到指令的编码 <code>4042cdab896745230100</code>。</p><hr /><blockquote><p>输入a和b，写出信号 xor的HCL表达式(   B   )</p><p>A. bool xor =（!a &amp;&amp; !b) || (a &amp;&amp; b)</p><p>B. bool xor =（!a &amp;&amp; b) || (a &amp;&amp; !b)</p><p>C. bool xor =（a &amp;&amp; b) || (a &amp;&amp; b)</p><p>D. bool xor =（a &amp;&amp; b) || (!a &amp;&amp; b)</p></blockquote><p>可以通过类似真值表的方式判断正确答案。</p><hr /><blockquote><p>输入a和b，控制信号输入位s，写出信号MUX的HCL表达式（  D ）</p><p>A. bool out = (s &amp;&amp; a) || (s &amp;&amp; b)</p><p>B. bool out = (!s &amp;&amp; a) || (!s &amp;&amp; b)</p><p>C. bool out = (s &amp;&amp; !a) || (s &amp;&amp; !b)</p><p>D. bool out = (s &amp;&amp; a) || (!s &amp;&amp; b)</p></blockquote><p><code>MUX</code> 为多路复用器，对 s 的不同输入情况采取不同的信号输出。</p><hr /><blockquote><p>Y86-64处理器执行一条完整指令所需的步骤有 （ A B C D E ）</p><p>A.访存</p><p>B.译码</p><p>C.执行</p><p>D.写回和更新PC</p><p>E.取指</p></blockquote><p>几乎所有的冯·诺伊曼型计算机的CPU，其工作都可以分为5个阶段：取指令、指令译码、执行指令、访存取数、结果写回。</p><p>各个阶段具体内容参考：<a href="https://blog.csdn.net/aigoogle/article/details/23750257">一条指令在cpu中的执行流程（理解CPU组成）_编码那些事儿的博客-CSDN博客</a></p><hr /><h1 id="第六章"><a class="markdownIt-Anchor" href="#第六章"></a> 第六章</h1><hr /><blockquote><p>主存储器和 CPU之间增加cache的目的是（ D ）。</p><p>A.扩大CPU中通用寄存器的数量</p><p>B.扩大主存储器的容量</p><p>C.既扩大主存容量又扩大CPU通用寄存器数量</p><p>D.解决CPU和主存之间的速度匹配问题</p></blockquote><hr /><blockquote><p>下列因素下，与cache的命中率无关的是（  D  ）。</p><p>A. cache 的组织方式</p><p>B. 块的大小</p><p>C. cache的容量</p><p>D. 主存的存取时间</p></blockquote><hr /><blockquote><p>以下哪一种情况能很好地发挥cache的作用? （  A  ）</p><p>A. 程序具有较好的访问局部性</p><p>B. 程序的大小不超过实际的内存容量</p><p>C. 程序的指令间相关度不高</p><p>D. 程序中不含有过多的I/O操作</p></blockquote><hr /><blockquote><p>在当前微机中，使用cache提高了计算机运行速度，主要是因为（  A  ）</p><p>A. cache缩短了CPU的等待时间</p><p>B. cache扩大了硬盘的容量</p><p>C. cache可以存放程序和数据</p><p>D. cache增大了内存的容量</p></blockquote><hr /><blockquote><p>在存储器层次结构中，存储器速度从最快到最慢的排列顺序是(   C   )</p><p>A.寄存器  -&gt; cache -&gt; 辅存 -&gt; 主存</p><p>B.寄存器 -&gt; 主存 -&gt; 辅存 -&gt; cache</p><p>C.寄存器 -&gt; cache -&gt; 主存 -&gt; 辅存</p><p>D.寄存器 -&gt; 主存 -&gt; cache -&gt; 辅存</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220626191551044.png" alt="image-20220626191551044" style="zoom:67%;" /><hr /><blockquote><p>在cache的地址映射中，若主存中的任意一块均可映射到cache内的任意一块的位置上，则这种方法称为（ D ）。</p><p>A. 组相联映射</p><p>B. 直接映射</p><p>C. 混合映射</p><p>D. 全相联映射</p></blockquote><hr /><blockquote><p>某计算机的cache共有16行,采用2路组相联映射方式(即每组2行)。每个主存块大小为32字节,按字节编址。主存135号单元所在主存块应装入到的cache组号是（ A ）。</p><p>A. 4</p><p>B. 2</p><p>C. 6</p><p>D. 0</p></blockquote><p>通过题目可以得出：该计算机的 cache 总共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">16 / 2 = 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 组，每组 2 行，每块 32 字节。</p><p>135 的二进制为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mtext> </mtext><mn>1000</mn><mtext> </mtext><mn>0111</mn></mrow><annotation encoding="application/x-tex">0 \space 1000 \space 0111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span>，重新调整排版后为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mtext> </mtext><mn>100</mn><mtext> </mtext><mn>00111</mn></mrow><annotation encoding="application/x-tex">0 \space 100 \space 00111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span>。</p><p>从低位向高位看：</p><ol><li>低 5 位表示每块 32 字节，即每行的偏移值。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>5</mn></msup><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">2^5 = 32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span></span></span></span>）</li><li>中 3 位表示共有 8 个组，即组索引。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">2^3=8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>）</li><li>高 t 位表示标记位，即说明这个组的哪一行包括了相关内容。</li></ol><p>所以 cache 组号为中 3 位，即为 4。</p><hr /><blockquote><p>假定主存按字节编址，cache 共有64行，采用直接映射方式，主存块大小为32字节，所有编号都从0开始。问主存第2593号单元所在主存块对应的cache行号是（ B ）</p><p>A.34</p><p>B.17</p><p>C.81</p><p>D.1</p></blockquote><p>得出的信息：</p><ol><li>共有 64 组，每组 1 行。 -&gt;  二进制中间部分位数为 6。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn><mo>=</mo><msup><mn>2</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">64 = 2^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>）</li><li>每块 32 字节。 -&gt; 二进制后面部分位数为 5。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn><mo>=</mo><msup><mn>2</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">32=2^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>）</li></ol><p>2593 的二进制为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mtext> </mtext><mn>010001</mn><mtext> </mtext><mn>00001</mn></mrow><annotation encoding="application/x-tex">1 \space 010001 \space 00001</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span></span></span></span>，所以 cache 行号为二进制中间部分，即为 17。选项 B 正确。</p><hr /><blockquote><p>假定主存按字节编址，cache 共有64行，采用4路组相联映射方式，主存块大小为32字节，所有编号都从0开始。问主存第2593号单元所在主存块对应的cache组号是（ D ）</p><p>A.34</p><p>B.17</p><p>C.81</p><p>D.1</p></blockquote><p>得出的信息：</p><ol><li>共有 16 组，每组 4 行。 -&gt;  二进制中间部分位数为 4。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn><mo>=</mo><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">16 = 2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>）</li><li>每块 32 字节。 -&gt; 二进制后面部分位数为 5。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn><mo>=</mo><msup><mn>2</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">32=2^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>）</li></ol><p>2593 的二进制为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>101</mn><mtext> </mtext><mn>0001</mn><mtext> </mtext><mn>00001</mn></mrow><annotation encoding="application/x-tex">101 \space 0001 \space 00001</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span></span></span></span>，所以 cache 行号为二进制中间部分，即为 1。选项 D 正确。</p><hr /><blockquote><p>下面的叙述中，不正确的是( B C D )。</p><p>A.重复引用相同变量的程序有良好的时间局部性</p><p>B.在CPU和主存间加入了多个cache，计算机总存储量就增加了</p><p>C.CPU要找的指令和数据都能在cache中访问到</p><p>D.主存和cache之间按主存块为单位传送数据时，主存块越大越好</p></blockquote>]]></content>
    
    
    <summary type="html">整理并分析了上课时的部分练习题。</summary>
    
    
    
    <category term="计算机系统" scheme="https://luoyu-ying.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="深入理解计算机系统" scheme="https://luoyu-ying.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Android 自定义 Toast [转载]</title>
    <link href="https://luoyu-ying.github.io/posts/e8e9356f3f9b/"/>
    <id>https://luoyu-ying.github.io/posts/e8e9356f3f9b/</id>
    <published>2022-06-24T06:17:11.000Z</published>
    <updated>2022-06-24T06:17:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章转载自：</p><ul><li><a href="https://blog.csdn.net/liuwan1992/article/details/52710652">Android 自定义Toast，修改Toast样式和显示时长_liuwan1992的博客-CSDN博客</a></li></ul></blockquote><hr /><p>Android 中有一个 Toast 控件，可以用来显示提示信息，还是非常好用的，但是样式和显示时长比较局限。所以我们来自定义一个 Toast ，让它可以显示我们想要的效果，并能设置显示时长。</p><p>首先，在 res\layout 文件夹下创建自定义 Toast 的布局文件 custom_toast.xml，用来设置 Toast 的样式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:id</span>=<span class="string">&quot;@+id/toast_custom_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:id</span>=<span class="string">&quot;@+id/tvToastContent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;46dp&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;75dp&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:background</span>=<span class="string">&quot;@drawable/toast_customer_style&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:textColor</span>=<span class="string">&quot;#FFFFFF&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的自定义 Toast 其实就是一个TextView ，其中引用了 res\drawable 文件夹下的一个 shape 样式文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:shape</span>=<span class="string">&quot;rectangle&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置背景透明度和颜色 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">&quot;#99000000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置四个角为弧形 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">&quot;23dp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">padding</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:left</span>=<span class="string">&quot;23dp&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:right</span>=<span class="string">&quot;23dp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure><p>到这里，所有的布局就已经设计好了，也就是实现了自定义样式，接下来就是在代码中实现自定义 Toast 了，以及实现设置显示时长：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomToast</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">canceled</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler handler;</span><br><span class="line">    <span class="keyword">private</span> Toast toast;</span><br><span class="line">    <span class="keyword">private</span> TimeCount time;</span><br><span class="line">    <span class="keyword">private</span> TextView toast_content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomToast</span><span class="params">(Context context, ViewGroup viewGroup)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, viewGroup, <span class="keyword">new</span> <span class="title class_">Handler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomToast</span><span class="params">(Context context, ViewGroup viewGroup, Handler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line"></span><br><span class="line">        <span class="type">View</span> <span class="variable">layout</span> <span class="operator">=</span> LayoutInflater.from(context).inflate(R.layout.custom_toast, viewGroup);</span><br><span class="line">        toast_content = (TextView) layout.findViewById(R.id.tvToastContent);</span><br><span class="line">        <span class="keyword">if</span> (toast == <span class="literal">null</span>) &#123;</span><br><span class="line">            toast = <span class="keyword">new</span> <span class="title class_">Toast</span>(context);</span><br><span class="line">        &#125;</span><br><span class="line">        toast.setGravity(Gravity.BOTTOM, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        toast.setDuration(Toast.LENGTH_LONG);</span><br><span class="line">        toast.setView(layout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text     要显示的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> duration 显示的时间长</span></span><br><span class="line"><span class="comment">     *                 根据LENGTH_MAX进行判断</span></span><br><span class="line"><span class="comment">     *                 如果不匹配，进行系统显示</span></span><br><span class="line"><span class="comment">     *                 如果匹配，永久显示，直到调用hide()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String text, <span class="type">int</span> duration)</span> &#123;</span><br><span class="line">        time = <span class="keyword">new</span> <span class="title class_">TimeCount</span>(duration, <span class="number">1000</span>);</span><br><span class="line">        toast_content.setText(text);</span><br><span class="line">        <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">            time.start();</span><br><span class="line">            canceled = <span class="literal">false</span>;</span><br><span class="line">            showUntilCancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 隐藏Toast</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hide</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (toast != <span class="literal">null</span>) &#123;</span><br><span class="line">            toast.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        canceled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showUntilCancel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        toast.show();</span><br><span class="line">        handler.postDelayed(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                showUntilCancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计时器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TimeCount</span> <span class="keyword">extends</span> <span class="title class_">CountDownTimer</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TimeCount</span><span class="params">(<span class="type">long</span> millisInFuture, <span class="type">long</span> countDownInterval)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(millisInFuture, countDownInterval); <span class="comment">// 总时长,计时的时间间隔</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFinish</span><span class="params">()</span> &#123; <span class="comment">// 计时完毕时触发</span></span><br><span class="line">            hide();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTick</span><span class="params">(<span class="type">long</span> millisUntilFinished)</span> &#123; <span class="comment">// 计时过程显示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要通过一个倒计时器和异步线程来实现设置显示时长。TimeCount 有两个参数，第一个是倒计时时长，也就是 Toast 要显示的时长，第二个是间隔时间，在倒计时内每隔一定时间会回调一次 onTick 方法，倒计时结束后回调 onFinish 方法。在倒计时器中我 们要设置的只有倒计时时长，即显示时长，时间到了就 cancel() 掉 Toast。在对 Toast 初始化时，默认设置的显示时长是LENGTH_LONG ，为2.5s。那么问题来了，3s以内倒计时器可以控制显示时长，但是超过3s Toast 就自行结束了，如果我们想要显示超过三秒怎么办，所以这里通过一个异步线程，并设置一个 postDelayed 任务，推迟3s执行，在线程中调用自身的方法，实现循环调用。 这样每隔3s显示一次 Toast ，达到了一直显示的效果。然后通过 canceled 属性，将倒计时器和异步线程联系到一起，这样就可以通过 Handler 让 Toast 一直显示，再通过 TimeCount 让 Toast 结束显示，达到了自定义显示时长的效果。</p><p>具体调用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CustomToast toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">toastMessage</span><span class="params">(String content)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (toast != <span class="literal">null</span>) &#123;</span><br><span class="line">        toast.hide();</span><br><span class="line">    &#125;</span><br><span class="line">    toast = <span class="keyword">new</span> <span class="title class_">CustomToast</span>(LoginActivity.<span class="built_in">this</span>,</span><br><span class="line">                            (ViewGroup) <span class="built_in">this</span>.findViewById(R.id.toast_custom_parent));</span><br><span class="line">    toast.show(content, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以在 onClick 等事件中通过调用 toastMessage(&quot;自定义 Toast 的显示内容 &quot;); 来显示你想要给用户看到的提示内容了。</p>]]></content>
    
    
    <summary type="html">转载了一篇可以自定义样式和显示时长的自定义Toast类。</summary>
    
    
    
    <category term="Android" scheme="https://luoyu-ying.github.io/categories/Android/"/>
    
    
    <category term="Toast" scheme="https://luoyu-ying.github.io/tags/Toast/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解计算机系统》 第三章 学习笔记</title>
    <link href="https://luoyu-ying.github.io/posts/9d9a45889a2d/"/>
    <id>https://luoyu-ying.github.io/posts/9d9a45889a2d/</id>
    <published>2022-06-21T02:57:28.000Z</published>
    <updated>2022-06-21T02:57:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li>《深入理解计算机系统》</li><li><a href="https://zhuanlan.zhihu.com/p/94406822">「抄书笔记」Machine Level Programming - 知乎 (zhihu.com)</a></li><li><a href="https://space.bilibili.com/354767108">九曲阑干的个人空间_哔哩哔哩_bilibili</a></li></ul><h1 id="寄存器"><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h1><h2 id="调用者保存"><a class="markdownIt-Anchor" href="#调用者保存"></a> 调用者保存</h2><p>调用者保存是指当P函数调用Q函数时，该寄存器中的内容由调用者P负责保存，Q可以直接使用该寄存器。</p><h2 id="被调用者保存"><a class="markdownIt-Anchor" href="#被调用者保存"></a> 被调用者保存</h2><p>被调用者保存是指当P函数调用Q函数时，该寄存器中的内容由被调用者Q负责保存。</p><h2 id="调用者保存寄存器caller-saved-registers"><a class="markdownIt-Anchor" href="#调用者保存寄存器caller-saved-registers"></a> 调用者保存寄存器（<code>caller saved registers</code>）</h2><p>也叫<strong>易失性寄存器</strong>，在程序调用的过程中，这些寄存器中的值不需要被保存（即压入到栈中再从栈中取出），如果某一个程序需要保存这个寄存器的值，需要调用者自己压入栈；</p><h2 id="被调用者保存寄存器callee-saved-registers"><a class="markdownIt-Anchor" href="#被调用者保存寄存器callee-saved-registers"></a> 被调用者保存寄存器（<code>callee saved registers</code>）</h2><p>也叫<strong>非易失性寄存器</strong>，在程序调用过程中，这些寄存器中的值需要被保存，不能被覆盖；当某个程序调用这些寄存器，被调用寄存器会先保存这些值然后再进行调用，且在调用结束后恢复被调用之前的值；</p><h2 id="寄存器及其功能"><a class="markdownIt-Anchor" href="#寄存器及其功能"></a> 寄存器及其功能</h2><p>其中，<code>rsp</code> 表示的是运行时栈结束的位置，即栈顶的位置。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-909063cd57cd5b2136ff8ed4d04bc5e6_1440w.jpg" alt="img" style="zoom:57%;" /><h1 id="汇编指令后缀"><a class="markdownIt-Anchor" href="#汇编指令后缀"></a> 汇编指令后缀</h1><p>如 <code>movq</code>，<code>callq</code>，<code>movl</code> 等等。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621113704881.png" alt="image-20220621113704881" style="zoom:40%;" /><h1 id="操作数格式"><a class="markdownIt-Anchor" href="#操作数格式"></a> 操作数格式</h1><p>比例因子的取值和源代码中存储对象的类型有关，且只能为1，2，4，8（分别对应着 <code>char</code>，<code>short</code>，<code>int</code>，<code>long</code>四个数据类型）。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625211452247.png" alt="image-20220625211452247" style="zoom:80%;" /><h1 id="mov-指令"><a class="markdownIt-Anchor" href="#mov-指令"></a> <code>MOV</code> 指令</h1><p>源操作数和目的操作数不能同时为寄存器地址。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621180210624.png" alt="image-20220621180210624" style="zoom: 80%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621182452659.png" alt="image-20220621182452659" style="zoom:67%;" /><h2 id="movq-movabsq"><a class="markdownIt-Anchor" href="#movq-movabsq"></a> <code>MOVQ</code> &amp; <code>MOVABSQ</code></h2><p>当出现 <code>MOVQ $Imm Destination</code> 指令时，该立即数只能是32位的补码表示，然后对该数值进行符号位扩展之后，将得到的64位数传送到目的位置。</p><p>这个限制会带来一个问题，就是如果立即数是64位时该如何处理？</p><p>这里引入了一个新的指令 <code>MOVABSQ $Imm Register</code> ，这里存放的可以是任意的64位立即数，但是目的操作数只能是寄存器。</p><h2 id="movl"><a class="markdownIt-Anchor" href="#movl"></a> <code>MOVL</code></h2><p>当 <code>MOVL</code> 的目的操作数是寄存器时，它会把该寄存器的高4字节设置为0，这是64位处理器的一个规定。即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置为0。</p><h2 id="movz-movs"><a class="markdownIt-Anchor" href="#movz-movs"></a> <code>MOVZ</code> &amp; <code>MOVS</code></h2><p>当源操作数的数位小于目的操作数时，便会对目的操作数剩余的字节进行扩展。</p><p>指令的最后两个字符表示了源操作数的大小以及目的操作数的大小。</p><p>零扩展中没有的 <code>movzlq</code> 指令可以通过 <code>movl</code> 指令实现。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-f59c8e900d14a5597a87959a6df649c7_720w.jpg" alt="img" style="zoom: 90%;" /><h1 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h1><h2 id="栈的结构"><a class="markdownIt-Anchor" href="#栈的结构"></a> 栈的结构</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621183231538.png" alt="image-20220621183231538" style="zoom: 67%;" /><p>栈的顶部在图中的底部，栈顶的元素时所有栈中元素地址最低的。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-429b736ec876e982f38a9f651303e9fa_720w.jpg" alt="img" style="zoom: 80%;" /><h2 id="push"><a class="markdownIt-Anchor" href="#push"></a> <code>PUSH</code></h2><p>使用 <code>push</code> 指令将数据压入栈内。</p><p>例如 <code>pushq %rax</code> 指令执行的过程可以分为两步：</p><ol><li>指向栈顶的寄存器 <code>rsp</code> 进行一个减法操作 <code>subq $8, %rsp</code>。</li><li>将需要保存的元素复制到新的栈顶位置 <code>movq %rax, (%rsp)</code>。</li></ol><h2 id="pop"><a class="markdownIt-Anchor" href="#pop"></a> <code>POP</code></h2><p>使用 <code>pop</code> 指令从内存中读取数据，并且修改栈顶指针。</p><p>例如 <code>popq %rbx</code> 指令就是将栈顶保存的数据复制到寄存器<code>rbx</code>中，该指令同样也可以分解成两步：</p><ol><li>从栈顶的位置读出数据，复制到寄存器 <code>rbx</code>：<code>movq (%rsp), %rbx</code>。</li><li>将栈顶的指针加8（因为 <code>q</code> 表示的是8个字节）：<code>addq $8, %rsp</code>。</li></ol><h1 id="算数和逻辑运算指令"><a class="markdownIt-Anchor" href="#算数和逻辑运算指令"></a> 算数和逻辑运算指令</h1><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-af64fab6c6832e1d6f6ff4dcebb0a07a_720w.jpg" alt="img" style="zoom: 80%;" /><h2 id="lea"><a class="markdownIt-Anchor" href="#lea"></a> <code>LEA</code></h2><p>实现的功能为加载有效的地址，即将计算出的源操作数的值直接写入到目的寄存器中。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621184454652.png" alt="image-20220621184454652" style="zoom: 67%;" /><p>其中，<code>q</code>表示为加载的地址的长度为8个字节。因为64位系统中地址的长度都是64位，所以不存在 <code>leab</code>，<code>leaw</code>这类有关大小的变种。</p><p>例如，<code>leaq 7(%rdx, %rdx, 4), %rax</code> ，它表示的含义是把有效地址复制到寄存器<code>rax</code>中。其中，有效地址的计算方式与之前讲到的内存地址的计算方式一致。</p><p>除了加载有效地址的功能，<code>leaq</code> 指令还可以用来表示加法和有限的乘法运算（比例因子的取值只能为1，2，4，8这四个数中的一个）。</p><h2 id="一元操作"><a class="markdownIt-Anchor" href="#一元操作"></a> 一元操作</h2><p>第一个操作数既是源操作数，也是目的操作数，可以是寄存器，也可以是内存地址。</p><h2 id="二元操作"><a class="markdownIt-Anchor" href="#二元操作"></a> 二元操作</h2><p>第二个操作数既是源操作数，也是目的操作数，但是其不能是立即数。</p><p>需要注意，<code>sub</code> 指令的减数和被减数的操作数位置，为第二个操作数减第一个操作数。</p><h2 id="移位操作"><a class="markdownIt-Anchor" href="#移位操作"></a> 移位操作</h2><p>两个左移的指令效果相同。</p><p>对于移位量k，可以是一个立即数，<strong>或者是放在寄存器 <code>cl</code> 中的数</strong>。</p><p>对于移位指令，只允许以特定的寄存器cl作为操作数，其他的寄存器不行，这里需要特别注意。</p><h2 id="其他特殊的算数指令"><a class="markdownIt-Anchor" href="#其他特殊的算数指令"></a> 其他特殊的算数指令</h2><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621195341299.png" alt="image-20220621195341299" /></p><h1 id="条件码寄存器"><a class="markdownIt-Anchor" href="#条件码寄存器"></a> 条件码寄存器</h1><p>ALU（算数执行单元）除了执行算数和逻辑运算指令外，还会根据该运算的结果去设置条件码寄存器。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621192149338.png" alt="image-20220621192149338" style="zoom:67%;" /><p>CPU 维护一组单个位的条件码寄存器，检测条件分支指令，描述了最近执行操作的属性。</p><ul><li><p>CF</p><blockquote><p><code>Carry Flag</code> —— 进位标志</p></blockquote><p>最近的操作让最高位进位，可以检查无符号操作数的溢出。</p></li><li><p>ZF</p><blockquote><p><code>Zero Flag</code> —— 零标志</p></blockquote><p>当最近操作的结果等于0时，需标志(ZF)会被置为1。</p></li><li><p>SF</p><blockquote><p><code>Sign Flag</code> —— 符号标志</p></blockquote><p>当最近的操作结果小于零时，符号标志(SF)会被置为1。</p></li><li><p>OF</p><blockquote><p><code>Overflow Flag</code> —— 溢出标志</p></blockquote><p>针对有符号数，最近的操作导致正溢出或者负溢出时，溢出标志(OF)会被置1（操作导致补码溢出）。</p></li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621192305450.png" alt="image-20220621192305450" style="zoom:67%;" /><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621195556936.png" alt="image-20220621195556936" /></p><h2 id="cmp"><a class="markdownIt-Anchor" href="#cmp"></a> <code>CMP</code></h2><p><code>cmp</code>指令是根据两个操作数的差来设置条件码寄存器，为第二个操作数减去第一个操作数。</p><p><code>cmp</code>指合和减法指令(<code>sub</code>)类似，也是根据两个操作数的差来设置条件码。二者不同的是cmp指令只是设置条件码寄存器，并不会更新目的寄存器的值。</p><p>指令<code>cmp</code>会根据差的结果来设置符号标志(SF)和溢出标志(OF)。</p><p>如果与 <code>CMOV</code> 指令一起使用的话，那么这个指令的含义便可以理解为，<strong>将第二个操作数与第一个操作数进行比较</strong>，比较的内容为 <code>CMOV</code> 指令中的内容。注意，一定是第二个操作数在比较符号之前，第一个操作数在符号之后。</p><h2 id="test"><a class="markdownIt-Anchor" href="#test"></a> <code>TEST</code></h2><p><code>test</code>指令和 <code>and</code> 指令类似，同样 <code>test</code> 指令只是设置条件码寄存器，并不会更新目的寄存器的值。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625160659795.png" alt="image-20220625160659795" style="zoom:67%;" /><h2 id="set"><a class="markdownIt-Anchor" href="#set"></a> <code>SET</code></h2><p>使用 <code>set</code> 指令，根据条件码寄存器中不同组合的对应的计算结果，将结果值复制到目的寄存器中。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621195516682.png" alt="SET 指令" /></p><h1 id="跳转指令与循环"><a class="markdownIt-Anchor" href="#跳转指令与循环"></a> 跳转指令与循环</h1><p>在汇编代码中，判断、循环语句的实现基本采用C语言中<code>goto</code>语句的实现方式。所以了解<code>goto</code>语句，能够更加容易掌握这部分知识。</p><h2 id="jump"><a class="markdownIt-Anchor" href="#jump"></a> <code>JUMP</code></h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621211143827.png" alt="image-20220621211143827" style="zoom:67%;" /><h3 id="跳转指令的编码"><a class="markdownIt-Anchor" href="#跳转指令的编码"></a> 跳转指令的编码</h3><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621211915713.png" alt="image-20220621211915713" /></p><h2 id="cmov"><a class="markdownIt-Anchor" href="#cmov"></a> <code>CMOV</code></h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625183509367.png" alt="image-20220625183509367" style="zoom:80%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621211422154.png" alt="image-20220621211422154" style="zoom:80%;" /><h2 id="判断语句"><a class="markdownIt-Anchor" href="#判断语句"></a> 判断语句</h2><h3 id="if-语句"><a class="markdownIt-Anchor" href="#if-语句"></a> <code>if</code> 语句</h3><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621212901469.png" alt="image-20220621212901469" style="zoom: 50%;" /><p><strong>使用例</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621212656994.png" alt="image-20220621212656994" style="zoom: 80%;" /><p>判断语句除了可以使用传统的 <code>jump</code> 指令，也可以通过更加高效的 <code>cmov</code> 指令实现。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621213135058.png" alt="image-20220621213135058" style="zoom: 67%;" /><h3 id="switch-语句"><a class="markdownIt-Anchor" href="#switch-语句"></a> <code>switch</code> 语句</h3><blockquote><p>switch（开关）语句可以根据一个整数索引值进行多重分支 (multiway branching) 。在 处理具有多种可能结果的测试时，这种语句特别有用。</p><p>它们不仅提高了 C 代码的可读性， 而且通过使用跳转表(jump table) 这种数据结构使得实现更加高效。</p><p>跳转表是一个数组，表项 i 是一个代码段的地址，这个代码段实现当开关索引值等于 i 时程序应该采取的动作。</p><p>和使用一 组很长的 if-else 语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。 当 switch 语句有上百种情况的时候，也可以只用一次跳转表访问去处理。</p><p>GCC 根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句。当开关情况数量比较多（例如 4 个以上），并且值的范围跨度比较小时，就会使用跳转表。情况数量较少或者值的范围跨度比较大时，会使用非常多的 <code>CMP</code> 指令，其实在这种情况下和使用多个 <code>if-else if</code> 一样。</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625191557467.png" alt="image-20220625191557467" style="zoom:80%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625191608408.png" alt="image-20220625191608408" style="zoom:80%;" /><h2 id="循环结构"><a class="markdownIt-Anchor" href="#循环结构"></a> 循环结构</h2><p>循环语句是通过条件测试和跳转语句的结合来实现的。</p><h3 id="do-while循环"><a class="markdownIt-Anchor" href="#do-while循环"></a> <code>do-while</code>循环</h3><p>    <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625183700482.png" alt="image-20220625183700482" style="zoom:80%;" />    <br><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625183817630.png" alt="image-20220625183817630" style="zoom:80%;" /></p><p><strong>使用例</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621213819867.png" alt="image-20220621213819867" style="zoom: 60%;" /><h3 id="while-循环"><a class="markdownIt-Anchor" href="#while-循环"></a> <code>while</code> 循环</h3><p>    <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625184638266.png" alt="image-20220625184638266" style="zoom:80%;" /></p> <p><strong>第一种翻译方法</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625184745056.png" alt="image-20220625184745056" style="zoom: 77%;" /><p><strong>第一种使用例</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625184927353.png" alt="image-20220625184927353" style="zoom:80%;" /><p><strong>第二种翻译方法</strong></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625185034919.png" alt="image-20220625185034919" style="zoom:80%;" /><br><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625185056071.png" alt="image-20220625185056071" style="zoom:80%;" /></p><p><strong>第二种使用例</strong></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625185240724.png" alt="image-20220625185240724" style="zoom:80%;" /><br><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625185305176.png" alt="image-20220625185305176" style="zoom:80%;" /><br><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625185319542.png" alt="image-20220625185319542" style="zoom:80%;" /></p><h3 id="for-循环"><a class="markdownIt-Anchor" href="#for-循环"></a> <code>for</code> 循环</h3><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625185948500.png" alt="image-20220625185948500" style="zoom:80%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625190037921.png" alt="image-20220625190037921" style="zoom:80%;" />]]></content>
    
    
    <summary type="html">《深入理解计算机系统》的第三章学习笔记。</summary>
    
    
    
    <category term="计算机系统" scheme="https://luoyu-ying.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="深入理解计算机系统" scheme="https://luoyu-ying.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解计算机系统》 第二章 学习笔记</title>
    <link href="https://luoyu-ying.github.io/posts/c0ead3b585d4/"/>
    <id>https://luoyu-ying.github.io/posts/c0ead3b585d4/</id>
    <published>2022-06-14T00:30:41.000Z</published>
    <updated>2022-06-19T00:30:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li>《深入理解计算机操作系统》</li><li><a href="https://space.bilibili.com/354767108">九曲阑干</a> 大佬的一系列视频<ul><li><a href="https://www.bilibili.com/video/BV1tV411U7N3">【CSAPP-深入理解计算机系统】2-1.信息的存储(上)_哔哩哔哩_bilibili</a></li><li>…</li></ul></li></ul><h1 id="信息存储"><a class="markdownIt-Anchor" href="#信息存储"></a> 信息存储</h1><h2 id="系统程序向后兼容"><a class="markdownIt-Anchor" href="#系统程序向后兼容"></a> 系统程序向后兼容</h2><ul><li>64位系统可以生成并使用32位程序。</li><li>32位系统无法使用64位程序。</li></ul><h2 id="c语言中数据类型所占用的字节数"><a class="markdownIt-Anchor" href="#c语言中数据类型所占用的字节数"></a> C语言中数据类型所占用的字节数</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614091625732.png" alt="image" style="zoom: 40%;" /><p>注意：</p><ol><li><code>long</code> 数据类型的取值范围与机器字长相关。</li></ol><h2 id="数据在内存中的存储顺序"><a class="markdownIt-Anchor" href="#数据在内存中的存储顺序"></a> 数据在内存中的存储顺序</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614091915842.png" alt="image" style="zoom: 67%;" /><ul><li>图中左边为低有效字节，右边为高有效字节。</li><li>大多数 Intel 兼容机、Linux、Android、IOS 都是采用小端模式。</li><li>IBM 和 SUN 公司的大多数机器都是采用的大端模式。</li><li>基于 ARM 架构的处理器则支持双端法，即同时支持上述两个模式。</li></ul><h2 id="布尔运算"><a class="markdownIt-Anchor" href="#布尔运算"></a> 布尔运算</h2><table><thead><tr><th>操作</th><th>符号</th></tr></thead><tbody><tr><td>与</td><td>AND</td></tr><tr><td>或</td><td>OR</td></tr><tr><td>非</td><td>NOT</td></tr><tr><td>异或</td><td>XOR</td></tr></tbody></table><h2 id="掩码"><a class="markdownIt-Anchor" href="#掩码"></a> 掩码</h2><p>掩码是一串二进制代码。对目标字段进行位与运算，从而屏蔽当前的输入位。</p><h2 id="逻辑运算"><a class="markdownIt-Anchor" href="#逻辑运算"></a> 逻辑运算</h2><table><thead><tr><th>操作</th><th>符号</th></tr></thead><tbody><tr><td>与</td><td>AND</td></tr><tr><td>或</td><td>OR</td></tr><tr><td>非</td><td>NOT</td></tr></tbody></table><p>注意：</p><ol><li>逻辑运算的结果只有 true 和 false。</li></ol><h2 id="位移运算"><a class="markdownIt-Anchor" href="#位移运算"></a> 位移运算</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614102822234.png" alt="image" style="zoom: 67%;" /><p>注意：</p><ol><li><p>算术右移高位填充的是原来数字的符号位。</p></li><li><p>几乎所有的编译器以及及其的组合都是对有符号数使用算术右移。</p></li></ol><h1 id="整数表示"><a class="markdownIt-Anchor" href="#整数表示"></a> 整数表示</h1><h2 id="无符号数编码"><a class="markdownIt-Anchor" href="#无符号数编码"></a> 无符号数编码</h2><p>无符号数只能表示非负数。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614103830722.png" alt="image" style="zoom:67%;" /><p>B2U：Binary to unsigned。</p><p>下图为无符号数的图形化表示。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614104406695.png" alt="image" style="zoom:40%;" /><h2 id="负数的编码补码"><a class="markdownIt-Anchor" href="#负数的编码补码"></a> 负数的编码（补码）</h2><p>计算机系统中存储负数基本采用补码的形式。<strong>补码 = 反码 + 1。</strong></p><p>     <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614105129560.png" alt="image" style="zoom:53%;" />    <center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614105643185.png" alt="image" style="zoom:40%;" /></center></p><p>需要注意的是最高位的权重为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><msup><mn>2</mn><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">-2^{w-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 。当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_{w-1} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，表示非负数；当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x_{w-1} = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，表示负数。</p><p>不能仅仅把最高位当成符号位看待，我们需要着重理解 <strong>负权重</strong> 的概念。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614105801516.png" alt="image" style="zoom:50%;" /><p>下图为图形化表示法，可以更加清晰的看到补码的计算过程。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614110234849.png" alt="image" style="zoom:40%;" /><p>注意：</p><ol><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 的补码和无符号数的最大数有着相同的表示形式。</li><li>对于相同的位模式，映射函数的不同，得到的数值也会不同。</li></ol><h2 id="有符号数转换为无符号数"><a class="markdownIt-Anchor" href="#有符号数转换为无符号数"></a> 有符号数转换为无符号数</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614112013343.png" alt="image-20220614" style="zoom:40%;" /><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 表示有符号数的二进制位数。</p><h2 id="无符号数转换为有符号数"><a class="markdownIt-Anchor" href="#无符号数转换为有符号数"></a> 无符号数转换为有符号数</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614112202660.png" alt="image-20220614" style="zoom:40%;" /><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 表示无符号数的二进制位数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mtext> </mtext><mi>M</mi><mi>a</mi><msub><mi>x</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">T \space Max_{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示有符号数的最大值。</p><h2 id="强制类型转换"><a class="markdownIt-Anchor" href="#强制类型转换"></a> 强制类型转换</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/usual_arithmetic_conversion.png" alt="Usual Arithmetic Conversion" style="zoom:80%;" /><h1 id="整数运算"><a class="markdownIt-Anchor" href="#整数运算"></a> 整数运算</h1><h2 id="加法运算"><a class="markdownIt-Anchor" href="#加法运算"></a> 加法运算</h2><h3 id="无符号数加法"><a class="markdownIt-Anchor" href="#无符号数加法"></a> 无符号数加法</h3><p>例如，两个 <code>unsigned char</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>127</mn><mi mathvariant="normal">、</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">127、1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span><span class="mord cjk_fallback">、</span><span class="mord">1</span></span></span></span> 相加，得到的结果不为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>128</mn></mrow><annotation encoding="application/x-tex">128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span> ，而是为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p><p>我们定义符号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>+</mo><mi>w</mi><mi>u</mi></msubsup><mi>y</mi></mrow><annotation encoding="application/x-tex">+^u_{w}y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.911392em;vertical-align:-0.247em;"></span><span class="mord"><span class="mbin">+</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 表示 <code>unsigned</code> 类型、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位的整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619194945095.png" alt="image-20220619" style="zoom: 60%;" /><p>通过程序判定是否溢出：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619195136224.png" alt="image-20220619" style="zoom:60%;" /><h3 id="有符号数加法"><a class="markdownIt-Anchor" href="#有符号数加法"></a> 有符号数加法</h3><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619195234384.png" alt="image-20220619" style="zoom:50%;" /><p>判断是否发生了溢出：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619195512632.png" alt="image" style="zoom:50%;" /><h2 id="减法运算"><a class="markdownIt-Anchor" href="#减法运算"></a> 减法运算</h2><p>减法操作在计算机中通过使用 <strong>加法逆元</strong> 实现。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619200901107.png" alt="image-20220619200901107" style="zoom:57%;" /><p>在上图中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">x&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的加法逆元，其中满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x + x&#x27; = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p><h3 id="无符号数减法"><a class="markdownIt-Anchor" href="#无符号数减法"></a> 无符号数减法</h3><p>无符号数的加法逆元为：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619201018960.png" alt="image-20220619201018960" style="zoom:67%;" /><p>由于无符号数中没有负数，我们通过溢出的方式使得两个无符号数相加和为 0。</p><h3 id="有符号数减法"><a class="markdownIt-Anchor" href="#有符号数减法"></a> 有符号数减法</h3><p>有符号数的加法逆元如下图：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619201235671.png" alt="image-20220619201235671" style="zoom:57%;" /><p>注意，有符号数的正负数表示范围并非对称，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>T</mi><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>T</mi><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>w</mi></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|T min_w|=|T max_w| + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，所以对最小值进行单独计算，得出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>T</mi><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>w</mi></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∣</mi><mi>T</mi><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">-(|T max_w| + 1) = |T min_w|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span> ，即最小值的加法逆元为其本身。</p><h2 id="乘法运算"><a class="markdownIt-Anchor" href="#乘法运算"></a> 乘法运算</h2><p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位的无符号数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，两者的乘积可能需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>w</mi></mrow><annotation encoding="application/x-tex">2w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位来表示。在 C 语言中，定义了无符号数乘法所产生的结果为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位，所以运行结果会截取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>w</mi></mrow><annotation encoding="application/x-tex">2w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 中的低 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619202338552.png" alt="image-20220619202324281" style="zoom:60%;" />]]></content>
    
    
    <summary type="html">整理了《深入理解计算机系统》第二章的部分知识点。</summary>
    
    
    
    <category term="计算机系统" scheme="https://luoyu-ying.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="深入理解计算机系统" scheme="https://luoyu-ying.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Microsoft Word 使用自定义论文样式集</title>
    <link href="https://luoyu-ying.github.io/posts/9fff5beeee26/"/>
    <id>https://luoyu-ying.github.io/posts/9fff5beeee26/</id>
    <published>2022-06-09T00:19:33.000Z</published>
    <updated>2022-06-13T00:19:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>本文仅提供设置方法，每一项的具体的字体字号根据学校的要求请另行更改。</li><li>本文将修改部分源文件，请<strong>及时备份相关文件</strong> 。</li></ol></blockquote><h1 id="效果"><a class="markdownIt-Anchor" href="#效果"></a> 效果</h1><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220609083109777.png" alt="image" style="zoom: 67%;" /><h1 id="样式设置方法"><a class="markdownIt-Anchor" href="#样式设置方法"></a> 样式设置方法</h1><h2 id="打开设置文件必做"><a class="markdownIt-Anchor" href="#打开设置文件必做"></a> 打开设置文件(必做)</h2><blockquote><p><strong>注意及时备份源文件!</strong></p></blockquote><ol><li><p>进入以下目录文件夹：<code>C:\Users\XXX\AppData\Roaming\Microsoft\Templates</code>。</p><p>如果 Microsoft Word 被安装在其他路径，请自行寻找。</p></li><li><p>打开其中的<code>Normal.dotm</code>文件。</p></li><li><p><strong>删除样式栏中所有已存在的样式。</strong></p></li></ol><h2 id="更改正文样式"><a class="markdownIt-Anchor" href="#更改正文样式"></a> 更改正文样式</h2><p>待添加…</p><h2 id="更改标题样式"><a class="markdownIt-Anchor" href="#更改标题样式"></a> 更改标题样式</h2><p>待添加…</p><h2 id="更改表格样式"><a class="markdownIt-Anchor" href="#更改表格样式"></a> 更改表格样式</h2><p>待添加…</p><h2 id="添加标题序号"><a class="markdownIt-Anchor" href="#添加标题序号"></a> 添加标题序号</h2><p>待添加…</p><h2 id="添加自定义题注"><a class="markdownIt-Anchor" href="#添加自定义题注"></a> 添加自定义题注</h2><p>待添加…</p><h1 id="其他-word-使用技巧"><a class="markdownIt-Anchor" href="#其他-word-使用技巧"></a> 其他 Word 使用技巧</h1><h2 id="页码设置"><a class="markdownIt-Anchor" href="#页码设置"></a> 页码设置</h2><p>待添加…</p><h2 id="去除标题前的小黑点"><a class="markdownIt-Anchor" href="#去除标题前的小黑点"></a> 去除标题前的小黑点</h2><p>我们以下图 <strong>标题3</strong> 前的小黑点为例：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220613184750085.png" alt="image" style="zoom: 80%;" /><ol><li><p>右击样式栏中对应的样式。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220613184856465.png" alt="image" style="zoom:67%;" /></li><li><p>依次选择：</p><p><strong>修改 &gt;&gt; 格式 &gt;&gt; 段落 &gt;&gt; 换行和分页</strong></p><p>进入下图中页面。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220613185044904.png" alt="image" style="zoom:67%;" /></li><li><p>将上图中的 <strong>与下段相同</strong> 和 <strong>段中不分页</strong> 前面的两个对号取消。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220613185210761.png" alt="image" style="zoom: 67%;" /></li><li><p>依次点击：</p><p><strong>确认 &gt;&gt; 确认</strong></p><p>返回文档编辑页面，即可发现 <strong>标题3</strong> 前面的小黑点已经消失了。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220613185459976.png" alt="image" style="zoom:80%;" /></li></ol><h1 id="如何将设置好的样式分享"><a class="markdownIt-Anchor" href="#如何将设置好的样式分享"></a> 如何将设置好的样式分享</h1><ol><li>发送该<code>Normal.dotm</code>文件到接收方。</li><li>在接收方的电脑上替换该文件。</li><li>重启 Microsoft Word，新建文档即可使用。</li></ol><h1 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h1><ol><li><p>已经创建的文档内的样式无法自动更改。</p><p>可以通过新建文档并复制原文档中的内容获取论文样式集。</p></li></ol>]]></content>
    
    
    <summary type="html">能够让自己以后每次打开 Word 都可以直接使用论文的样式集。</summary>
    
    
    
    <category term="Microsoft Applications" scheme="https://luoyu-ying.github.io/categories/Microsoft-Applications/"/>
    
    <category term="Windows OS" scheme="https://luoyu-ying.github.io/categories/Windows-OS/"/>
    
    
    <category term="Microsoft Office" scheme="https://luoyu-ying.github.io/tags/Microsoft-Office/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Butterfly 修改侧边栏分类排序规则</title>
    <link href="https://luoyu-ying.github.io/posts/bd6604dc1b1f/"/>
    <id>https://luoyu-ying.github.io/posts/bd6604dc1b1f/</id>
    <published>2022-06-08T12:51:35.000Z</published>
    <updated>2022-06-08T12:51:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1><p><code>Hexo Butterfly</code> 主题中，主页侧边栏中的 <code>categories</code> 默认显示顺序是按 <code>name</code> 排序，导致某些分类下虽然文章数量较少，但却排序靠前。并且默认设置下，主题中侧边 <code>categories</code> 只显示8条（如需修改可以修改<strong>主题配置文件</strong>）。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220608210201564.png" alt="image" style="zoom:67%;" /><p>便想将其修改为 <strong>按照分类内文章的数量进行降序排序</strong> 。</p><h1 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h1><blockquote><p>该方法需要修改源代码，建议及时备份需要修改的文件。</p></blockquote><ol><li><p>找到 <code>themes\butterfly\scripts\helpers\aside_categories.js</code> 文件，并修改源代码。</p></li><li><p>修改以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const orderby = options.orderby || &#x27;name&#x27; // 默认-&gt;name-&gt;按categories字母顺序</span></span><br><span class="line"><span class="keyword">const</span> orderby = options.<span class="property">orderby</span> || <span class="string">&#x27;length&#x27;</span>  <span class="comment">// length-&gt;按categories下文章数量排序</span></span><br><span class="line"><span class="comment">// const order = options.order || 1  // 默认-&gt;1-&gt;升序 -1-&gt;逆序</span></span><br><span class="line"><span class="keyword">const</span> order = options.<span class="property">order</span> || -<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>执行 <code>hexo g &amp;&amp; hexo d</code> 查看修改效果。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220608205749969.png" alt="image" style="zoom: 67%;" /></li></ol><h1 id="参考教程"><a class="markdownIt-Anchor" href="#参考教程"></a> 参考教程</h1><ul><li><a href="https://www.yanchengxu.top/hexo-categories-sort/">【Hexo-Butterfly】修改侧边栏分类排序规则 | yanchengxu</a></li></ul>]]></content>
    
    
    <summary type="html">记录了修改侧边栏分类模块的排序规则的方法。</summary>
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Butterfly 字体修改</title>
    <link href="https://luoyu-ying.github.io/posts/01f186841de9/"/>
    <id>https://luoyu-ying.github.io/posts/01f186841de9/</id>
    <published>2022-06-07T13:17:24.000Z</published>
    <updated>2022-06-07T13:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备字体"><a class="markdownIt-Anchor" href="#准备字体"></a> 准备字体</h1><blockquote><p>注意字体的版权！</p></blockquote><p>自行下载需要的字体。</p><p>本文使用的是 <code>Intellij IDEA</code> 文件中的 <code>JetBrainsMono-Regular.ttf</code>。</p><p>在 <code>themes/butterfly/source/</code> 下创建 <code>font</code> 文件夹，将下载好的字体放入 <code>font</code> 文件夹中。</p><p>其中，<code>Hexo Butterfly</code> 已默认支持 <strong><code>Microsoft YaHei</code></strong> ，无需另行下载。</p><h1 id="创建-css-文件"><a class="markdownIt-Anchor" href="#创建-css-文件"></a> 创建 <code>CSS</code> 文件</h1><p>在<code>themes/butterfly/source/css/</code>下创建<code>article-font.css</code> 并编辑该文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;JetBrainsMono&#x27;</span>;</span><br><span class="line">    <span class="attribute">font-display</span>: swap;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;../font/JetBrainsMono-Regular.ttf&#x27;</span>) <span class="built_in">format</span>(<span class="string">&quot;truetype&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将所有非代码部分的文字更改为自定义字体 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;JetBrainsMono&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 仅将博客正文中的非代码部分的文字更改为自定义字体 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#article-container &#123;</span></span><br><span class="line"><span class="comment">    font-family: &#x27;JetBrainsMono&#x27;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>第一段代码必须写入 <code>CSS</code> 文件中。</p><ul><li><strong><code>font-family</code> ：</strong> 其他文件引用该字体的名称，更改为自己所需的名称。</li><li><strong><code>src: url()</code> ：</strong> 更改为自己准备的字体的路径。</li></ul><p>第二段和第三段代码根据自己所需的改变范围自行选择其中一个。其中第二段代码改变的范围为所有页面的所有非代码部分的文字。</p><h1 id="引入-css-文件"><a class="markdownIt-Anchor" href="#引入-css-文件"></a> 引入 <code>CSS</code> 文件</h1><p>编辑 <code>_config.butterfly.yml</code>，引入 <code>article-font.css</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class="line"><span class="comment"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/article-font.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>修改完成后，重新 <code>generate</code> 便可修改非代码部分的文字的字体了。</p><h1 id="改变代码部分的文字字体可选"><a class="markdownIt-Anchor" href="#改变代码部分的文字字体可选"></a> 改变代码部分的文字字体（可选）</h1><p>若需修改代码部分的文字的字体，编辑 <code>_config.butterfly.yml</code>，找到以下代码并将 <code>font-family</code> 中定义的名称加入<code>code-font-family</code>，重新<code>generate</code>即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global font settings</span></span><br><span class="line"><span class="comment"># Don&#x27;t modify the following settings unless you know how they work (非必要不要修改)</span></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">global-font-size:</span></span><br><span class="line">  <span class="attr">code-font-size:</span></span><br><span class="line">  <span class="attr">font-family:</span></span><br><span class="line">  <span class="attr">code-font-family:</span> <span class="string">JetBrainsMono</span></span><br></pre></td></tr></table></figure><h1 id="参考博客"><a class="markdownIt-Anchor" href="#参考博客"></a> 参考博客</h1><ul><li><a href="https://www.yanchengxu.top/hexo-font-modification/">【Hexo-Butterfly】字体修改 | yanchengxu</a></li></ul>]]></content>
    
    
    <summary type="html">记录使用 Hexo Butterfly 时字体修改的过程。</summary>
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
