<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洛语 の Blog</title>
  
  
  <link href="https://luoyu-ying.github.io/atom.xml" rel="self"/>
  
  <link href="https://luoyu-ying.github.io/"/>
  <updated>2022-05-22T08:33:12.000Z</updated>
  <id>https://luoyu-ying.github.io/</id>
  
  <author>
    <name>LuoYu-Ying</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>通过 AutoHotKey 简化 Hexo 操作</title>
    <link href="https://luoyu-ying.github.io/posts/050a11a7817a/"/>
    <id>https://luoyu-ying.github.io/posts/050a11a7817a/</id>
    <published>2022-05-22T08:33:12.000Z</published>
    <updated>2022-05-22T08:33:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>功能持续更新中！</p></blockquote><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>通过 <code>AutoHotKey</code> 编写可视化界面以解决每一次部署博客都需要输入命令的情况。</p><p>使用的  <code>AutoHotKey</code> 版本：1.33</p><h1 id="效果"><a class="markdownIt-Anchor" href="#效果"></a> 效果</h1><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220522225631.png" style="zoom: 50%;" /><p><strong>功能介绍：</strong></p><ol><li><p><strong>Open Blog</strong></p><p>打开自己的博客。</p></li><li><p><strong>New Post</strong></p><p>新建博文，点击后会弹出如下窗口：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220522225716.png" style="zoom: 50%;" /><p>在输入窗口中可以输入文章的标题，确认后会创建文件并打开<code>_posts</code>文件夹。</p><p>提示等待的弹窗无需确认，5秒后会自行消失。等待时间可通过代码自行设置。</p></li><li><p><strong>Open Root Folder</strong></p><p>打开根目录文件夹。</p></li><li><p><strong>Open Post Folder</strong></p><p>打开已发布文章的文件夹。</p></li><li><p><strong>Open Draft Folder</strong></p><p>打开草稿文章文件夹。</p></li><li><p><strong>Clean &amp; Generate &amp; Server</strong></p><p>部署到本地。</p></li><li><p><strong>Clean &amp; Generate &amp; Deploy</strong></p><p>部署到服务器（适用于对文章做出结构性更改）。</p></li><li><p><strong>Generate &amp; Deploy</strong></p><p>部署到服务器（适用于仅对文章内容做出更改）。</p></li><li><p><strong>Deploy</strong></p><p>部署到服务器（适用于部署失败时重新部署）。</p></li></ol><h1 id="实现步骤"><a class="markdownIt-Anchor" href="#实现步骤"></a> 实现步骤</h1><h2 id="下载-autohotkey"><a class="markdownIt-Anchor" href="#下载-autohotkey"></a> 下载 <code>AutoHotKey</code></h2><p>到 <a href="https://www.autohotkey.com/"><code>AutoHotKey</code> 官网</a>自行下载。</p><h2 id="新建-ahk-文件并复制以下代码"><a class="markdownIt-Anchor" href="#新建-ahk-文件并复制以下代码"></a> 新建 <code>ahk</code> 文件并复制以下代码</h2><ol><li><p>桌面空白处鼠标右键 &gt;&gt; 新建 &gt;&gt; <code>AutoHotKey Script</code>。</p></li><li><p>对新建的<code>ahk</code>文件右键 &gt;&gt; <code>Edit Script</code>。</p></li><li><p>进入编辑界面后复制以下代码：</p></li></ol><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#SingleInstance, Force</span></span><br><span class="line"></span><br><span class="line">blogSite := <span class="string">&quot;https://XXX.github.io/&quot;</span> <span class="comment">; 更改为自己的博客网址</span></span><br><span class="line">rootFolderPath := <span class="string">&quot;D:\XXX\MyHexoBlog&quot;</span><span class="comment">; 更改为自己的博客根目录地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 控件添加</span></span><br><span class="line"><span class="built_in">Gui,</span> Add, Text , w200 h27 center section , `nHexo Blog Updater </span><br><span class="line"><span class="built_in">Gui,</span> Add, Text , w200 <span class="number">0</span>x10 <span class="comment">; 横向分割线</span></span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , <span class="keyword">New</span> Post</span><br><span class="line"><span class="built_in">Gui,</span> Add, Text , w200 <span class="number">0</span>x10 </span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Open Root Folder</span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Open Post Folder</span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Open Draft Folder</span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 ys , Open Blog</span><br><span class="line"><span class="built_in">Gui,</span> Add, Text , w200 <span class="number">0</span>x10</span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Clean &amp;&amp; Generate &amp;&amp; Server</span><br><span class="line"><span class="built_in">Gui,</span> Add, Text , w200 <span class="number">0</span>x10 </span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Clean &amp;&amp; Generate &amp;&amp; Deploy</span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Generate &amp;&amp; Deploy</span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Deploy</span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">Gui,</span> Show, Center , Hexo Blog Updater</span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 按钮事件监听</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 打开博客</span></span><br><span class="line"><span class="title">ButtonOpenBlog:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%blogSite%</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 清理、生成和本地部署</span></span><br><span class="line"><span class="title">ButtonCleanGenerateServer:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%comSpec%</span> /c hexo clean &amp;&amp; hexo g &amp;&amp; hexo s &amp;&amp; <span class="keyword">pause</span>, <span class="variable">%rootFolderPath%</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 清理、生成和服务器部署</span></span><br><span class="line"><span class="title">ButtonCleanGenerateDeploy:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%comSpec%</span> /c hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; <span class="keyword">pause</span>, <span class="variable">%rootFolderPath%</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 生成和服务器部署</span></span><br><span class="line"><span class="title">ButtonGenerateDeploy:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%comSpec%</span> /c hexo g &amp;&amp; hexo d &amp;&amp; <span class="keyword">pause</span>, <span class="variable">%rootFolderPath%</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 服务器部署</span></span><br><span class="line"><span class="title">ButtonDeploy:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%comSpec%</span> /c hexo d &amp;&amp; <span class="keyword">pause</span>, <span class="variable">%rootFolderPath%</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 打开根目录文件夹</span></span><br><span class="line"><span class="title">ButtonOpenRootFolder:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%rootFolderPath%</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 打开已发布文章文件夹</span></span><br><span class="line"><span class="title">ButtonOpenPostFolder:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%rootFolderPath%</span>\source\_posts</span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 打开草稿文章文件夹</span></span><br><span class="line"><span class="title">ButtonOpenDraftFolder:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%rootFolderPath%</span>\source\_drafts</span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 添加新文章</span></span><br><span class="line"><span class="title">ButtonNewPost:</span></span><br><span class="line"><span class="built_in">    InputBox,</span> FileName, NewPostTitle, Please enter the title of <span class="keyword">new</span> post., , , <span class="number">130</span></span><br><span class="line">    if <span class="built_in">ErrorLevel</span></span><br><span class="line">        <span class="keyword">Return</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%comSpec%</span> /c hexo <span class="keyword">new</span> post <span class="string">&quot;%FileName%&quot;</span>, <span class="variable">%rootFolderPath%</span>, Min</span><br><span class="line"><span class="built_in">    MsgBox,</span> , File Creating, File creating...`nPlease wait..., <span class="number">5</span> <span class="comment">; 最后一个数字为对话窗口的持续时间，可自行设置</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%rootFolderPath%</span>\source\_posts</span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 退出程序</span></span><br><span class="line"><span class="title">GuiEscape:</span></span><br><span class="line"><span class="title">GuiClose:</span></span><br><span class="line"><span class="keyword">ExitApp</span></span><br></pre></td></tr></table></figure><h2 id="修改上述部分代码"><a class="markdownIt-Anchor" href="#修改上述部分代码"></a> 修改上述部分代码</h2><ol><li>代码<strong>第3行</strong>处更换为自己的<strong>博客网址</strong>。</li><li>代码<strong>第4行</strong>处更换为自己的<strong>博客根目录地址</strong>。</li></ol><p>修改完成后，保存以上代码。</p><h1 id="使用方式"><a class="markdownIt-Anchor" href="#使用方式"></a> 使用方式</h1><ol><li><p>双击该文件即可使用。</p></li><li><p>也可以对该文件右键并选择 <code>Compile Script</code>，生成<code>exe</code>文件使用。</p></li></ol><h1 id="autohotkey-学习资料"><a class="markdownIt-Anchor" href="#autohotkey-学习资料"></a> <code>AutoHotKey</code> 学习资料</h1><ul><li><p><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/AutoHotkey.htm">快速参考 | AutoHotkey (autoahk.com)</a></p></li><li><p><a href="https://wyagd001.github.io/zh-cn/docs/AutoHotkey.htm">快速参考 | AutoHotkey (wyagd001.github.io)</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;功能持续更新中！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;通过 &lt;code&gt;AutoHotKey&lt;/code&gt; 编写</summary>
      
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/tags/AutoHotKey/"/>
    
  </entry>
  
  <entry>
    <title>Activity - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/4aa0626e110f/"/>
    <id>https://luoyu-ying.github.io/posts/4aa0626e110f/</id>
    <published>2022-05-21T08:40:02.000Z</published>
    <updated>2022-05-21T12:06:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="activity的启动流程"><a class="markdownIt-Anchor" href="#activity的启动流程"></a> <code>Activity</code>的启动流程</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/cpcpcp123/article/details/122055099">面试：Activity的启动流程简述_沙漠一只雕得儿得儿的博客-CSDN博客_activity启动流程面试</a></li><li><a href="https://www.jianshu.com/p/6c55c169ba54">Android 系统启动 - SystemServer 进程 - 简书 (jianshu.com)</a></li></ul></blockquote><p>大致为以下过程：</p><ol><li><code>Launcher</code> 通过 <code>startActivity</code> 方法调用 <code>AMS</code>。</li><li><code>AMS</code> 向 <code>Zygote</code> 进程发送创建应用进程的请求。</li><li><code>Zygote</code> 进程接受请求并在 <code>main</code> 方法中孵化应用进程。</li><li>应用进程通过<code>SystemServer#main</code>启动<code>ActivityThread</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SystemServer#main</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemServer</span>().run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// Ensure binder calls into the system always run at foreground priority.</span></span><br><span class="line">    <span class="comment">// 确保当前进程的 binder 调用总是运行在前台优先级</span></span><br><span class="line">    BinderInternal.disableBackgroundScheduling(<span class="literal">true</span>);</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// 创建主线程 Looper</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize native services.</span></span><br><span class="line">    <span class="comment">// 加载android_servers.so库，该库包含的源码在frameworks/base/services/目录下</span></span><br><span class="line">    System.loadLibrary(<span class="string">&quot;android_servers&quot;</span>);</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// Initialize the system context.</span></span><br><span class="line">    <span class="comment">// 初始化系统上下文</span></span><br><span class="line">    createSystemContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the system service manager.</span></span><br><span class="line">    <span class="comment">//创建系统服务管理</span></span><br><span class="line">    mSystemServiceManager = <span class="keyword">new</span> <span class="title class_">SystemServiceManager</span>(mSystemContext);</span><br><span class="line">    <span class="comment">// 将mSystemServiceManager添加到本地服务的成员sLocalServiceObjects</span></span><br><span class="line">    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start services.</span></span><br><span class="line">    <span class="comment">//  启动各种系统服务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startBootstrapServices(); <span class="comment">// 启动引导服务</span></span><br><span class="line">        startCoreServices();      <span class="comment">// 启动核心服务</span></span><br><span class="line">        startOtherServices();     <span class="comment">// 启动其他服务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// Loop forever.</span></span><br><span class="line">    <span class="comment">// 启动 Looper 循环</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="onsaveinstancestate和onrestoreinstancestate的调用时机"><a class="markdownIt-Anchor" href="#onsaveinstancestate和onrestoreinstancestate的调用时机"></a> <code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>的调用时机</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/cpcpcp123/article/details/113396301">Android onSaveInstanceState和onRestoreInstanceState调用时机、及大小限制_沙漠一只雕得儿得儿的博客-CSDN博客_onsaveinstancestate</a></li></ul></blockquote><p><strong><font size = "5">onSaveInstanceState(Bundle outState)</font></strong></p><p>当 Activity 在不正常销毁的情况下，就会调用 onSaveInstanceState 方法，并将 Activity 中需要保存的数据（比如 View 状态 或者我们自己的数据）保存到这个方法的参数 Bundle 中。</p><p><strong>onSaveInstanceState(Bundle outState)会在以下情况被调用</strong>：</p><ol><li>当用户按下HOME键时。</li><li>从最近应用中选择运行其他的程序时。</li><li>按下电源按键（关闭屏幕显示）时。</li><li>从当前activity启动一个新的activity时。</li><li>屏幕方向切换时(无论竖屏切横屏还是横屏切竖屏都会调用)。</li></ol><p><strong>Activity的onSaveInstanceState回调时机，取决于app的targetSdkVersion</strong>：</p><ul><li><p>targetSdkVersion低于11的app，onSaveInstanceState方法会在Activity.onPause之前回调；</p></li><li><p>targetSdkVersion低于28的app，则会在onStop之前回调；</p></li><li><p><strong>28之后，onSaveInstanceState在onStop回调之后才回调。</strong></p></li></ul><p><strong><font size = "5">onRestoreInstanceState(Bundle savedInstanceState)</font></strong></p><p>onRestoreInstanceState(Bundle savedInstanceState)只有在activity确实是被系统回收，重新创建activity的情况下才会被调用。</p><p><strong>onRestoreInstanceState(Bundle outState)会在以下情况被调用</strong>：</p><ol><li>屏幕方向切换时（无论竖屏切横屏还是横屏切竖屏都会调用）</li><li>由于内存紧张导致后台运行的程序被kill掉时（这种不太好模拟）</li></ol><p><strong>onRestoreInstanceState(Bundle outState)</strong> 的回调时机：</p><p>回调发生在<code>onStart</code>回调之后。</p><h1 id="oncreate和onrestoreinstance方法中恢复数据时的区别"><a class="markdownIt-Anchor" href="#oncreate和onrestoreinstance方法中恢复数据时的区别"></a> <code>onCreate</code>和<code>onRestoreInstance</code>方法中恢复数据时的区别</h1><p>因为<code>onSaveInstanceState</code> 不一定会被调用，所以<code>onCreate</code>里的<code>Bundle</code>参数可能为空，如果使用<code>onCreate</code>来恢复数据，一定要做非空判断。</p><p>而<code>onRestoreInstanceState</code>的<code>Bundle</code>参数一定不会是空值，因为它只有在上次<code>activity</code>被回收了才会调用。</p><h1 id="activity的数据是怎么保存的进程被kill后保存的数据怎么恢复的"><a class="markdownIt-Anchor" href="#activity的数据是怎么保存的进程被kill后保存的数据怎么恢复的"></a> <code>Activity</code>的数据是怎么保存的,进程被<code>Kill</code>后,保存的数据怎么恢复的？</h1><blockquote><p>答案参考自：</p><ul><li>《Android 开发艺术探索》</li></ul></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220521185305.png" style="zoom:67%;" /><p>通过<code>onSaveInstanceState</code>方法和<code>onRestoreInstanceState</code>方法进行数据的保存和恢复。</p><p>在 <code>onSaveInstanceState</code>和 <code>onRestoreInstanceState</code>方法中，系统自动为我们做了一定的恢复工作。当 <code>Activity</code> 在异常情况下需要重新创建时，系统会默认为我们保存当前<code>Activity</code> 的视图结构，并且在<code>Activity</code>重启后为我们恢复这些数据，比如文本框中用户输入的数据、<code>ListView</code>滚动的位置等。</p><h1 id="activity的启动模式和使用场景"><a class="markdownIt-Anchor" href="#activity的启动模式和使用场景"></a> <code>Activity</code>的启动模式和使用场景</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/sinat_14849739/article/details/78072401">Android中Activity的启动模式（LaunchMode）和使用场景_Shawpoo的博客-CSDN博客_launchmode</a></li></ul></blockquote><p>Activity的启动模式有四种：<strong><code>standard</code>、<code>singleTop</code>、<code>singleTask</code>和<code>singleInstance</code></strong>。</p><p><strong><font size="5">standard：标准模式</font></strong></p><p>这种启动模式为标准模式，也是默认模式。每当我们启动一个Activity，系统就会相应的创建一个实例，不管这个实例是否已经存在。这种模式，一个栈中可以有多个实例，每个实例也都有自己的任务栈。而且是谁启动了此Activity，那么这个Activity就运行在启动它的Activity所在的栈中。</p><p><strong>分析总结</strong></p><p><strong>标准模式下，只要启动一次Activity，系统就会在当前任务栈新建一个实例。</strong></p><p><strong>使用场景</strong></p><p>正常的去打开一个新的页面，这种启动模式使用最多，最普通 。</p><p><strong><font size="5">singleTop：栈顶复用模式</font></strong></p><p>这种启动模式下，如果要启动的Activity已经处于栈的顶部，那么此时系统不会创建新的实例，而是直接打开此页面，同时它的onNewIntent()方法会被执行，我们可以通过Intent进行传值，而且它的onCreate()，onStart()方法不会被调用，因为它并没有发生任何变化。</p><p><strong>分析总结</strong></p><ol><li>当前栈中已有该Activity的实例并且该实例位于栈顶时，不会创建实例，而是复用栈顶的实例，并且会将Intent对象传入，回调onNewIntent()方法；</li><li>当前栈中已有该Activity的实例但是该实例不在栈顶时，其行为和standard启动模式一样，依然会创建一个新的实例；</li><li>当前栈中不存在该Activity的实例时，其行为同standard启动模式。</li></ol><p><strong>使用场景</strong></p><p>这种模式应用场景的话，假如一个新闻客户端，在通知栏收到了3条推送，点击每一条推送会打开新闻的详情页，如果为默认的启动模式的话，点击一次打开一个页面，会打开三个详情页，这肯定是不合理的。如果启动模式设置为singleTop，当点击第一条推送后，新闻详情页已经处于栈顶，当我们第二条和第三条推送的时候，只需要通过Intent传入相应的内容即可，并不会重新打开新的页面，这样就可以避免重复打开页面了。</p><p><strong><font size="5">singleTask：栈内复用模式</font></strong></p><p>在这个模式下，如果栈中存在这个Activity的实例就会复用这个Activity，不管它是否位于栈顶，复用时，会将它上面的Activity全部出栈，因为singleTask本身自带clearTop这种功能。并且会回调该实例的onNewIntent()方法。其实这个过程还存在一个任务栈的匹配，因为这个模式启动时，会在自己需要的任务栈中寻找实例，这个任务栈就是通过taskAffinity属性指定。如果这个任务栈不存在，则会创建这个任务栈。不设置taskAffinity属性的话，默认为应用的包名。</p><p><strong>分析总结</strong></p><p>在复用的时候，首先会根据taskAffinity去找对应的任务栈：</p><ol><li>如果不存在指定的任务栈，系统会新建对应的任务栈，并新建Activity实例压入栈中。</li><li>如果存在指定的任务栈，则会查找该任务栈中是否存在该Activity实例<ol><li>如果不存在该实例，则会在该任务栈中新建Activity实例。</li><li>如果存在该实例，则会直接引用，并且回调该实例的onNewIntent()方法。并且任务栈中该实例之上的Activity会被全部销毁。</li></ol></li></ol><p><strong>使用场景</strong></p><p>SingleTask这种启动模式最常使用的就是一个APP的首页，因为一般为一个APP的第一个页面，且长时间保留在栈中，所以最适合设置singleTask启动模式来复用。</p><p><strong><font size="5">singleInstance：单实例模式</font></strong></p><p>单实例模式，顾名思义，只有一个实例。该模式具备singleTask模式的所有特性外，与它的区别就是，这种模式下的<strong>Activity会单独占用一个Task栈，具有全局唯一性</strong>，即整个系统中就这么一个实例，由于栈内复用的特性，后续的请求均不会创建新的Activity实例，除非这个特殊的任务栈被销毁了。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。</p><p><strong>分析总结</strong></p><p>启动该模式Activity的时候，会查找系统中是否存在：</p><ol><li>不存在，首先会新建一个任务栈，其次创建该Activity实例。</li><li>存在，则会直接引用该实例，并且回调onNewIntent()方法。</li><li>特殊情况：该任务栈或该实例被销毁，系统会重新创建。</li></ol><p><strong>使用场景</strong></p><p>很常见的是，电话拨号盘页面，通过自己的应用或者其他应用打开拨打电话页面 ，只要系统的栈中存在该实例，那么就会直接调用。</p><p><strong><font size="5">总结</font></strong></p><p>在使用APP过程中，不可避免页面之间的跳转，那么就会涉及到启动模式。其实在对界面进行跳转时，Android系统既能在同一个任务中对Activity进行调度，也能以Task（任务栈）为单位进行整体调度。在启动模式为standard或singleTop时，一般是在同一个任务中对Activity进行调度，而在启动模式为singleTask或singleInstance是，一般会对Task进行整体调度。</p><h1 id="activity的onnewintent方法什么时候会执行"><a class="markdownIt-Anchor" href="#activity的onnewintent方法什么时候会执行"></a> <code>Activity</code>的<code>onNewIntent</code>方法什么时候会执行</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/8897068505d8">Android中的onNewIntent()函数 - 简书 (jianshu.com)</a></li></ul></blockquote><p><strong>使用<code>SingleTask</code>以及<code>SingleInstance</code>启动模式的时候，会调用<code>onNewInstance</code>方法。</strong></p><p><code>Activity</code>第一次启动的时候执行<code>onCreate</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>等后续生命周期函数，也就时说第一次启动Activity并不会执行到<code>onNewIntent</code>。</p><p>而后面如果再有想启动<code>Activity</code>的时候，那就是执行**<code>onNewIntent</code> -&gt; <code>onResart</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>**。</p><p>如果Android系统由于内存不足把已存在<code>Activity</code>释放掉了，那么再次调用的时候会重新启动<code>Activity</code>即执行<code>onCreate</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>等。</p><p>当调用到<code>onNewIntent(intent)</code>的时候，需要在<code>onNewIntent</code>中使用<code>setIntent(intent)</code>赋值给<code>Activity</code>的<code>Intent</code>。否则，后续的<code>getIntent</code>都是得到旧的<code>Intent</code>。</p><h1 id="activity-生命周期"><a class="markdownIt-Anchor" href="#activity-生命周期"></a> <code>Activity</code> 生命周期</h1><blockquote><p>答案参考自：</p><ul><li><p>《Android 开发艺术探索》</p></li><li><p><a href="https://blog.csdn.net/xiajun2356033/article/details/78741121">activity生命周期（这篇足够了）_android_Mr_夏的博客-CSDN博客</a></p></li></ul></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220521182943.png" alt="Activity的生命周期" style="zoom:67%;" /><ol><li><p><code>onCreate</code></p><p>表示 Activity 正在被创建，这是生命周期的第一个方法。在这个方法中,我们可以做一些<strong>初始化工作</strong>,比如调用<strong>setContentView</strong>去加载界面布局资源,初始化Activity所需数据等。</p></li><li><p><code>onStart</code></p><p>表示Activity正在被启动，即将开始，这时 Activity已经<strong>可见</strong>了，但是还<strong>没有出现在前台</strong>，还<strong>无法和用户交互</strong>。这个时候其实可以理解为Activity已经显示出来了，但是我们还<strong>看不到</strong>。</p></li><li><p><code>onResume</code></p><p>表示 Activity<strong>已经可见</strong>了，并且<strong>出现在前台并开始活动</strong>。</p><p>要注意这个和 onStart的对比, onStart和onResume都表示Activity已经可见,但是onStart的时候Activity还在后台，onResume的时候Activity才显示到前台。</p></li><li><p><code>onPause</code></p><p>表示Activity正在停止，正常情况下，紧接着onStop就会被调用。</p><p>在特殊情况下，如果这个时候快速地再回到当前Activity，那么onResume会被调用。笔者的理解是，这种情况属于极端情况，用户操作很难重现这一场景。</p><p><strong>当前Activity是可见的，但不能与用户交互状态（即不在前台）。</strong></p><p>此时可以做一些<strong>存储数据、停止动画</strong>等工作，但是注意<strong>不能太耗时</strong>，因为这会影响到新Activity的显示，<strong>onPause必须先执行完，新Activity 的onResume才会执行。</strong></p></li><li><p><code>onStop</code></p><p>表示Activity即将停止，此时Activity对用户是<strong>不可见</strong>的，可以做一些稍微重量级的回收工作，同样<strong>不能太耗时</strong>。</p><p>在系统内存紧张的情况下，有可能会被系统进行回收，所以一般在当前方法可做资源回收。</p></li><li><p><code>onDestroy</code></p><p>表示Activity即将被销毁，这是Activity生命周期中的最后一个回调,在这里我们可以做一些<strong>回收工作和最终的资源释放</strong>。</p></li><li><p><code>onRestart</code></p><p>表示Activity正在重新启动。一般情况下，当当前Activity 从<strong>不可见重新变为可见状态</strong>时，onRestart就会被调用。</p><p>这种情形一般是用户行为所导致的，比如用户按Home键切换到桌面或者用户打开了一个新的Activity，这时当前的Activity就会暂停，也就是onPause和 onStop被执行了，接着用户又回到了这个Activity，就会出现这种情况。</p></li></ol><p><strong>具体情况分析</strong>：</p><ol><li><p>针对一个特定的Activity,<strong>第一次启动</strong>,回调如下：<code>onCreate</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>。</p></li><li><p>当用户<strong>打开新的Activity</strong>或者<strong>切换到桌面</strong>的时候，回调如下： <code>onPause</code> -&gt; <code>onStop</code>。</p><p>这里有一种特殊情况,如果新Activity 采用了透明主题,那么当前Activity不会回调<code>onStop</code>。</p></li><li><p>当用户<strong>再次回到原Activity</strong> 时，回调如下： <code>onRestart</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>。</p></li><li><p>当用户<strong>按back键回退</strong>时，回调如下: <code>onPause</code> -&gt; <code>onStop</code> -&gt; <code>onDestroy</code>。</p></li><li><p>当<strong>Activity被系统回收后再次打开</strong>，生命周期方法回调过程和（1）一样，注意只是生命周期方法一样，不代表所有过程都一样，比如<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>的调用。</p></li><li><p>从<strong>Activity_A跳转到Activity_B</strong>，会先执行A活动的<code>onPause</code>，再执行B活动的<code>onResume</code>。</p></li><li><p>从<strong>整个生命周期</strong>来说，<code>onCreate</code>和 <code>onDestroy</code>是配对的，分别标识着Activity 的创建和销毁，并且只可能有一次调用。</p></li><li><p>从<strong>Activity是否可见</strong>来说，<code>onStart</code>和 <code>onStop</code>是配对的，随着用户的操作或者设备屏幕的点亮和熄灭，这两个方法可能被调用多次。</p></li><li><p>从 <strong>Activity是否在前台</strong>来说，<code>onResume</code>和 <code>onPause</code>是配对的,随着用户操作或者设备屏幕的点亮和熄灭，这两个方法可能被调用多次。</p></li></ol><table><thead><tr><th>生命周期</th><th>是否可见</th><th>是否在前台</th></tr></thead><tbody><tr><td><code>onStart</code></td><td>是</td><td>否</td></tr><tr><td><code>onResume</code></td><td>是</td><td>是</td></tr><tr><td><code>onPause</code></td><td>是</td><td>否</td></tr><tr><td><code>onStop</code></td><td>否</td><td>否</td></tr></tbody></table><h1 id="onstart-和-onresume-onpause-和-onstop-的区别"><a class="markdownIt-Anchor" href="#onstart-和-onresume-onpause-和-onstop-的区别"></a> <code>onStart</code> 和 <code>onResume</code>、<code>onPause</code> 和 <code>onStop</code> 的区别</h1><blockquote><p>答案参考自：</p><ul><li>《Android 开发艺术探索》</li></ul></blockquote><p>从实际使用过程来说，<code>onStart</code>和 <code>onResume</code>、<code>onPause</code>和 <code>onStop</code>看起来的确差不多，甚至我们可以只保留其中一对，比如只保留<code>onStart</code>和 <code>onStop</code>。既然如此,那为什么Android系统还要提供看起来重复的接口呢？</p><p>根据上面的分析，我们知道，这两个配对的回调分别表示不同的意义，<code>onStart</code>和 <code>onStop</code>是从<strong>Activity是否可见</strong>这个角度来回调的，而 <code>onResume</code>和 <code>onPause</code>是从<strong>Activity是否位于前台</strong>这个角度来回调的，除了这种区别，在实际使用中没有其他明显区别。</p><h1 id="activity的显式启动和隐式启动"><a class="markdownIt-Anchor" href="#activity的显式启动和隐式启动"></a> <code>Activity</code>的显式启动和隐式启动</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/lrq851215/article/details/62881056">显示和隐式启动Activity的方式_卩s秋灬的博客-CSDN博客</a></li></ul></blockquote><p>启动Activity主要是通过Intent（意图）来实现。主要分为显示的和隐式的两种。</p><p><strong><font size="4">隐式启动 <code>Activity</code></font></strong></p><p>优点：</p><ol><li>只要知道被启动<code>Activity</code>的<code>Action</code>和<code>Category</code>即可，不用知道对应的类名或者是包名。</li><li>只要<code>Activity</code>有对应的<code>Action</code>和<code>Category</code>都会被启动起来。然后提供给用户选择要启动哪一个。</li></ol><p>需要被启动的<code>Activity</code>，需要在自己的<code>AndroidManifest.xml</code>定义对应的<code>action</code> 和 <code>category</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;com.android.activity.demo.SecondActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;@string/second_activity_name&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.SECONDACTIVITY_START&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动<code>Activity</code>的地方，把对应的<code>Action</code>填入即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startSecondActivityByAction</span><span class="params">()</span> &#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;startSecondActivityByAction()&quot;</span>);</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">    intent.setAction(<span class="string">&quot;android.intent.action.SECONDACTIVITY_START&quot;</span>);</span><br><span class="line">    intent.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;start activity error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font size="4">显示启动 <code>Activity</code></font></strong></p><p>不足：</p><ol><li>被启动的应用的包名或者类名发生变化后，就会无法启动。、</li></ol><p>通过类名类启动Activity， 一般是同一个APK里面使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startSecondActivityByClass</span><span class="params">()</span> &#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;startSecondActivityByClass()&quot;</span>);</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(FirstActivity.<span class="built_in">this</span>, SecondActivity.class);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;start activity error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="activty间传递数据的方式"><a class="markdownIt-Anchor" href="#activty间传递数据的方式"></a> Activty间传递数据的方式</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/u010112268/article/details/83832021">关于Android Activity之间传递数据的6种方式_淼淼1111的博客-CSDN博客_activity传递数据</a></li></ul></blockquote><p>共六种传递数据的方式。</p><ol><li><p><strong>使用Intent的putExtra传递</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建意图对象</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>,TwoActivity.class);</span><br><span class="line"><span class="comment">//设置传递键值对</span></span><br><span class="line">intent.putExtra(<span class="string">&quot;data&quot;</span>,str);</span><br><span class="line"><span class="comment">//激活意图</span></span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>第二个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取意图对象</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line"><span class="comment">//获取传递的值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;data&quot;</span>);</span><br><span class="line"><span class="comment">//设置值</span></span><br><span class="line">tv.setText(str);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用Intention的Bundle传递</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建意图对象</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>,TwoActivity.class);</span><br><span class="line"><span class="comment">//用数据捆传递数据</span></span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">bundle.putString(<span class="string">&quot;data&quot;</span>, str);</span><br><span class="line"><span class="comment">//把数据捆设置改意图</span></span><br><span class="line">intent.putExtra(<span class="string">&quot;bun&quot;</span>, bundle);</span><br><span class="line"><span class="comment">//激活意图</span></span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>第二个Activity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Bundle</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> intent.getBundleExtra(<span class="string">&quot;bun&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">tv.setText(str);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用Activity销毁时传递数据(startActivityForResult)</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>,TwoActivity.class);</span><br><span class="line"><span class="comment">//用一种特殊方式开启Activity</span></span><br><span class="line">startActivityForResult(intent, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置数据</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, Intent data)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> data.getStringExtra(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">    tvOne.setText(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置返回的数据</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.putExtra(<span class="string">&quot;data&quot;</span>, edtOne.getText().toString().trim());</span><br><span class="line">setResult(<span class="number">3</span>, intent);</span><br><span class="line"><span class="comment">//关闭当前activity</span></span><br><span class="line">finish();</span><br></pre></td></tr></table></figure></li><li><p><strong>SharedPreferences传递数据</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SharedPreferences</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="built_in">this</span>.getSharedPreferences(<span class="string">&quot;info&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//获取sp编辑器</span></span><br><span class="line"><span class="type">Editor</span> <span class="variable">edit</span> <span class="operator">=</span> sp.edit();</span><br><span class="line">edit.putString(<span class="string">&quot;data&quot;</span>, str);</span><br><span class="line">edit.commit();</span><br><span class="line"><span class="comment">//创建意图对象</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>,TwoActivity.class);</span><br><span class="line"><span class="comment">//激活意图</span></span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>第二个activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SharedPreferences</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="built_in">this</span>.getSharedPreferences(<span class="string">&quot;info&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//设置数据</span></span><br><span class="line">tv.setText(sp.getString(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>使用序列化对象Seriazable</strong></p><p>工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataBean</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建意图</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>,TwoActivity.class);</span><br><span class="line"><span class="type">DataBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataBean</span>();</span><br><span class="line"><span class="comment">//通过set方法把数据保存到DataBean对象中</span></span><br><span class="line">bean.setName(<span class="string">&quot;啦啦&quot;</span>);</span><br><span class="line">bean.setSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;key&quot;</span>, bean);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>第二个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line"><span class="comment">//反序列化数据对象</span></span><br><span class="line"><span class="type">Serializable</span> <span class="variable">se</span> <span class="operator">=</span> intent.getSerializableExtra(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(se <span class="keyword">instanceof</span> DataBean)&#123;</span><br><span class="line">    <span class="comment">//获取到携带数据的DataBean对象db</span></span><br><span class="line">    <span class="type">DataBean</span> <span class="variable">db</span> <span class="operator">=</span> (DataBean) se;</span><br><span class="line">    tv.setText(db.getName() + <span class="string">&quot;===&quot;</span> + db.getSex());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用静态变量传递数据</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>,TwoActivity.class);</span><br><span class="line">TwoActivity.name = <span class="string">&quot;NAME&quot;</span>;</span><br><span class="line">TwoActivity.str = <span class="string">&quot;STR&quot;</span>;</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>第二个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态变量</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> String name;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> String str;</span><br><span class="line">tv.setText(str + name);</span><br></pre></td></tr></table></figure></li></ol><h1 id="有哪些activity常用的标记位flags"><a class="markdownIt-Anchor" href="#有哪些activity常用的标记位flags"></a> 有哪些<code>Activity</code>常用的标记位<code>Flags</code></h1><ol><li><p>FLAG_ACTIVITY_NEW_TASK、</p><p>指定启动模式为SingleTask</p></li><li><p>FLAG_ACTIVITY_SINGLE_TOP</p><p>指定启动模式为SingleTop</p></li><li><p>FLAG_ACTIVITY_CLEAR_TOP</p><p>一般与SingleTask启动模式一起出现，启动时位于它上方的Activity出栈，如果被启动的Activity实例已存在，系统则会调用它的onNewIntent；</p></li></ol><h1 id="activity任务栈是什么"><a class="markdownIt-Anchor" href="#activity任务栈是什么"></a> <code>Activity</code>任务栈是什么</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/Lwenlong/p/15939583.html">Android面试——Activity篇 - 向着内核前进！ - 博客园 (cnblogs.com)</a></li></ul></blockquote><p>即Task，栈结构，存放Activity；退出应用程序时只有将所有任务栈找那个的所有Activity出栈，任务栈才能销毁。</p><p>任务栈可以移动到后台，在其中保留每一个Activity的状态。</p><p>对应的类：ActivityRecord、TaskRecord、ActivityStack。</p><h1 id="跨app启动activity的方式注意事项"><a class="markdownIt-Anchor" href="#跨app启动activity的方式注意事项"></a> 跨<code>App</code>启动<code>Activity</code>的方式,注意事项</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/Lwenlong/p/15939583.html">Android面试——Activity篇 - 向着内核前进！ - 博客园 (cnblogs.com)</a></li><li>《Android 开发艺术探索》</li></ul></blockquote><ol><li><p>指定打开的应用</p><p>通过Intent 隐式启动时，如果有多个action值相同的Activity，系统会让你选择启动哪个，解决办法时通过指定Intent-filter的 <code>data</code>属性，Intent 则要加上一个URI，该URI的scheme必须与data的scheme相同。</p><blockquote><p>data由两部分组成，mimeType和 URI。mimeType指媒体类型，比如 image/ijpeg.audio/mpeg4-generic和 video/*等，可以表示图片、文本、视频等不同的媒体格式，而URI中包含的数据就比较多了，下面是URI的结构：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]</span><br></pre></td></tr></table></figure><p>Scheme：URI的模式，比如 http、file、content等，如果URI中没有指定scheme，那么整个URI的其他参数无效，这也意味着URI是无效的。</p></blockquote></li><li><p>如何防止自己的Activity被外部非正常启动</p><p>给自己的Activity 添加<code>android:permission=”xxx.xxx.xx”</code>，那么想要访问你的Activity就必须声明<code>uses-permission xxx.xxx.xx</code></p></li></ol><h1 id="anr-的四种场景"><a class="markdownIt-Anchor" href="#anr-的四种场景"></a> <code>ANR</code> 的四种场景</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/xingyu19911016/article/details/122080235">ANR 的四种场景_橙子19911016的博客-CSDN博客_anr的四种场景</a></li></ul></blockquote><ol><li><p><code>Service TimeOut</code></p><p><code>Service</code>未在规定时间执行完成，前台服务20s，后台200s。</p></li><li><p><code>BroadCastQueue TimeOut</code></p><p>未在规定时间内未处理完广播，前台广播10s内，后台60s内。</p></li><li><p><code>ContentProvider TimeOut</code></p><p><code>publish</code>在10s内没有完成。</p></li><li><p><code>Input Dispatching timeout</code></p><p>5s内未响应键盘输入、触摸屏幕等事件。</p></li></ol><p>Activity的生命周期回调的阻塞并不在触发ANR的场景里面，所以并不会直接触发ANR。 只不过死循环阻塞了主线程，如果系统再有上述的四种事件发生，就无法在相应的时间内处理从而触发ANR。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;activity的启动流程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#activity的启动流程&quot;&gt;&lt;/a&gt; &lt;code&gt;Activity&lt;/code&gt;的启动流程&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;答案参考自：&lt;/p&gt;
&lt;u</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="Activity" scheme="https://luoyu-ying.github.io/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 提交出现 FATAL err Error Spawn failed</title>
    <link href="https://luoyu-ying.github.io/posts/b6ee2f2e134b/"/>
    <id>https://luoyu-ying.github.io/posts/b6ee2f2e134b/</id>
    <published>2022-05-20T09:22:43.000Z</published>
    <updated>2022-05-20T09:22:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h1><p>当我们使用 <code>Hexo</code> 博客，在提交的时候可能会出现以下的错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FATAL &#123;</span><br><span class="line">    err: Error: Spawn failed</span><br><span class="line">        at ChildProcess.&lt;anonymous&gt; (node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">        at ChildProcess.emit (node:events:390:28)</span><br><span class="line">        at ChildProcess.cp.emit (node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">        at Process.ChildProcess._handle.onexit (node:internal/child_process:290:12) &#123;</span><br><span class="line">         code: 128</span><br><span class="line">     &#125;</span><br><span class="line">&#125; Something&#x27;s wrong. Maybe you can find the solution here: ...</span><br></pre></td></tr></table></figure><h1 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h1><p>打开博客根目录下的  <strong><code>_config.yml</code></strong> 文件，并找到以下段落：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/...</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>将原来 <code>repo</code> 处 <code>HTTPS</code> 格式的仓库地址（<code>https://github.com/...</code>）换成 <code>SSH</code> 格式的仓库地址（<code>git@github.com:...</code>）后，重新推送即可解决。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在博客根目录下，通过 cmd 或 git 输入该命令重新推送。 </span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题描述&quot;&gt;&lt;/a&gt; 问题描述&lt;/h1&gt;
&lt;p&gt;当我们使用 &lt;code&gt;Hexo&lt;/code&gt; 博客，在提交的时候可能会出现以下的错误：&lt;/p&gt;
&lt;figure class=&quot;hi</summary>
      
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>序列化 - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/1718d96306cd/"/>
    <id>https://luoyu-ying.github.io/posts/1718d96306cd/</id>
    <published>2022-05-20T08:44:02.000Z</published>
    <updated>2022-05-20T08:45:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/douzi520/p/9497889.html">Java中序列化的好处及意义 - 久孤丶 - 博客园 (cnblogs.com)</a></li><li><a href="https://www.jianshu.com/p/2ed41bb7aa3a">Serializable和Parcelable区别 - 简书 (jianshu.com)</a></li></ul></blockquote><h1 id="什么是序列化"><a class="markdownIt-Anchor" href="#什么是序列化"></a> 什么是序列化？</h1><p><strong>序列化：</strong> 把对象转化为可传输的字节序列过程称为序列化。</p><p><strong>反序列化：</strong> 把字节序列还原为对象的过程称为反序列化。</p><h1 id="为什么需要使用序列化和反序列化"><a class="markdownIt-Anchor" href="#为什么需要使用序列化和反序列化"></a> 为什么需要使用序列化和反序列化？</h1><p>目的是为了对象可以<strong>跨平台存储，和进行网络传输</strong>。</p><h1 id="序列化的有哪些好处"><a class="markdownIt-Anchor" href="#序列化的有哪些好处"></a> 序列化的有哪些好处</h1><p>对对象进行序列化操作，可以极大程度的方便传输。</p><h1 id="什么情况下需要序列化"><a class="markdownIt-Anchor" href="#什么情况下需要序列化"></a> 什么情况下需要序列化</h1><ol><li>当你想把的内存中的对象保存到一个文件中或者数据库中时候。</li><li>当你想用序列化在网络上传送对象的时候。</li></ol><h1 id="什么是serialversionuid"><a class="markdownIt-Anchor" href="#什么是serialversionuid"></a> 什么是<code>serialVersionUID</code></h1><p><code>serialVersionUID</code>是用来辅助序列化和反序列化的过程。原则上序列化后的数据中的<code>serialVersionUID</code>只有和当前类的<code>serialVersionUID</code>一致才能成功的反序列化。</p><h1 id="为什么还要显示指定serialversionuid的值"><a class="markdownIt-Anchor" href="#为什么还要显示指定serialversionuid的值"></a> 为什么还要显示指定<code>serialVersionUID</code>的值?</h1><p><code>serialVersionUID</code>的详细工作机制是这样的：</p><p>序列化的时候系统会把当前类的<code>serialVersionUID</code>写入序列化的文件中(也可能是其他中介)。当反序列化的时候系统会去检测文件中的<code>serialVersionUID</code>，看它是否和当前类的<code>serialVersionUID</code>一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则就说明当前类和序列化的类相比发生了某些变换，比如成员变量的数量、类型可能会发生变化，这时候就无法正常的反序列化。</p><p>以一般来说，我们应该手动去指定<code>serialVersionUID</code>的值，比如&quot;1L&quot;,也可以让IDE根据当前类的结构去生成对应的<code>hash</code>值，这样序列化和反序列化时两者的<code>serialVersionUID</code>是相同的，因此可以正常的进行反序列化。如果不不设置<code>serialVersionUID</code>，系统在序列化的时候默认会根据类的结构在生成对应的<code>serialVersionUID</code>，在反序列化的时候，如果当类有变化，比如增加或者减少字段，这时候当前的类的<code>serialVersionUID</code>和序列化的时候的<code>serialVersionUID</code>就不一样了，就会出现反序列化失败，如果没有捕获异常会导致<code>crash</code>。</p><p><strong>所以当我们手动制订了它之后，就可以很大程度上避免了反序列化过程的失败。</strong></p><p>比如当版本升级以后，我们可能删除了某个成员变量也可能增加一些新的成员变量，这个时候我们的反序列化过程仍然可以成功，程序仍然能够最大限度地恢复数据。相反 如果我们没有指定<code>serialVersionUID</code>的话，程序就会挂掉。</p><p>当然我们也要考虑到另外一种情况，如果类结构发生了非常规性的改变，比如修改了类名，修改了成员变量的类型，这个时候尽管<code>serialVersionUID</code>验证通过了，但是反序列化过程还是会失败，因为类的而结构有了重大改变，根本无法从老版本的数据还原出一个新的类结构对象。</p><p><strong>注意</strong></p><ol><li><p>静态成员变量属于类，不属于对象，所以不会参与序列化的过程</p></li><li><p>用transient关键字编辑的成员变量不参与序列化的过程。</p></li><li><p>可以通过重写<code>writeObject</code>和<code>readObject</code>两个方法来重写系统默认的序列化和反序列化的过程。不过并不推荐。</p></li></ol><h1 id="serializable-和-parcelable-的区别"><a class="markdownIt-Anchor" href="#serializable-和-parcelable-的区别"></a> <code>Serializable</code> 和 <code>Parcelable</code> 的区别</h1><p><strong>1、平台区别</strong></p><ul><li><code>Serializable</code>是属于 <code>Java</code> 自带的，表示一个对象可以转换成可存储或者可传输的状态，序列化后的对象可以在网络上进行传输，也可以存储到本地。</li><li><code>Parcelable</code> 是属于 <code>Android</code> 专用。不过不同于<code>Serializable</code>，<code>Parcelable</code>实现的原理是将一个完整的对象进行分解。而分解后的每一部分都是Intent所支持的数据类型。</li></ul><p><strong>2、编写上的区别</strong></p><ul><li><code>Serializable</code>代码量少，写起来方便</li><li><code>Parcelable</code>代码多一些，略复杂</li></ul><p><strong>3、选择的原则</strong></p><ul><li>如果是仅仅在内存中使用，比如<code>activity</code>、<code>service</code>之间进行对象的传递，强烈推荐使用<code>Parcelable</code>，因为<code>Parcelable</code>比<code>Serializable</code>性能高很多。因为<code>Serializable</code>在序列化的时候会产生大量的临时变量， 从而引起频繁的<code>GC</code>。</li><li>如果是持久化操作，推荐<code>Serializable</code>，虽然<code>Serializable</code>效率比较低，但是还是要选择它，因为在外界有变化的情况下，<code>Parcelable</code>不能很好的保存数据的持续性。</li></ul><p><strong>4、本质的区别</strong></p><ul><li><code>Serializable</code>的本质是使用了反射，序列化的过程比较慢，这种机制在序列化的时候会创建很多临时的对象，比引起频繁的GC、</li><li><code>Parcelable</code>方式的本质是将一个完整的对象进行分解，而分解后的每一部分都是<code>Intent</code>所支持的类型，这样就实现了传递对象的功能了。</li></ul><h1 id="java-transient-解析"><a class="markdownIt-Anchor" href="#java-transient-解析"></a> Java <code>transient</code> 解析</h1><ol><li><code>transient</code> 关键字<strong>只能修饰变量，而不能修饰方法和类</strong>。注意，本地变量是不能被 <code>transient</code> 关键字修饰的。变量如果是用户自定义的类变量，则该类是要实现 <code>Serializable</code> 接口。</li><li>一旦变量被 <code>transient</code> 修饰，变量将不是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li><li>静态变量不管是否被 <code>transient</code> 修饰，都无法被序列化。</li></ol><p><strong>注意： 被 <code>transient</code> 修饰的变量也是可以被序列化的。</strong></p><p>Java 中，对象的序列化可以通过实现两个接口实现：</p><ul><li>若实现的是 <code>Serializable</code> 接口，则所有的序列化都将会自动进行，被 <code>transient</code> 修饰的变量将不会被序列化。</li><li>若实现的是 <code>Externalizable</code> 接口，则任何东西都需要自己在 <code>writeExternal</code> 方法中自己手动指定需要序列化的变量。任何变量都可以序列化，与变量是否被 <code>transient</code> 修饰无关。</li></ul><h1 id="其他注意事项"><a class="markdownIt-Anchor" href="#其他注意事项"></a> 其他注意事项</h1><ol><li>当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</li><li>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</li><li>并非所有的对象都可以序列化，,至于为什么不可以，有很多原因了。比如：<ol><li>安全方面的原因，比如一个对象拥有<code>private</code>，<code>public</code>等<code>field</code>，对于一个要传输的对象，比如写到文件，或者进行<code>RMI</code>传输 等等，在序列化进行传输的过程中，这个对象的<code>private</code>等域是不受保护的。</li><li>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;答案参考自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/douzi520/p/9497889.html&quot;&gt;Java中序列化的好处及意义 - 久孤丶 - 博客园 (cnblogs.com)&lt;/a&gt;&lt;/</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="序列化" scheme="https://luoyu-ying.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/ca56681199c8/"/>
    <id>https://luoyu-ying.github.io/posts/ca56681199c8/</id>
    <published>2022-05-20T07:21:02.000Z</published>
    <updated>2022-05-20T14:47:58.004Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://blog.csdn.net/qq_51596354/article/details/122398978">Java ArrayList底层原理详情笔记和相关面试题_抹泪的知更鸟的博客-CSDN博客</a></li></ul></blockquote><h1 id="arraylist是如何扩容的"><a class="markdownIt-Anchor" href="#arraylist是如何扩容的"></a> <code>ArrayList</code>是如何扩容的？</h1><p>初始容量为10，第一扩容就为10。</p><p>以后每次的扩容都是原容量的1.5倍。</p><h1 id="arraylist继承关系"><a class="markdownIt-Anchor" href="#arraylist继承关系"></a> <code>ArrayList</code>继承关系</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><h2 id="实现serializable标记型接口"><a class="markdownIt-Anchor" href="#实现serializable标记型接口"></a> 实现<code>Serializable</code>标记型接口</h2><p>序列化：将对象转化为字节数组的过程</p><p>反序列化：将字节数组转化为对象的过程</p><h2 id="实现cloneable标记型接口"><a class="markdownIt-Anchor" href="#实现cloneable标记型接口"></a> 实现<code>Cloneable</code>标记型接口</h2><p>克隆：将<code>ArrayList</code>集合的数组clone到另一个集合</p><p>实际底层调用的是Object中的<code>clone</code>方法，而<code>clone</code>是一个<code>native</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.clone();</span><br><span class="line">System.out.println(o == list);<span class="comment">//地址不一样，深度克隆</span></span><br></pre></td></tr></table></figure><p>使用了<code>Arrays#copyOf</code>方法进行复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="built_in">super</span>.clone();</span><br><span class="line">v.elementData = Arrays.copyOf(elementData, size);</span><br></pre></td></tr></table></figure><p>浅拷贝：基本数据类型可以达到完全复制，引用数据类型拷贝的是栈上的地址值，所以修改引用类型的数据，会改变原来的数据。</p><p>深拷贝：基本数据类型和引用类型都可以完全复制，引用对象在堆中创建新的对象，对原数据没有任何影响。</p><p><strong>深拷贝的实现方式：</strong></p><p>实现<code>Cloneable</code>接口并重写<code>clone</code>方法。</p><p>让其<code>clone</code>方法通过序列化和反序列化的方式来生成一个原对象的深拷贝副本</p><h2 id="实现randomaccess标记型接口"><a class="markdownIt-Anchor" href="#实现randomaccess标记型接口"></a> 实现<code>RandomAccess</code>标记型接口</h2><p><strong><code>ArrayList</code>支持随机访问。</strong></p><p>通过<code>get(i)</code>即可获得相应内存中存放的值。原因是因为<code>ArrayList</code>存放的内容在内存中是连续的，数组直接用<code>[]</code>访问，相当于直接操作内存地址，所以随机访问的效率较高。</p><p>普通的for循环是随机访问的，所以遍历<code>ArrayList</code>使用普通<code>for</code>循环比增强<code>for</code>循环和迭代器的效率高。</p><p>而<code>LinkedList</code>是一个双向链表，链表只能顺序访问，不支持随机访问，<code>LinkedList</code>中的<code>get</code>方法是按照顺序从列表的一端开始检查，直到找到要找的地址。所以遍历<code>LinkedList</code>使用增强<code>for</code>循环和迭代器的效率高，使用普通<code>for</code>循环会每次都从头开始遍历，效率较差。</p><h2 id="abstractlist抽象类"><a class="markdownIt-Anchor" href="#abstractlist抽象类"></a> <code>AbstractList</code>抽象类</h2><p><code>AbstractList</code> 虽然是抽象类，但其内部只有一个抽象方法 <code>get</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br></pre></td></tr></table></figure><p>从字面上看这是获取的方法，子类必须实现它，一般是作为获取元素的用途，除此之外，如果子类要操作元素，还需要重写 <code>add</code>、<code>set</code>、 <code>remove</code>方法，因为 <code>AbstractList</code> 虽然定义了这几个方法，但默认是不支持的。</p><h1 id="arraylist频繁扩容导致添加性能急剧下降如何处理"><a class="markdownIt-Anchor" href="#arraylist频繁扩容导致添加性能急剧下降如何处理"></a> <code>ArrayList</code>频繁扩容导致添加性能急剧下降，如何处理？</h1><p>每次扩容都会创建一个数据，将数据复制到新数组，所以在<code>ArrayList</code>中有一个构造方法，参数是自定义长度，指定初始容量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123; <span class="comment">//手动初始化</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果长度为0，使用final修饰的空数组</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="arraylist插入或删除元素一定比linkedlist慢吗"><a class="markdownIt-Anchor" href="#arraylist插入或删除元素一定比linkedlist慢吗"></a> <code>ArrayList</code>插入或删除元素一定比<code>LinkedList</code>慢吗？</h1><p>不一定，<code>LinkedList</code> 其底层调用了 Node的方法,该方法循环也是比较复杂的 , 如果这个<code>LinkedList</code>上的数据很多,虽说进行了折半的 但是效率也是比较低的。</p><p>而<code>ArrayList</code>底层数组需要移动位置，复制数组。</p><h1 id="arraylist是线程安全的吗"><a class="markdownIt-Anchor" href="#arraylist是线程安全的吗"></a> <code>ArrayList</code>是线程安全的吗？</h1><p><code>ArrayList</code>不是线程安全的，效率高。</p><h1 id="如何解决arraylist线程安全问题"><a class="markdownIt-Anchor" href="#如何解决arraylist线程安全问题"></a> 如何解决<code>ArrayList</code>线程安全问题？</h1><p>可以使用安全集合<code>Vector</code>。</p><p>可以使用<code>Collections</code>工具类中的<code>SyschronizedList</code>方法解决<code>ArrayList</code>的线程安全问题</p><p>定义为全局变量，被多个线程所共享，就要考虑线程问题</p><p>定义为局部变量时，调用方法会在虚拟机栈处创建一个栈帧，虚拟机栈线程私有的，每一次只有一个线程执行，所以局部变量的数据是独立的，不需要考虑安全问题</p><h1 id="如何复制一个arraylist集合到另一个arraylist集合中"><a class="markdownIt-Anchor" href="#如何复制一个arraylist集合到另一个arraylist集合中"></a> 如何复制一个<code>ArrayList</code>集合到另一个<code>ArrayList</code>集合中？</h1><p>可以使用clone()方法</p><p>使用其中的构造器</p><p>使用addAll()方法</p><p>for循环遍历复制</p><h1 id="已知成员变量集合存储n多用户名称在多线程的环境下使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合"><a class="markdownIt-Anchor" href="#已知成员变量集合存储n多用户名称在多线程的环境下使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合"></a> 已知成员变量集合存储N多用户名称，在多线程的环境下，使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合？</h1><p>在多线程读写操作，<code>ArrayList</code>会抛出并发异常，所以在进行读写数据时，使用读写的操作时，使用<code>CopyOnWriteArrayList</code>这个读写分离的集合。</p><h1 id="arraylist和linkedlist区别"><a class="markdownIt-Anchor" href="#arraylist和linkedlist区别"></a> <code>ArrayList</code>和<code>LinkedList</code>区别？</h1><p><strong><code>ArrayList</code></strong></p><ul><li><p>基于动态数组的数据结构</p></li><li><p><code>ArrayList</code>支持随机访问</p></li><li><p>查询快，增删慢，但并不一定比<code>LinkedList</code>慢</p></li></ul><p><strong><code>LinkedList</code></strong></p><ul><li><p>基于链表的数据结构</p></li><li><p>对于顺序操作，<code>LinkedList</code>不一定比<code>ArrayList</code>慢</p></li><li><p>查询慢，增删快</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文参考自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_51596354/article/details/122398978&quot;&gt;Java ArrayList底层原理详情笔记和相关面试题_抹泪的知更</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="ArrayList" scheme="https://luoyu-ying.github.io/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>HashMap - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/217436a720e7/"/>
    <id>https://luoyu-ying.github.io/posts/217436a720e7/</id>
    <published>2022-05-18T11:40:20.000Z</published>
    <updated>2022-05-19T12:21:20.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/weixin_44015043/article/details/105346187">看完还不懂HashMap算我输（附职场面试常见问题）_黛色翩翩的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/weixin_39603469/article/details/110639674">hashmap为什么用红黑树_HashMap面试必问的6个点，你知道几个？_weixin_39603469的博客-CSDN博客</a></li></ul></blockquote><h1 id="jdk-18-中-hashmap-更改了什么内容"><a class="markdownIt-Anchor" href="#jdk-18-中-hashmap-更改了什么内容"></a> <code>JDK 1.8</code> 中 <code>HashMap</code> 更改了什么内容？</h1><ol><li>将存储方式更改为了 数组 + 链表/<strong>红黑树</strong>。</li><li>优化了高位运算的<code>hash</code>算法：<code>h &amp; (h &gt;&gt;&gt; 16)</code>。</li><li>扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。</li></ol><h1 id="hashmap-原理"><a class="markdownIt-Anchor" href="#hashmap-原理"></a> <code>HashMap</code> 原理</h1><p><strong>几个重要的变量</strong></p><ul><li><p><code>DEFAULT_INITIAL_CAPACITY</code></p><p>Table数组的初始化长度： <code>1 &lt;&lt; 4</code> 。</p></li><li><p><code>MAXIMUM_CAPACITY</code></p><p>Table数组的最大长度： <code>1 &lt;&lt; 30</code>。</p></li><li><p><code>DEFAULT_LOAD_FACTOR</code></p><p>负载因子：默认值为<code>0.75</code>。</p><p>当<code>元素的总个数 &gt; (当前数组的长度 * 负载因子)</code>，数组会进行扩容，<strong>扩容为原来的两倍</strong>。</p></li><li><p><code>TREEIFY_THRESHOLD</code></p><p>链表树化阙值： 默认值为 <code>8</code> 。</p><p>表示在一个node（Table）节点下的值的个数大于8时候，会将链表转换成为红黑树。</p></li><li><p><code>UNTREEIFY_THRESHOLD</code></p><p>红黑树链化阙值： 默认值为 <code>6</code> 。</p><p>表示在进行扩容期间，单个Node节点下的红黑树节点的个数小于6时候，会将红黑树转化成为链表。</p></li><li><p><code>MIN_TREEIFY_CAPACITY = 64</code></p><p>最小树化阈值，值为 64。</p><p>当Table所有元素超过改值，才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突）。</p></li></ul><p><strong>实现原理</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220522214849.png" style="zoom:67%;" /><p><code>HashMap</code>采⽤<code>Entry</code>数组来存储<code>key-value</code>对，每⼀个键值对组成了⼀个<code>Entry</code>实体，<code>Entry</code>类实际上是⼀个单向的链表结构，它具有<code>Next</code>指针，可以连接下⼀个<code>Entry</code>实体。 只是在<code>JDK1.8</code>中，链表⻓度⼤于<code>8</code>的时候，链表会转成<strong>红⿊树</strong>。</p><h1 id="为什么使用-链表-数组-的存储方式"><a class="markdownIt-Anchor" href="#为什么使用-链表-数组-的存储方式"></a> 为什么使用 <code>链表</code> + <code>数组</code> 的存储方式？</h1><p>由于我们的数组的值是限制死的，我们在对<code>key</code>值进行散列取到下标以后，放入到数组中时，难免出现两个<code>key</code>值不同，但是却放入到下标相同的<strong>格子</strong>中，此时我们就可以使用链表来对其进行链式的存放。</p><h1 id="用linkedlist代替数组结构可以吗"><a class="markdownIt-Anchor" href="#用linkedlist代替数组结构可以吗"></a> ⽤<code>LinkedList</code>代替<code>数组</code>结构可以吗？</h1><p>可以的。</p><h1 id="既然可以使用进行替换处理为什么偏偏使用到数组呢"><a class="markdownIt-Anchor" href="#既然可以使用进行替换处理为什么偏偏使用到数组呢"></a> 既然可以使用进行替换处理，为什么偏偏使用到<code>数组</code>呢？</h1><p>因为使用数组效率最高。</p><p>在<code>HashMap</code>中，定位节点的位置是通过 <code>i = (n - 1) &amp; hash</code> 得到。此时，我们已得到节点的位置。显然数组的查找效率比<code>LinkedList</code>更优（底层是链表结构）。</p><p>那<code>ArrayList</code>，底层也是数组，查找也快啊，为啥不⽤<code>ArrayList</code>?</p><p>因为采用基本数组结构，扩容机制可以自己定义，<code>HashMap</code>中数组扩容刚好是<strong>2的次幂</strong>，方便原数组中的元素的位置变动， 而<code>ArrayList</code>的扩容机制是1.5倍扩容。</p><h1 id="hashmap中如何计算出存放位置的hash函数怎么实现的"><a class="markdownIt-Anchor" href="#hashmap中如何计算出存放位置的hash函数怎么实现的"></a> <code>HashMap</code>中如何计算出存放位置的？<code>hash</code>函数怎么实现的?</h1><p><strong>该问题解析同下问。</strong></p><h1 id="为什么不直接将hashcode作为哈希值去做取模而是要先高16位异或低16位"><a class="markdownIt-Anchor" href="#为什么不直接将hashcode作为哈希值去做取模而是要先高16位异或低16位"></a> 为什么不直接将<code>hashcode</code>作为哈希值去做取模,而是要先高16位异或低16位</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap#putVal 计算位置并存放</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p><strong>通过图做进一步的了解 <code>i = (n - 1) &amp; hash</code>：</strong></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220522214907.png" alt="" /></p><p>这里我们也就得知为什么<code>Table</code>数组的长度要一直都为<code>2的n次方</code>，只有这样，减一进行<strong>与操作</strong>时候，才能够达到最大的<code>n-1</code>值。</p><p><strong>通过反例验证一下：</strong></p><p>我们现 数组的长度为 15 ，减一为 14 ，二进制表示 <code>0000 1110</code> 。进行<strong>与操作</strong>时候，最后一位永远是0，这样就可能导致不能够完完全全的进行Table数组的使用。违背了我们最开始的想要对Table数组进行<strong>最大限度的无序使用</strong>的原则，因为HashMap为了能够存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表⻓度⼤致相同。</p><p><strong>此时还有一点需要注意的是： 我们对key值进行hashcode以后，进行相与时候都是只用到了后四位，前面的很多位都没有能够得到使用,这样也可能会导致我们所生成的下标值不能够完全散列。</strong></p><p><strong>解决方案：</strong></p><p>将生成的<code>hashcode</code>值的高16位于低16位进行异或运算，这样得到的值再进行<strong>与操作</strong>，得散列的下标值，异或的1或0的结果都是1/2，使得散列更均匀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="还有哪些hash函数的实现方式"><a class="markdownIt-Anchor" href="#还有哪些hash函数的实现方式"></a> 还有哪些<code>hash</code>函数的实现方式？</h1><p>先说⼀下<code>hash</code>算法⼲嘛的，<code>hash</code>函数是指把⼀个⼤范围映射到⼀个⼩范围。把⼤范围映射到⼀个⼩范围的⽬的往往是为了 节省空间，使得数据容易保存。</p><p>⽐较出名的有<code>MurmurHash</code>、<code>MD4</code>、<code>MD5</code>等等。</p><p><strong><code>String</code>中<code>hashcode</code>的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="hash冲突有哪些解决办法"><a class="markdownIt-Anchor" href="#hash冲突有哪些解决办法"></a> hash冲突有哪些解决办法</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/qq_48241564/article/details/118613312">解决哈希冲突（四种方法）_君诀的博客-CSDN博客_解决哈希冲突的方法</a></li></ul></blockquote><p>有三个方法：</p><ol><li>开放定址法</li><li>再哈希法</li><li>链地址法</li></ol><h1 id="解决hash冲突的时候为什么用红黑树"><a class="markdownIt-Anchor" href="#解决hash冲突的时候为什么用红黑树"></a> 解决<code>hash</code>冲突的时候，为什么用红黑树？</h1><p>当链表过长的时候，如果仍旧使用链表进行搜索和删改，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，所消耗的时间叫较大。</p><p>如果采用了红黑树的设计，则可以使得在数据量较大的情况下，以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的时间复杂度进行搜索和删改，大幅减少使用的时间。</p><h1 id="红黑树的效率高为什么一开始不用红黑树存储"><a class="markdownIt-Anchor" href="#红黑树的效率高为什么一开始不用红黑树存储"></a> 红黑树的效率高，为什么一开始不用红黑树存储？</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/baidu_37147070/article/details/98785367">JDK1.8以后的hashmap为什么在链表长度为8的时候变为红黑树_向日葵班学霸的博客-CSDN博客</a></li></ul></blockquote><p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。</p><p>源码中的注释写的很清楚，因为树节点所占空间是普通节点的两倍，所以只有当节点足够多的时候，才会使用树节点。也就是说，节点少的时候，尽管时间复杂度上，红黑树比链表好一点，但是红黑树所占空间比较大，综合考虑，认为只能在节点太多的时候，红黑树占空间大这一劣势不太明显的时候，才会舍弃链表，使用红黑树。</p><h1 id="不用红黑树用二叉查找树可以不"><a class="markdownIt-Anchor" href="#不用红黑树用二叉查找树可以不"></a> 不用<a href="https://luoyu-ying.github.io/posts/59c5aea57d8c/">红黑树</a>，用二叉查找树可以不？</h1><p>可以。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。</p><h1 id="为什么阈值是8才转为红黑树"><a class="markdownIt-Anchor" href="#为什么阈值是8才转为红黑树"></a> 为什么阈值是8才转为红黑树</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/baidu_37147070/article/details/98785367">JDK1.8以后的hashmap为什么在链表长度为8的时候变为红黑树_向日葵班学霸的博客-CSDN博客</a></li></ul></blockquote><p>源码上说，为了配合使用分布良好的hashCode，树节点很少使用。并且在理想状态下，受随机分布的hashCode影响，链表中的节点<strong>遵循泊松分布</strong>，而且根据统计，<strong>链表中节点数</strong>是8的概率已经接近千分之一，而且此时链表的性能已经很差了。</p><p>所以在这种比较罕见和极端的情况下，才会把链表转变为红黑树。因为链表转换为红黑树也是需要消耗性能的，特殊情况特殊处理，为了挽回性能，权衡之下，才使用红黑树，提高性能。</p><p>也就是大部分情况下，hashmap还是使用的链表，如果是理想的均匀分布，节点数不到8，hashmap就自动扩容了。为什么这么说呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在链表转变为红黑树方法中，有这样一个判断，数组长度小于<code>MIN_TREEIFY_CAPACITY = 64</code>，就会扩容，而不是直接转变为红黑树，可不是什么链表长度为8就变为红黑树，要仔细看代码，还有别的条件。</p><p>现在回头想想，为啥用8？</p><p><strong>因为通常情况下，链表长度很难达到8，但是特殊情况下链表长度为8，哈希表容量又很大，造成链表性能很差的时候，只能采用红黑树提高性能，这是一种应对策略。</strong></p><h1 id="为什么退化为链表的阈值是6"><a class="markdownIt-Anchor" href="#为什么退化为链表的阈值是6"></a> 为什么退化为<a href="https://luoyu-ying.github.io/posts/59c5aea57d8c/">链表</a>的阈值是6</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/a7a76c5b8435">HashMap系列：树化阀值8，退化阀值6 - 简书 (jianshu.com)</a></li></ul></blockquote><p>如果不设退化阀值，只以8来树化与退化：<br />那么8将成为一个临界值，时而树化，时而退化，此时会非常影响性能，因此，我们需要一个比8小的退化阀值；</p><p>UNTREEIFY_THRESHOLD = 7<br />同样，与上面的情况没有好多少，仅相差1个元素，仍旧会在链表与树之间反复转化；</p><p>那为什么是6呢？<br />源码中也说了，考虑到内存（树节点比普通节点内存大2倍，以及避免反复转化），所以，退化阀值最多为6。</p><h1 id="hashmap中put如何实现的"><a class="markdownIt-Anchor" href="#hashmap中put如何实现的"></a> <code>HashMap</code>中<code>put</code>如何实现的</h1><p><code>put</code> 方法中会实现以下的过程：</p><ol><li>如果 <code>table</code> 没有初始化，就先进行初始化（<code>resize</code>）操作。</li><li>对 <code>key</code> 进行 <code>hash</code>，并计算出存放位置 <code>index</code> (<code>i = (n - 1) &amp; hash</code>)。</li><li>如果没碰撞直接放到<code>bucket</code>中。</li><li>如果发生碰撞了，就遍历链表：<ol><li>如果出现了key相同，value不同的节点，就替换该value(保证key的唯⼀性)。</li><li>否则直接加入到链表的结尾（<strong>尾插法</strong>）。</li></ol></li><li>如果链表过长(大于等于<code>TREEIFY_THRESHOLD</code>)，就把链表转换成红黑树(<code>JDK1.8</code>中的改动)。</li><li>如果<code>bucket</code>满了(超过<code>DEFAULT_LOAD_FACTOR</code> * <code>CAPACITY</code>)，就要<code>resize</code>。</li></ol><h1 id="hashmap中get如何实现的"><a class="markdownIt-Anchor" href="#hashmap中get如何实现的"></a> <code>HashMap</code>中<code>get</code>如何实现的</h1><p><code>get</code> 方法中会实现以下的过程：</p><ol><li>判断<code>table</code>是否为<code>null</code>，若为<code>null</code>，则直接返回<code>null</code>。</li><li>计算<code>key</code>的<code>hash</code>，并计算存放位置。</li><li>直接判断第一个元素是否为自己所需要的元素。如果是，则直接返回该节点。</li><li>如果有冲突，则通过<code>key.equals(k)</code>去查找对应的<code>Entry</code>。<ol><li>若为树，则<strong>在树中</strong>通过<code>key.equals(k)</code>查找，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</li><li>若为链表，则<strong>在链表中</strong>通过<code>key.equals(k)</code>查找，时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 判断 表是否为空，表重读是否大于零，并且根据此 key 对应的表内是否存在 Node节点。    </span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 检查第一个Node 节点，若是命中则不需要进行do... whirle 循环。</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="comment">//树形结构，采用 对应的检索方法，进行检索。</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//链表方法 做while循环，直到命中结束或者遍历结束。</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表的查找的时间复杂度是多少"><a class="markdownIt-Anchor" href="#链表的查找的时间复杂度是多少"></a> 链表的查找的时间复杂度是多少</h1><p>时间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p><h1 id="hashmap在什么条件下扩容"><a class="markdownIt-Anchor" href="#hashmap在什么条件下扩容"></a> <code>HashMap</code>在什么条件下扩容</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/yanzige/p/8392142.html">深入理解HashMap的扩容机制 - 颜子歌 - 博客园 (cnblogs.com)</a></li></ul></blockquote><p>Java8不再像Java7中那样需要满足两个条件，Java8中扩容只需要满足一个条件：</p><p><em><em>当前存放新值</em>（注意不是替换已有元素位置时）<em>的时候已有元素的个数大于等于阈值（已有元素等于阈值，下一个存放后必然触发扩容机制）</em></em></p><p>注：</p><ol><li>扩容一定是放入新值的时候，该新值不是替换以前位置的情况下（说明：put（“name”,“zhangsan”），而map里面原有数据&lt;“name”,“lisi”&gt;，则该存放过程就是替换一个原有值，而不是新增值，则不会扩容）。</li><li>扩容发生在存放后，即是数据存放后（先存放后扩容），判断当前存入对象的个数，如果大于阈值则进行扩容。</li></ol><h1 id="为什么扩容是2的次幂"><a class="markdownIt-Anchor" href="#为什么扩容是2的次幂"></a> 为什么扩容是<strong>2的次幂</strong></h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/weixin_44273302/article/details/113733422">HashMap初始容量为什么是2的n次幂及扩容为什么是2倍的形式？_喜欢敲代码的Apollo的博客-CSDN博客</a></li></ul></blockquote><ol><li><p>得到的新的数组索引和老数组索引只有最高位区别，更快地得到新索引。</p></li><li><p>rehash时的取余操作，hash % length == hash &amp; (length - 1)这个关系只有在length等于二的幂次方时成立，位运算能比%高效得多。</p></li></ol><p><strong>HashMap#resize 源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HashMap#resize</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(<span class="type">int</span> newCapacity)</span> &#123;</span><br><span class="line">    HashMapEntry[] oldTable = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMapEntry[] newTable = <span class="keyword">new</span> <span class="title class_">HashMapEntry</span>[newCapacity];<span class="comment">//新建一个数组</span></span><br><span class="line">    transfer(newTable);<span class="comment">//完成新旧数组拷贝</span></span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(HashMapEntry[] newTable)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (HashMapEntry&lt;K,V&gt; e : table) &#123;<span class="comment">//遍历整个数组</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">null</span> != e) &#123;<span class="comment">//将同一个位置的元素按链表顺序取出</span></span><br><span class="line">            HashMapEntry&lt;K,V&gt; next = e.next;<span class="comment">//先将当前元素指向的下一个元素存起来，一个一个存放到新表的位置中，记住不一定是同一位置，因为长度变了</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> indexFor(e.hash, newCapacity);<span class="comment">//根据新数组长度，重新生成数组索引</span></span><br><span class="line">            e.next = newTable[i];<span class="comment">//将当前位置的元素链表头指向即将新加入的元素，</span></span><br><span class="line">            newTable[i] = e;<span class="comment">//然后放入数组中，完成同一位置元素链表的拼接，最先添加的元素总在链表末尾</span></span><br><span class="line">            e = next;<span class="comment">//然后继续循环，拿出下一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="为什么hashmap线程不安全"><a class="markdownIt-Anchor" href="#为什么hashmap线程不安全"></a> 为什么<code>HashMap</code>线程不安全</h1><p>HashMap 没有通过锁的方式使得同一时间只有一个线程可以访问，如果多个线程同一时间对同一个元素进行修改，便会出现结果错误的情况。</p><h1 id="处理hashmap线程不安全"><a class="markdownIt-Anchor" href="#处理hashmap线程不安全"></a> 处理<code>HashMap</code>线程不安全</h1><ol><li>在之前使用<code>HashTable</code>。 在每一个函数前面都加上了synchronized 但是 效率太低 我们现在不常用了。</li><li>使用 <code>ConcurrentHashmap</code>。用于提高效率。</li></ol><h1 id="concurrenthashmap"><a class="markdownIt-Anchor" href="#concurrenthashmap"></a> <code>ConcurrentHashMap</code></h1><blockquote><p>答案参考自：</p><ul><li><a href="https://cloud.tencent.com/developer/article/1873182">ConcurrentHashMap（JDK8） - 云+社区 - 腾讯云 (tencent.com)</a></li></ul></blockquote><p><font size="5"><strong>对比</strong></font></p><p><font size="4"><strong>与HashMap的区别是什么？</strong></font></p><p>ConcurrentHashMap是HashMap的升级版，HashMap是线程不安全的，而ConcurrentHashMap是线程安全。而其他功能和实现原理和HashMap类似。</p><p><font size="4"><strong>与Hashtable的区别是什么？</strong></font></p><p>Hashtable也是线程安全的，但每次要锁住整个结构，并发性低。相比之下，ConcurrentHashMap获取size时才锁整个对象。</p><p>Hashtable对get/put/remove都使用了同步操作。ConcurrentHashMap只对put/remove同步。</p><p>Hashtable是快速失败的，遍历时改变结构会报错ConcurrentModificationException。ConcurrentHashMap是安全失败，允许并发检索和更新。</p><p><font size="4"><strong>JDK8的ConcurrentHashMap和JDK7的ConcurrentHashMap有什么区别？</strong></font></p><ol><li>JDK8中新增了红黑树</li><li>JDK7中使用的是头插法，JDK8中使用的是尾插法</li><li>JDK7中使用了分段锁，而JDK8中没有使用分段锁了</li><li>JDK7中使用了ReentrantLock，JDK8中没有使用ReentrantLock了，而使用了Synchronized</li><li>JDK7中的扩容是每个Segment内部进行扩容，不会影响其他Segment，而JDK8中的扩容和HashMap的扩容类似，只不过支持了多线程扩容，并且保证了线程安全</li></ol><p><font size="5"><strong>特性</strong></font></p><p><font size="4"><strong>ConcurrentHashMap是如何保证并发安全的？</strong></font></p><p>JDK7中ConcurrentHashMap是通过ReentrantLock+CAS+分段思想来保证的并发安全的，ConcurrentHashMap的put方法会通过CAS的方式，把一个Segment对象存到Segment数组中，一个Segment内部存在一个HashEntry数组，相当于分段的HashMap，Segment继承了ReentrantLock，每段put开始会加锁。</p><p>在JDK7的ConcurrentHashMap中，首先有一个Segment数组，存的是Segment对象，Segment相当于一个小HashMap，Segment内部有一个HashEntry的数组，也有扩容的阈值，同时Segment继承了ReentrantLock类，同时在Segment中还提供了put，get等方法，比如Segment的put方法在一开始就会去加锁，加到锁之后才会把key,value存到Segment中去，然后释放锁。同时在ConcurrentHashMap的put方法中，会通过CAS的方式把一个Segment对象存到Segment数组的某个位置中。同时因为一个Segment内部存在一个HashEntry数组，所以和HashMap对比来看，相当于分段了，每段里面是一个小的HashMap，每段公用一把锁，同时在ConcurrentHashMap的构造方法中是可以设置分段的数量的，叫做并发级别concurrencyLevel.</p><p>JDK8中ConcurrentHashMap是通过synchronized+cas来实现了。在JDK8中只有一个数组，就是Node数组，Node就是key，value，hashcode封装出来的对象，和HashMap中的Entry一样，在JDK8中通过对Node数组的某个index位置的元素进行同步，达到该index位置的并发安全。同时内部也利用了CAS对数组的某个位置进行并发安全的赋值。</p><p><font size="4"><strong>JDK8中的ConcurrentHashMap为什么使用synchronized来进行加锁？</strong></font></p><p>JDK8中使用synchronized加锁时，是对链表头结点和红黑树根结点来加锁的，而ConcurrentHashMap会保证，数组中某个位置的元素一定是链表的头结点或红黑树的根结点，所以JDK8中的ConcurrentHashMap在对某个桶进行并发安全控制时，只需要使用synchronized对当前那个位置的数组上的元素进行加锁即可，对于每个桶，只有获取到了第一个元素上的锁，才能操作这个桶，不管这个桶是一个链表还是红黑树。</p><p>想比于JDK7中使用ReentrantLock来加锁，因为JDK7中使用了分段锁，所以对于一个ConcurrentHashMap对象而言，分了几段就得有几个ReentrantLock对象，表示得有对应的几把锁。</p><p>而JDK8中使用synchronized关键字来加锁就会更节省内存，并且jdk也已经对synchronized的底层工作机制进行了优化，效率更好。</p><p><font size="4"><strong>JDK7中的ConcurrentHashMap是如何扩容的？</strong></font></p><p>JDK7中的ConcurrentHashMap和JDK7的HashMap的扩容是不太一样的，首先JDK7中也是支持多线程扩容的，原因是，JDK7中的ConcurrentHashMap分段了，每一段叫做Segment对象，每个Segment对象相当于一个HashMap，分段之后，对于ConcurrentHashMap而言，能同时支持多个线程进行操作，前提是这些操作的是不同的Segment，而ConcurrentHashMap中的扩容是仅限于本Segment，也就是对应的小型HashMap进行扩容，所以是可以多线程扩容的。</p><p>每个Segment内部的扩容逻辑和HashMap中一样。</p><p><font size="4"><strong>JDK8中的ConcurrentHashMap是如何扩容的？</strong></font></p><p>首先，JDK8中是支持多线程扩容的，JDK8中的ConcurrentHashMap不再是分段，或者可以理解为每个桶为一段，在需要扩容时，首先会生成一个双倍大小的数组，生成完数组后，线程就会开始转移元素，在扩容的过程中，如果有其他线程在put，那么这个put线程会帮助去进行元素的转移，虽然叫转移，但是其实是基于原数组上的Node信息去生成一个新的Node的，也就是原数组上的Node不会消失，因为在扩容的过程中，如果有其他线程在get也是可以的。</p><p><font size="4"><strong>JDK8中的ConcurrentHashMap有一个CounterCell，你是如何理解的？</strong></font></p><p>CounterCell是JDK8中用来统计ConcurrentHashMap中所有元素个数的，在统计ConcurentHashMap时，不能直接对ConcurrentHashMap对象进行加锁然后再去统计，因为这样会影响ConcurrentHashMap的put等操作的效率，在JDK8的实现中使用了CounterCell+baseCount来辅助进行统计，baseCount是ConcurrentHashMap中的一个属性，某个线程在调用ConcurrentHashMap对象的put操作时，会先通过CAS去修改baseCount的值，如果CAS修改成功，就计数成功，如果CAS修改失败，则会从CounterCell数组中随机选出一个CounterCell对象，然后利用CAS去修改CounterCell对象中的值，因为存在CounterCell数组，所以，当某个线程想要计数时，先尝试通过CAS去修改baseCount的值，如果没有修改成功，则从CounterCell数组中随机取出来一个CounterCell对象进行CAS计数，这样在计数时提高了效率。</p><p>所以ConcurrentHashMap在统计元素个数时，就是baseCount加上所有CountCeller中的value值，所得的和就是所有的元素个数。</p><h1 id="key可以是null吗value可以是null吗"><a class="markdownIt-Anchor" href="#key可以是null吗value可以是null吗"></a> key可以是<code>null</code>吗，<code>value</code>可以是<code>null</code>吗</h1><p>当然都是可以的，但是对于 <code>key</code>来说只能运行出现一个<code>key</code>值为<code>null</code>，但是可以出现多个<code>value</code>值为<code>null</code>。</p><h1 id="一般用什么值作为key值"><a class="markdownIt-Anchor" href="#一般用什么值作为key值"></a> 一般用什么值作为<code>key</code>值？</h1><p>一般用Integer、String这种不可变类当HashMap当key，⽽且String最为常⽤。</p><ol><li>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。 这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。 这就是HashMap中的键往往都使⽤字符串</li><li>因为获取对象的时候要⽤到equals()和hashCode()⽅法，那么键对象正确的重写这两个⽅法是⾮常重要的,这些类已 经很规范的覆写了hashCode()以及equals()⽅法。</li></ol><h1 id="用可变类当hashmap的key会有什么问题"><a class="markdownIt-Anchor" href="#用可变类当hashmap的key会有什么问题"></a> 用可变类当<code>Hashmap</code>的<code>key</code>会有什么问题</h1><p><code>hashcode</code>可能会发生变化，导致<code>put</code>进行的值，无法<code>get</code>出来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;答案参考自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_44015043/article/details/105346187&quot;&gt;看完还不懂HashMap算我输（附职场面试常见问题）_黛色翩</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="HashMap" scheme="https://luoyu-ying.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Handler - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/a2ee5464a9b5/"/>
    <id>https://luoyu-ying.github.io/posts/a2ee5464a9b5/</id>
    <published>2022-05-17T08:40:02.000Z</published>
    <updated>2022-05-20T14:48:04.648Z</updated>
    
    <content type="html"><![CDATA[<h1 id="handler的实现原理"><a class="markdownIt-Anchor" href="#handler的实现原理"></a> <code>Handler</code>的实现原理</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://luoyu-ying.github.io/posts/9435d0391c8a/">Handler 机制解析 | 洛语 の Blog (luoyu-ying.github.io)</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/Handler%E6%9C%BA%E5%88%B6ver2.png" alt="Handler 机制" /></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/a3f0101bb9aef02691d45337a906325f.png" alt="" /></p><h1 id="子线程中能不能直接new一个handler为什么主线程可以主线程的looper第一次调用loop方法什么时候哪个类"><a class="markdownIt-Anchor" href="#子线程中能不能直接new一个handler为什么主线程可以主线程的looper第一次调用loop方法什么时候哪个类"></a> 子线程中能不能直接<code>new</code>一个<code>Handler</code>,为什么主线程可以？主线程的<code>Looper</code>第一次调用<code>loop</code>方法,什么时候,哪个类？</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/886b11e233b3">可以在子线程直接new一个Handler吗？怎么做？ - 简书 (jianshu.com)</a></li></ul></blockquote><p><strong>可以在子线程直接<code>new</code>一个<code>Handler</code>，不过需要在子线程里先调用<code>Looper#prepare</code>。<code>new</code>一个<code>Handler</code>后，还需要调用<code>Looper#loop</code>方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>有人会问，在主线程中为什么没看到<code>Looper.prepare()</code>？其实系统已经给我们调用了，不过调用的是<code>Looper.prepareMainLooper()</code>，如下源码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SystemServer 类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The main entry point from zygote.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SystemServer</span>().run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code>方法是整个<code>android</code>应用的入口，在子线程中调用<code>Looper.prepare()</code>是为了创建一个<code>Looper</code>对象，并将该对象存储在当前线程的<code>ThreadLocal</code>中。</p><p>每个线程都会有一个<code>ThreadLocal</code>，它为每个线程提供了一个本地的副本变量机制，实现了和其它线程隔离，并且这种变量只在本线程的生命周期内起作用，可以减少同一个线程内多个方法之间的公共变量传递的复杂度。<code>Looper.loop()</code>方法是为了取出消息队列中的消息并将消息发送给指定的<code>handler</code>,通过<code>msg.target.dispatchMassage()</code>方法。</p><h1 id="handler导致的内存泄露原因及其解决方案"><a class="markdownIt-Anchor" href="#handler导致的内存泄露原因及其解决方案"></a> <code>Handler</code>导致的内存泄露原因及其解决方案</h1><blockquote><p>当不再需要某个实例后，这个对象却仍然被引用，阻止被垃圾回收(Prevent from being bargage collected)，这个情况就叫做内存泄露(Memory Leak)。</p></blockquote><p>考虑以下的代码；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Handler</span> <span class="variable">mLeakyHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然不明显，但是这段代码可能导致内存泄露。Android Lint会提示以下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In Android, Handler classes should be static or leaks might occur.</span><br></pre></td></tr></table></figure><p><strong>它到底是如何泄露的呢？</strong></p><ol><li><p>当一个<code>Android</code>应用程序启动的时候，<code>Android</code>框架为这个程序的主线程即UI线程创建了一个<code>Looper</code>对象，用于处理<code>Handler</code>中的<code>Message</code>。<br /><code>Looper</code>实现了一个简单的消息队列<code>MessageQueue</code>，不断循环的处理其中的<code>message</code>。<br />所有的应用程序框架的事件（比如<code>Activity</code>生命周期的调用，按钮的点击等）都被封装在这个<code>Message</code>对象里，然后被加入到<code>Looper</code>的<code>MessageQueue</code>，最后一个一个的处理这些<code>Message</code>。<br />注意，<code>Looper</code>在整个应用程序的生命周期中一直存在。</p></li><li><p>在主线程中实例化一个<code>Handler</code>对象的时候，就和它关联了主线程<code>Looper</code>的消息队列<code>MessageQueue</code>。<br />被发送到这个消息队列的<code>Message</code>将保持对这个Handler对象的引用，这样框架就可以在处理这个<code>Message</code>的时候调用<code>Handler.handleMessage(Message)</code>来处理消息了。<br />(也就是说，只要没有处理到这个<code>Message</code>，<code>Handler</code>就一直在队列中被引用)。</p></li><li><p>在<code>Java</code>中，非静态内部类和匿名内部类都隐式的保持了一个对外部类<code>outerclass</code>的引用。<strong>但是静态内部类不会有这个引用。</strong></p></li></ol><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/5238c9d2921c4ba6b78be289b24a7d27.jpg" style="zoom:67%;" /><p><strong>正确的解决方法：</strong></p><ol><li><code>Handler</code>静态内部类 + <code>WeakReference&lt;Activity&gt;</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态内部类不会持有外部类的信用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyHandler</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;MainActivity&gt; mActivity;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyHandler</span><span class="params">(MainActivity activity)</span> &#123;</span><br><span class="line">            mActivity = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;MainActivity&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">            <span class="type">MainActivity</span> <span class="variable">activity</span> <span class="operator">=</span> mActivity.get();</span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">MyHandler</span> <span class="variable">mHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHandler</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><ol start="2"><li>静态<code>Runnable</code>，避免对外部类的引用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匿名类用static修饰后，不会再持有外部类的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">sRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// TODO</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState); </span><br><span class="line">        mHandler.postDelayed(sRunnable, <span class="number">1000</span> * <span class="number">60</span> * <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// Go back to the previous Activity.</span></span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类和非静态内部类的区别很微小，但是开发人员必须了解。</p><p>那么底线是什么？</p><p>当内部类可以独立于<code>Activity</code>的生命周期而存在的时候，应该避免使用非静态内部类，应该用静态内部类并且使用<code>WeakReference</code>保持对<code>Activity</code>的引用。</p><p><strong>深入理解</strong></p><p>像下面这样使用handler的时候，其实是将handler定义为了匿名内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Handler mLeakyHandler=<span class="keyword">new</span> <span class="title class_">Handler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMessage</span><span class="params">(Message msg)</span> &#123; </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<strong>匿名内部类会默认持有外部类（<code>MainActivity</code>）的引用</strong>。</p><p>学过<code>handler</code>的都知道，<code>handler</code>发送消息后，消息会进行入队操作，在<code>enqueueMessage</code>方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg.targer = <span class="built_in">this</span>;</span><br></pre></td></tr></table></figure><p><code>this</code>指的就是handler，所以<code>handler</code>被<code>message</code>持有了，而<code>message</code>放入消息队列后，<code>message</code>又被<code>MessageQueue</code>持有了，而<code>MessageQueue</code>是在创建Looper的时候生成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Looper</span><span class="params">(<span class="type">boolean</span> quitAllowed)</span> &#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(quitAllowed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以<code>MessageQueue</code>又被<code>looper</code>所持有。如果这个<code>handler</code>是主线程的<code>handler</code>，那么此时的<code>looper</code>就是指的主线程的<code>Looper</code>，它的声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;</span><br></pre></td></tr></table></figure><p>可以看到主线程的<code>looper</code>是<code>static</code>静态变量，而<code>static</code>静态变量在垃圾回收的时候是会被当做<code>GC Root</code>的，静态变量的生命周期与<code>APP</code>的生命周期、与虚拟机的生命周期是一样的，所以正是因为这个持有链的存在，导致了内存泄露。</p><p>引用链大致如下：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRstaticLooper[&quot;(static) Looper&quot;]staticLooper --&gt;|持有| MessageQueue --&gt;|持有| Message --&gt;|持有| Handler --&gt;|持有| MainActivity  </pre></div><p>所以解决 <code>handler</code> 内存泄露的办法就是要破坏这个持有链，比如只要 <code>handler</code> 不被 <code>activity</code> 持有就可以，所以可以把 <code>handler</code> 定义为<code>static</code>，因为 <code>static</code> 不会持有外部类，这样 <code>handler</code> 就不会持有 <code>activity</code> 了。</p><p><strong>怎样判断一个内部类有没有被持有外部类？</strong></p><p>比如上面的<code>handler</code>定义，没有加static的时候，在<code>handleMessage</code>方法里面可以正常使用<code>MainActivity.this</code>，这说明它持有了外部类。而一旦<code>Handler</code>加上static关键字，在<code>handleMessage</code>方法内部就不能再使用<code>MainActivity.this</code>，说明它没有持有外部类。</p><p>（为什么<code>static</code>变量，不会造成内存泄露？<code>static</code> 不会去持有外部类）</p><h1 id="messagequeue是什么数据结构"><a class="markdownIt-Anchor" href="#messagequeue是什么数据结构"></a> <code>MessageQueue</code>是什么数据结构</h1><p><code>MessageQueue</code> 是一个基于时间排序的<strong>优先队列</strong>。</p><h1 id="message对象创建的方式有哪些-区别"><a class="markdownIt-Anchor" href="#message对象创建的方式有哪些-区别"></a> <code>Message</code>对象创建的方式有哪些 &amp; 区别？</h1><p>创建Message对象的时候，<strong>有三种方式</strong>，分别为：</p><ol><li><code>Message msg = new Message();</code></li><li><code>Message msg = Message.obtain();</code></li><li><code>Message msg = handler.obtainMessage();</code></li></ol><p><strong>分析</strong></p><ol><li><p><code>Message msg = new Message();</code></p><p>这种就是直接初始化一个Message对象，没有什么特别的。</p></li><li><p><code>Message msg = Message.obtain();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return a new Message instance from the global pool. Allows us to</span></span><br><span class="line"><span class="comment">* avoid allocating new objects in many cases.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line"><span class="keyword">if</span> (sPool != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="literal">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从注释可以得知，从整个<code>Message</code>池中返回一个新的<code>Message</code>实例，通过<code>obtainMessage</code>能避免重复<code>Message</code>创建对象。</p></li><li><p><code>Message msg = handler1.obtainMessage();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title function_">obtainMessage</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Message.obtain(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">(Handler h)</span> &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> obtain();</span><br><span class="line">    m.target = h;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title function_">obtain</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">m</span> <span class="operator">=</span> sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="literal">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，第二种跟第三种其实是一样的，都可以避免重复创建Message对象，所以建议用第二种或者第三种任何一个创建Message对象。</p></li></ol><h1 id="messageobtain怎么维护消息池的"><a class="markdownIt-Anchor" href="#messageobtain怎么维护消息池的"></a> <code>Message.obtain()</code>怎么维护消息池的？</h1><p>使用了<strong>享元设计模式</strong>，当前message执行完后，把message置为空，然后重新给message进行赋值。 通<strong>过链表的形式</strong>，进行了复用和回收</p><h1 id="handler-有哪些发送消息的方法"><a class="markdownIt-Anchor" href="#handler-有哪些发送消息的方法"></a> <code>Handler</code> 有哪些发送消息的方法</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//版本1</span><br><span class="line">Message message = new Message();</span><br><span class="line">message.what = 0;</span><br><span class="line">message.obj = &quot;hello&quot;;</span><br><span class="line">mHandler.sendMessage(message); </span><br><span class="line"></span><br><span class="line">//版本2</span><br><span class="line">Message message = mHandler.obtainMessage();</span><br><span class="line">message.what = 0;</span><br><span class="line">message.obj = &quot;hello&quot;;</span><br><span class="line">mHandler.sendMessage(message);</span><br><span class="line"></span><br><span class="line">//版本3</span><br><span class="line">mHandler.obtainMessage(0,&quot;hello&quot;).sendToTarget();</span><br></pre></td></tr></table></figure><p>其中，版本3 使用到的 <code>sendToTarget</code> 方法只适用于有<code>target</code>值的<code>Message</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Sends this Message to the Handler specified by &#123;<span class="doctag">@link</span> #getTarget&#125;.</span></span><br><span class="line"><span class="comment">* Throws a null pointer exception if this field has not been set.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendToTarget</span><span class="params">()</span> &#123;</span><br><span class="line">target.sendMessage(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="handler的post与sendmessage的区别和应用场景"><a class="markdownIt-Anchor" href="#handler的post与sendmessage的区别和应用场景"></a> <code>Handler</code>的<code>post</code>与<code>sendMessage</code>的区别和应用场景</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/jingerlovexiaojie/article/details/107973310">Handler发送消息的方式_程序员老林的博客-CSDN博客_handler发送消息</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220517154734.png" alt="" /></p><h1 id="子线程能不能更新ui"><a class="markdownIt-Anchor" href="#子线程能不能更新ui"></a> 子线程能不能更新UI</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/xyh269/article/details/52728861">Android中子线程真的不能更新UI吗？_yinhuanxu的博客-CSDN博客_android非主线程更新ui</a></li></ul></blockquote><p>极端情况下是可以的。</p><ol><li><p>更新UI后会立即通过 <code>ViewRootImpl</code> 类执行里面的 <code>performTraversal</code> 方法。</p></li><li><p>在 <code>performTraversal</code> 方法前，还会先执行一个 <code>chechThread</code> 方法。如果监测到当前的线程不是主线程，就会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">checkThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CalledFromWrongThreadException</span>(</span><br><span class="line">                <span class="string">&quot;Only the original thread that created a view hierarchy can touch its views.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过源码可以发现， <code>ViewRootImpl</code> 类的创建是在回调了 <code>onResume</code> 方法之后。所以我们在 <code>onCreate</code> 方法中通过子线程立即更新UI时，由于该类并没有创建，所以无法检测当前线程是否为主线程，所以程序没有崩溃一样能跑起来，如果修改了程序，让线程休眠了200毫秒后，程序就崩了。很明显200毫秒后<code>ViewRootImpl</code>已经创建了，可以执行<code>checkThread</code>方法检查当前线程。</p></li></ol><h1 id="为什么android系统不建议子线程访问ui"><a class="markdownIt-Anchor" href="#为什么android系统不建议子线程访问ui"></a> 为什么Android系统不建议子线程访问UI</h1><p>Android的UI访问是没有加锁的，这样在多个线程访问UI是不安全的。所以Android中规定只能在UI线程中访问UI。</p><h1 id="postdelay后消息队列有什么变化假设先-postdelay-10s-再postdelay-1s-怎么处理这2条消息"><a class="markdownIt-Anchor" href="#postdelay后消息队列有什么变化假设先-postdelay-10s-再postdelay-1s-怎么处理这2条消息"></a> <code>postDelay</code>后消息队列有什么变化，假设先 <code>postDelay</code> 10s, 再<code>postDelay</code> 1s, 怎么处理这2条消息</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://juejin.cn/post/7030413030940737549">android 面试题handle系列 - 掘金 (juejin.cn)</a></li></ul></blockquote><p>如果队列中只有这个消息，那么消息不会被发送，而是计算到时唤醒的时间，先将Looper阻塞，到时间就唤醒它。</p><p>但如果此时要加入新消息，该消息队列的对头跟delay时间相比更长，则插入到头部，<strong>按照触发时间进行排序</strong>，队头的时间最小、队尾的时间最大。<strong>（消息队列为优先队列）</strong></p><h1 id="messagequeue的enqueuemessage方法如何进行线程同步的"><a class="markdownIt-Anchor" href="#messagequeue的enqueuemessage方法如何进行线程同步的"></a> <code>MessageQueue</code>的<code>enqueueMessage</code>()方法如何进行线程同步的</h1><p>通过源码可以发现，<code>enqueueMessage</code> 方法中，通过了 <code>synchronized</code> 关键字对 <code>MessageQueue</code> 进行了上锁的处理。保证了线程的同步。</p><h1 id="threadlocal在handler机制中的作用"><a class="markdownIt-Anchor" href="#threadlocal在handler机制中的作用"></a> <code>ThreadLocal</code>在<code>Handler</code>机制中的作用</h1><blockquote><p>ThreadLocal 更多细节：</p><ul><li>[ThreadLocal 解析 <a href="https://luoyu-ying.github.io/posts/03160a3be19b/">转载] | 洛语 の Blog (luoyu-ying.github.io)</a></li></ul></blockquote><p><code>Threadlocal</code>内部是一个<code>Map</code>实现，以当前线程<code>Threadlocal</code>为键，以<code>Looper</code>为值进行绑定，<strong>保证一个线程对应一个<code>Looper</code></strong>。</p><h1 id="当activity有多个handler的时候怎么样区分当前消息由哪个handler处理"><a class="markdownIt-Anchor" href="#当activity有多个handler的时候怎么样区分当前消息由哪个handler处理"></a> 当<code>Activity</code>有多个<code>Handler</code>的时候，怎么样区分当前消息由哪个<code>Handler</code>处理</h1><p>在<code>Looper#loop</code>中，<code>Looper</code>把<code>message</code>直接交给了<code>target</code>即发送这个消息的<code>handler</code>处理。</p><h1 id="handler-如何与-looper-关联的"><a class="markdownIt-Anchor" href="#handler-如何与-looper-关联的"></a> <code>Handler</code> 如何与 <code>Looper</code> 关联的</h1><p>通过 ThreadLocal 进行关联。</p><h1 id="looper-如何与-thread-关联的"><a class="markdownIt-Anchor" href="#looper-如何与-thread-关联的"></a> <code>Looper</code> 如何与 <code>Thread</code> 关联的</h1><p>通过 ThreadLocal 进行关联。</p><h1 id="通过handler如何实现线程的切换"><a class="markdownIt-Anchor" href="#通过handler如何实现线程的切换"></a> 通过<code>Handler</code>如何实现线程的切换</h1><p>实际线程间切换，就是通过<strong>线程间共享变量</strong>实现的。</p><p>在A线程new handler()，在b线程调用这个handler发送消息，这个message发送到了，A线程中的 messageQueue里面，又回到了a线程中执行。</p><h1 id="android中为什么主线程不会因为looperloop里的死循环卡死"><a class="markdownIt-Anchor" href="#android中为什么主线程不会因为looperloop里的死循环卡死"></a> <code>Android</code>中为什么主线程不会因为<code>Looper#loop</code>里的死循环卡死？</h1><p>主线程确实是阻塞的,不阻塞那<code>APP</code>怎么能一直运行？</p><p>所以说主线程阻塞是一个伪命题,只不过是没有弄明白既然阻塞了,为什么还能调用各种声明周期而已。</p><p>调用生命周期是因为有<code>Looper</code>,有<code>MessageQueue</code>,还有沟通的桥梁<code>Handler</code>,通过<code>IPC</code>机制调用<code>Handler</code>发送各种消息,保存到<code>MessageQueue</code>中,然后在主线程中的<code>Looper</code>提取了消息,并在主线程中调用<code>Handler</code>的方法去处理消息.最终完成各种声明周期。</p><h1 id="messagequeuenext-在没有消息的时候会阻塞如何恢复"><a class="markdownIt-Anchor" href="#messagequeuenext-在没有消息的时候会阻塞如何恢复"></a> <code>MessageQueue#next</code> 在没有消息的时候会阻塞，如何恢复？</h1><p>用 <code>MessageQueue#enqueueMessage</code> 时会唤醒 <code>MessageQueue</code>，这个方法会被 <code>Handler#sendMessage</code>、<code>Handler#post</code> 等一系列发送消息的方法调用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;handler的实现原理&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#handler的实现原理&quot;&gt;&lt;/a&gt; &lt;code&gt;Handler&lt;/code&gt;的实现原理&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;答案参考自：&lt;/p&gt;
&lt;ul&gt;
</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="Handler" scheme="https://luoyu-ying.github.io/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>View事件分发 - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/0557737935e1/"/>
    <id>https://luoyu-ying.github.io/posts/0557737935e1/</id>
    <published>2022-05-16T13:19:02.000Z</published>
    <updated>2022-05-20T14:48:19.085Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/qq_40959750/article/details/119218780">View事件分发相关面试题_打架不行的二哈的博客-CSDN博客_事件分发机制面试题</a></li></ul></blockquote><h1 id="view事件分发机制"><a class="markdownIt-Anchor" href="#view事件分发机制"></a> <code>View</code>事件分发机制</h1><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/22046c435b7d49f29b7ad04214c4c2fb.png" alt="" /></p><h1 id="事件是先到-decorview-还是先到-window"><a class="markdownIt-Anchor" href="#事件是先到-decorview-还是先到-window"></a> 事件是先到 <code>DecorView</code> 还是先到 <code>Window</code></h1><p>由上述流程图中可以得知，事件的分发顺序为</p><p><code>Activity -&gt; Window -&gt; DecorView -&gt; ViewGroup -&gt; View</code></p><h1 id="view的ontouchevent-onclicklisterner和ontouchlistener的ontouch方法的三者优先级"><a class="markdownIt-Anchor" href="#view的ontouchevent-onclicklisterner和ontouchlistener的ontouch方法的三者优先级"></a> <code>View</code>的<code>onTouchEvent</code>、<code>OnClickListerner</code>和<code>OnTouchListener</code>的<code>onTouch</code>方法的三者优先级</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://cloud.tencent.com/developer/article/1333422">Android View的Touch事件分发</a></li></ul></blockquote><p>点击事件的执行顺序为</p><p><code>OnTouchListener.DOWN -&gt; OnTouchEvent.DOWN -&gt; OnTouchListener.MOVE -&gt; OnTouchEvent.MOVE -&gt; OnTouchListener.UP -&gt; OnTouchEvent.UP -&gt; OnClickListener</code></p><p>所以三者的优先级为</p><p><code>OnTouchListener &gt; onTouchEvent &gt; onClick</code></p><h1 id="ontouch-和-ontouchevent-的区别"><a class="markdownIt-Anchor" href="#ontouch-和-ontouchevent-的区别"></a> <code>onTouch</code> 和 <code>onTouchEvent</code> 的区别</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/huiguixian/article/details/22193977">Android View的onTouchEvent和OnTouch区别_小小攻城师的博客-CSDN博客_ontouch和ontouchevent区别</a></li></ul></blockquote><ol><li><p><code>onTouchListener</code>的<code>onTouch</code>方法优先级比<code>onTouchEvent</code>高，会先触发。</p></li><li><p>假如<code>onTouch</code>方法返回false会接着触发<code>onTouchEvent</code>，反之<code>onTouchEvent</code>方法不会被调用。</p></li><li><p>内置诸如<code>click</code>事件的实现等等都基于<code>onTouchEvent</code>，假如<code>onTouch</code>返回<code>true</code>，这些事件将不会被触发。</p></li></ol><h1 id="activity-viewgroup和view都不消费action_down那么action_up事件是怎么传递的"><a class="markdownIt-Anchor" href="#activity-viewgroup和view都不消费action_down那么action_up事件是怎么传递的"></a> <code>Activity</code> 、<code>ViewGroup</code>和<code>View</code>都不消费<code>ACTION_DOWN</code>,那么<code>ACTION_UP</code>事件是怎么传递的</h1><p>首先，如果大家都不消费 ACTION_DOWN，那么 ACTION_DOWN 的事件传递流程是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Activity.dispatchTouchEvent() </span><br><span class="line">-&gt; ViewGroup1.dispatchTouchEvent() </span><br><span class="line">-&gt; ViewGroup1.onInterceptTouchEvent()</span><br><span class="line">-&gt; view1.dispatchTouchEvent() </span><br><span class="line">-&gt; view1.onTouchEvent() </span><br><span class="line">-&gt; ViewGroup1.onTouchEvent() </span><br><span class="line">-&gt; Activity.onTouchEvent();</span><br></pre></td></tr></table></figure><p>接着，由于大家都不消费 ACTION_DOWN，对于 ACTION_MOVE 和 ACTION_UP 的事件传递是这样的</p><p>接着，由于大家都不消费 ACTION_DOWN，对于 ACTION_MOVE 和 ACTION_UP 的事件传递是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Activity.dispatchTouchEvent()</span><br><span class="line">-&gt; Activity.onTouchEvent();</span><br><span class="line">-&gt; 消费</span><br></pre></td></tr></table></figure><h1 id="点击事件被拦截但是想传到下面的view如何操作"><a class="markdownIt-Anchor" href="#点击事件被拦截但是想传到下面的view如何操作"></a> 点击事件被拦截，但是想传到下面的<code>View</code>，如何操作</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getParent().requestDisallowInterceptTouchEvent(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>可将点击事件传到下面的<code>View</code>, 剥夺了父<code>View</code> 对除了<code>ACTION_DOWN</code>以外的事件的处理权。</p><h1 id="如何解决view的事件冲突"><a class="markdownIt-Anchor" href="#如何解决view的事件冲突"></a> 如何解决<code>View</code>的事件冲突</h1><h2 id="三种出现滑动冲突的情况"><a class="markdownIt-Anchor" href="#三种出现滑动冲突的情况"></a> 三种出现滑动冲突的情况</h2><ol><li><code>内部View</code>与<code>外部View</code>的滑动方向相反。</li><li><code>内部View</code>与<code>外部View</code>的滑动方向相同。</li><li>前两种情况的嵌套。</li></ol><p>三种情况的处理思路：</p><ol><li>通过手势滑动的角度判断滑动的方向。</li><li>通过当前处于的不同的页面状态来判断应该滑动的<code>View</code>。</li><li>通过前两种的综合使用。</li></ol><h2 id="滑动冲突的解决方式"><a class="markdownIt-Anchor" href="#滑动冲突的解决方式"></a> 滑动冲突的解决方式</h2><h3 id="外部拦截法"><a class="markdownIt-Anchor" href="#外部拦截法"></a> 外部拦截法</h3><p>通过重写<strong>父容器的</strong><code>onInterceptTouchEvent</code>方法，所有的事件都先经过父容器的筛选，对其中父容器需要的事件进行拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">intercepted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) event.getX();</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) event.getY();</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN : &#123;</span><br><span class="line">            intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE : &#123;</span><br><span class="line">            <span class="keyword">if</span> (父容器需要当前的点击事件)</span><br><span class="line">                intercepted = <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">                intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP : &#123;</span><br><span class="line">            intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastXIntercept = x;</span><br><span class="line">    mLastYIntercept = y;</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部拦截法"><a class="markdownIt-Anchor" href="#内部拦截法"></a> 内部拦截法</h3><p>父元素拦截除<code>ACTION_DOWN</code>以外的其他事件，当事件到达子元素后，由子元素判断是否需要这些事件，不需要的事件将重新交由父容器来处理。这种方法和Android的事件分发机制不一致，需要配合<code>requestDisallowInterceptTouchEvent</code>方法才能正常的工作。</p><p>相关阅读链接：<a href="https://www.jianshu.com/p/fe3d109eb27e">Android TouchEvent之requestDisallowInterceptTouchEvent - 简书 (jianshu.com)</a></p><p><strong>子元素的<code>dispatchTouchEvent</code>方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) event.getX();</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) event.getY();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN : &#123;</span><br><span class="line">            parent.requestDisallowInterceptTouchEvent(<span class="literal">true</span>); <span class="comment">// 此子View的所有父ViewGroup会跳过onInterceptTouchEvent回调</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE : &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">deltaX</span> <span class="operator">=</span> x - mLastX;</span><br><span class="line">            <span class="type">int</span> <span class="variable">deltaY</span> <span class="operator">=</span> y - mLastY;</span><br><span class="line">            <span class="keyword">if</span> (父容器需要当前的点击事件) &#123;</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP : &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> : </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastX = x;</span><br><span class="line">    mLastY = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>父容器的<code>onInterceptTouchEvent</code>方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="requestdisallowintercepttouchevent的调用时机"><a class="markdownIt-Anchor" href="#requestdisallowintercepttouchevent的调用时机"></a> <code>requestDisallowInterceptTouchEvent</code>的调用时机</h1><p><strong><code>parent.requestDisallowInterceptTouchEvent</code>的调用需要写在<code>onTouchEvent</code>方法中</strong></p><p>我们一个手势的操作，会经历<code>ACTION_DOWN</code>、<code>ACTION_MOVE</code>、<code>ACTION_UP</code>等操作。</p><p>子<code>view</code>调用<code>requestDisallowInterceptTouchEvent(true)</code>的时间，是必须在能拿到点击事件的时候。</p><p>比如我们在<code>ACTION_DOWN</code>的时候调用了方法，接下来的<code>ACTION_MOVE</code>、<code>ACTION_UP</code>都会直接传递到子<code>view</code>上了；如果是在子<code>view</code>的<code>ACTION_MOVE</code>方法中调用的话，那么要确认父<code>view</code>在<code>ACTION_MOVE</code>的过程中，能否将事件传递给子<code>view</code>就好了。</p><h1 id="同时对父-view-和子-view-设置点击方法优先响应哪个"><a class="markdownIt-Anchor" href="#同时对父-view-和子-view-设置点击方法优先响应哪个"></a> 同时对父 <code>View</code> 和子 <code>View</code> 设置点击方法，优先响应哪个</h1><p>优先响应子 view。</p><p>如果先响应父 view，那么子 view 将永远无法响应。父 view 要优先响应事件，必须先调用 onInterceptTouchEvent 对事件进行拦截，那么事件不会再往下传递，直接交给父 view 的 onTouchEvent 处理。</p><p>Android系统中ViewGroup的拦截事件默认不拦截。</p><h1 id="action_cancel什么时候触发"><a class="markdownIt-Anchor" href="#action_cancel什么时候触发"></a> <code>ACTION_CANCEL</code>什么时候触发</h1><ol><li><p>如果在父<code>View</code>中拦截<code>ACTION_UP</code>或<code>ACTION_MOVE</code>，在第一次父视图拦截消息的瞬间，父视图指定子视图不接受后续消息了，同时子视图会收到<code>ACTION_CANCEL</code>事件。一般是系统自己处理</p></li><li><p>如果触摸某个控件，但是又不是在这个控件的区域上抬起（移动到别的地方了），就会出现<code>ACTION_CANCEL</code>。</p></li></ol><h1 id="为什么子-view-不消费-action_down之后的所有事件都不会向下传递了"><a class="markdownIt-Anchor" href="#为什么子-view-不消费-action_down之后的所有事件都不会向下传递了"></a> 为什么子 <code>View</code> 不消费 <code>ACTION_DOWN</code>,之后的所有事件都不会向下传递了</h1><p>答案是：<code>mFirstTouchTarget</code>。</p><p>当子 view 对事件进行处理的时，那么 <code>mFirstTouchTarget</code> 就会被赋值，若是子 <code>view</code> 不对事件进行处理，那么 <code>mFirstTouchTarget</code> 就为 <code>null</code>，之后 <code>VIewGroup</code> 就会默认拦截所有的事件。</p><p>我们可以从 <code>dispatchTouchEvent</code> 中找到如下代码，可以看出来，若是子 <code>View</code> 不处理 <code>ACTION_DOWN</code>,那么之后的事件也不会给到它了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否拦截</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 省略和问题无关代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 默认拦截</span></span><br><span class="line">    intercepted = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在-viewgroup-中的-ontouchevent-中消费-action_down-事件onintercepttouch-默认设置那么-action_move-和-action_up-事件是怎么传递的"><a class="markdownIt-Anchor" href="#在-viewgroup-中的-ontouchevent-中消费-action_down-事件onintercepttouch-默认设置那么-action_move-和-action_up-事件是怎么传递的"></a> 在 <code>ViewGroup</code> 中的 <code>onTouchEvent</code> 中消费 <code>ACTION_DOWN</code> 事件（<code>onInterceptTouch</code> 默认设置），那么 <code>ACTION_MOVE</code> 和 <code>ACTION_UP</code> 事件是怎么传递的？</h1><p>首先，我们先分析一下 ACTION_DOWN 的事件走向，由于 ViewGroup 中的 onInterceptTouch 是默认设置的，那么 ACTION_DOWN 的事件最终在 ViewGroup 中的 onTouchEvent 方法中停止了，事件走向是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Activity.dispatchTouchEvent() </span><br><span class="line">-&gt; ViewGroup1.dispatchTouchEvent() </span><br><span class="line">-&gt; ViewGroup1.onInterceptTouchEvent()</span><br><span class="line">-&gt; view1.dispatchTouchEvent() </span><br><span class="line">-&gt; view1.onTouchEvent() </span><br><span class="line">-&gt; ViewGroup1.onTouchEvent() </span><br></pre></td></tr></table></figure><p>接着 ACTION_MOVE 和 ACTION_UP 的事件分发流程，之后 onInterceptTouch 和 View 中的方法都不会被调用了，事件分发如下：</p><p>接着 ACTION_MOVE 和 ACTION_UP 的事件分发流程，之后 onInterceptTouch 和 View 中的方法都不会被调用了，事件分发如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Activity.dispatchTouchEvent() </span><br><span class="line">-&gt; ViewGroup1.dispatchTouchEvent() </span><br><span class="line">-&gt; ViewGroup1.onTouchEvent() </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;答案参考自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_40959750/article/details/119218780&quot;&gt;View事件分发相关面试题_打架不行的二哈的博客-CSDN博客_事件</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="View" scheme="https://luoyu-ying.github.io/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>Animation - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/004ee5be31d6/"/>
    <id>https://luoyu-ying.github.io/posts/004ee5be31d6/</id>
    <published>2022-05-15T11:30:02.000Z</published>
    <updated>2022-05-15T11:30:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动画的类型"><a class="markdownIt-Anchor" href="#动画的类型"></a> 动画的类型</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/luzaiyy611/article/details/82083213">Android 属性动画和补间动画的区别和特性_luzaiyy611的博客-CSDN博客_属性动画和补间动画的区别</a></li></ul></blockquote><ol><li><p>View 动画（补间动画）</p><p>只产生了一个动画效果，其真实的坐标并没有发生改变（只是改变了View的显示效果而已，并不会真正的改变View的属性）。View做在做动画的时候，它并没有真正的移动它的位置，而是根据动画时间的插值，计算出一个Matrix，然后不停的invalidate，在onDraw中的Canvas上使用这个计算出来的Matrix去draw这个View的内容，并有onLayout中还是原来的位置，所以点击事件只能点击到原来的位置才能触发</p></li><li><p>帧动画</p></li><li><p>属性动画</p><p>属性动画可以对任何对象的属性做动画而不仅仅是View，甚至可以没有对象。除了作用对象进行扩展外，属性动画的效果也加强了，不仅能实现View动画的四种效果，还能实现其它多种效果，这些效果都是通过<code>ValuAnimator</code>或<code>ObjectAnimator</code>、<code>AnimatorSet</code>等来实现的。我们只需要告诉系统动画的运行时长，需要执行哪种类型的动画，以及动画的初始值和结束值，剩下的工作就可以全部交给系统去完成了。</p></li></ol><h1 id="补间动画和属性动画的区别"><a class="markdownIt-Anchor" href="#补间动画和属性动画的区别"></a> 补间动画和属性动画的区别</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/lgdcoder/p/10684996.html">Android补间动画和属性动画的区别及属性动画使用详解</a></li></ul></blockquote><ol start="2"><li>作用对象不同，补间动画只能作用在view上，属性动画可以作用在所有对象上。</li><li>属性变化不同，补间动画只是改变显示效果，不会改变view的属性，比如位置、宽高等，而属性动画实际改变对象的属性。</li><li>动画效果不同，补间动画只能实现位移、缩放、旋转和透明度四种动画操作，而属性动画还能实现补间动画所有效果及其他更多动画效果。</li></ol><h1 id="objectanimatorvalueanimator及其区别"><a class="markdownIt-Anchor" href="#objectanimatorvalueanimator及其区别"></a> <code>ObjectAnimator</code>，<code>ValueAnimator</code>及其区别</h1><p><strong>ValueAnimator</strong></p><p>ValueAnimator是整个属性动画机制当中最核心的一个类，前面我们已经提到了，属性动画的运行机制是通过不断地<strong>对值进行操作</strong>来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等，确实是一个非常重要的类。</p><p><strong>ObjectAnimator</strong></p><p>相比于ValueAnimator，ObjectAnimator可能才是我们最常接触到的类，因为ValueAnimator只不过是对值进行了一个平滑的动画过渡，但我们实际使用到这种功能的场景好像并不多。而ObjectAnimator则就不同了，它是可以直接<strong>对任意对象的任意属性进行动画操作</strong>的，比如说View的alpha属性。</p><p>不过虽说ObjectAnimator会更加常用一些，但是它其实是继承自ValueAnimator的，底层的动画实现机制也是基于ValueAnimator来完成的，因此ValueAnimator仍然是整个属性动画当中最核心的一个类。</p><p><strong>总结</strong></p><p><code>ValueAnimator</code> 是<strong>对 数值 进行平滑操作</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ValueAnimator</span> <span class="variable">anim</span> <span class="operator">=</span> ValueAnimator.ofFloat(<span class="number">0f</span>, <span class="number">1f</span>);  </span><br></pre></td></tr></table></figure><p><code>ObjectAnimator</code> 功能更加强大，是<strong>对 任意对象 的 任意属性值 进行平滑操作</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectAnimator</span> <span class="variable">animator</span> <span class="operator">=</span> ObjectAnimator.ofFloat(textview, <span class="string">&quot;alpha&quot;</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>);</span><br></pre></td></tr></table></figure><h1 id="timeinterpolator插值器typeevaluator估值器"><a class="markdownIt-Anchor" href="#timeinterpolator插值器typeevaluator估值器"></a> TimeInterpolator插值器，TypeEvaluator估值器</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://luoyu-ying.github.io/posts/89ece43bd0a9/">Android 动画深入分析 | 洛语 の Blog (luoyu-ying.github.io)</a></li></ul></blockquote><p>插值器和估值器是实现非匀速动画的重要手段。</p><h3 id="timeinterpolator"><a class="markdownIt-Anchor" href="#timeinterpolator"></a> <code>TimeInterpolator</code></h3><p>时间插值器。作用为<strong>根据时间的流逝的百分比计算当前属性值改变的百分比</strong>。</p><p>预设的有多种插值器，常见的三种如下：</p><ol><li><code>LinearInterpolator</code>——线性插值器：匀速动画</li><li><code>AccelerateDecelerateInterpolator</code>——加速减速插值器：动画两头慢中间快</li><li><code>DecelerateInterpolator</code>——减速插值器：动画越来越慢</li></ol><p>三个类都实现了<code>Interpolartor</code>接口，接口内部只有一个用来计算属性值的改变的百分比的<code>getInterpolation</code>方法需要实现。</p><h3 id="typeevaluator"><a class="markdownIt-Anchor" href="#typeevaluator"></a> <code>TypeEvaluator</code></h3><p>类型估值算法，也叫估值器。作用是<strong>根据属性值改变的百分比来计算改变后的属性值</strong>。</p><p>系统预置的有3种：</p><ol><li><code>IntEvaluator</code>：针对整形属性</li><li><code>FloatEvaluator</code>：针对浮点型属性</li><li><code>ArgbEvaluator</code>：针对Color属性</li></ol><p>三个类都实现了<code>TypeEvalator</code>接口，接口内部只有一个用来计算改变后的属性值的<code>evaluate</code>方法需要实现。</p><h3 id="计算顺序"><a class="markdownIt-Anchor" href="#计算顺序"></a> 计算顺序</h3><p>系统会根据当前的帧所在时刻与动画播放的总时间求出时间的流逝的百分比，再通过插值器计算出当前属性值改变的百分比，后用此值通过估值器计算出当前的属性改变后的确定的值是多少并通过<code>set</code>方法对属性赋值。</p><p>故属性动画要求对象的该属性有<code>set</code>方法（必须有）和<code>get</code>方法（可选）。</p><h1 id="自定义插值器和估值器"><a class="markdownIt-Anchor" href="#自定义插值器和估值器"></a> 自定义插值器和估值器</h1><p>我们可以自定义插值器和估值器，来实现自己想要的动画效果。实现方式也很简单。</p><p>因为插值器和估值器都是一个接口，且内部都只有一个方法，所以我们只需要派生一个类并实现接口就可以了，然后就可以做出千奇百怪的动画效果了。即：</p><ul><li>自定义插值器需要实现<code>Interpolator</code>或者<code>TimeInterpolator</code>接口</li><li>自定义估值器需要实现<code>TypeEvaluator</code>接口。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动画的类型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#动画的类型&quot;&gt;&lt;/a&gt; 动画的类型&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;答案参考自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="Animation" scheme="https://luoyu-ying.github.io/tags/Animation/"/>
    
  </entry>
  
  <entry>
    <title>Typora 流程图中文字显示不全 [转载]</title>
    <link href="https://luoyu-ying.github.io/posts/b97556f04186/"/>
    <id>https://luoyu-ying.github.io/posts/b97556f04186/</id>
    <published>2022-05-14T15:49:44.000Z</published>
    <updated>2022-05-21T04:52:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：</p><ul><li><a href="https://blog.csdn.net/qq_28225871/article/details/119521382">Typora流程图中文字显示不全解决_日之朝矣的博客-CSDN博客_typora流程图不显示</a></li></ul></blockquote><p>最近使用 Typora 的流程图，发现流程图里的字总是显示不全，让我感觉十分难受，百度去搜解决方案，却没有人回答，因此写下此文。</p><p>这个是主题的问题，更改为 Github 主题，发现仍然显示不全，但是更改为 PixyII 主题却能正常使用了，推测从官方那里下载来的部分主题是基于 Github 主题进行修改。</p><p>我喜欢我现在的主题，不想换，下面是我的解决方法。</p><p><strong>文件 &gt;&gt; 偏好设置 &gt;&gt; 外观 &gt;&gt; 打开主题文件夹</strong></p><p>找到当前主题对应的 CSS 文件，比如 <code>Github.css</code> ，用记事本或者 VSCode 打开，翻到最下面，另起一行，添加如下代码，保存后，关闭所有 Typora 窗口，重新启动便可解决问题。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.md-require-zoom-fix</span> foreignObject &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: unset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局限性就是需要把自己喜欢的主题一个一个文件进行添加，但本人日常只用那一个主题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_28225871/article/details/119521382&quot;&gt;Typora流程图中文字显示不全解决_日之朝矣的博客-CSDN博客_</summary>
      
    
    
    
    <category term="Markdown" scheme="https://luoyu-ying.github.io/categories/Markdown/"/>
    
    
    <category term="Typora" scheme="https://luoyu-ying.github.io/tags/Typora/"/>
    
  </entry>
  
  <entry>
    <title>View绘制 - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/76aedbc4e682/"/>
    <id>https://luoyu-ying.github.io/posts/76aedbc4e682/</id>
    <published>2022-05-14T12:02:02.000Z</published>
    <updated>2022-05-14T14:02:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="view-的绘制流程"><a class="markdownIt-Anchor" href="#view-的绘制流程"></a> View 的绘制流程</h1><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-3d1255a5093de81fd5bdc27a300d2f0d_720w.jpg" alt="" /></p><h1 id="measurespec-是什么"><a class="markdownIt-Anchor" href="#measurespec-是什么"></a> <code>MeasureSpec</code> 是什么</h1><blockquote><p><code>spec</code> <strong><code>英[spek]</code></strong><code>n.</code>规格 <code>vt.</code>按特定标准设计并制造</p></blockquote><p><code>MeasureSpec</code>参与了<code>View</code>的<code>measure</code>过程。在测量过程中，系统将<code>View</code>的<code>LayoutParams</code>根据父容器所施加的规则转换成对应的<code>MeasureSpec</code>，然后再根据这个<code>MeasureSpec</code>来测量出<code>View</code>的测量宽/高。</p><p><code>MeasureSpec</code>代表一个32位的<code>int</code>值，高两位代表 测量模式<code>SpecMode</code>，低30位代表 该测量模式下的规格大小<code>SpecSize</code>。</p><p><code>MeasureSpec</code>与<code>SpecMode</code>、<code>SpecSize</code>之间可以通过位运算互相求出。</p><p>每个<code>View</code>的<code>measure</code>过程之前都会先计算其<code>MeasureSpec</code>的值，然后再对其进行<code>measure</code>。</p><p><strong>注意</strong>：<code>View</code>的宽和高各有一个<code>MeasureSpec</code>值，分别为<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>。</p><p><strong><code>SpecMode</code>的三种状态</strong></p><ol><li><p><code>UNSPECIFIED</code></p><p>父容器不对<code>View</code>做任何的限制，要多大给多大。<strong>这种情况一般用于系统的内部</strong>，表示一种测量方式的状态。</p></li><li><p><code>EXACTLY</code></p><p>父容器已经测出了<code>View</code>所需要的精确大小，此时的大小就是<code>View</code>的最终大小。</p><p>它对应于<code>LayoutParams</code>的<code>match_parent</code>和具体的数值这两种模式。</p></li><li><p><code>AT_MOST</code></p><p>父容器指定了一个可用的大小，<code>View</code>的大小不能大于这个值。</p><p>它对应于<code>LayoutParams</code>中的<code>wrap_content</code>。</p></li></ol><h1 id="子view创建measurespec创建规则是什么"><a class="markdownIt-Anchor" href="#子view创建measurespec创建规则是什么"></a> 子View创建<code>MeasureSpec</code>创建规则是什么</h1><p><strong><code>MeasureSpec</code>和<code>LayoutParams</code>的对应关系</strong></p><p>对于<code>DecorView</code>和普通<code>View</code>来说，<code>MeasureSpec</code>的转化过程略有不同。</p><p><strong>对于<code>DecorView</code>：</strong></p><p><strong><code>DecorView</code>的<code>MeasureSpec</code>由窗口的大小和<code>DecorView</code>自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在<code>ViewRootImpl</code>中的<code>measureHierarchy</code>方法中，调用<code>getRootMeasureSpec</code>方法，获得<code>DecorView</code>的<code>MeasureSpec</code>。</p><p>其中<code>getRootMeasureSpec</code>方法中，根据自身<code>LayoutParams</code>的不同大小，共有三种情况：</p><ol><li><code>LayoutParams.MATCH_PARENT</code>：精确模式，大小就是窗口的大小。</li><li><code>LayoutParams.WRAP_CONTENT</code>：最大模式，大小不定，但是不能超过窗口的大小。</li><li>固定大小(比如100dp)：精确模式，大小为<code>LayoutParams</code>中指定的大小。</li></ol><p><strong>对于普通<code>View</code>：</strong></p><p><strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><p>通过在父容器的<code>measureChildWithMargins</code>中的<code>getChildMeasureSpec</code>方法获得<code>View</code>的<code>MeasureSpec</code>。</p><p>其中<code>getChildMeasureSpec</code>方法的参数中使用到了父容器的<code>MeasureSpec</code>。在这个方法中通过<code>switch</code>和<code>if</code>语句，对<code>View</code>的<code>MeasureSpec</code>进行了决定。结果如下：</p><table><thead><tr><th><code>↓childLayoutParams</code> \ <code>parentMeasureSpec→</code></th><th><code>EXACTLY</code></th><th><code>AT_MOST</code></th><th><code>UNSPECIFIED</code></th></tr></thead><tbody><tr><td><code>dp</code>/<code>px</code></td><td><code>EXACTLY</code><br>childSize</td><td><code>EXACTLY</code><br/>childSize</td><td><code>EXACTLY</code><br/>childSize</td></tr><tr><td><code>match_parent</code></td><td><code>EXACTLY</code><br/>parentSize</td><td><code>AT_MOST</code><br>parentSize</td><td><code>UNSPECIFIED</code><br>0</td></tr><tr><td><code>wrap_content</code></td><td><code>AT_MOST</code><br>parentSize</td><td><code>AT_MOST</code><br/>parentSize</td><td><code>UNSPECIFIED</code><br/>0</td></tr></tbody></table><p>上图可以简单记为：除了<code>dp</code>/<code>px</code>的精确模式情况外，三种<code>MeasureSpec</code>的级别为：<code>EXACTLY</code> &lt; <code>AT_MOST</code> &lt; <code>UNSPECIFIED</code> 且<code>childMeasureSpec</code> = max(<code>childLayoutParams</code> , <code>parentMeasureSpec</code>)。（<strong>实际上并无级别之分</strong>）</p><p>通过上面的表格，可以更加直观的看出：<strong>普通<code>View</code>的<code>MeasureSpec</code>由父容器的<code>MeasureSpec</code>和自身的<code>LayoutParams</code>共同决定的。</strong></p><h1 id="自定义view-wrap_content不起作用的原因"><a class="markdownIt-Anchor" href="#自定义view-wrap_content不起作用的原因"></a> 自定义View <code>wrap_content</code>不起作用的原因</h1><p>对于直接继承<code>View</code>的自定义<code>View</code>来说，<strong>需要重写<code>onMeasure</code>方法并设置在<code>wrap_content</code>情况时的自身大小</strong>，否则在布局中使用<code>wrap_content</code>就相当于使用<code>match_parent</code>。</p><p>因为当自定义<code>View</code>处于<code>wrap_content</code>时，它的<code>SpecMode</code>为<code>AT_MOST</code>模式，由前文可知，当父容器无论为<code>AT_MOST</code>还是<code>ECACTLY</code>模式时，自定义<code>View</code>都为<code>AT_MOST</code>模式且尺寸大小为<code>parentSize</code>，也就是父容器的剩余空间，即自定义<code>View</code>的大小变得与父容器的剩余空间大小一致，显然不是我们需要的。</p><p><strong>解决方法：</strong></p><p>解决方法也是非常简单的。我们只需要在<code>onMeasure</code>方法中对</p><ol><li>仅<code>width</code>方向为<code>AT_MOST</code>模式</li><li>仅<code>height</code>方向为<code>AT_MOST</code>模式</li><li><code>width</code>方向以及<code>height</code>方向都为<code>AT_MOST</code>模式</li><li>其他的情况</li></ol><p>这四个状态单独判断，分别使用<code>setMeasuredDimension</code>方法直接为自定义<code>View</code>设置我们需要的值即可。</p><p>源码中对于<code>TextView</code>、<code>ImageView</code>等控件的<code>wrap_content</code>也做了特殊的处理。</p><h1 id="在activity中获取某个view的宽高有几种方法"><a class="markdownIt-Anchor" href="#在activity中获取某个view的宽高有几种方法"></a> 在Activity中获取某个View的宽高有几种方法</h1><p>由于<code>Activity</code>的启动和<code>View</code>的测量过程并不是同步进行的，因此无法保证在<code>Activity</code>启动时某个<code>View</code>已经测量完毕了。所以我们在<code>Activity</code>启动的时候，如果直接通过<code>getMeasuredWidth</code>/<code>getMeasuredHeight</code>方法获得的值可能为0。</p><p>以下有四种方法可以解决这个问题（详细代码见《Android开发艺术探索》190页）。</p><ol><li><p><code>Activity/View#onWindowFocusChanged</code></p><p>在<code>Activity</code>的<code>onResume</code>和<code>onPause</code>方法启动时，<code>onWindowFocusChanged</code>方法也会同时被调用，可以重写里面的内容，使之计算<code>View</code>的宽高。</p><p><strong>注意</strong>：<code>onWindowFocusChanged</code>方法会在<code>View</code>已经初始化完毕后才开始调用。</p></li><li><p><code>view.post(runnable)</code></p><p>通过<code>post</code>可以将一个<code>runnable</code>投递都消息队列的尾部，然后等待<code>Looper</code>调用此<code>runnable</code>的时候，<code>View</code>也已经初始化好了。</p></li><li><p><code>ViewTreeObserver</code></p><p><code>ViewTreeObserver</code>中的众多回调可以完成这个功能。</p><p>比如<code>OnGlobalLayoutListener</code>接口，当<code>View</code>树的状态发生改变或者<code>View</code>树内部的<code>View</code>的可见性发生改变的时候，<code>onGlobalLayout</code>方法将被回调，此时就可以获取<code>View</code>的宽高了。</p></li><li><p><code>view.measure(int widthMeasureSpec, int heightMeasureSpec)</code></p><p>可以主动调用该方法开始计算<code>view</code>的宽高。</p><ol><li><p><strong><code>match_parent</code></strong></p><p>由于正常的<code>measure</code>过程中，我们需要父容器的<code>MeasureSpec</code>的值，而此时父容器并没开始计算，我们无从得知这两个值的大小。故我们无法对<code>match_parent</code>的<code>view</code>计算其宽高。</p></li><li><p><strong><code>dp</code>/<code>px</code></strong></p><p>因为有精确的数值了，所以我们可以直接使用这个精确的数值通过<code>MeasureSpec.makeMeasureSpec</code>方法构建<code>view</code>的<code>MeasureSpec</code>。</p></li><li><p><strong><code>wrap_content</code></strong></p><p>直接将<code>MeasureSpec.makeMeasureSpec</code>方法中参数的值设置为<code>(1&lt;&lt;30)-1</code>即可，这是<code>View</code>理论上可以支持的最大值，所以这样构建<code>MeasureSpec</code>是合理的。</p></li></ol></li></ol><h1 id="oncreate-onresume中可以获取view的宽高吗怎么做brviewpost-为什么可以获取"><a class="markdownIt-Anchor" href="#oncreate-onresume中可以获取view的宽高吗怎么做brviewpost-为什么可以获取"></a> <code>onCreate</code>、<code>onResume</code>中可以获取View的宽高吗？怎么做？<br><code>View#post</code> 为什么可以获取？</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/qq_40714317/article/details/117666277">onCreate()、onResume() 中可以获取View的宽高吗？怎么做？ View.post{} 为什么可以获取？_qq_40714317的博客</a></li><li><a href="https://github.com/Moosphan/Android-Daily-Interview/issues/126">2019-08-21：View.post()为什么可以获取到宽高信息？ · Issue #126 · Moosphan/Android-Daily-Interview </a></li></ul></blockquote><p><strong><code>onCreate</code>、<code>onResume</code>中可以获取View的宽高吗？怎么做？</strong></p><p>View 的测绘绘制流程就是从 ViewRootImpl#performTraversals() 开始的，而这个方法的调用是在 onResume() 方法之后，所以在 onCreate() 和 onResume() 方法中拿不到 View 的测量值。</p><p>View的宽高是在onLayout阶段才能最终确定的，而在Activity#onCreate中并不能保证View已经执行到了onLayout方法，也就是说Activity的声明周期与View的绘制流程并不是一一绑定。所以onCreate() 和 onResume() 中获取不到View的宽高值。以Handler为基础，View.post() 将传入任务的执行时机调整到View 绘制完成之后。</p><p><strong><code>View#post</code> 为什么可以获取？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">view.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> view.getWidth();</span><br><span class="line"><span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> view.getHeight();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样写一般是在 Activity 的 onResume 方法中，因为 onResume 执行在 View 初始化之前，如果在 onResume 中直接获取 View 宽高是获取不到的。</p><p>使用 view.post 就能获取到，因为 view.post 是向 主 Handler 的 MessageQueue 中插入一条待执行消息，但是因为系统在 ViewRoot 中初始化 View 时也是利用 Handler 机制，平且为了优先执行 View 的初始化设置了同步屏障，导致 view.post 插入的消息会在 View 初始化之后执行，那么肯定就能获取到 View 的宽高啦！</p><p><strong><code>Runnable</code>的执行时机具体是什么</strong></p><p>在 <strong>Android 7.0</strong> 之后，view.post()中的runnbale 能确定被执执行。具体来说：</p><p>Android 7.0之后，除了<code>performTraversal</code>中会调用外，在View的<code>dispatchAttachedToWindow</code>中也会调用，但Android 7.0之后不管在主线程还是在子线程都可以成功执行<code>view.post</code>内部逻辑，并不是因为增加了调用时机，而是取消了<code>ThreadLocal</code>机制，使得 <strong>不管在主线程还是子线程调用view.post方法，都会将runnable对象丢到主线程的任务队列中，更新UI或者获取view的信息</strong>。</p><h1 id="viewpost与handlerpost的区别"><a class="markdownIt-Anchor" href="#viewpost与handlerpost的区别"></a> <code>View#post</code>与<code>Handler#post</code>的区别</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/7280b2d3b4d1">Handler.post和View.post的区别 - 简书 (jianshu.com)</a></li></ul></blockquote><ol><li><p><code>Handler.post</code>，它的执行时间基本是等同于<code>onCreate</code>里那行代码触达的时间；</p></li><li><p>View.post，则不同，它说白了执行时间一定是在<code>Activity#onResume</code>发生后才开始算的；或者换句话说它的效果相当于你上面的<code>View.post</code>方法是写在<code>Activity#onResume</code>里面的（但只执行一次，因为<code>onCreate</code>不像onResume会被多次触发）；</p></li><li><p>当然，虽然这里说的是<code>post</code>方法，但对应的<code>postDelayed</code>方法区别也是类似的。</p></li></ol><h1 id="getwidth方法和getmeasurewidth方法的区别"><a class="markdownIt-Anchor" href="#getwidth方法和getmeasurewidth方法的区别"></a> <code>getWidth()</code>方法和<code>getMeasureWidth()</code>方法的区别</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/7d8a54dd692f">getMeasureWidth和getWidth的区别 - 简书 (jianshu.com)</a></li><li><a href="https://www.cnblogs.com/yongdaimi/p/13612622.html">android: View的getWidth() 和 getMeasureWidth()方法的区别 - 夜行过客 - 博客园 (cnblogs.com)</a></li></ul></blockquote><ol><li><p><code>getMeasureWidth()</code>方法在<code>measure()</code>过程结束后就可以获取到了，而<code>getWidth()</code>方法要在<code>layout()</code>过程结束后才能获取到。<code>getMeasuredWidth()</code>获取的是<code>View</code>原始的大小，也就是这个<code>View</code>在<code>XML</code>文件中配置或者是代码中设置的大小。<code>getWidth()</code>获取的是这个<code>View</code>最终显示的大小，这个大小有可能等于原始的大小，也有可能不相等。只要在代码里重新修改了子控件的摆放位置，<code>getWidth()</code>和<code>getMeasureWidth()</code>的值就会不同。</p></li><li><p><code>getMeasureWidth()</code>方法中的值是通过<code>setMeasuredDimension()</code>方法来进行设置的，而<code>getWidth()</code>方法中的值则是通过视图右边的坐标减去左边的坐标计算出来的。</p></li></ol><h1 id="view加载流程setcontentview"><a class="markdownIt-Anchor" href="#view加载流程setcontentview"></a> View加载流程（setContentView）</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/pgg_cold/article/details/79481301"> Android面试题（28）-android的view加载和绘制流程_胖哥哥飘过的博客-CSDN博客_android view加载流程</a></li></ul></blockquote><ol><li><p>通过Activity的setContentView方法间接调用Phonewindow的setContentView()，在PhoneWindow中通过getLayoutInflate()得到LayoutInflate对象。</p></li><li><p>通过LayoutInflate对象去加载View，主要步骤是：</p><ol><li>通过xml的Pull方式去解析xml布局文件，获取xml信息，并保存缓存信息，因为这些数据是静态不变的。</li><li>根据xml的tag标签通过反射创建View逐层构建View。</li><li>递归构建其中的子View，并将子View添加到父ViewGroup中。</li></ol></li></ol><p>其中，有四种加载XML文件的常用方法：</p><ol><li><p>使用view的静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> View.inflate(context, R.layout.child, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过系统获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LayoutInflater</span> <span class="variable">inflater</span> <span class="operator">=</span> (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> inflater.inflate(R.layout.child, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过LayoutInflater</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LayoutInflater</span> <span class="variable">inflater</span> <span class="operator">=</span> LayoutInflater.from(context);</span><br><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> inflater.inflate(R.layout.child, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过getLayoutInflater</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">View</span> <span class="variable">view</span> <span class="operator">=</span> getLayoutInflater().inflate(R.layout.child, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure></li></ol><p>View 加载过程结束后，便会开始 View 的绘制流程了。</p><h1 id="invalidate-和-postinvalidate-的区别"><a class="markdownIt-Anchor" href="#invalidate-和-postinvalidate-的区别"></a> <code>invalidate()</code> 和 <code>postInvalidate()</code> 的区别</h1><p>这两个方法都是在<strong>重绘当前控件</strong>的时候调用的。</p><p><strong>invalidate在UI线程中调用，postInvalidate在非UI线程中调用。</strong> 因为android的UI线程是非线程安全的，所以在非UI线程中，需要使用postInvalidate来使View重绘。</p><p>view调用invalidate将导致当前view的重绘（draw调用），view的父类将不会执行draw方法；viewGroup调用invalidate会使viewGroup的子view调用draw，也就是viewGroup内部的子view进行重绘。</p><h1 id="requestlayout-和-onlayout-的区别"><a class="markdownIt-Anchor" href="#requestlayout-和-onlayout-的区别"></a> <code>requestLayout()</code> 和 <code>onLayout()</code> 的区别</h1><p><strong>requestLayout()</strong></p><p><code>requestLayout</code>方法只会<strong>导致当前<code>view</code>的<code>measure</code>和<code>layout</code></strong>，而<code>draw</code>不一定被执行，只有当<code>view</code>的位置发生改变才会执行<code>draw</code>方法，因此如果要使当前<code>view</code>重绘需要调用<code>invalidate</code>。</p><p><strong>onLayout()</strong></p><p>在很多情况下requestLayout是不需要被调用的。</p><p>例如，我们把一个AbsoluteLayout里面的childView挪动一下位置。我们仅仅需要调用的可能就是重新布局当前AbsoluteLayout，然后调用invalidate方法进行重绘。而不是从当前View向上的整个View树形结构都要重新layout，onLayout，measure，onMeasure一次。在这种情况下可以直接调用onLayout。然后调用invalidate进行重绘。很明显可以提升绘制效率。</p><p>由于父View的layout实现了会通知布局的listener。但是由于无法得到listener，因此调用onlayout的时候无法对其进行通知，这也是这种实现的缺陷。</p><h1 id="自定义-view-的流程和注意事项"><a class="markdownIt-Anchor" href="#自定义-view-的流程和注意事项"></a> 自定义 View 的流程和注意事项</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/b0f0d5462d16">自定义View学习–定义View流程和注意事项 - 简书 (jianshu.com)</a></li><li><a href="https://blog.csdn.net/lmj623565791/article/details/38339817"> Android 手把手教您自定义ViewGroup（一）_鸿洋_的博客-CSDN博客_自定义viewgroup</a></li></ul></blockquote><hr /><h1 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> TODO</h1><ol><li>invalidate怎么局部刷新</li><li>Android绘制和屏幕刷新机制原理`</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;view-的绘制流程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#view-的绘制流程&quot;&gt;&lt;/a&gt; View 的绘制流程&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://lly-blog-img.oss-cn-hangzhou.a</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="View" scheme="https://luoyu-ying.github.io/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/743419965876/"/>
    <id>https://luoyu-ying.github.io/posts/743419965876/</id>
    <published>2022-05-13T09:14:02.000Z</published>
    <updated>2022-05-20T14:48:14.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="recyclerview-为什么要预布局"><a class="markdownIt-Anchor" href="#recyclerview-为什么要预布局"></a> RecyclerView 为什么要预布局</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://juejin.cn/post/6908256535005102094">RecyclerView：预布局和 ItemAnimator 解析</a></li></ul></blockquote><p><strong>什么是预布局</strong></p><p>预布局是指在正式布局 <code>RecyclerView</code> 中的 <code>ItemView</code> 前执行的一次布局过程。</p><p><strong>预布局的作用</strong></p><p>预布局的作用是为了使 <code>ItemAnimator</code> 执行时能给用户更好的视觉体验。</p><p><strong>预布局和正式布局的区别</strong></p><p>预布局过程和正式布局过程执行的都是一样的代码，不同的是预布局过程得到的是 <code>ItemAnimator</code> 执行前的布局，而正式布局得到的是 <code>ItemAnimator</code> 执行后的布局也就是最终用户看到的布局。</p><p><strong>什么情况下会执行预布局</strong></p><p>当布局结束后若有新的 <code>ItemView</code> 在布局结尾显示则需要执行预布局，也就是当 <code>RecycleView</code> 中有 <code>ItemView</code> 被删除或更新时需要执行预布局。看下图更清晰。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/recyclerview-interviewList-1.awebp" alt="img" /></p><p>从上图中可以看到当不执行预布局时如果布局结尾有新的 <code>ItemView</code> 出现会执行 <code>DefaultItemAnimator</code> 的添加动画（淡入），这种看起来好像卡顿一样的显示给用户的感觉并不好。当然如果根本没有动画那预布局也就没有了意义。</p><h1 id="recyclerview的多级缓存机制每一级缓存具体作用是什么分别在什么场景下会用到哪些缓存"><a class="markdownIt-Anchor" href="#recyclerview的多级缓存机制每一级缓存具体作用是什么分别在什么场景下会用到哪些缓存"></a> RecyclerView的多级缓存机制,每一级缓存具体作用是什么,分别在什么场景下会用到哪些缓存</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://juejin.cn/post/6935605122567241742">详细讲解RecyclerView缓存机制</a></li><li><a href="https://blog.csdn.net/jb_home/article/details/111647931">Android深入理解RecyclerView的缓存机制</a></li></ul></blockquote><p>RecyclerView 是先复用，后回收。</p><p>共四级缓存，分别为：</p><ol><li><code>ArrayList&lt;ViewHolder&gt; mAttachedScrap</code> &amp; <code>ArrayList&lt;ViewHolder&gt; mChangedSracp</code> (屏幕内)</li><li><code>ArrayList&lt;ViewHolder&gt; mCachedViews</code> (屏幕外)</li><li><code>ViewCacheExtension mViewCacheExtension</code> (自定义缓存)</li><li><code>RecycledViewPool mRecyclerPool</code> (缓存池)</li></ol><p>每一级缓存的具体作用是什么？</p><ol><li>mAttachedScrap(屏幕内)<ol><li>用于屏幕内itemview快速重用，不需要重新createView和bindView。</li><li>缓存大小没有限制，大小等于RecyclerView子View的数量。</li><li>该缓存中的ViewHolder无需重新绑定，只要ViewHolder的position和数据源中的position对应上。</li></ol></li><li>mCacheViews(屏幕外)<ol><li>保存最近移出屏幕的ViewHolder，包含数据和position信息，复用时必须是相同位置的ViewHolder才能复用。</li><li>应用场景在那些需要来回滑动的列表中，当往回滑动时，能直接复用ViewHolder数据，不需要重新bindView。</li><li>缓存大小有限制，默认缓存大小为2，可以修改默认缓存大小。</li><li>该缓存的特性是FIFO。</li><li>该缓存中的ViewHolder无需重新绑定，只要ViewHolder的position和数据源中的position和itemType对应上。</li></ol></li><li>mViewCacheExtension(自定义缓存)。<ol><li>不直接使用，需要用户自定义实现，默认不实现。</li><li>该接口只提供了get方法，没提供put方法。</li></ol></li><li>mRecyclerPool(缓存池)<ol><li>当cacheView满了后或者adapter被更换，将cacheView中移出的ViewHolder放到Pool中，放之前会把ViewHolder数据清除掉，所以复用时需要重新bindView。需要重新执行onBindView的只有一种缓存区，就是缓存池mRecyclerPool。</li><li>每个itemType对应的ScrapData的缓存大小默认值是5，可以修改缓存大小。</li><li>该缓存中的ViewHolder需要重新绑定数据。</li><li>可以提供给多个RecyclerView共享。</li></ol></li></ol><h1 id="recyclerview的回收复用机制"><a class="markdownIt-Anchor" href="#recyclerview的回收复用机制"></a> RecyclerView的回收复用机制</h1><p><code>RecyclerView</code>滑动时会触发<code>onTouchEvent#onMove</code>，回收及复用<code>ViewHolder</code>在这里就会开始。</p><p><strong>保存缓存流程：</strong></p><ol><li><p>插入或是删除itemView时，先把屏幕内的ViewHolder保存至AttachedScrap中。</p></li><li><p>滑动屏幕的时候，先消失的itemview会保存到CacheView，CacheView大小默认是2，超过数量的话按照先入先出原则，移出头部的itemview保存到RecyclerPool缓存池（如果有自定义缓存就会保存到自定义缓存里），RecyclerPool缓存池会按照itemview的itemtype进行保存，每个itemType缓存个数为5个，超过就会被回收。</p></li></ol><p><strong>获取缓存流程：</strong></p><ol><li><p>AttachedScrap中获取，通过pos匹配holder——&gt;获取失败，从CacheView中获取，也是通过pos获取holder缓存 ——&gt;获取失败，从自定义缓存中获取缓存——&gt;获取失败，从mRecyclerPool中获取 ——&gt;获取失败，重新创建viewholder——createViewHolder并bindview。</p></li><li><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/d7f4bedb15c617e67c094b234c8b0958.webp" alt="" /></p></li><li><p>总结一下上述流程：</p><ol><li>通过mAttachedScrap、mCachedViews及mViewCacheExtension获取的ViewHolder不需要重新创建布局及绑定数据；</li><li>通过缓存池mRecyclerPool获取的ViewHolder不需要重新创建布局，但是需要重新绑定数据；</li><li>如果上述缓存中都没有获取到目标ViewHolder，那么就会回调Adapter#onCreateViewHolder创建布局，以及回调Adapter#onBindViewHolder来绑定数据。</li></ol></li></ol><h1 id="listview-和-recyclerview-的区别"><a class="markdownIt-Anchor" href="#listview-和-recyclerview-的区别"></a> ListView 和 RecyclerView 的区别</h1><p>缓存机制</p><ol><li>ListView 是二级缓存，缓存的对象为 View</li><li>RecyclerView 是四级缓存，缓存的对象为 RecyclerView.ViewHolder</li></ol><p>使用方式</p><ol><li>ListView<ol><li>需要继承 BaseAdapter 类</li><li>需要自定义 ViewHolder 实现 Item 的复用</li></ol></li><li>RecyclerView<ol><li>需要继承 RecyclerView.Adapter 以及 RecyclerView.ViewHolder</li></ol></li></ol><p>布局效果</p><ol><li>ListView 只有一种纵向布局</li><li>RecyclerView 默认有三种布局效果，可以自己继承 LayoutManager 实现自己想要的效果</li></ol><p>空数据处理</p><ol><li>ListView 有 <code>setEmptyView</code> 方法处理 Adapter 数据为空的情况</li><li>RecyclerView 必须自己处理数据为空的情况</li></ol><p>Header View 与 Footer View</p><ol><li>ListView 提供了添加 Header View 与 Footer View 的方法</li><li>RecyclerView 必须自己实现添加的方法</li></ol><p>动画效果</p><ol><li>ListView 中没有默认实现的动画效果，但是我们可以在 Adapter 中自行实现。</li><li>RecyclerView 中已经实现了部分默认的动画效果，例如 <code>notifyItemChanged()</code>、<code>notifyDataInserted()</code>等方法。如果需要自定义动画，我们可以继承 RecyclerView.ItemAnimator类实现自己的动画效果。</li></ol><p>点击事件</p><ol><li>ListView 实现了 <code>onItemClickListener</code> 接口。</li><li>RecyclerView 中并没有实现默认的点击事件的监听方法，我们需要自行实现。</li></ol><p>嵌套滚动机制</p><ol><li>ListView没有实现嵌套滚动机制。</li><li>在事件分发机制中，Touch事件在进行分发的时候，由父View向子View传递，一旦子View消费这个事件的话，那么接下来的事件分发的时候，父View将不接受，由子View进行处理；但是与Android的事件分发机制不同，嵌套滚动机制（<code>Nested Scrolling</code>）可以弥补这个不足，<strong>能让子View与父View同时处理这个Touch事件</strong>，主要实现在于NestedScrollingChild与NestedScrollingParent这两个接口；而在RecyclerView中，实现的是NestedScrollingChild，所以能实现嵌套滚动机制。</li></ol><h1 id="recyclerview性能优化"><a class="markdownIt-Anchor" href="#recyclerview性能优化"></a> RecyclerView性能优化</h1><blockquote><p>答案参考自：</p><ul><li>[RecyclerView性能优化](<a href="https://www.jianshu.com/p/1853ff1e8de6">RecyclerView性能优化 - 简书 (jianshu.com)</a>)</li><li>[RecyclerView性能优化及高级使用](<a href="https://www.jianshu.com/p/b79ee254f848">RecyclerView性能优化及高级使用 - 简书 (jianshu.com)</a>)</li></ul></blockquote><ol><li><p><strong>减少 xml 文件 inflate 时间</strong></p><p>xml文件包括：layout、drawable的xml，xml文件inflate出ItemView是通过耗时的IO操作。可以使用代码去生成布局，即new View()的方式。这种方式是比较麻烦，但是在布局太过复杂，或对性能要求比较高的时候可以使用。</p></li><li><p><strong>设置高度固定</strong></p><p>如果item高度是固定的话，可以使用RecyclerView.setHasFixedSize(true);来避免requestLayout浪费资源。</p></li><li><p><strong>共用RecycledViewPool</strong></p><p>在嵌套RecyclerView中，如果子RecyclerView具有相同的adapter，那么可以设置RecyclerView.setRecycledViewPool(pool)来共用一个RecycledViewPool。</p><p><strong>Note</strong>: 如果LayoutManager是LinearLayoutManager或其子类，需要手动开启这个特性：layout.setRecycleChildrenOnDetach(true)。</p></li><li><p><strong>加大RecyclerView的缓存</strong></p><p>用空间换时间，来提高滚动的流畅性。</p><p>recyclerView.setItemViewCacheSize(20);</p><p>recyclerView.setDrawingCacheEnabled(true);</p><p>recyclerView.setDrawingCacheQuality(View.DRAWING_CACHE_QUALITY_HIGH);</p></li><li><p><strong>增加RecyclerView预留的额外空间</strong></p><p>额外空间：显示范围之外，应该额外缓存的空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">newLinearLayoutManager( <span class="built_in">this</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getExtraLayoutSpace</span><span class="params">(RecyclerView.Statestate)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><strong>减少ItemView监听器的创建</strong></p><p>对ItemView设置监听器，不要对每个item都创建一个监听器，而应该共用一个XxListener，然后根据ID来进行不同的操作，优化了对象的频繁创建带来的资源消耗。</p></li><li><p><strong>回收资源</strong></p><p>通过重写RecyclerView.onViewRecycled(holder)来回收资源。</p></li></ol><hr /><h1 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> TODO</h1><ol><li>RecyclerView的刷新回收复用机制</li><li>RecyclerView的滑动回收复用机制</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;recyclerview-为什么要预布局&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#recyclerview-为什么要预布局&quot;&gt;&lt;/a&gt; RecyclerView 为什么要预布局&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;答案参考自</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="RecyclerView" scheme="https://luoyu-ying.github.io/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>已整理问题列表 - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/fcc3036e996a/"/>
    <id>https://luoyu-ying.github.io/posts/fcc3036e996a/</id>
    <published>2022-05-12T08:40:02.000Z</published>
    <updated>2022-05-23T00:22:25.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="activity"><a class="markdownIt-Anchor" href="#activity"></a> <a href="https://luoyu-ying.github.io/posts/4aa0626e110f/"><code>Activity</code></a></h1><ol><li><a href="https://luoyu-ying.github.io/posts/4aa0626e110f/#activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">1. Activity的启动流程</a></li><li><a href="https://luoyu-ying.github.io/posts/4aa0626e110f/#onsaveinstancestate%E5%92%8Conrestoreinstancestate%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA">2. onSaveInstanceState和onRestoreInstanceState的调用时机</a></li><li><a href="https://luoyu-ying.github.io/posts/4aa0626e110f/#oncreate%E5%92%8Conrestoreinstance%E6%96%B9%E6%B3%95%E4%B8%AD%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE%E6%97%B6%E7%9A%84%E5%8C%BA%E5%88%AB">3. onCreate和onRestoreInstance方法中恢复数据时的区别</a></li><li><a href="https://luoyu-ying.github.io/posts/4aa0626e110f/#activity%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E6%80%8E%E4%B9%88%E4%BF%9D%E5%AD%98%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%A2%ABkill%E5%90%8E%E4%BF%9D%E5%AD%98%E7%9A%84%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E6%81%A2%E5%A4%8D%E7%9A%84">4. Activity的数据是怎么保存的,进程被Kill后,保存的数据怎么恢复的？</a></li><li><a href="https://luoyu-ying.github.io/posts/4aa0626e110f/#activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">5. Activity的启动模式和使用场景</a></li><li><a href="https://luoyu-ying.github.io/posts/4aa0626e110f/#activity%E7%9A%84onnewintent%E6%96%B9%E6%B3%95%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%89%A7%E8%A1%8C">6. Activity的onNewIntent方法什么时候会执行</a></li><li><a href="https://luoyu-ying.github.io/posts/4aa0626e110f/#activity-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">7. Activity 生命周期</a></li><li><a href="https://luoyu-ying.github.io/posts/4aa0626e110f/#onstart-%E5%92%8C-onresume-onpause-%E5%92%8C-onstop-%E7%9A%84%E5%8C%BA%E5%88%AB">8. onStart 和 onResume、onPause 和 onStop 的区别</a></li><li><a href="https://luoyu-ying.github.io/posts/4aa0626e110f/#activity%E7%9A%84%E6%98%BE%E5%BC%8F%E5%90%AF%E5%8A%A8%E5%92%8C%E9%9A%90%E5%BC%8F%E5%90%AF%E5%8A%A8">9. Activity的显式启动和隐式启动</a></li><li><a href="https://luoyu-ying.github.io/posts/4aa0626e110f/#activty%E9%97%B4%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F">10. Activty间传递数据的方式</a></li><li><a href="https://luoyu-ying.github.io/posts/4aa0626e110f/#%E6%9C%89%E5%93%AA%E4%BA%9Bactivity%E5%B8%B8%E7%94%A8%E7%9A%84%E6%A0%87%E8%AE%B0%E4%BD%8Dflags">11. 有哪些Activity常用的标记位Flags</a></li><li><a href="https://luoyu-ying.github.io/posts/4aa0626e110f/#activity%E4%BB%BB%E5%8A%A1%E6%A0%88%E6%98%AF%E4%BB%80%E4%B9%88">12. Activity任务栈是什么</a></li><li><a href="https://luoyu-ying.github.io/posts/4aa0626e110f/#%E8%B7%A8app%E5%90%AF%E5%8A%A8activity%E7%9A%84%E6%96%B9%E5%BC%8F%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">13. 跨App启动Activity的方式,注意事项</a></li><li><a href="https://luoyu-ying.github.io/posts/4aa0626e110f/#anr-%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%9C%BA%E6%99%AF">14. ANR 的四种场景</a></li></ol><h1 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> <a href="https://luoyu-ying.github.io/posts/1718d96306cd/">序列化</a></h1><ol><li><a href="https://luoyu-ying.github.io/posts/1718d96306cd/#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96">1. 什么是序列化？</a></li><li><a href="https://luoyu-ying.github.io/posts/1718d96306cd/#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">2. 为什么需要使用序列化和反序列化？</a></li><li><a href="https://luoyu-ying.github.io/posts/1718d96306cd/#%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E5%A4%84">3. 序列化的有哪些好处</a></li><li><a href="https://luoyu-ying.github.io/posts/1718d96306cd/#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E5%BA%8F%E5%88%97%E5%8C%96">4. 什么情况下需要序列化</a></li><li><a href="https://luoyu-ying.github.io/posts/1718d96306cd/#%E4%BB%80%E4%B9%88%E6%98%AFserialversionuid">5. 什么是serialVersionUID</a></li><li><a href="https://luoyu-ying.github.io/posts/1718d96306cd/#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9Aserialversionuid%E7%9A%84%E5%80%BC">6. 为什么还要显示指定serialVersionUID的值?</a></li><li><a href="https://luoyu-ying.github.io/posts/1718d96306cd/#serializable-%E5%92%8C-parcelable-%E7%9A%84%E5%8C%BA%E5%88%AB">7. Serializable 和 Parcelable 的区别</a></li><li><a href="https://luoyu-ying.github.io/posts/1718d96306cd/#java-transient-%E8%A7%A3%E6%9E%90">8. Java transient 解析</a></li><li><a href="https://luoyu-ying.github.io/posts/1718d96306cd/#%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">9. 其他注意事项</a></li></ol><h1 id="arraylist"><a class="markdownIt-Anchor" href="#arraylist"></a> <a href="https://luoyu-ying.github.io/posts/ca56681199c8/"><code>ArrayList</code></a></h1><ol><li><a href="https://luoyu-ying.github.io/posts/ca56681199c8/#arraylist%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A9%E5%AE%B9%E7%9A%84">1. ArrayList是如何扩容的？</a></li><li>\2. ArrayList继承关系<ol><li><a href="https://luoyu-ying.github.io/posts/ca56681199c8/#%E5%AE%9E%E7%8E%B0serializable%E6%A0%87%E8%AE%B0%E5%9E%8B%E6%8E%A5%E5%8F%A3">2.1. 实现Serializable标记型接口</a></li><li><a href="https://luoyu-ying.github.io/posts/ca56681199c8/#%E5%AE%9E%E7%8E%B0cloneable%E6%A0%87%E8%AE%B0%E5%9E%8B%E6%8E%A5%E5%8F%A3">2.2. 实现Cloneable标记型接口</a></li><li><a href="https://luoyu-ying.github.io/posts/ca56681199c8/#%E5%AE%9E%E7%8E%B0randomaccess%E6%A0%87%E8%AE%B0%E5%9E%8B%E6%8E%A5%E5%8F%A3">2.3. 实现RandomAccess标记型接口</a></li><li><a href="https://luoyu-ying.github.io/posts/ca56681199c8/#abstractlist%E6%8A%BD%E8%B1%A1%E7%B1%BB">2.4. AbstractList抽象类</a></li></ol></li><li><a href="https://luoyu-ying.github.io/posts/ca56681199c8/#arraylist%E9%A2%91%E7%B9%81%E6%89%A9%E5%AE%B9%E5%AF%BC%E8%87%B4%E6%B7%BB%E5%8A%A0%E6%80%A7%E8%83%BD%E6%80%A5%E5%89%A7%E4%B8%8B%E9%99%8D%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86">3. ArrayList频繁扩容导致添加性能急剧下降，如何处理？</a></li><li><a href="https://luoyu-ying.github.io/posts/ca56681199c8/#arraylist%E6%8F%92%E5%85%A5%E6%88%96%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E4%B8%80%E5%AE%9A%E6%AF%94linkedlist%E6%85%A2%E5%90%97">4. ArrayList插入或删除元素一定比LinkedList慢吗？</a></li><li><a href="https://luoyu-ying.github.io/posts/ca56681199c8/#arraylist%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97">5. ArrayList是线程安全的吗？</a></li><li><a href="https://luoyu-ying.github.io/posts/ca56681199c8/#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3arraylist%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98">6. 如何解决ArrayList线程安全问题？</a></li><li><a href="https://luoyu-ying.github.io/posts/ca56681199c8/#%E5%A6%82%E4%BD%95%E5%A4%8D%E5%88%B6%E4%B8%80%E4%B8%AAarraylist%E9%9B%86%E5%90%88%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AAarraylist%E9%9B%86%E5%90%88%E4%B8%AD">7. 如何复制一个ArrayList集合到另一个ArrayList集合中？</a></li><li><a href="https://luoyu-ying.github.io/posts/ca56681199c8/#%E5%B7%B2%E7%9F%A5%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8n%E5%A4%9A%E7%94%A8%E6%88%B7%E5%90%8D%E7%A7%B0%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%9C%A8%E8%AF%BB%E5%8F%96%E9%9B%86%E5%90%88%E6%95%B0%E6%8D%AE%E7%9A%84%E5%90%8C%E6%97%B6%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E8%BF%98%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E7%9A%84%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E5%88%B0%E9%9B%86%E5%90%88">8. 已知成员变量集合存储N多用户名称，在多线程的环境下，使用迭代器在读取集合数据的同时如何保证还可以正常的写入数据到集合？</a></li><li><a href="https://luoyu-ying.github.io/posts/ca56681199c8/#arraylist%E5%92%8Clinkedlist%E5%8C%BA%E5%88%AB">9. ArrayList和LinkedList区别？</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;activity&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#activity&quot;&gt;&lt;/a&gt; &lt;a href=&quot;https://luoyu-ying.github.io/posts/4aa0626e110f/&quot;&gt;&lt;code&gt;Activi</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>原问题列表 - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/59c5aea57d8c/"/>
    <id>https://luoyu-ying.github.io/posts/59c5aea57d8c/</id>
    <published>2022-05-12T04:20:02.000Z</published>
    <updated>2022-05-23T00:17:42.615Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://www.nowcoder.com/discuss/692490?type=post&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack">已经过了字节试用期，才敢回来还愿，Android社招面经分享_笔经面经_牛客网 (nowcoder.com)</a></li></ul></blockquote><h1 id="android"><a class="markdownIt-Anchor" href="#android"></a> Android</h1><h2 id="activity"><a class="markdownIt-Anchor" href="#activity"></a> Activity</h2><ol><li>Activity的启动流程</li><li>onSaveInstanceState(),onRestoreInstanceState的掉用时机</li><li>activity的启动模式和使用场景</li><li>Activity A跳转Activity B，再按返回键，生命周期执行的顺序</li><li>横竖屏切换,按home键,按返回键,锁屏与解锁屏幕,跳转透明Activity界面,启动一个 Theme 为 Dialog 的 Activity，弹出Dialog时Activity的生命周期</li><li>onStart 和 onResume、onPause 和 onStop 的区别</li><li>Activity之间传递数据的方式Intent是否有大小限制，如果传递的数据量偏大，有哪些方案</li><li>Activity的onNewIntent()方法什么时候会执行</li><li>显示启动和隐式启动</li><li>scheme使用场景,协议格式,如何使用</li><li>ANR 的四种场景</li><li>onCreate和onRestoreInstance方法中恢复数据时的区别</li><li>activty间传递数据的方式</li><li>跨App启动Activity的方式,注意事项</li><li>Activity任务栈是什么</li><li>有哪些Activity常用的标记位Flags</li><li>Activity的数据是怎么保存的,进程被Kill后,保存的数据怎么恢复的</li></ol><h2 id="service"><a class="markdownIt-Anchor" href="#service"></a> Service</h2><ol><li>service 的生命周期，两种启动方式的区别</li><li>Service启动流程</li><li>Service与Activity怎么实现通信</li><li>IntentService是什么,IntentService原理，应用场景及其与Service的区别</li><li>Service 的 onStartCommand 方法有几种返回值?各代表什么意思?</li><li>bindService和startService混合使用的生命周期以及怎么关闭</li></ol><h2 id="broadcastreceiver"><a class="markdownIt-Anchor" href="#broadcastreceiver"></a> BroadcastReceiver</h2><ol><li>广播的分类和使用场景</li><li>广播的两种注册方式的区别</li><li>广播发送和接收的原理</li><li>本地广播和全局广播的区别</li></ol><h2 id="contentprovider"><a class="markdownIt-Anchor" href="#contentprovider"></a> ContentProvider</h2><ol><li>什么是ContentProvider及其使用</li><li>ContentProvider,ContentResolver,ContentObserver之间的关系</li><li>ContentProvider的实现原理</li><li>ContentProvider的优点</li><li>Uri 是什么</li></ol><h2 id="handler"><a class="markdownIt-Anchor" href="#handler"></a> Handler</h2><ol><li>Handler的实现原理</li><li>子线程中能不能直接new一个Handler,为什么主线程可以？主线程的Looper第一次调用loop方法,什么时候,哪个类</li><li>Handler导致的内存泄露原因及其解决方案</li><li>一个线程可以有几个Handler,几个Looper,几个MessageQueue对象</li><li>Message对象创建的方式有哪些 &amp; 区别？Message.obtain()怎么维护消息池的</li><li>Handler 有哪些发送消息的方法</li><li>Handler的post与sendMessage的区别和应用场景</li><li>handler postDelay后消息队列有什么变化，假设先 postDelay 10s, 再postDelay 1s, 怎么处理这2条消息</li><li>MessageQueue是什么数据结构</li><li>Handler怎么做到的一个线程对应一个Looper，如何保证只有一个MessageQueue？ThreadLocal在Handler机制中的作用</li><li>HandlerThread是什么 &amp; 好处 &amp;原理 &amp; 使用场景</li><li>IdleHandler及其使用场景</li><li>消息屏障,同步屏障机制</li><li>子线程能不能更新UI</li><li>为什么Android系统不建议子线程访问UI</li><li>Android中为什么主线程不会因为Looper.loop()里的死循环卡死？MessageQueue#next 在没有消息的时候会阻塞，如何恢复？</li><li>Handler消息机制中，一个looper是如何区分多个Handler的？当Activity有多个Handler的时候，怎么样区分当前消息由哪个Handler处理？处理message的时候怎么知道是去哪个callback处理的</li><li>Looper.quit/quitSafely的区别</li><li>通过Handler如何实现线程的切换</li><li>Handler 如何与 Looper 关联的</li><li>Looper 如何与 Thread 关联的</li><li>Looper.loop()源码</li><li>MessageQueue的enqueueMessage()方法如何进行线程同步的</li><li>MessageQueue的next()方法内部原理</li><li>子线程中是否可以用MainLooper去创建Handler，Looper和Handler是否一定处于一个线程</li><li>ANR和Handler的联系</li></ol><h2 id="view绘制"><a class="markdownIt-Anchor" href="#view绘制"></a> View绘制</h2><ol><li>View绘制流程</li><li>MeasureSpec是什么</li><li>子View创建MeasureSpec创建规则是什么</li><li>自定义Viewwrap_content不起作用的原因</li><li>在Activity中获取某个View的宽高有几种方法</li><li>为什么onCreate获取不到View的宽高</li><li>View#post与Handler#post的区别</li><li>Android绘制和屏幕刷新机制原理</li><li>Choreography原理</li><li>什么是双缓冲</li><li>为什么使用SurfaceView</li><li>什么是SurfaceView</li><li>View和SurfaceView的区别</li><li>SurfaceView为什么可以直接子线程绘制</li><li>SurfaceView、TextureView、SurfaceTexture、GLSurfaceView</li><li>getWidth()方法和getMeasureWidth()区别</li><li>invalidate() 和 postInvalidate() 的区别</li><li>Requestlayout，onlayout，onDraw，DrawChild区别与联系</li><li>LinearLayout、FrameLayout 和 RelativeLayout 哪个效率高</li><li>LinearLayout的绘制流程</li><li>自定义 View 的流程和注意事项</li><li>自定义View如何考虑机型适配</li><li>自定义控件优化方案</li><li>invalidate怎么局部刷新</li><li>View加载流程（setContentView）</li></ol><h2 id="view事件分发"><a class="markdownIt-Anchor" href="#view事件分发"></a> View事件分发</h2><ol><li>View事件分发机制</li><li>view的onTouchEvent，OnClickListerner和OnTouchListener的onTouch方法 三者优先级</li><li>onTouch 和onTouchEvent 的区别</li><li>ACTION_CANCEL什么时候触发</li><li>事件是先到DecorView还是先到Window</li><li>点击事件被拦截，但是想传到下面的View，如何操作</li><li>如何解决View的事件冲突</li><li>在 ViewGroup 中的 onTouchEvent 中消费 ACTION_DOWN 事件，ACTION_UP事件是怎么传递</li><li>Activity ViewGroup和View都不消费ACTION_DOWN,那么ACTION_UP事件是怎么传递的</li><li>同时对父 View 和子 View 设置点击方法，优先响应哪个</li><li>requestDisallowInterceptTouchEvent的调用时机</li></ol><h2 id="recycleview"><a class="markdownIt-Anchor" href="#recycleview"></a> RecycleView</h2><ol><li>RecyclerView的多级缓存机制,每一级缓存具体作用是什么,分别在什么场景下会用到哪些缓存</li><li>RecyclerView的滑动回收复用机制</li><li>RecyclerView的刷新回收复用机制</li><li>RecyclerView 为什么要预布局</li><li>ListView 与 RecyclerView区别</li><li>RecyclerView性能优化</li></ol><h2 id="viewpager-fragment"><a class="markdownIt-Anchor" href="#viewpager-fragment"></a> ViewPager &amp; Fragment</h2><ol><li>Fragment的生命周期 &amp; 结合Activity的生命周期</li><li>Activity和Fragment的通信方式， Fragment之间如何进行通信</li><li>为什么使用Fragment.setArguments(Bundle)传递参数</li><li>FragmentPageAdapter和FragmentStatePageAdapter区别及使用场景</li><li>Fragment懒加载</li><li>ViewPager2与ViewPager区别</li><li>Fragment嵌套问题</li></ol><h2 id="webview"><a class="markdownIt-Anchor" href="#webview"></a> WebView</h2><ol><li>如何提高WebView加载速度</li><li>WebView与 js的交互</li><li>WebView的漏洞</li><li>JsBridge原理</li></ol><h2 id="动画"><a class="markdownIt-Anchor" href="#动画"></a> 动画</h2><ol><li>动画的类型</li><li>补间动画和属性动画的区别</li><li>ObjectAnimator，ValueAnimator及其区别</li><li>TimeInterpolator插值器，自定义插值器</li><li>TypeEvaluator估值器</li></ol><h2 id="bitmap"><a class="markdownIt-Anchor" href="#bitmap"></a> Bitmap</h2><ol><li>Bitmap 内存占用的计算</li><li>getByteCount() &amp; getAllocationByteCount()的区别</li><li>Bitmap的压缩方式</li><li>LruCache &amp; DiskLruCache原理</li><li>如何设计一个图片加载库</li><li>有一张非常大的图片,如何去加载这张大图片</li><li>如果把drawable-xxhdpi下的图片移动到drawable-xhdpi下，图片内存是如何变的。</li><li>如果在hdpi、xxhdpi下放置了图片，加载的优先级。如果是400800，10801920，加载的优先级。</li></ol><h2 id="mvc-mvp-mvvm"><a class="markdownIt-Anchor" href="#mvc-mvp-mvvm"></a> MVC &amp; MVP &amp; MVVM</h2><ol><li>MVC及其优缺点</li><li>MVP及其优缺点</li><li>MVVM及其优缺点</li><li>MVP如何管理Presenter的生命周期，何时取消网络请求</li></ol><h2 id="binder"><a class="markdownIt-Anchor" href="#binder"></a> Binder</h2><ol><li>Android中进程和线程的关系,区别</li><li>为何需要进行IPC,多进程通信可能会出现什么问题</li><li>Android中IPC方式有几种、各种方式优缺点</li><li>为何新增Binder来作为主要的IPC方式</li><li>什么是Binder</li><li>Binder的原理</li><li>Binder Driver 如何在内核空间中做到一次拷贝的？</li><li>使用Binder进行数据传输的具体过程</li><li>Binder框架中ServiceManager的作用</li><li>什么是AIDL</li><li>AIDL使用的步骤</li><li>AIDL支持哪些数据类型</li><li>AIDL的关键类，方法和工作流程</li><li>如何优化多模块都使用AIDL的情况</li><li>使用 Binder 传输数据的最大限制是多少，被占满后会导致什么问题</li><li>Binder 驱动加载过程中有哪些重要的步骤</li><li>系统服务与bindService启动的服务的区别</li><li>Activity的bindService流程</li><li>不通过AIDL，手动编码来实现Binder的通信</li></ol><h2 id="内存泄漏内存溢出"><a class="markdownIt-Anchor" href="#内存泄漏内存溢出"></a> 内存泄漏&amp;内存溢出</h2><ol><li>什么是OOM &amp; 什么是内存泄漏以及原因</li><li>Thread是如何造成内存泄露的，如何解决？</li><li>Handler导致的内存泄露的原因以及如何解决</li><li>如何加载Bitmap防止内存溢出</li><li>MVP中如何处理Presenter层以防止内存泄漏的</li></ol><h2 id="性能优化"><a class="markdownIt-Anchor" href="#性能优化"></a> 性能优化</h2><ol><li>内存优化</li><li>启动优化</li><li>布局加载和绘制优化</li><li>卡顿优化</li><li>网络优化</li></ol><h2 id="windowwindowmanager"><a class="markdownIt-Anchor" href="#windowwindowmanager"></a> Window&amp;WindowManager</h2><ol><li>什么是Window</li><li>什么是WindowManager</li><li>什么是ViewRootImpl</li><li>什么是DecorView</li><li>Activity，View，Window三者之间的关系</li><li>DecorView什么时候被WindowManager添加到Window中</li></ol><h2 id="wms"><a class="markdownIt-Anchor" href="#wms"></a> WMS</h2><ol><li>什么是WMS</li><li>WMS是如何管理Window的</li><li>IWindowSession是什么，WindowSession的创建过程是怎样的</li><li>WindowToken是什么</li><li>WindowState是什么</li><li>Android窗口大概分为几种？分组原理是什么</li><li>Dialog的Context只能是Activity的Context，不能是Application的Context？</li><li>App应用程序如何与SurfaceFlinger通信的？View 的绘制是如何把数据传递给 SurfaceFlinger 的</li><li>共享内存的具体实现是什么</li><li>relayout是如何向SurfaceFlinger申请Surface</li><li>什么是Surface</li></ol><h2 id="ams"><a class="markdownIt-Anchor" href="#ams"></a> AMS</h2><ol><li>ActivityManagerService是什么？什么时候初始化的？有什么作用？</li><li>ActivityThread是什么?ApplicationThread是什么?他们的区别</li><li>Instrumentation是什么？和ActivityThread是什么关系？</li><li>ActivityManagerService和zygote进程通信是如何实现的</li><li>ActivityRecord、TaskRecord、ActivityStack，ActivityStackSupervisor，ProcessRecord</li><li>ActivityManager、ActivityManagerService、ActivityManagerNative、ActivityManagerProxy的关系</li><li>手写实现简化版AMS</li></ol><h2 id="系统启动"><a class="markdownIt-Anchor" href="#系统启动"></a> 系统启动</h2><ol><li>android系统启动流程</li><li>SystemServer，ServiceManager，SystemServiceManager的关系</li><li>孵化应用进程这种事为什么不交给SystemServer来做，而专门设计一个Zygote</li><li>Zygote的IPC通信机制为什么使用socket而不采用binder</li></ol><h2 id="app启动打包安装"><a class="markdownIt-Anchor" href="#app启动打包安装"></a> App启动&amp;打包&amp;安装</h2><ol><li>应用启动流程</li><li>apk组成和Android的打包流程</li><li>Android的签名机制，签名如何实现的,v2相比于v1签名机制的改变</li><li>APK的安装流程</li></ol><h2 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h2><ol><li>什么是序列化</li><li>为什么需要使用序列化和反序列化</li><li>序列化的有哪些好处</li><li>Serializable 和 Parcelable 的区别</li><li>什么是serialVersionUID</li><li>为什么还要显示指定serialVersionUID的值?</li></ol><h2 id="art-dalvik-及其区别"><a class="markdownIt-Anchor" href="#art-dalvik-及其区别"></a> Art &amp; Dalvik 及其区别</h2><ol><li>Art &amp; Dalvik 及其区别</li></ol><h2 id="模块化组件化"><a class="markdownIt-Anchor" href="#模块化组件化"></a> 模块化&amp;组件化</h2><ol><li>什么是模块化</li><li>什么是组件化</li><li>组件化优点和方案</li><li>组件独立调试</li><li>组件间通信</li><li>Aplication动态加载</li><li>ARouter原理</li></ol><h2 id="热修复插件化"><a class="markdownIt-Anchor" href="#热修复插件化"></a> 热修复&amp;插件化</h2><ol><li>插件化的定义</li><li>插件化的优势</li><li>插件化框架对比</li><li>插件化流程</li><li>插件化类加载原理</li><li>插件化资源加载原理</li><li>插件化Activity加载原理</li><li>热修复和插件化区别</li><li>热修复原理</li></ol><h2 id="aop"><a class="markdownIt-Anchor" href="#aop"></a> AOP</h2><ol><li>AOP是什么</li><li>AOP的优点</li><li>AOP的实现方式,APT,AspectJ,ASM,epic,hook</li></ol><h2 id="jetpack"><a class="markdownIt-Anchor" href="#jetpack"></a> Jetpack</h2><ol><li>Navigation</li><li>DataBinding</li><li>Viewmodel</li><li>livedata</li><li>liferecycle</li></ol><h2 id="开源框架"><a class="markdownIt-Anchor" href="#开源框架"></a> 开源框架</h2><ol><li>Okhttp源码流程,线程池</li><li>Okhttp拦截器,addInterceptor 和 addNetworkdInterceptor区别</li><li>Okhttp责任链模式</li><li>Okhttp缓存怎么处理</li><li>Okhttp连接池和socket复用</li><li>Glide怎么绑定生命周期</li><li>Glide缓存机制,内存缓存，磁盘缓存</li><li>Glide与Picasso的区别</li><li>LruCache原理</li><li>Retrofit源码流程,动态代理</li><li>LeakCanary弱引用,源码流程</li><li>Eventbus</li><li>Rxjava</li></ol><h1 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h1><h2 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h2><ol><li>HashMap原理</li><li>HashMap中put()如何实现的</li><li>HashMap中get()如何实现的</li><li>为什么HashMap线程不安全</li><li>HashMap1.7和1.8有哪些区别</li><li>解决hash冲突的时候，为什么用<a href="">红黑树</a></li><li><a href="">红黑树</a>的效率高，为什么一开始不用<a href="">红黑树</a>存储</li><li>不用<a href="">红黑树</a>，用二叉查找树可以不</li><li>为什么阀值是8才转为<a href="">红黑树</a></li><li>为什么退化为<a href="">链表</a>的阈值是6</li><li>hash冲突有哪些解决办法</li><li>HashMap在什么条件下扩容</li><li>HashMap中hash函数怎么实现的，还有哪些hash函数的实现方式</li><li>为什么不直接将hashcode作为哈希值去做取模,而是要先高16位异或低16位</li><li>为什么扩容是2的次幂</li><li><a href="">链表</a>的查找的时间复杂度是多少</li><li><a href="">红黑树</a></li></ol><h2 id="arraylist"><a class="markdownIt-Anchor" href="#arraylist"></a> ArrayList</h2><h2 id="jvm"><a class="markdownIt-Anchor" href="#jvm"></a> Jvm</h2><ol><li>Jvm的内存模型,每个里面都保存的什么</li><li>类加载机制的几个阶段加载、验证、准备、解析、初始化、使用、卸载</li><li>对象实例化时的顺序</li><li>类加载器,双亲委派及其优势</li><li>垃圾回收机制</li></ol><h2 id="多线程"><a class="markdownIt-Anchor" href="#多线程"></a> 多线程</h2><ol><li>Java中创建线程的方式,Callable,Runnable,Future,FutureTask</li><li>线程的几种状态</li><li>谈谈线程死锁，如何有效的避免线程死锁？</li><li>如何实现多线程中的同步</li><li>synchronized和Lock的使用、区别,原理；</li><li>volatile，synchronized和volatile的区别？为何不用volatile替代synchronized？</li><li>锁的分类，锁的几种状态，CAS原理</li><li>为什么会有线程安全？如何保证线程安全</li><li>sleep()与wait()区别,run和start的区别,notify和notifyall区别,锁池,等待池</li><li>Java多线程通信</li><li>为什么Java用线程池</li><li>Java中的线程池参数,共有几种</li></ol><h2 id="注解"><a class="markdownIt-Anchor" href="#注解"></a> 注解</h2><ol><li>注解的分类和底层实现原理</li><li>自定义注解</li></ol><h2 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h2><ol><li>什么是反射</li><li>反射机制的相关类</li><li>反射中如何获取Class类的实例</li><li>如何获取一个类的属性对象 &amp; 构造器对象 &amp; 方法对象</li><li>Class.getField和getDeclaredField的区别，getDeclaredMethod和getMethod的区别</li><li>反射机制的优缺点</li></ol><h2 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h2><h2 id="设计模式"><a class="markdownIt-Anchor" href="#设计模式"></a> 设计模式</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文参考自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nowcoder.com/discuss/692490?type=post&amp;amp;order=recall&amp;amp;pos=&amp;amp;page=1&amp;amp;ncTr</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp 解析 [转载]</title>
    <link href="https://luoyu-ying.github.io/posts/85849a386862/"/>
    <id>https://luoyu-ying.github.io/posts/85849a386862/</id>
    <published>2022-05-10T16:41:06.000Z</published>
    <updated>2022-05-21T04:54:07.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文转载自：</p><ul><li><a href="https://blog.csdn.net/gdutxiaoxu/article/details/100545600">一步步带你读懂 Okhttp 源码</a></li><li><a href="https://www.jianshu.com/p/8522bc275390">okhttp拦截器Interceptor详解</a></li></ul></blockquote><hr /><h1 id="使用-okhttp-的基本流程"><a class="markdownIt-Anchor" href="#使用-okhttp-的基本流程"></a> 使用 OkHttp 的基本流程</h1><ol><li>创建 OkHttpClient 对象</li><li>创建 Request 对象</li><li>创建 Call 对象</li><li>同步请求调用 call.execute()；异步请求调用 call.enqueue()</li></ol><h2 id="同步执行"><a class="markdownIt-Anchor" href="#同步执行"></a> 同步执行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建OkHttpClient对象</span></span><br><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line"></span><br><span class="line">String <span class="title function_">run</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="comment">//创建Request请求对象</span></span><br><span class="line">  <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建Call对象，并执行同步获取网络数据</span></span><br><span class="line">  <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">return</span> response.body().string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步执行"><a class="markdownIt-Anchor" href="#异步执行"></a> 异步执行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">runAsync</span><span class="params">(String url, Callback callback)</span> &#123;</span><br><span class="line">    <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().addInterceptor(<span class="keyword">new</span> <span class="title class_">Interceptor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> chain.request();</span><br><span class="line">            Request.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> request.newBuilder().addHeader(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> chain.proceed(builder.build());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).build();</span><br><span class="line">    <span class="comment">//创建Request请求对象</span></span><br><span class="line">    <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">            .url(url)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    client.newCall(request).enqueue(callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="创建-okhttpclient-对象"><a class="markdownIt-Anchor" href="#创建-okhttpclient-对象"></a> 创建 OkHttpClient 对象</h1><p>创建 OkHttpClient 一般有两种方法，一种是直接 new OkHttpClient(),另外一种是通过 OkHttpClient.Builder()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkhttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span></span><br><span class="line">                    .Builder()</span><br><span class="line">                    .connectTimeout(<span class="number">5</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .writeTimeout(<span class="number">10</span>,TimeUnit.SECONDS)</span><br><span class="line">                    .readTimeout(<span class="number">10</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .build();</span><br></pre></td></tr></table></figure><p>第二种创建方式主要是通过建造者模式，来配置一些参数，比如连接超时时间，读写超时时间，超时重试次数等。这样有一个好处，可以对外屏蔽掉构建 client 的细节。</p><p>OkhttpClient 对象主要处理一些基础的配置，比如连接超时，读写超时，添加拦截器。</p><hr /><h1 id="创建-request-对象"><a class="markdownIt-Anchor" href="#创建-request-对象"></a> 创建 Request 对象</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Request</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> HttpUrl url;</span><br><span class="line">  <span class="keyword">final</span> String method;</span><br><span class="line">  <span class="keyword">final</span> Headers headers;</span><br><span class="line">  <span class="keyword">final</span> RequestBody body;</span><br><span class="line">  <span class="keyword">final</span> Object tag;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> CacheControl cacheControl; <span class="comment">// Lazily initialized.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Request 对象主要封装的是一些网络请求的信息，比如请求 url，请求方法，请求头，请求 body 等，也比较简单，这里不再展开阐述。</p><hr /><h1 id="创建-call-对象"><a class="markdownIt-Anchor" href="#创建-call-对象"></a> 创建 Call 对象</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> Call <span class="title function_">newCall</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RealCall</span>(<span class="built_in">this</span>, request, <span class="literal">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 call 对象实际是 RealCall 的实例化对象。</p><hr /><h1 id="同步请求"><a class="markdownIt-Anchor" href="#同步请求"></a> 同步请求</h1><h2 id="realcallexecute"><a class="markdownIt-Anchor" href="#realcallexecute"></a> RealCall#execute()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">    executed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  captureCallStackTrace();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行 client.dispatcher() 的 executed 方法</span></span><br><span class="line">    client.dispatcher().executed(<span class="built_in">this</span>);</span><br><span class="line">    <span class="type">Response</span> <span class="variable">result</span> <span class="operator">=</span> getResponseWithInterceptorChain();</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Canceled&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 最后再执行 dispatcher 的 finish 方法</span></span><br><span class="line">    client.dispatcher().finished(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 execute 方法中：</p><ol><li>首先会调用 client.dispatcher().executed(this) 加入到 runningAsyncCalls 队列当中</li><li>接着执行 getResponseWithInterceptorChain() 获取请求结果</li><li>最终再执行 client.dispatcher().finished(this) 将 realCall 从 runningAsyncCalls 队列中移除</li></ol><hr /><h1 id="拦截器-interceptor"><a class="markdownIt-Anchor" href="#拦截器-interceptor"></a> 拦截器 Interceptor</h1><h2 id="getresponsewithinterceptorchain"><a class="markdownIt-Anchor" href="#getresponsewithinterceptorchain"></a> getResponseWithInterceptorChain()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Response <span class="title function_">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">   List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   interceptors.addAll(client.interceptors());</span><br><span class="line">   interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">   interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>(client.cookieJar()));</span><br><span class="line">   interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>(client.internalCache()));</span><br><span class="line">   interceptors.add(<span class="keyword">new</span> <span class="title class_">ConnectInterceptor</span>(client));</span><br><span class="line">   <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">     interceptors.addAll(client.networkInterceptors());</span><br><span class="line">   &#125;</span><br><span class="line">   interceptors.add(<span class="keyword">new</span> <span class="title class_">CallServerInterceptor</span>(forWebSocket));</span><br><span class="line">   Interceptor.<span class="type">Chain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">       interceptors, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">   <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，首先，他会将客户端的 interceptors 添加到 List 当中，接着，再添加 okhttp 里面的 interceptor，然后构建了一个 RealInterceptorChain 对象，并将我们的 List<Interceptor> 作为成员变量，最后调用 RealInterceptorChain 的 proceed 方法。</p><p>其中，client.interceptors() 为我们自己添加的请求拦截器，通常是做一些添加统一的token之类操作。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/4122684-67fcdd5d7e5f984e.jpg" alt="其余较重要的拦截器" /></p><p><strong>RetryAndFollowUpInterceptor 拦截器</strong></p><ul><li>RetryAndFollowUpInterceptor 此拦截器顾名思义就是主要负责失败重连工作，但是并不是所有的网络请求都会进行失败重连的,在此拦截器内部会进行网络请求的异常检测和响应码的判断,如果都在限制范围内,那么就可以进行失败重连。</li></ul><p><strong>CacheInterceptor 拦截器</strong></p><ul><li><p>如果当前未使用网络，并且缓存不可以使用，通过构建者模式创建一个 Response 响应,抛出504错误。</p></li><li><p>如果有缓存 但是不能使用网络 ，直接返回缓存结果。这是在进行网络请求之前所做的事情，当网络请求完成，得到下一个拦截器返回的 response 之后，判断 response 的响应码是否是 HTTP_NOT_MODIFIED = 304（未改变），是则从缓存中读取数据。</p></li></ul><h2 id="proceed"><a class="markdownIt-Anchor" href="#proceed"></a> proceed()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Response <span class="title function_">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span><br><span class="line"><span class="params">    Connection connection)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 省略无关代码</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">//  生成 list 当中下一个 interceptot 的 chain 对象</span></span><br><span class="line">  <span class="type">RealInterceptorChain</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">      interceptors, streamAllocation, httpCodec, connection, index + <span class="number">1</span>, request);</span><br><span class="line">  <span class="comment">// 当前的 interceptor</span></span><br><span class="line">  <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors.get(index);</span><br><span class="line">  <span class="comment">// 当前的 intercept 处理下一个 intercept 包装的 chain 对象</span></span><br><span class="line">  <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ----</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proceed 方法也很简单，proceed方法每次从拦截器列表中取出拦截器，并调用 interceptor.intercept(next)。</p><p>熟悉 Okhttp 的应该都知道，我们在 addInterceptor 创建 Interceptor 实例，最终都会调用 chain.proceed(Request request),从而形成一种链式调用。这种便是责任链设计模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().addInterceptor(<span class="keyword">new</span> <span class="title class_">Interceptor</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> chain.request();</span><br><span class="line">        Request.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> request.newBuilder().addHeader(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(builder.build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).build();</span><br></pre></td></tr></table></figure><p>而 OkHttp 是怎样结束循环调用的，这是因为最后一个拦截器 CallServerInterceptor 并没有调用 chain.proceed(request)，所以能够结束循环调用。</p><hr /><h1 id="异步请求"><a class="markdownIt-Anchor" href="#异步请求"></a> 异步请求</h1><h2 id="dispatcher-分发器"><a class="markdownIt-Anchor" href="#dispatcher-分发器"></a> dispatcher 分发器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Dispatcher</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRequests</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxRequestsPerHost</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">private</span> Runnable idleCallback;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Executes calls. Created lazily. */</span></span><br><span class="line">  <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步的请求等待队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步的正在请求的队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同步的正在请求的队列</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分发器 Dispatcher，里面有三个请求队列，一个是正在请求的队列，一个是等待队列，另外一个是同步的正在请求的队列，当我们执行 enqueue 方法的时候，他会判断正在请求队列数量是否超过允许的最大并发数量（默认是 64）（线程池的原理），如果超过了，会添加到等待队列里面。</p><p>execute 方法是同步执行的，每次执行会添加到同步请求队列当中，执行完毕之后会移除。</p><h2 id="realcallenqueuecallback-responsecallback"><a class="markdownIt-Anchor" href="#realcallenqueuecallback-responsecallback"></a> RealCall#enqueue(Callback responseCallback)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Callback responseCallback)</span> &#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Already Executed&quot;</span>);</span><br><span class="line">    executed = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  captureCallStackTrace();</span><br><span class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> <span class="title class_">AsyncCall</span>(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，AsyncCall 是 Runnable 的子类，实现了 run 方法。</p><h2 id="dispatcherenqueueasynccall-call"><a class="markdownIt-Anchor" href="#dispatcherenqueueasynccall-call"></a> dispatcher().enqueue(AsyncCall call)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(AsyncCall call)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">    runningAsyncCalls.add(call);</span><br><span class="line">    executorService().execute(call);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    readyAsyncCalls.add(call);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行 executorService().execute(call) 的时候，会调用 run 方法， run 方法又会调用到 execute 方法进行网络请求，请求完成之后，会调用 client.dispatcher().finished(this) 从队列里面移除。</p><hr /><p>到此， Okhttp 的主要流程已经讲完。</p><hr /><h1 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h1><ol><li><p>有一个分发器 Dispatcher，里面有三个请求队列，一个是正在请求的队列，一个是等待队列，另外一个是同步的正在请求的队列，当我们执行 enqueue 方法的时候，他会判断正在请求队列数量是否超过允许的最大并发数量（默认是 64）（线程池的原理），如果超过了，会添加到等待队列里面。<br />excute 方法是同步执行的，每次执行会添加到同步请求队列当中，执行完毕之后会移除。</p></li><li><p>设计的核心思想责任链模式，当我们需要拦截的时候，可以实现 Interceptor 接口，会按照添加的顺序执行 Chain.proceed 方法。</p></li><li><p>职责分明，OkhttpClient 对象主要处理一些基础的配置，比如连接超时，读写超时，添加拦截器。Request 主要配置请求方法，请求头等。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文转载自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/gdutxiaoxu/article/details/100545600&quot;&gt;一步步带你读懂 Okhttp 源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a h</summary>
      
    
    
    
    <category term="Android" scheme="https://luoyu-ying.github.io/categories/Android/"/>
    
    
    <category term="OkHttp" scheme="https://luoyu-ying.github.io/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>c++ 不同数据类型 scanf 输入输出写法</title>
    <link href="https://luoyu-ying.github.io/posts/645f57a51719/"/>
    <id>https://luoyu-ying.github.io/posts/645f57a51719/</id>
    <published>2022-05-08T15:28:06.000Z</published>
    <updated>2022-05-21T04:54:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="signed-int"><a class="markdownIt-Anchor" href="#signed-int"></a> <code>signed int</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br></pre></td></tr></table></figure><h1 id="unsigned-int"><a class="markdownIt-Anchor" href="#unsigned-int"></a> <code>unsigned int</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u&quot;</span>, x);</span><br></pre></td></tr></table></figure><h1 id="long-long-int"><a class="markdownIt-Anchor" href="#long-long-int"></a> <code>long long int</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, x);</span><br></pre></td></tr></table></figure><h1 id="unsigned-long-long-int"><a class="markdownIt-Anchor" href="#unsigned-long-long-int"></a> <code>unsigned long long int</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%llu&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu&quot;</span>, x);</span><br></pre></td></tr></table></figure><h1 id="float"><a class="markdownIt-Anchor" href="#float"></a> <code>float</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, x);</span><br></pre></td></tr></table></figure><h1 id="double"><a class="markdownIt-Anchor" href="#double"></a> <code>double</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, x);</span><br></pre></td></tr></table></figure><h1 id="long-double"><a class="markdownIt-Anchor" href="#long-double"></a> <code>long double</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, x);</span><br></pre></td></tr></table></figure><h1 id="char"><a class="markdownIt-Anchor" href="#char"></a> <code>char</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br></pre></td></tr></table></figure><h1 id="string"><a class="markdownIt-Anchor" href="#string"></a> <code>string</code></h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[LEN];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;signed-int&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#signed-int&quot;&gt;&lt;/a&gt; &lt;code&gt;signed int&lt;/code&gt;&lt;/h1&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    <category term="XCPC" scheme="https://luoyu-ying.github.io/categories/XCPC/"/>
    
    
    <category term="XCPC" scheme="https://luoyu-ying.github.io/tags/XCPC/"/>
    
  </entry>
  
  <entry>
    <title>K 短路模板</title>
    <link href="https://luoyu-ying.github.io/posts/ac36d4ee2e65/"/>
    <id>https://luoyu-ying.github.io/posts/ac36d4ee2e65/</id>
    <published>2022-04-28T11:49:23.000Z</published>
    <updated>2022-05-21T04:54:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="k-短路"><a class="markdownIt-Anchor" href="#k-短路"></a> K 短路</h1><h2 id="input"><a class="markdownIt-Anchor" href="#input"></a> Input</h2><p>第一行输入五个数字，依次表示为图的点数 N、边数 M、所求的第 K 段路、开始的点号 S、结尾的点号 T。<br />后面的 M 行，每行三个数字，代表一条单向边，分别为 From, To, Distance。</p><h2 id="output"><a class="markdownIt-Anchor" href="#output"></a> Output</h2><p>一个数字，表示第 K 短路的值。</p><h2 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Kth_Path &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span> + <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        N nodes, M edges, find the K-th path from S to T.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> N, M, S, T, K;</span><br><span class="line">    <span class="type">int</span> dist[MAXN], cnt, fa[MAXN];</span><br><span class="line">    <span class="type">bool</span> tf[MAXN], vis[MAXN], onTree[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Path</span> &#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>, head[MAXN];</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">            <span class="type">int</span> next, to, dis;</span><br><span class="line">        &#125; G[MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> dis)</span> </span>&#123;</span><br><span class="line">            G[++num] = &#123;head[from], to, dis&#125;;</span><br><span class="line">            head[from] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; E1, E2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> x, val;</span><br><span class="line"></span><br><span class="line">        Node *<span class="keyword">operator</span>=(Node a) &#123;</span><br><span class="line">            x = a.x;</span><br><span class="line">            val = a.val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>&lt;(Node a) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> val &gt; a.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; A;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;Node&gt; Q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">        vis[s] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = E2.head[s]; i; i = E2.G[i].next) &#123;</span><br><span class="line">            <span class="type">int</span> to = E2.G[i].to;</span><br><span class="line">            <span class="keyword">if</span> (vis[to])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (dist[to] == dist[s] + E2.G[i].dis) &#123;</span><br><span class="line">                fa[to] = s;</span><br><span class="line">                onTree[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LeftistTree</span> &#123;</span><br><span class="line">        <span class="type">int</span> num, rt[MAXN], lc[MAXN * <span class="number">20</span>], rc[MAXN * <span class="number">20</span>], dist[MAXN * <span class="number">20</span>];</span><br><span class="line">        Node v[MAXN &lt;&lt; <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">LeftistTree</span>() &#123;</span><br><span class="line">            dist[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">newNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">            v[++num] = node;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!x || !y)</span><br><span class="line">                <span class="keyword">return</span> x + y;</span><br><span class="line">            <span class="keyword">if</span> (v[x] &lt; v[y])</span><br><span class="line">                <span class="built_in">swap</span>(x, y);</span><br><span class="line">            <span class="type">int</span> p = ++num;</span><br><span class="line">            lc[p] = lc[x];</span><br><span class="line">            v[p] = v[x];</span><br><span class="line">            rc[p] = <span class="built_in">merge</span>(rc[x], y);</span><br><span class="line">            <span class="keyword">if</span> (dist[lc[p]] &lt; dist[rc[p]])</span><br><span class="line">                <span class="built_in">swap</span>(lc[p], rc[p]);</span><br><span class="line">            dist[p] = dist[rc[p]] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ST;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">        vis[s] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (fa[s])</span><br><span class="line">            ST.rt[s] = ST.<span class="built_in">merge</span>(ST.rt[s], ST.rt[fa[s]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = E2.head[s]; i; i = E2.G[i].next) &#123;</span><br><span class="line">            <span class="type">int</span> to = E2.G[i].to;</span><br><span class="line">            <span class="keyword">if</span> (fa[to] == s &amp;&amp; !vis[to])</span><br><span class="line">                <span class="built_in">dfs</span>(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cin &gt;&gt; N &gt;&gt; M &gt;&gt; K &gt;&gt; S &gt;&gt; T;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; i++) &#123;</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> x, y, z;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">            E1.<span class="built_in">addEdge</span>(x, y, z);</span><br><span class="line">            E2.<span class="built_in">addEdge</span>(y, x, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  Solve the K-th path problem.</span></span><br><span class="line"><span class="comment">        if answer is -1, there is no k-th path in this graph.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Q.<span class="built_in">push</span>(&#123;T, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (Q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            A = Q.<span class="built_in">top</span>();</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (tf[A.x])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            tf[A.x] = <span class="literal">true</span>;</span><br><span class="line">            dist[A.x] = A.val;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = E2.head[A.x]; i; i = E2.G[i].next) &#123;</span><br><span class="line">                Q.<span class="built_in">push</span>(&#123;E2.G[i].to, A.val + E2.G[i].dis&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tf[S])</span><br><span class="line">                <span class="keyword">return</span> dist[S];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(T);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tf[i])</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = E1.head[i]; j; j = E1.G[j].next)</span><br><span class="line">                    <span class="keyword">if</span> (!onTree[j])</span><br><span class="line">                        <span class="keyword">if</span> (tf[E1.G[j].to])</span><br><span class="line">                            ST.rt[i] = ST.<span class="built_in">merge</span>(</span><br><span class="line">                                ST.rt[i],</span><br><span class="line">                                ST.<span class="built_in">newNode</span>(&#123;</span><br><span class="line">                                    E1.G[j].to,</span><br><span class="line">                                    dist[E1.G[j].to] + E1.G[j].dis - dist[i]</span><br><span class="line">                                &#125;)</span><br><span class="line">                            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs2</span>(T);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ST.rt[S])</span><br><span class="line">            Q.<span class="built_in">push</span>(&#123;</span><br><span class="line">                ST.rt[S],</span><br><span class="line">                dist[S] + ST.v[ST.rt[S]].val</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (Q.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            A = Q.<span class="built_in">top</span>();</span><br><span class="line">            Q.<span class="built_in">pop</span>();</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (cnt == K - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> A.val;</span><br><span class="line">            <span class="keyword">if</span> (ST.lc[A.x])</span><br><span class="line">                Q.<span class="built_in">push</span>(&#123;</span><br><span class="line">                    ST.lc[A.x],</span><br><span class="line">                    A.val - ST.v[A.x].val + ST.v[ST.lc[A.x]].val</span><br><span class="line">                &#125;);</span><br><span class="line">            <span class="keyword">if</span> (ST.rc[A.x])</span><br><span class="line">                Q.<span class="built_in">push</span>(&#123;</span><br><span class="line">                    ST.rc[A.x],</span><br><span class="line">                    A.val - ST.v[A.x].val + ST.v[ST.rc[A.x]].val</span><br><span class="line">                &#125;);</span><br><span class="line">            <span class="type">int</span> X = ST.rt[ST.v[A.x].x];</span><br><span class="line">            <span class="keyword">if</span> (X)</span><br><span class="line">                Q.<span class="built_in">push</span>(&#123;X, A.val + ST.v[X].val&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Kth_Path::<span class="built_in">input</span>();</span><br><span class="line">    cout &lt;&lt; Kth_Path::<span class="built_in">solve</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;k-短路&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#k-短路&quot;&gt;&lt;/a&gt; K 短路&lt;/h1&gt;
&lt;h2 id=&quot;input&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#input&quot;&gt;&lt;/a&gt; Input&lt;</summary>
      
    
    
    
    <category term="XCPC" scheme="https://luoyu-ying.github.io/categories/XCPC/"/>
    
    
    <category term="图论" scheme="https://luoyu-ying.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="XCPC" scheme="https://luoyu-ying.github.io/tags/XCPC/"/>
    
  </entry>
  
  <entry>
    <title>字符串哈希</title>
    <link href="https://luoyu-ying.github.io/posts/bb54934ff9ed/"/>
    <id>https://luoyu-ying.github.io/posts/bb54934ff9ed/</id>
    <published>2022-04-28T11:49:23.000Z</published>
    <updated>2022-05-21T04:55:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="http://www.yhzq-blog.cc/%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E6%80%BB%E7%BB%93/">字符串Hash总结 | 远航休息栈</a></li></ul></blockquote><hr /><h1 id="code"><a class="markdownIt-Anchor" href="#code"></a> Code</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> StringHash &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">50</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> BASE = <span class="number">131</span>;</span><br><span class="line">    <span class="type">char</span> s[MAXN]; <span class="comment">// cin &gt;&gt; (s + 1);</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> hash[MAXN], power[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">preHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        power[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) </span><br><span class="line">            power[i] = power[i - <span class="number">1</span>] * BASE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">calcHash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            hash[i] = hash[i - <span class="number">1</span>] * BASE + s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">getHash</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)hash[r] - hash[l - <span class="number">1</span>] * power[r - l + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cin &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">        len = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringHash::<span class="built_in">input</span>();</span><br><span class="line">    StringHash::<span class="built_in">preHash</span>();</span><br><span class="line">    StringHash::<span class="built_in">calcHash</span>();</span><br><span class="line">    cout &lt;&lt; StringHash::<span class="built_in">getHash</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="使用字符串哈希完成其他算法"><a class="markdownIt-Anchor" href="#使用字符串哈希完成其他算法"></a> 使用字符串哈希完成其他算法</h1><h2 id="kmp"><a class="markdownIt-Anchor" href="#kmp"></a> KMP</h2><blockquote><p>给两个字符串 S1、S2，求 S2 是否是 S1 的字串，并求出 S2 在 S1 中出现的次数。</p></blockquote><p>将 S2 哈希后，在 S1 中查询所有长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mn>2</mn><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|S2|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">2</span><span class="mord">∣</span></span></span></span> 的字串，并进行哈希比较。</p><blockquote><p>复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mn>1</mn><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|S1|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。</p></blockquote><h2 id="ac-自动机"><a class="markdownIt-Anchor" href="#ac-自动机"></a> AC 自动机</h2><blockquote><p>给出 N 个单词串，和一个文章串，求每个单词串是否是文章串的子串，并求每个单词在文章中出现的次数。</p></blockquote><p>先把每一个单词串哈希，再把文章的每一个子串也进行整数，接下来只需要进行整数上的查找即可。</p><blockquote><p>复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>A</mi><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|A|^2+|S|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|S|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span></span></span></span> 是单词串总长，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>A</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|A|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">A</span><span class="mord">∣</span></span></span></span> 是文章串长度。</p></blockquote><h2 id="后缀数组"><a class="markdownIt-Anchor" href="#后缀数组"></a> 后缀数组</h2><blockquote><p>给出两个字符串 S1、S2，求它们的最长公共子串的长度。</p></blockquote><p>将 S1 的每一个子串都哈希成一个整数，再对 S2 的每一个字串进行哈希，并判断是否与 S1 的某一个字串相同，不断维护相同的字串的长度最大值即可。</p><blockquote><p>复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mn>1</mn><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mn>2</mn><msup><mi mathvariant="normal">∣</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|S1|^2+|S2|^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">2</span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</p></blockquote><h2 id="马拉车"><a class="markdownIt-Anchor" href="#马拉车"></a> 马拉车</h2><blockquote><p>给一个字符串 S，求 S 的最长回文子串。</p></blockquote><p>将 S 从前后两个方向分别进行字符车哈希。<br />先求子串长度位奇数的，再求偶数的。<br />枚举回文子串的中心位置，然后二分子串的长度，直到找到一个该位置的最长回文子串，不断维护长度最大值即可。</p><blockquote><p>复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|S|log|S|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。</p></blockquote><h2 id="扩展-kmp"><a class="markdownIt-Anchor" href="#扩展-kmp"></a> 扩展 KMP</h2><blockquote><p>给一个字符串 S，求 S 的每个后缀与S的最长公共前缀。</p></blockquote><p>枚举每一个后缀的起始位置，二分长度，求出每个后缀与S的最长公共前缀。</p><blockquote><p>复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(|S|log|S|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">∣</span><span class="mclose">)</span></span></span></span>。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文参考自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.yhzq-blog.cc/%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E6%80%BB%E7%BB%93/&quot;&gt;字符串Hash总结 | 远航休息栈&lt;/</summary>
      
    
    
    
    <category term="XCPC" scheme="https://luoyu-ying.github.io/categories/XCPC/"/>
    
    
    <category term="XCPC" scheme="https://luoyu-ying.github.io/tags/XCPC/"/>
    
  </entry>
  
  <entry>
    <title>View 的事件体系</title>
    <link href="https://luoyu-ying.github.io/posts/38fdb1d1c50f/"/>
    <id>https://luoyu-ying.github.io/posts/38fdb1d1c50f/</id>
    <published>2022-04-27T11:49:25.000Z</published>
    <updated>2022-05-21T04:53:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="view基础知识"><a class="markdownIt-Anchor" href="#view基础知识"></a> View基础知识</h1><h2 id="一-view的相关坐标和位置"><a class="markdownIt-Anchor" href="#一-view的相关坐标和位置"></a> 一、<code>View</code>的相关坐标和位置</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20180802114150486.jpg" style="zoom:80%;" /><p><strong>先来了解一个概念：</strong></p><p><code>view动画</code>不改变<code>view</code>的真实位置，就是肉眼看上去，<code>view</code>位置发生了变化，但是它的点击区域还是在原来的位置。</p><p>为了方便描述，下文中的的 <code>真实View</code>，表示真实位置的<code>View</code>，<code>看到的View</code>，表示肉眼看到的<code>View</code>。</p><p>属性动画和 <code>setTranslationX</code> / <code>setTranslationY</code> ，会改变显示位置和真实位置。</p><p>上图中<code>view1</code>是初始位置，通过执行<code>setTranslation</code>函数，得到的<code>view2</code>位置，其中<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>这几个值不会改变。</p><h3 id="lefttoprightbottom"><a class="markdownIt-Anchor" href="#lefttoprightbottom"></a> <code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code></h3><p><code>View</code>的位置主要由它的四个顶点的位置来决定，分别对应 View 的四个属性：<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>。对应的函数是<code>getLeft</code>，<code>getTop</code>，<code>getRight</code>，<code>getBottom</code>。</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td><code>left</code></td><td><code>View</code> 左上顶点相对于父容器的横坐标</td></tr><tr><td><code>top</code></td><td><code>View</code> 左上顶点相对于父容器的纵坐标</td></tr><tr><td><code>right</code></td><td><code>View</code> 右下顶点相对于父容器的横坐标</td></tr><tr><td><code>bottom</code></td><td><code>View</code> 右下顶点相对于父容器的纵坐标</td></tr></tbody></table><p>这几个值表示的是View的真身位置，它表示哪里，点击区域就在哪里。和肉眼在屏幕上看到的位置可能不一样。</p><h3 id="xy"><a class="markdownIt-Anchor" href="#xy"></a> <code>X</code>，<code>Y</code></h3><p>上面说到view动画不改变<code>view</code>的真实位置（也就是不改变<code>view</code>的<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>）。</p><p>看到的view相对于真实<code>view</code>，位置发生了变化，但是它的点击区域还是在真实view的位置。</p><p>从 Android 3.0 开始，<code>View</code> 增加了 x，y，<code>translationX</code> 和 <code>translationY</code>。</p><p>x，y 是看到的<code>view</code>的左上角相对父容器的坐标，但不同于 left 和 top ，这两个坐标点的值并一定都是相等的。</p><p>真实<code>view</code> 和 看到<code>view</code>的偏差用 <code>translationX</code> 和 <code>translationY</code> <code>来表示</code>。</p><h3 id="translationxtranslationy"><a class="markdownIt-Anchor" href="#translationxtranslationy"></a> <code>translationX</code>，<code>translationY</code></h3><p>**android开发艺术探索中，关于<code>translationX</code>的讲解是错误的。**真实情况是，<code>translationX</code>是<code>真实view</code> 相对于<code>看到view</code>的 x 方向偏移量。</p><p>从上图可以得知：<code>x</code> = <code>left</code> + <code>translationX</code>。</p><h2 id="二-点击事件的xy坐标"><a class="markdownIt-Anchor" href="#二-点击事件的xy坐标"></a> 二、点击事件的<code>XY</code>坐标</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20180802143219331.jpg" style="zoom:50%;" /><h2 id="三-motionevent"><a class="markdownIt-Anchor" href="#三-motionevent"></a> 三、<code>MotionEvent</code></h2><p>常见的触摸动作一共有三个：</p><ol><li><code>ACTION_DOWN</code>手指按下动作</li><li><code>ACTION_MOVE</code>手指滑动动作</li><li><code>ACTION_UP</code>    手指抬起动作</li></ol><h2 id="四-gesturedetector"><a class="markdownIt-Anchor" href="#四-gesturedetector"></a> 四、<code>GestureDetector</code></h2><p>手势检测，检测用户的单击、双击、长按等操作。</p><p>通过创建<code>GestureDetector</code>对象并实现<code>OnGestureListener</code>接口（检测单击相关手势）或者<code>OnDoubleTapListener</code>接口（检测双击相关动作）。</p><h2 id="五-touchslop"><a class="markdownIt-Anchor" href="#五-touchslop"></a> 五、<code>TouchSlop</code></h2><p>不同安卓设备认为的最小的滑动距离，低于此距离，将不认为用户在滑动，开发者可自行更改，默认为<code>8dp</code>。</p><h2 id="六-velocitytracker"><a class="markdownIt-Anchor" href="#六-velocitytracker"></a> 六、<code>VelocityTracker</code></h2><p>速度检测，可以计算出用户的手势的滑动速度。</p><p>注意，在<code>VelocityTracker#computeCurrentVelocity(int time)</code>中的<code>time</code>参数是我们计算速度的单位时间，相同的速度用不同的单位时间会有不同的表示方法。</p><h2 id="七-scroller"><a class="markdownIt-Anchor" href="#七-scroller"></a> 七、<code>Scroller</code></h2><p>弹性滑动对象，由于View中的<code>scrollTo/scrollBy</code>都是瞬间完成位移的。对用户的使用体验不太友好，所以引入弹性滑动对象，使得<code>View</code>的滑动变得可视化。</p><h1 id="view的滑动"><a class="markdownIt-Anchor" href="#view的滑动"></a> View的滑动</h1><h2 id="一-scrolltoscrollby"><a class="markdownIt-Anchor" href="#一-scrolltoscrollby"></a> 一、<code>scrollTo</code>/<code>scrollBy</code></h2><p>View有专门的方法实现滑动，即<code>scrollTo()</code>, <code>scrollBy()</code>;</p><p>这两个函数只能将<code>View</code>中间的内容进行位移，但是不能改变<code>View</code>本身的位置。</p><p>可以方便的实现滑动效果并且不影响内部元素的点击事件。</p><p><code>scrollTo(int destX, int destY)</code>直接让View出现在目标位置，无中间动画。</p><p>参数变量的单位都是像素级。</p><h2 id="二-使用动画"><a class="markdownIt-Anchor" href="#二-使用动画"></a> 二、使用动画</h2><p>有两种动画的使用方法。</p><ol><li><p><code>View</code>动画</p><p>在<code>XML</code>文件里面通过改变<code>translationX</code>/<code>translationY</code>的方式来实现View的移动效果。</p></li><li><p>属性动画</p><p>在<code>Android3.0</code>版本以上，可以使用<code>ObjectAnimator</code>类来实现属性动画的效果。</p><p>在<code>Android3.0</code>以下的版本中，我们需要自己加载开源动画库<code>NineOldAndroids</code>。</p></li></ol><p>在<code>XML</code>文件中，有一个<code>andoird:fillAfter=&quot;true|false&quot;</code>的选项。</p><p>当为<code>true</code>的时候，View在动画结束后，图像将停留在目标位置上。</p><p>当为<code>false</code>的时候，View会在动画结束后，从末位置消失，重新在初位置出现。</p><p>不论是<code>true</code>还是<code>false</code>，View的点击事件的坐标还是在原先的初始位置上，并不会随着<code>View</code>的移动而移动。</p><p>在<code>Android3.0</code>以上使用属性动画可以解决这样的问题。</p><h2 id="三-改变布局参数"><a class="markdownIt-Anchor" href="#三-改变布局参数"></a> 三、改变布局参数</h2><p>通过修改<code>View</code>的<code>marginLeft</code>等等布局参数，以此来达到<code>View</code>滑动的效果。</p><h1 id="弹性滑动"><a class="markdownIt-Anchor" href="#弹性滑动"></a> 弹性滑动</h1><h2 id="一-scroller"><a class="markdownIt-Anchor" href="#一-scroller"></a> 一、<code>Scroller</code></h2><p><code>Scroller#smoothScrollTo(int destX, int destY)</code>将<strong>目标位置与初始位置的偏移值delta</strong>计算后调用<code>startScroller()</code>方法存储相关参数，并开始使用<code>invalidate()</code>方法重绘<code>View</code>。重绘<code>View</code>时的<code>draw()</code>方法会调用<code>computeScroll()</code>方法，其中又会调用<code>invalidate</code>方法重绘<code>View</code>，不断的循环。由于<code>scrollTo(int destX, int destY)</code>直接让View出现在目标位置，所以我们在<code>computeScroll()</code>方法中采取微分法的做法，即将一段长距离拆分成许多微小的距离。不断通过<code>scrollTo()</code>的直接滑动以及<code>computeScrollOffset()</code>的重新计算下一个短距离的相关参数以及<code>postInvalidate()</code>的重绘View，最终达到弹性滑动的效果。</p><p><code>computeScrollOffset()</code>方法通过计算目前已经位移的百分比来计算下一次的位移目标以及是否已经完成的滑动，不通过计时器等工具。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  flowchart TDA[startScroll]B[invalidate]C[computeScroll]D[computeScrollOffset : boolean]E[invalidate]A --&gt; B --&gt;|draw| C --&gt; D --&gt;|not finish| E --&gt;|draw| CD --&gt;|finish| F[finish]  </pre></div><h2 id="二-通过动画"><a class="markdownIt-Anchor" href="#二-通过动画"></a> 二、通过动画</h2><p>通过<code>ObjectAnimator类</code>我们可以直接的通过动画完成<code>View</code>的弹性滑动。</p><p>我们也可以通过<code>onAnimatorUpdate</code>方法还自定义自己想要的动画效果。</p><h2 id="三-使用延时策略"><a class="markdownIt-Anchor" href="#三-使用延时策略"></a> 三、使用延时策略</h2><p>可以通过<code>Thread#sleep</code>或者<code>Handler#postDelayed</code>方法来达到间隔一定的时间就改变一次微小位置变化的操作。</p><p>在此次的<code>scrollTo</code>方法执行结束后，通过<code>sleep|postDelayed</code>方法暂停一定的时间，然后重复执行<code>scrollTo</code>的方法，以此来达到弹性滑动的效果。</p><p>**注意：**无法在精准的时间内移动固定的位移，因为系统的消息调度（<code>sleep|postDelayed</code>）也是需要时间的。</p><h1 id="view的事件分发机制"><a class="markdownIt-Anchor" href="#view的事件分发机制"></a> <code>View</code>的事件分发机制</h1><h2 id="一-点击事件的传递规则"><a class="markdownIt-Anchor" href="#一-点击事件的传递规则"></a> 一、点击事件的传递规则</h2><p>点击事件分发过程，即将一系列的<code>MotionEvent</code>事件序列（由<code>ACTION_DOWN</code>开始到<code>ACTION_UP</code>结束的一连串操作）交给一个<code>View</code>执行的过程。</p><p>点击事件的分发主要由三个重要方法构成：<code>dispatchTouchEvent</code>, <code>onInterceptTouchEvent</code>,<code>onTouchEvent</code>。</p><p>三个方法的执行顺序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123; <span class="comment">// 对当前的View进行事件的分发</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">consume</span> <span class="operator">=</span> <span class="literal">false</span>;                        <span class="comment">// 判断是否可以消耗这个事件序列</span></span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123;                <span class="comment">// 如果准备拦截此次事件序列</span></span><br><span class="line">        consume = onTouchEvent(ev);                 <span class="comment">// 事件由该View执行，并返回结果</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        consume = child.dispatchTouchEvent(ev);     <span class="comment">// 若不准备拦截，则交给子View进行判断</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consume;                                 <span class="comment">// 向父级返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中执行事件序列的不同方法中同样由优先顺序：<code>onTouchListener &gt; onTouchEvent &gt; onClickListener</code></p><p>当点击事件发生后，它的传递过程会遵循以下的顺序：<code>Activity　-&gt; Window -&gt; DecorView -&gt; View -&gt; ...</code>、</p><p>同时，如果子级发现无法执行这个事件的时候，那么它的父容器的<code>onTouchEvent</code>就会重新调用，直到<code>Activity</code>。</p><p>其中，<code>ViewGroup</code>默认不拦截任何事件，<code>View</code>没有<code>onInterceptTouchEvent</code>方法。</p><h2 id="二-事件分发解析"><a class="markdownIt-Anchor" href="#二-事件分发解析"></a> 二、事件分发解析</h2><h3 id="activity对点击事件的分发"><a class="markdownIt-Anchor" href="#activity对点击事件的分发"></a> <code>Activity</code>对点击事件的分发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) <span class="comment">// 如果Window可以处理点击事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev); <span class="comment">// 返回Activity自己处理点击事件的结果(true|false)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="window对点击事件的分发"><a class="markdownIt-Anchor" href="#window对点击事件的分发"></a> <code>Window</code>对点击事件的分发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> PhoneWindow#superDispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">  <span class="keyword">return</span> mDecor.superDispatchTouchEvent(ev); <span class="comment">// 返回DecorView的处理结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顶级view对点击事件的分发"><a class="markdownIt-Anchor" href="#顶级view对点击事件的分发"></a> <code>顶级View</code>对点击事件的分发</h3><p>由此开始，将执行（一）所讲述的事件传递规则。其主要的部分是<code>ViewGroup</code>的事件传递。<code>顶级View</code>一般来说都是<code>ViewGroup</code>。</p><h4 id="判断当前viewgroup是否拦截点击事件"><a class="markdownIt-Anchor" href="#判断当前viewgroup是否拦截点击事件"></a> 判断当前<code>ViewGroup</code>是否拦截点击事件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION.DOWN || mFirstTouchTarget != NULL) &#123; <span class="comment">// 意思见下方文字</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>; <span class="comment">// 判断是否允许屏蔽自身的onInterceptTouchEvent方法</span></span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123; <span class="comment">// 如果允许拦截</span></span><br><span class="line">        intercepted = onInterceptTouchEvent(ev); <span class="comment">// 询问能否拦截并赋值</span></span><br><span class="line">        ev.setAction(action); <span class="comment">// 防止事件被修改，存储事件的动作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="literal">false</span>; <span class="comment">// 由于不允许拦截，则直接赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    intercepted = <span class="literal">true</span>; <span class="comment">// 由于直接拦截，则不用询问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的几个变量的作用：</p><ol><li><p>当事件由<code>ViewGroup</code>的子元素处理成功时，<code>mFirstTouchTarget</code>就会被赋值并指向子元素，此时的<code>mFirstTouchTarget != NULL</code>。</p></li><li><p><code>FLAG_DISALLOW_INTERCEPT</code>一旦被设置后，那么当前的<code>ViewGroup</code>就无法拦截<code>ACTION_MOVE</code>以及<code>ACTION_UP</code>。</p><p>由于事件为<code>ACTION_DOWN</code>的时候，<code>ViewGroup</code>会重置<code>FLAG_DISALLOW_INTERCEPT</code>，所以每次事件为<code>ACTION_DOWN</code>的时候，都会执行一次<code>onInterceptTouchEvent</code>方法。</p></li></ol><p>第3行的判断语句的意思为：</p><ol><li>如果当前的事件为<code>ACTION_DOWN</code>时，作为一个点击事件的开始，需要向子元素传递，返回<code>true</code>。允许向子元素传递。</li><li>如果当前的事件为<code>ACTION_MOVE</code>或者<code>ACTION_UP</code>的时候，如果<code>ACTION_DOWN</code>已经被子元素处理了（<code>mFirstTouchTarget != NULL</code>），那么由于一系列的点击事件都要有同一个<code>View</code>处理，则不能在此拦截，故返回<code>true</code>。反之，如果<code>mFirstTouchTarget == NULL</code>，则代表<code>ACTION_DOWN</code>是由<code>ViewGroup</code>自身处理的，则不能向下传递，返回<code>false</code>。</li></ol><h4 id="viewgroup在action_down到来时的重置操作"><a class="markdownIt-Anchor" href="#viewgroup在action_down到来时的重置操作"></a> <code>ViewGroup</code>在<code>ACTION_DOWN</code>到来时的重置操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle an initial down.</span></span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">cancelAndClearTouchTargets(ev);</span><br><span class="line">resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>resetTouchState</code>方法中会对<code>FLAG_DISALLOW_INTERCEPT</code>进行重置。</p><p>因此<code>子View</code>的<code>requestDisallowInterceptTouchEvent</code>方法并不能影响<code>ViewGroup</code>对<code>ACTION_DOWN</code>事件的处理。</p><h4 id="viewgroup不拦截事件时对点击事件的分发"><a class="markdownIt-Anchor" href="#viewgroup不拦截事件时对点击事件的分发"></a> <code>ViewGroup</code>不拦截事件时，对点击事件的分发</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> View[] = mChildren;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 获取每一个子View的位置以及其他信息</span></span><br><span class="line">    <span class="keyword">if</span> (子元素正在播放动画 || 点击事件的坐标落在当前子元素的区域外) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    newTouchTarget = getTouchTarget(child); </span><br><span class="line">    <span class="keyword">if</span> (newTouchTarget != NULL) &#123; <span class="comment">// 如果不是NULL的话(该child之前初始化过)，就直接向其中添加元素就行了</span></span><br><span class="line">        newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果 newTouchTarget == NULL, 那么就初始化 + 添加第一个可用子元素</span></span><br><span class="line">    resetCancelNextUpFlag(child);</span><br><span class="line">    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="literal">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">        alreadyDispatchedToNewTouchTarget = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不断的遍历当前<code>ViewGroup</code>的所有子元素，如果<strong>子元素不在播放动画</strong>以及<strong>点击事件的坐标落在当前子元素的区域内</strong>，那么这个子元素就是一个可以传递的。</p><blockquote><p>由<code>TouchTarget</code>源码可知：</p><p><code>TouchTarget</code>保存了响应触摸事件的子<code>view</code>和该子view上的触摸点ID集合，表示一个触摸事件派发目标。通过<code>next</code>成员可以看出，它支持作为一个链表节点储存。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TouchTarget</span> &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The touched child view.</span></span><br><span class="line">    <span class="comment">// 被触摸的子元素</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> View child;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The combined bit mask of pointer ids for all pointers captured by the target.</span></span><br><span class="line">    <span class="comment">// 指针 id 的位的掩码组合，用于目标捕获的所有指针</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> pointerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The next target in the target list.</span></span><br><span class="line">    <span class="comment">// 目标列表中的下一个目标</span></span><br><span class="line">    <span class="keyword">public</span> TouchTarget next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「分则能成」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/dehang0/article/details/104317611</span></span><br></pre></td></tr></table></figure></blockquote><p>如果是第一个可传递元素，那么就会进入初始化部分，其中的<code>dispatchTransformedTouchEvent</code>方法实际上就是调用的子元素的<code>dispatchTouchEvent</code>方法。在该方法中有如下的一段内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == NULL) &#123;</span><br><span class="line">    handled = <span class="built_in">super</span>.dispatchTouchTarget(event);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handled = child.dispatchTouchTarget(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于前面的代码中<code>dispatchTransformedTouchEvent</code>方法的第三个参数为<code>child</code>，所以会执行子元素的<code>dispatchTouchEvent</code>方法，点击事件交由子元素处理，从而完成了一轮事件的分发。</p><p>当子元素的<code>dispatchTouchEvent</code>方法返回<code>true</code>时，<code>dispatchTransformedTouchEvent</code>方法同样也会返回<code>true</code>，接着便执行<code>if语句</code>的代码块部分了。如果<code>dispatchTouchEvent</code>方法返回<code>false</code>的话，<code>ViewGroup</code>就会把事件向后遍历，寻找新的可传递的子元素。在<code>if语句</code>的代码块中，<code>mFirstTouchTarget</code>会被赋值同时跳出<code>for循环</code>。</p><p>其中<code>mFirstTouchTarget</code>的赋值由<code>addTouchTarget</code>方法完成，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TouchTarget <span class="title function_">addTouchTarget</span><span class="params">(View child, <span class="type">int</span> pointerIdBits)</span> &#123;</span><br><span class="line">    <span class="type">TouchTarget</span> <span class="variable">target</span> <span class="operator">=</span> TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">   target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以很容易的看出，<code>mFirstTouchTarget</code>其实是一个<strong>单链表结构</strong>，<code>mFirstTouchTarget</code>是否被赋值，将直接影响<code>ViewGroup</code>对事件的拦截策略。</p><h4 id="viewgroup中没有合适的子元素"><a class="markdownIt-Anchor" href="#viewgroup中没有合适的子元素"></a> <code>ViewGroup</code>中没有合适的子元素</h4><p>有两种情况，<code>ViewGroup</code>中会没有合适的子元素可以传递：</p><ol><li><code>ViewGroup</code>没有子元素</li><li>子元素处理了点击事件，但是<code>dispatchTouchEvent</code>方法返回了<code>false</code>，这一般是因为子元素在<code>onTouchEvent</code>中返回了<code>false</code>。</li></ol><p>在这两种情况中，<code>ViewGroup</code>都会自己处理点击事件。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == NULL) &#123;</span><br><span class="line"><span class="comment">// 没有可分发子元素，就当其是一个普通的View</span></span><br><span class="line">handled = dispatchTransformedTouchEvent(ev, canceled, <span class="literal">null</span>, TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，代码中的<code>dispatchTransformedTouchEvent</code>方法的第三个参数将其设置为<code>null</code>，此时它就会调用<code>super.dispatchTouchTarget</code>方法了。</p><h3 id="view对点击事件的处理过程"><a class="markdownIt-Anchor" href="#view对点击事件的处理过程"></a> <code>View</code>对点击事件的处理过程</h3><p>这里的<code>View</code>不包含<code>ViewGroup</code>，因为没有子元素，所以不用向下分发事件，只能自己处理事件。</p><p>先看它的<code>dispatchTouchEvent</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="type">ListenerInfo</span> <span class="variable">li</span> <span class="operator">=</span> mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="literal">null</span> &amp;&amp; li.mOnTouchListener.onTouch(<span class="built_in">this</span>, event) &amp;&amp; ...) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的代码可以看出，<code>View</code>对点击事件的处理流程中，首先会判断有没有设置<code>onTouchListener</code>，如果有且其中的<code>onTouch</code>方法返回<code>true</code>，则<code>onTouchEvent</code>方法就不会被调用。</p><p>从其他的代码中也可以得出的一些结论：</p><ol><li>如果<code>View</code>的<code>CLICKABLE</code>以及<code>LONG_CLICKABLE</code>中有一个为<code>true</code>，不论<code>View</code>是否为<code>DISABLE</code>，都会消耗事件（也就是即使<code>View</code>看起来没有任何的反应，但是也消耗了点击事件）。</li><li><code>View</code>的<code>LONG_CLICKABLE</code>默认为<code>false</code>，而<code>CLICKABLE</code>是否为<code>false</code>与其<code>View</code>有关，如<code>button</code>的默认为<code>true</code>、<code>textview</code>的默认为<code>false</code>。</li><li>当<code>ACTION_UP</code>事件发生时，会触发<code>performClick</code>方法，如果<code>View</code>设置了<code>OnClickListener</code>，那么<code>performClick</code>方法就会调用它的<code>onClick</code>方法。（即<code>onClick</code>的触发前提时<code>View</code>是可点击的，且收到了<code>DOWN</code>和<code>UP</code>的点击事件。）</li><li><code>setOnClickListener</code>方法会自动将<code>CLICKABLE</code>设置为<code>true</code>，<code>setOnLongClickListener</code>方法会自动将<code>LONG_CLICKABLE</code>设置为<code>true</code>。</li></ol><h1 id="view的滑动冲突"><a class="markdownIt-Anchor" href="#view的滑动冲突"></a> <code>View</code>的滑动冲突</h1><p>总共会出现三种滑动冲突的情况：</p><ol><li><code>内部View</code>与<code>外部View</code>的滑动方向相反。</li><li><code>内部View</code>与<code>外部View</code>的滑动方向相同。</li><li>前两种情况的嵌套。</li></ol><p>三种情况的处理思路：</p><ol><li>通过手势滑动的角度判断滑动的方向。</li><li>通过当前处于的不同的页面状态来判断应该滑动的<code>View</code>。</li><li>通过前两种的综合使用。</li></ol><h2 id="滑动冲突的解决方式"><a class="markdownIt-Anchor" href="#滑动冲突的解决方式"></a> 滑动冲突的解决方式</h2><h3 id="外部拦截法"><a class="markdownIt-Anchor" href="#外部拦截法"></a> 外部拦截法</h3><p>通过重写<strong>父容器的</strong><code>onInterceptTouchEvent</code>方法，所有的事件都先经过父容器的筛选，对其中父容器需要的事件进行拦截。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">intercepted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) event.getX();</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) event.getY();</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN : &#123;</span><br><span class="line">            intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE : &#123;</span><br><span class="line">            <span class="keyword">if</span> (父容器需要当前的点击事件)</span><br><span class="line">                intercepted = <span class="literal">true</span>;</span><br><span class="line">           <span class="keyword">else</span> </span><br><span class="line">                intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP : &#123;</span><br><span class="line">            intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastXIntercept = x;</span><br><span class="line">    mLastYIntercept = y;</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内部拦截法"><a class="markdownIt-Anchor" href="#内部拦截法"></a> 内部拦截法</h3><p>父元素拦截除<code>ACTION_DOWN</code>以外的其他事件，当事件到达子元素后，由子元素判断是否需要这些事件，不需要的事件将重新交由父容器来处理。这种方法和Android的事件分发机制不一致，需要配合<code>requestDisallowInterceptTouchEvent</code>方法才能正常的工作。</p><p>相关阅读链接：<a href="https://www.jianshu.com/p/fe3d109eb27e">Android TouchEvent之requestDisallowInterceptTouchEvent - 简书 (jianshu.com)</a></p><h4 id="子元素的dispatchtouchevent方法"><a class="markdownIt-Anchor" href="#子元素的dispatchtouchevent方法"></a> 子元素的<code>dispatchTouchEvent</code>方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) event.getX();</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) event.getY();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN : &#123;</span><br><span class="line">            parent.requestDisallowInterceptTouchEvent(<span class="literal">true</span>); <span class="comment">// 此子View的所有父ViewGroup会跳过onInterceptTouchEvent回调</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE : &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">deltaX</span> <span class="operator">=</span> x - mLastX;</span><br><span class="line">            <span class="type">int</span> <span class="variable">deltaY</span> <span class="operator">=</span> y - mLastY;</span><br><span class="line">            <span class="keyword">if</span> (父容器需要当前的点击事件) &#123;</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP : &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> : </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastX = x;</span><br><span class="line">    mLastY = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="父容器的onintercepttouchevent方法"><a class="markdownIt-Anchor" href="#父容器的onintercepttouchevent方法"></a> 父容器的<code>onInterceptTouchEvent</code>方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;view基础知识&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#view基础知识&quot;&gt;&lt;/a&gt; View基础知识&lt;/h1&gt;
&lt;h2 id=&quot;一-view的相关坐标和位置&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href</summary>
      
    
    
    
    <category term="Android" scheme="https://luoyu-ying.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="https://luoyu-ying.github.io/tags/Android/"/>
    
    <category term="View" scheme="https://luoyu-ying.github.io/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>XCPC 读入操作模板</title>
    <link href="https://luoyu-ying.github.io/posts/cec9f65c0174/"/>
    <id>https://luoyu-ying.github.io/posts/cec9f65c0174/</id>
    <published>2022-04-23T15:48:15.000Z</published>
    <updated>2022-05-21T04:54:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考：</p><ul><li><a href="https://www.cnblogs.com/AlvinZH/p/6798023.html">C/C++如何整行读入字符串？</a></li></ul></blockquote><hr /><h1 id="快速读入-int"><a class="markdownIt-Anchor" href="#快速读入-int"></a> 快速读入 <code>int</code></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        f = (ch == <span class="number">45</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))</span><br><span class="line">        x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> f ? (~x + <span class="number">1</span>) : x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="字符串整行读入"><a class="markdownIt-Anchor" href="#字符串整行读入"></a> 字符串整行读入</h1><h2 id="char-整行读入"><a class="markdownIt-Anchor" href="#char-整行读入"></a> char[] 整行读入</h2><h3 id="使用-gets-推荐"><a class="markdownIt-Anchor" href="#使用-gets-推荐"></a> 使用 <code>gets()</code> [推荐]</h3><p>读入不需要考虑换行符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[LEN];</span><br><span class="line"><span class="built_in">gets</span>(s);</span><br></pre></td></tr></table></figure><h3 id="使用-scanf"><a class="markdownIt-Anchor" href="#使用-scanf"></a> 使用 <code>scanf()</code></h3><p>无法读入末尾的换行符，需使用 <code>getchar()</code> 额外读取以便下一行的正常读入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[LEN];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%[^\m]&quot;</span>, s);</span><br><span class="line"><span class="built_in">getchar</span>(); <span class="comment">// 读取末尾换行符</span></span><br></pre></td></tr></table></figure><h3 id="使用-getchar"><a class="markdownIt-Anchor" href="#使用-getchar"></a> 使用 <code>getchar()</code></h3><p>无法读入末尾的换行符，需使用 <code>getchar()</code> 额外读取以便下一行的正常读入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[LEN];</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((s[len] = <span class="built_in">getchar</span>()) != <span class="string">&#x27;\n&#x27;</span>) </span><br><span class="line">  len++;</span><br><span class="line"><span class="built_in">getchar</span>(); <span class="comment">// 读取末尾换行符</span></span><br></pre></td></tr></table></figure><h3 id="使用-getline"><a class="markdownIt-Anchor" href="#使用-getline"></a> 使用 <code>getline()</code></h3><p>读入不需要考虑换行符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[LEN];</span><br><span class="line">cin.<span class="built_in">getline</span>(s, LEN);</span><br></pre></td></tr></table></figure><h2 id="string-整行读入"><a class="markdownIt-Anchor" href="#string-整行读入"></a> string 整行读入</h2><h3 id="使用-getline-2"><a class="markdownIt-Anchor" href="#使用-getline-2"></a> 使用 <code>getline()</code></h3><p>读入不需要考虑换行符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin, s);</span><br></pre></td></tr></table></figure><hr />]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本文参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/AlvinZH/p/6798023.html&quot;&gt;C/C++如何整行读入字符串？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;hr</summary>
      
    
    
    
    <category term="XCPC" scheme="https://luoyu-ying.github.io/categories/XCPC/"/>
    
    
    <category term="XCPC" scheme="https://luoyu-ying.github.io/tags/XCPC/"/>
    
  </entry>
  
</feed>
