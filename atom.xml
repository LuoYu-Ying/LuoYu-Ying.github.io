<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洛语 の Blog</title>
  
  
  <link href="https://luoyu-ying.github.io/atom.xml" rel="self"/>
  
  <link href="https://luoyu-ying.github.io/"/>
  <updated>2022-10-24T11:50:09.000Z</updated>
  <id>https://luoyu-ying.github.io/</id>
  
  <author>
    <name>LuoYu-Ying</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo Butterfly 美化-修改分割线的样式</title>
    <link href="https://luoyu-ying.github.io/posts/53768a5482ee/"/>
    <id>https://luoyu-ying.github.io/posts/53768a5482ee/</id>
    <published>2022-10-24T11:50:09.000Z</published>
    <updated>2022-10-24T11:50:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是分割线，上传前需要删除</p></blockquote><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>查看大佬们的博客的时候，并没有看到详细自定义分割线样式的博客，所以想记录一下自己美化分割线的过程。</p><blockquote><p><strong>Butterfly 主题默认分割线样式</strong></p>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221024200848426.png" alt="Butterfly 主题默认分割线样式" style="zoom:80%;" /></blockquote><blockquote><p><strong>通过修改后的分割线样式</strong></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026222103059.png" alt="通过修改后的分割线样式" /></p></blockquote><hr /><blockquote><p>通过对博客页面中的分割线进行查看页面源代码（F12）。可以发现相关样式的配置选项。</p></blockquote><hr /><h1 id="浮动图标图片"><a class="markdownIt-Anchor" href="#浮动图标图片"></a> 浮动图标图片</h1><p>将剪刀图片修改为其他的图片，如上文中的小汽车图片。</p><p>两种方式可以修改：</p><ol><li><p>修改 <code>_config.butterfly.yml</code> 文件中的 <code>hr_icon -&gt; icon</code> 内容（推荐）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The setting of divider icon (水平分隔線圖標設置)</span></span><br><span class="line"><span class="attr">hr_icon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">&#x27;\f5e4&#x27;</span> <span class="comment"># the unicode value of Font Awesome icon, such as &#x27;\3423&#x27;</span></span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br></pre></td></tr></table></figure></li><li><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>hr -&gt; &amp;:before -&gt; content</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hr</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attribute">content</span>: <span class="variable">$hr</span>-icon // 同样修改为如 <span class="string">&#x27;\3423&#x27;</span> 形式</span><br></pre></td></tr></table></figure></li></ol><blockquote><p><strong><code>the unicode value of Font Awesome icon</code> 获取方法：</strong></p><ol><li><p>打开 <code>Font Awesome</code> 网址：<a href="https://fontawesome.com/v5/search">Search v5 Icons | Font Awesome</a></p></li><li><p>通过搜索栏选择并点击自己心仪的图标</p></li><li><p>下图中箭头所指内容即为 <code>the unicode value of Font Awesome icon</code></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026225602023.png" alt="the unicode value of Font Awesome icon" style="zoom:60%;" /></li></ol></blockquote><hr /><h1 id="浮动图标颜色"><a class="markdownIt-Anchor" href="#浮动图标颜色"></a> 浮动图标颜色</h1><p>修改浮动图标的颜色，同样可以有两种方法进行更改：</p><ol><li><p>修改 <code>_config.butterfly.yml</code> 中的 <code>theme_color -&gt; hr_color</code> 内容（推荐）</p><p><strong>可能会将分割线横线的颜色同时进行更改。</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme_color:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br><span class="line">  <span class="attr">hr_color:</span> <span class="string">&quot;#A4D8FA&quot;</span> <span class="string">//</span> <span class="string">修改此处内容</span></span><br></pre></td></tr></table></figure></li><li><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>hr -&gt; &amp;:before -&gt; color</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hr</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attribute">color</span>: var(--hr-before-color) // 修改为如 <span class="number">#A4D8FA</span> 形式</span><br></pre></td></tr></table></figure></li></ol><hr /><h1 id="浮动图标相对于横线的位置"><a class="markdownIt-Anchor" href="#浮动图标相对于横线的位置"></a> 浮动图标相对于横线的位置</h1><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>hr -&gt; &amp;:before -&gt; line-height</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hr</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1</span> // 图标浮于横线中间，其他参数见下文</span><br></pre></td></tr></table></figure><p><strong><code>line-height</code> 参数说明：</strong></p><ul><li><p><code>1</code></p><p>图标浮于横线中间</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026230524821.png" style="zoom:80%;" /></li><li><p><code>0</code></p><p>图标浮于横线上方</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026230609189.png" style="zoom:80%;" /></li><li><p><code>-1</code></p><p>图标浮于横线下方</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026230634557.png" style="zoom:80%;" /></li></ul><hr />]]></content>
    
    
    <summary type="html">记录一下自己修改 Butterfly 主题的分割线样式修改过程。</summary>
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>《图解HTTP》阅读笔记（一）</title>
    <link href="https://luoyu-ying.github.io/posts/c6d0698aa12b/"/>
    <id>https://luoyu-ying.github.io/posts/c6d0698aa12b/</id>
    <published>2022-09-29T06:17:45.000Z</published>
    <updated>2022-09-29T06:17:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-了解web及网络基础"><a class="markdownIt-Anchor" href="#第一章-了解web及网络基础"></a> 第一章 了解Web及网络基础</h1><h2 id="http-诞生"><a class="markdownIt-Anchor" href="#http-诞生"></a> HTTP 诞生</h2><h3 id="为知识共享而规划-web"><a class="markdownIt-Anchor" href="#为知识共享而规划-web"></a> 为知识共享而规划 Web</h3><p>现在已经提出了 3 项 WWW （万维网）构建技术，分别是：</p><ol><li>作为页面的文本标记语言的 HTML（超文本标记语言）</li><li>所谓文档传递协议的 HTTP（超文本传输协议）</li><li>指定文档所在地址的 URL（统一资源定位符）</li></ol><h3 id="驻足不前的-http"><a class="markdownIt-Anchor" href="#驻足不前的-http"></a> 驻足不前的 HTTP</h3><ol><li>HTTP/0.9</li><li>HTTP/1.0</li><li>HTTP/1.1</li></ol><h2 id="网络基础-tcpip"><a class="markdownIt-Anchor" href="#网络基础-tcpip"></a> 网络基础 TCP/IP</h2><blockquote><p>不同的硬件、操作系统之间 的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议 （protocol）。</p><p><strong>TCP/IP 是互联网相关的各类协议族的总称。</strong></p></blockquote><h3 id="tcpip-的分层管理"><a class="markdownIt-Anchor" href="#tcpip-的分层管理"></a> TCP/IP 的分层管理</h3><p>TCP/IP 协议族按层次分别 分为以下 4 层：应用层、传输层、网络层和数据链路层。TCP/IP 协议族各层的作用如下。</p><p><strong>应用层</strong></p><p>应用层决定了向用户提供应用服务时通信的活动。HTTP 协议也处于该层。</p><p><strong>传输层</strong></p><p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的 数据传输。</p><p>在传输层有两个性质不同的协议：TCP（Transmission Control  Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据 报协议）。</p><p><strong>网络层</strong></p><p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。</p><p>网络层 所起的作用就是在众多的选项内选择一条传输路线</p><p><strong>链路层</strong></p><p>硬件上的范畴 均在链路层的作用范围之内。</p><h3 id="tcpip-通信传输流"><a class="markdownIt-Anchor" href="#tcpip-通信传输流"></a> TCP/IP 通信传输流</h3><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221006225838653.png" alt="image-1" style="zoom:67%;" /><p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221006225940392.png" alt="image-2" style="zoom: 67%;" /><p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个 该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层 时会把对应的首部消去。</p><p>这种把数据信息包装起来的做法称为封装（encapsulate）。</p><h2 id="理解-ip-tcp-和-dns-协议"><a class="markdownIt-Anchor" href="#理解-ip-tcp-和-dns-协议"></a> 理解 IP、TCP 和 DNS 协议</h2><h3 id="负责传输的-ip-协议"><a class="markdownIt-Anchor" href="#负责传输的-ip-协议"></a> 负责传输的 IP 协议</h3><p>按层次分，IP（Internet Protocol）网际协议位于网络层。TCP/IP 协议族中的 IP 指的就是网际协议。</p><p>可能有人会 把 “IP” 和 “IP 地址” 搞混，“IP” 其实是一种协议的名称。</p><ul><li><strong>IP 协议</strong> 的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。</li><li><strong>IP 地址</strong> 指明了节点被分配到的地址，MAC 地址是指网卡所属的固 定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。</li></ul><p><strong>使用 ARP 协议凭借 MAC 地址进行通信</strong></p><p>IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网 （LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。</p><p>这时，会采用 ARP 协议（Address Resolution  Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。</p><p><strong>没有人能够全面掌握互联网中的传输状况</strong></p><p>在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线。</p><p>这种机制称为路由选择（routing），无论哪台计算机、哪台网络设备，它 们都无法全面掌握互联网中的细节。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221006230911597.png" alt="image-3" style="zoom:67%;" /><h3 id="确保可靠性的-tcp-协议"><a class="markdownIt-Anchor" href="#确保可靠性的-tcp-协议"></a> 确保可靠性的 TCP 协议</h3>]]></content>
    
    
    <summary type="html">《图解HTTP》 第一章、第二章</summary>
    
    
    
    <category term="HTTP" scheme="https://luoyu-ying.github.io/categories/HTTP/"/>
    
    
    <category term="HTTP" scheme="https://luoyu-ying.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 在同一行中声明多个变量</title>
    <link href="https://luoyu-ying.github.io/posts/d5b7437105b8/"/>
    <id>https://luoyu-ying.github.io/posts/d5b7437105b8/</id>
    <published>2022-09-28T11:26:57.000Z</published>
    <updated>2022-09-28T11:26:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：尽管在 <code>Kotlin</code> 中可以达到一行中声明多个变量的效果，但是不推荐如此做。</p></blockquote><hr /><p>在 <code>Kotlin</code> 中，正常情况下无法做到将多个变量放在同一行中声明。</p><p>我们可以通过取巧的方法达到我们所需要的效果，<strong>但是不适用与 <code>lateinit</code> 前缀</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">18</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明了 8 个变量，支持 val / var</span></span><br><span class="line">    <span class="keyword">var</span> (a, b, c, d) = listOf(<span class="string">&quot;fly&quot;</span>, <span class="number">9</span>, <span class="number">55.9</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">val</span> (e, f) = listOf(<span class="string">&#x27;c&#x27;</span>, person)</span><br><span class="line">    <span class="keyword">val</span> (name, age) = person</span><br><span class="line">    </span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$a</span> <span class="variable">$b</span> <span class="variable">$c</span> <span class="variable">$d</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$e</span> <span class="variable">$f</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$name</span> <span class="variable">$age</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fly <span class="number">9</span> <span class="number">55.9</span> <span class="literal">true</span></span><br><span class="line">c Person(name=Jack, age=<span class="number">18</span>)</span><br><span class="line">Jack <span class="number">18</span></span><br></pre></td></tr></table></figure><hr /><p>可以发现，该方法本用于取出一个类变量的主构造方法中的所有参数，但是我们仍然可以使用该方法完成我们想要的效果。</p><p>我们使用 <code>listOf</code> 创建了类型为 <code>Object</code> 的列表，并且一一对应的将其赋值给了前面我们定义的变量的顺序，这样我们就完成了一行中进行多个变量的声明的操作了。</p><p><strong>此方法不适用于含有 <code>lateinit</code> 前缀的变量声明。</strong></p><p>相较于其他的语言，如 <code>double a, b, c, d;</code>，这种方法可以在一行中声明不同的类型的变量。</p>]]></content>
    
    
    <summary type="html">探索如何在同一行中声明多个属性。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>英语 编程命名 单词规范表 [自用]</title>
    <link href="https://luoyu-ying.github.io/posts/03b86e3ef474/"/>
    <id>https://luoyu-ying.github.io/posts/03b86e3ef474/</id>
    <published>2022-09-13T06:30:07.000Z</published>
    <updated>2022-09-13T06:30:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命名规范"><a class="markdownIt-Anchor" href="#命名规范"></a> 命名规范</h1><ol><li>属性使用名词性短语。</li><li>动作使用动词或者一个描述当前函数功能的一个动作短语。</li><li>函数命名无需使用任何时态，皆使用一般形式即可。</li><li>编写函数时，尽量满足函数单一职责以及不变性原则。</li></ol><hr /><h1 id="单词表"><a class="markdownIt-Anchor" href="#单词表"></a> 单词表</h1><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">词性</th><th style="text-align:center">中文</th></tr></thead><tbody><tr><td style="text-align:center">landscape</td><td style="text-align:center">n.</td><td style="text-align:center">横屏</td></tr><tr><td style="text-align:center">portrait</td><td style="text-align:center">n.</td><td style="text-align:center">竖屏</td></tr><tr><td style="text-align:center">start</td><td style="text-align:center">v.</td><td style="text-align:center">开始、启动</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">规范和整理一下自己在写代码时命名的统一和规范。(持续更新)</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Android Studio 调试断点类型</title>
    <link href="https://luoyu-ying.github.io/posts/624cb914d8f1/"/>
    <id>https://luoyu-ying.github.io/posts/624cb914d8f1/</id>
    <published>2022-09-04T12:31:36.000Z</published>
    <updated>2022-09-04T12:31:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>更多内容待完善~ ( •̀ ω •́ )✧</p></blockquote><p>在 <code>Intellj IDEA</code> 和 <code>Android Studio</code> 两个软件中调试 <code>Kotlin</code> 代码的时候，肯定会与断点打交道，那么扩充关于断点的知识可以让我们进行更加方便和快速的工作。</p><hr /><h1 id="调试的两种方法"><a class="markdownIt-Anchor" href="#调试的两种方法"></a> 调试的两种方法</h1><h2 id="debug-app"><a class="markdownIt-Anchor" href="#debug-app"></a> <code>Debug App</code></h2><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220912113808254.png" alt="image-20220912113808254" /></p><p>会重新进行一次编译，并使用新打出的 debug 包进行调试，对于较大项目来说，可能会使得调试的等待时间大幅增加。</p><h2 id="attach-debugger-to-android-process"><a class="markdownIt-Anchor" href="#attach-debugger-to-android-process"></a> <code>Attach Debugger to Android Process</code></h2><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220912120636190.png" alt="image-20220912120636190" /></p><p>可使用已经编译好的程序直接进行调试，降低等待调试的时间。推荐优先使用该方式。</p><hr /><h1 id="断点的-7-种类型"><a class="markdownIt-Anchor" href="#断点的-7-种类型"></a> 断点的 7 种类型</h1><p>断点从功能方面来看一共有 7 种：</p><ol><li><code>Line Breakpoint</code></li><li><code>Field Watchpoint</code></li><li><code>Method Watchpoint</code></li><li><code>Exception Watchpoint</code></li><li><code>Conditional Breakpoint</code></li><li><code>Log Breakpoint</code></li><li><code>Dependent Breakpoint</code></li></ol><p>后面将对以上 7 种进行详细的介绍。</p><hr /><blockquote><p>一般情况下，我们都可以在断点设置中选择 <code>Suspend: All</code>。下文中并没有统一更改为此配置。</p></blockquote><hr /><h1 id="line-breakpoint"><a class="markdownIt-Anchor" href="#line-breakpoint"></a> <code>Line Breakpoint</code></h1><p>最普通的断点，在我们设置后，当我们调试时程序运行到此处时会自动暂停执行。</p><hr /><h1 id="field-watchpoint"><a class="markdownIt-Anchor" href="#field-watchpoint"></a> <code>Field Watchpoint</code></h1><blockquote><p>让我们想想一个这样的场景：某个变量的值在我们看不到的地方莫名其妙的被更改了？</p></blockquote><p><strong>定义</strong></p><p><code>Field Watchpoint</code> 就可以在每个 <code>Field</code> 被创建、访问、修改的时候触发断点。</p><p>我们只需要在变量处添加断点，无需在其他该变量值变化处添加行断点，当改值按照我们设置的触发条件变化后会自动在对应行停止。</p><p><strong>使用方法</strong></p><ol><li>在变量所在行的行号后面添加断点时，选择 <code>Kotlin Field Watchpoint</code>。</li></ol><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220905011919.png" style="zoom:80%;" /><ol start="2"><li>进入断点设置界面，便可以在 <code>Watch</code> 分类中选择我们需要触发断点的条件。</li></ol><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220905010035.png" alt="Field Watchpoint" style="zoom: 80%;" /><hr /><h1 id="method-watchpoint"><a class="markdownIt-Anchor" href="#method-watchpoint"></a> <code>Method Watchpoint</code></h1><p>待添加……</p><hr /><h1 id="exception-watchpoint"><a class="markdownIt-Anchor" href="#exception-watchpoint"></a> <code>Exception Watchpoint</code></h1><p>待添加……</p><hr /><h1 id="conditional-breakpoint"><a class="markdownIt-Anchor" href="#conditional-breakpoint"></a> <code>Conditional Breakpoint</code></h1><p>待添加……</p><hr /><h1 id="log-breakpoint"><a class="markdownIt-Anchor" href="#log-breakpoint"></a> <code>Log Breakpoint</code></h1><p>待添加……</p><hr /><h1 id="dependent-breakpoint"><a class="markdownIt-Anchor" href="#dependent-breakpoint"></a> <code>Dependent Breakpoint</code></h1><p>待添加……</p>]]></content>
    
    
    <summary type="html">梳理了使用 Android Studio 调试时断点的种类、作用以及使用方法。</summary>
    
    
    
    <category term="Android" scheme="https://luoyu-ying.github.io/categories/Android/"/>
    
    
    <category term="Android Studio" scheme="https://luoyu-ying.github.io/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 集合遍历方式梳理</title>
    <link href="https://luoyu-ying.github.io/posts/b928600a96ee/"/>
    <id>https://luoyu-ying.github.io/posts/b928600a96ee/</id>
    <published>2022-09-03T12:04:46.000Z</published>
    <updated>2022-09-03T12:04:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>仅在 LeetCode 中使用，在工程代码中可能并不适合。</p></blockquote><hr /><h1 id="for-i-in-indices"><a class="markdownIt-Anchor" href="#for-i-in-indices"></a> <code>for (i in indices)</code></h1><blockquote><p><strong><code>indices</code></strong></p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;T&gt; Array&lt;<span class="keyword">out</span> T&gt;.indices: IntRange</span><br><span class="line"><span class="keyword">val</span> Collection&lt;*&gt;.indices: IntRange</span><br></pre></td></tr></table></figure><p>返回数组或集合的有效索引范围。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intArray = IntArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> intArray.indices) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="comment">// for (i in 0 until intArray.size) &#123;&#125;</span></span><br></pre></td></tr></table></figure><hr /><h1 id="foreach"><a class="markdownIt-Anchor" href="#foreach"></a> <code>forEach</code></h1><blockquote>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;out T&gt;</span>.<span class="title">forEach</span><span class="params">(action: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> Map<span class="type">&lt;out K, V&gt;</span>.<span class="title">forEach</span><span class="params">(action: (<span class="type">Entry</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterator<span class="type">&lt;T&gt;</span>.<span class="title">forEach</span><span class="params">(operation: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span></span><br></pre></td></tr></table></figure><p><code>Lambda</code> 中使用 <code>it</code> 表示每一项的值，而非下标。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intArray = IntArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">intArray.forEach &#123;</span><br><span class="line">    println(<span class="string">&quot;Value is <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// Value is 1</span></span><br><span class="line"><span class="comment">// Value is 2</span></span><br><span class="line"><span class="comment">// Value is 3</span></span><br></pre></td></tr></table></figure><hr /><h1 id="foreachindexed"><a class="markdownIt-Anchor" href="#foreachindexed"></a> <code>forEachIndexed</code></h1><blockquote>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;out T&gt;</span>.<span class="title">forEachIndexed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    action: (<span class="type">index</span>: <span class="type">Int</span>, <span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">forEachIndexed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    action: (<span class="type">index</span>: <span class="type">Int</span>, <span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span></span><br></pre></td></tr></table></figure><p><code>forEachIndexed</code> 遍历数组中的元素并且打印出 index 索引值。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intArray = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">intArray.forEachIndexed &#123; index, value -&gt;</span><br><span class="line">    println(<span class="string">&quot;Index <span class="variable">$index</span> &#x27;s value is <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// Index 0 &#x27;s value is 1</span></span><br><span class="line"><span class="comment">// Index 1 &#x27;s value is 2</span></span><br><span class="line"><span class="comment">// Index 2 &#x27;s value is 3</span></span><br></pre></td></tr></table></figure><hr /><h1 id="reverse"><a class="markdownIt-Anchor" href="#reverse"></a> <code>reverse</code></h1><blockquote>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;T&gt;</span>.<span class="title">reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;T&gt;</span>.<span class="title">reverse</span><span class="params">(fromIndex: <span class="type">Int</span>, toIndex: <span class="type">Int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MutableList<span class="type">&lt;T&gt;</span>.<span class="title">reverse</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><code>reverse</code> 返回反转之后的数组或者列表。</p></blockquote>]]></content>
    
    
    <summary type="html">梳理一下可能会在 LeetCode 做题中使用到的集合遍历的方法。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
    <category term="LeetCode" scheme="https://luoyu-ying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 字符串常用算法</title>
    <link href="https://luoyu-ying.github.io/posts/e6b5f22ff8f5/"/>
    <id>https://luoyu-ying.github.io/posts/e6b5f22ff8f5/</id>
    <published>2022-09-01T05:04:02.000Z</published>
    <updated>2022-09-01T05:04:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是一个分割线</p></blockquote><h1 id="字符串哈希"><a class="markdownIt-Anchor" href="#字符串哈希"></a> 字符串哈希</h1><blockquote><p>更多关于字符串哈希的使用请看：<a href="https://luoyu-ying.github.io/posts/bb54934ff9ed/">XCPC 字符串哈希 | 洛语 の Blog (luoyu-ying.github.io)</a></p></blockquote><h2 id="clang"><a class="markdownIt-Anchor" href="#clang"></a> <code>Clang</code></h2><p>使用单哈希且自然溢出的方法，质数选用 131。</p><h2 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> <code>Kotlin</code></h2>]]></content>
    
    
    <summary type="html">整理了自己之前学习到的一些字符串相关算法</summary>
    
    
    
    <category term="LeetCode" scheme="https://luoyu-ying.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://luoyu-ying.github.io/tags/LeetCode/"/>
    
    <category term="字符串" scheme="https://luoyu-ying.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode C++ sort 食用方法</title>
    <link href="https://luoyu-ying.github.io/posts/43b3ec0d3402/"/>
    <id>https://luoyu-ying.github.io/posts/43b3ec0d3402/</id>
    <published>2022-08-06T16:51:05.000Z</published>
    <updated>2022-08-07T04:08:25.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="出现的问题"><a class="markdownIt-Anchor" href="#出现的问题"></a> 出现的问题</h1><p>在 LeetCode 中做题的时候，使用 <code>sort</code> 函数，并使用另一个比较函数的使用，出现以下的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(...)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; G;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="built_in">sort</span>(G.<span class="built_in">begin</span>(), G.<span class="built_in">end</span>(), comp);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行上述代码的时候，便会出现编译错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: reference to non-static member function must be called </span><br><span class="line">    sort(G.begin(), G.end(), comp); </span><br><span class="line">                             ^~~ </span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><hr /><h1 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h1><p>使用 <code>static</code> 修饰比较函数，即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">comp</span><span class="params">(...)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>即可在类中使用比较函数。</p>]]></content>
    
    
    <summary type="html">记录一下在 LeetCode 中使用 C++ 中的 sort 函数遇到的 reference to non-static member function 问题。</summary>
    
    
    
    <category term="LeetCode" scheme="https://luoyu-ying.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>英语 横屏与竖屏</title>
    <link href="https://luoyu-ying.github.io/posts/225ab1cafae6/"/>
    <id>https://luoyu-ying.github.io/posts/225ab1cafae6/</id>
    <published>2022-07-30T02:45:44.000Z</published>
    <updated>2022-07-30T02:45:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>在公司实习的时候，看到代码中的 <code>landscape</code> 以及  <code>portrait</code> 两个单词的时候，并没有意识到这两个单词的含义 。</p><p>还是英语单词的储备量太少了 (´。＿。｀)。</p><hr /><h1 id="landscape"><a class="markdownIt-Anchor" href="#landscape"></a> <code>LANDSCAPE</code></h1><p>手机横屏。代码中可以简写成 <code>land</code>。</p><p>本意为风景、风景画等。</p><p>可能因为这类画作通常以横幅的形式展现，所以便使用了 <code>landscape</code> 这个英语单词表示手机的横屏。</p><hr /><h1 id="portrait"><a class="markdownIt-Anchor" href="#portrait"></a> <code>PORTRAIT</code></h1><p>手机竖屏。代码中可以简写成 <code>port</code>。</p><p>本意为肖像、肖像画等。</p><p>可能因为这类画作基本以竖幅的形式展现，所以使用了 <code>portrait</code> 这个单词表示了手机的竖屏。</p>]]></content>
    
    
    <summary type="html">记录一下英语中手机横屏与竖屏的表达。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Android Gradle 学习笔记</title>
    <link href="https://luoyu-ying.github.io/posts/a3b80f176756/"/>
    <id>https://luoyu-ying.github.io/posts/a3b80f176756/</id>
    <published>2022-07-23T14:10:28.000Z</published>
    <updated>2022-07-24T06:10:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要讨论 Gradle 构建项目中的细节，而非构建 Gradle 的语言 Groovy 本身。</p></blockquote><hr /><blockquote><p>建议配合以下文章阅读：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/139685763">理解Android Studio中的Gradle - 知乎 (zhihu.com)</a></li></ul></blockquote><hr /><h1 id="gradle-是什么"><a class="markdownIt-Anchor" href="#gradle-是什么"></a> Gradle 是什么</h1><ol><li><p>Gradle 是一个构建工具。</p><p>Android Studio 构建系统以 Gradle 为基础，并且 Android Gradle 插件添加了几项专用于构建 Android 应用的功能。</p><p><strong>要注意的是</strong>，Gradle 它并不是独属于 Android。Gradle 本身也没有提供多少对 Android 程序构建的功能。</p><p>Gradle 是 Android Studio 默认的构建工具，它提高了 Android 的开发效率，它的作用就是管理项目中的依赖、打包、编译……</p></li><li><p>Gradle 并非一门语言，它是使用了 Groovy 语言创造出的一个 DSL。</p></li></ol><h1 id="gradle-如何构建"><a class="markdownIt-Anchor" href="#gradle-如何构建"></a> Gradle 如何构建</h1><p>我们通过 Gradle 的语法，在下列文件中指定 Gradle 的规则：</p><ol><li><code>build.gradle</code></li><li><code>settings.gradle</code></li><li><code>gradle-warpper</code></li><li>……</li></ol><hr /><h1 id="groovy-语言部分特性"><a class="markdownIt-Anchor" href="#groovy-语言部分特性"></a> Groovy 语言部分特性</h1><ol><li><p>使用函数时，函数名称后面的括号可以不写。</p></li><li><p>可以通过闭包传递函数以及其他的属性。</p><blockquote><p>闭包</p><ol><li>可以理解为 Groovy 中的 Lambda 表达式。</li><li>在功能上，和 Kotlin 的 Lambda ⽐较相似，都是⼀个「可以传递的代码块」，但是具体的功能⽐ Kotlin 的 Lambda 更强⼀些，但基本的概念是⼀样的。都是由大括号包含代码块组成。</li></ol></blockquote></li><li><p>如果函数定义的最后一个参数为闭包，那么闭包便可以写在括号外面；如果该函数只有一个参数且该参数为闭包，那么小括号可以省略。</p></li><li><p>可以在每个类中定义 <code>methodMissing</code> 函数，如果在脚本中执行了一个未在该类中定义的一个函数，Groovy 便会调用该类的 <code>methodMissing</code> 函数，并在该函数中寻找我们写入的解决方案。</p><blockquote><p>例如，<code>build.gradle</code> 中的 <code>classpath</code> 便是通过调用 <code>methodMissing</code> 函数实现依赖添加的功能。</p></blockquote></li><li><p>单引号和双引号都可以表达字符串的概念。</p></li></ol><h1 id="为什么-groovy-可以写出类似-json-格式的配置"><a class="markdownIt-Anchor" href="#为什么-groovy-可以写出类似-json-格式的配置"></a> 为什么 Groovy 可以写出类似 JSON 格式的配置？</h1><p>因为它们其实都是方法调用，只是省略了括号，以及用闭包来写成了看起来像是 JSON 型的格式。</p><hr /><h1 id="buildgradle"><a class="markdownIt-Anchor" href="#buildgradle"></a> <code>build.gradle</code></h1><h2 id="buildtypes"><a class="markdownIt-Anchor" href="#buildtypes"></a> <code>buildTypes</code></h2><p>通常有 <code>release</code>、<code>debug</code>、<code>develop</code>等等版本，也可以自定义版本。</p><p>通过 Project 形式查看文件结构，可以清楚的发现，当我们在 <code>src</code> 文件夹下面，创建类似 <code>main</code> 的层级文件夹 <code>debug</code> ，并在 <code>Build Varians</code> 选项卡中，选择 <code>debug</code> 构建模式时，AS 便会将 <code>main</code> 下方的文件以及 <code>debug</code> 下方的文件整合到一起执行，其他版本同理。</p><p>所以我们可以通过创建不同版本特有的文件夹，以达到不同版本使用、开发人员的差异化显示以及功能等区别。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220724160910544.png" alt="image" style="zoom: 80%;" /><h2 id="productflavors"><a class="markdownIt-Anchor" href="#productflavors"></a> <code>productFlavors</code></h2><p>为我们软件的版本提供更多的分类与维度，需要与 <code>flavorDimensions</code> 函数配合使用。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions <span class="string">&#x27;dimension1&#x27;</span>, <span class="string">&#x27;dimension2&#x27;</span> <span class="comment">// 确认具体的分类项</span></span><br><span class="line"></span><br><span class="line">productFlavors &#123;</span><br><span class="line">    flavor1 &#123;                              <span class="comment">// 每个具体的属性</span></span><br><span class="line">        dimension <span class="string">&#x27;dimension1&#x27;</span>             <span class="comment">// 属性所属的分类项</span></span><br><span class="line">    &#125;</span><br><span class="line">    flavor2 &#123;</span><br><span class="line">        dimension <span class="string">&#x27;dimension1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    flavor3 &#123;</span><br><span class="line">        dimension <span class="string">&#x27;dimension2&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    flavor4 &#123;</span><br><span class="line">        dimension <span class="string">&#x27;dimension2&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的示例代码，我们可以发现共有 4 种组合方式：</p><ol><li><code>flavor1</code> + <code>flavor3</code></li><li><code>flavor1</code> + <code>flavor4</code></li><li><code>flavor2</code> + <code>flavor3</code></li><li><code>flavor2</code> + <code>flavor4</code></li></ol><p>若结合上面 <code>buildTypes</code> 种的版本数量，最终共有 8 种组合方式（2 种 <code>dimension1</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 2 种 <code>dimension2</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 2 种 <code>buildTypes</code>），需要使用到某种版本时，同样可以在 <code>Build Varians</code> 选项卡中进行更改。</p><p>如果文件夹创建齐全，则上述 <code>flavor2Flavor3Debug</code> 版本的软件就会将所有与该版本有关的文件夹：</p><ol><li><code>main</code></li><li><code>debug</code></li><li><code>flavor2</code></li><li><code>flavor3</code></li><li><code>flavor2Debug</code></li><li><code>flavor3Debug</code></li><li><code>flavor2Flavor3</code></li><li><code>flavor2Flavor3Debug</code></li></ol><p>这 8 个文件夹下面的所有代码文件全部汇总后编译出最终的文件。如果存在没有创建的文件夹则忽略。</p><hr /><h1 id="compile-implementation-和-api"><a class="markdownIt-Anchor" href="#compile-implementation-和-api"></a> <code>compile</code>、<code>implementation</code> 和 <code>api</code></h1><blockquote><p>以下内容：</p><p>| 0 级项目 | --依赖–&gt; | 1 级依赖 | --依赖–&gt; | 2 级依赖 |</p></blockquote><ul><li><p><code>implementation</code>：</p><ol><li>不会传递依赖 。</li><li>0 级项目只能使用 1 级依赖提供的内容。</li></ol></li><li><p><code>compile</code> / <code>api</code>：</p><ol><li>会传递依赖；<code>api</code> 是 <code>compile</code> 的替代品，效果完全等同。</li><li>0 级项目可以直接使用 2 级依赖中的代码内容。</li></ol></li><li><p>0 级项目的修改不会影响其他项目，所以 <code>| 0 级项目 | --依赖--&gt; | 1 级依赖 |</code> 时可以使用任意函数。</p><p>推荐仍使用 <code>implementation</code> ，因为 0 级项目不需要传递依赖。</p></li><li><p><code>| 1 级依赖 | --依赖--&gt; | 2 级依赖 |</code> 中的依赖关系需要仔细考虑：</p><ul><li><p>当依赖被传递时(<code>compile</code> / <code>api</code>)，认为 0 级项目同样直接依赖 2 级依赖，2 级依赖的。改动会导致 0 级项目重新编译。</p></li><li><p>当依赖不传递时(<code>implementation</code>)，2 级依赖的改动不会导致 0 级项目重新编译，常用于本地项目，方便短时间对 0 级项目快速重写编译，减少打包时间。</p><blockquote><p>编译只是打包过程中的其中一个步骤。</p></blockquote></li></ul></li></ul><hr /><h1 id="gradle-wrapper"><a class="markdownIt-Anchor" href="#gradle-wrapper"></a> <code>Gradle Wrapper</code></h1><p>即 <code>gradlew</code>，用于 gradle 自动配置。</p><p>使用 <code>gradlew</code> 发现如果我们的电脑里有了已经配置好的 gradle ，那么就会直接使用，否则的话，就会通过互联网下载我们需要的 gradle 并使用。</p><p>如果我们的项目中有多个模块需要一样的 gradle 配置，那么我们就可以通过 gradlew 让所有的模块都去使用同一个 gradle 而不是为每个模块单独、分别下载一份一模一样的文件。</p><p>通过「只同步版本，不同步文件」的方式来减小协作项目的大小。我们可以通过指定 gradle 版本的方式，让对方的电脑主动下载我们需要的版本的 gradle，而不是我们将自己电脑的 gradle 打包进项目中，减少了项目的大小。</p><p>每个⼈电脑上的 Gradle 存放在固定位置，然后使用 Gradle Wrapper 的配置来取用对应的版本就行了。</p><p>使用方式：命令行中：<code>./gradlew</code>。</p><h2 id="gradle-wrapperproperties"><a class="markdownIt-Anchor" href="#gradle-wrapperproperties"></a> gradle-wrapper.properties</h2><p>是对 gradle wrapper 的配置文件，用于显示的表示 gradle wrapper 的存放位置，以及找不到对应的 gradle wrapper ，从而去网络下载的网络地址。</p><hr /><h1 id="settingsgradle"><a class="markdownIt-Anchor" href="#settingsgradle"></a> <code>settings.gradle</code></h1><p>整个项目的结构，说明我们整个项目中有哪几个子项目。</p><hr /><h1 id="task"><a class="markdownIt-Anchor" href="#task"></a> <code>task</code></h1><ul><li><p>使用方法： <code>./gradlew taskName</code></p></li><li><p><code>task</code> 的结构：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> taskName &#123;</span><br><span class="line">    初始化代码</span><br><span class="line">    <span class="keyword">doFirst</span> &#123;</span><br><span class="line">        <span class="keyword">task</span> 代码</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">doLast</span> &#123;</span><br><span class="line">        <span class="keyword">task</span> 代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>doFirst</code> 以及 <code>doLast</code> 和普通代码段的区别：</p><ul><li><p>普通代码段：在 <code>task</code> 创建过程中就会被执⾏，发⽣在 configuration 阶段。</p></li><li><p><code>doFirst</code> 和 <code>doLast</code>：在 task 执行过程中被执⾏，发生在 execution 阶段。</p><p>如果用户没有直接或间接执行 <code>task</code>，那么它的 <code>doLast</code>、 <code>doFirst</code> 代码不会被执行。</p></li><li><p><code>doFirst</code> 和 <code>doLast</code> 都是 <code>task</code> 代码，其中 <code>doFirst</code> 是往队列的前面插⼊代码，<code>doLast</code> 是往队列的后面插⼊代码。</p><p>一个 <code>task</code> 里面可以写入多个 <code>doFirst</code> 以及 <code>doLast</code>。</p></li></ul></li><li><p><code>task</code> 的依赖：</p><p>可以使用 <code>task taskA(dependsOn: taskB)</code> 的形式来指定依赖。 指定依赖后，<code>taskA</code> 会在自己执行前先执行自己依赖的 <code>taskB</code>。</p><p>将所有的 task 通过一条有向边连接到其依赖 task 后，可以得到一个由所有 task 所组成的有向无环图。</p></li></ul><hr /><h1 id="gradle-执行的生命周期"><a class="markdownIt-Anchor" href="#gradle-执行的生命周期"></a> Gradle 执行的生命周期</h1><h2 id="三个阶段"><a class="markdownIt-Anchor" href="#三个阶段"></a> 三个阶段</h2><p>Gradle 执行的生命周期一共有三个阶段：</p><ol><li><p>初始化阶段</p><p>执行 settings.gradle，确定主 project 和子 project。</p></li><li><p>定义阶段（配置阶段）：</p><p>配置每个 project 的 bulid.gradle，确定出所有 task 所组成的有向无环图。</p></li><li><p>执行阶段：</p><p>按照上一阶段所确定出的有向无环图来执行指定的 task。</p></li></ol><h2 id="在阶段之间插入代码"><a class="markdownIt-Anchor" href="#在阶段之间插入代码"></a> 在阶段之间插⼊代码</h2><p>一二阶段之间：</p><ul><li>在 <code>settings.gradle</code> 的末尾写入插入的代码。</li></ul><p>二三阶段之间：</p><ul><li><p>在 <code>build.gradle</code> 文件中使用 <code>afterEvaluate</code> 函数：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">afterEvaluate &#123;</span><br><span class="line">    <span class="comment">// 插入的代码，例如网络、文件相关的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">Android 中 Gradle 配置文件浅淡</summary>
    
    
    
    <category term="Gradle" scheme="https://luoyu-ying.github.io/categories/Gradle/"/>
    
    
    <category term="Gradle" scheme="https://luoyu-ying.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>AutoHotKey 变量和字符串</title>
    <link href="https://luoyu-ying.github.io/posts/82303f29c0e9/"/>
    <id>https://luoyu-ying.github.io/posts/82303f29c0e9/</id>
    <published>2022-07-23T08:23:08.000Z</published>
    <updated>2022-07-23T08:23:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Variables.htm">变量和表达式 | AutoHotkey (autoahk.com)</a></li><li><a href="https://www.autohotkey.com/boards/viewtopic.php?t=14633">String literal that spans multiple lines? - AutoHotkey Community</a></li></ul></blockquote><hr /><blockquote><p>下文中的链接皆指向 AHK 技术文档，可放心查看。</p></blockquote><hr /><h1 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h1><p>有关一般说明和变量如何工作的详细信息, 请参阅<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Concepts.htm#variables">变量</a>.</p><h2 id="给变量赋值"><a class="markdownIt-Anchor" href="#给变量赋值"></a> <strong>给变量赋值</strong></h2><p>要将字符串或数字存储在变量中, 有两种方法: <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#legacy-syntax">传统方式</a>和<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#expressions">表达式</a>. 传统方法使用<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/SetEnv.htm">等号运算符(=)</a> 来指定<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#unquoted-text"><strong>不加引号的</strong>原义字符串</a>或用百分号括起来的变量. 例如:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyNumber = <span class="number">123</span></span><br><span class="line">MyString = This is a literal string.</span><br><span class="line">CopyOfVar = <span class="variable">%Var%</span>  <span class="comment">; 和 = 运算符一起使用时, 需要使用百分号来获取变量的内容.</span></span><br></pre></td></tr></table></figure><p>与之相比, 表达式方法使用<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/SetExpression.htm">冒号等号运算符(:=)</a> 来保存数字, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#strings"><strong>加引号的</strong>字符串</a>和其他类型的<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#expressions">表达式</a>. 以下示例在功能上与前面的例子相同:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyNumber := <span class="number">123</span></span><br><span class="line">MyString := <span class="string">&quot;This is a literal string.&quot;</span></span><br><span class="line">CopyOfVar := Var  <span class="comment">; 和前面段落中与其作用相同的语句不同, 百分号不和 := 运算符一起使用.</span></span><br></pre></td></tr></table></figure><p><strong>后一种方法由于其更清晰并且与其他许多语言几乎一致的<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#expressions">表达式语法</a>成为大多数人的首选方法.</strong></p><p>从上面的例子中您可能已经想到了有两种方法来清除变量的内容(即让变量为空):</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyVar =</span><br><span class="line">MyVar := <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>上面的这对空引号只能和 := 运算符一起使用, 因为和 = 运算符一起使用时, 则会在变量中保存两个原义的引号字符.</p><h2 id="获取变量的内容"><a class="markdownIt-Anchor" href="#获取变量的内容"></a> <strong>获取变量的内容</strong></h2><p>如同赋值有两种方法, 获取变量的内容也有两种方法: <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#legacy-syntax">传统方法</a>和<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#variables">表达式方法</a>. 传统方法需要将变量名包围在百分号中来获取变量的内容. 例如:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MsgBox The value in the variable named Var is <span class="variable">%Var%</span>.</span><br><span class="line">CopyOfVar = <span class="variable">%Var%</span></span><br></pre></td></tr></table></figure><p>与之相比, 表达式方法省去了变量名两边的百分号, 但<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#strings">原义的字符串</a>必须包围在双引号中. 所以, 下面的表达式作用等同于上面的例子:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MsgBox %</span> <span class="string">&quot;The value in the variable named Var is &quot;</span> . Var . <span class="string">&quot;.&quot;</span>  <span class="comment">; 使用句点连接(join 拼接) 两个字符串.</span></span><br><span class="line">CopyOfVar := Var</span><br></pre></td></tr></table></figure><p>在上面的 MsgBox 这行, 通过使用<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#-expression">百分号和空格</a>把参数从传统模式改变为表达式模式. 因为所有的命令默认情况下使用传统模式(除了另外注明的那些), 所以这是必须的.</p><h2 id="变量的比较"><a class="markdownIt-Anchor" href="#变量的比较"></a> <strong>变量的比较</strong></h2><p>请阅读下面表达式部分中关于不同类型变量比较的重要提示, 尤其是关于何时使用小括号的内容.</p><hr /><h1 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h1><h2 id="保存带有引号的字符串"><a class="markdownIt-Anchor" href="#保存带有引号的字符串"></a> 保存带有引号的字符串</h2><p>如果我们想用变量保存一个带有双引号的字符串，需要使用 = 操作符：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var = this is <span class="string">&quot; ; 输出的字符串中包含双引号</span></span><br></pre></td></tr></table></figure><h2 id="保存多行字符串"><a class="markdownIt-Anchor" href="#保存多行字符串"></a> 保存多行字符串</h2><p>如果我们想要保存多行的字符串，可以使用 <code>()</code> 包含文本内容并使用 <code>=</code> 且 <strong>不加 <code>&quot;&quot;</code></strong> 的方式（文本中每行的字符串形式与使用 <code>=</code> 操作符保存单行字符串的形式相同）：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var = string</span><br><span class="line"></span><br><span class="line">exampleString =</span><br><span class="line">(                      <span class="comment">; 左括号右侧的字符会被自动忽略，正文从下行开始</span></span><br><span class="line">    multiple</span><br><span class="line">        lines          <span class="comment">; 该行字符的所有字符（包括空格）会全部输出</span></span><br><span class="line">                       <span class="comment">; 空行也会如实输出  </span></span><br><span class="line"><span class="built_in">    of</span></span><br><span class="line"><span class="built_in">        %</span>var%</span><br><span class="line">)                      <span class="comment">; 右括号左侧不能有其他字符，否则将报错</span></span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">MsgBox,</span> % exampleString</span><br></pre></td></tr></table></figure><p>输出结果截图（第一个非空字符前的空格将忽略）：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220723170233064.png" alt="image-20220723170233064" style="zoom: 50%;" /><p><strong>注意：</strong></p><ol><li>该方式中的 <code>()</code> 必须分别、单独在一行，不能接在其他语句末尾。且文本将严格按照输入形式输出，两个括号之间的空行和空格也会如实输出，但是第一个非空字符前的空格将忽略。</li><li>左括号右侧的字符会被自动忽略，正文从下行开始；右括号左侧不能有其他字符，否则将报错。</li><li>如果需要使用 <code>:=</code> 操作符进行多行字符串保存，请使用 `n 转义字符进行换行操作。</li></ol>]]></content>
    
    
    <summary type="html">记录了 AutoHotKey 中变量以及字符串的基本概念与使用方法。</summary>
    
    
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/categories/AutoHotKey/"/>
    
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/tags/AutoHotKey/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 标准函数</title>
    <link href="https://luoyu-ying.github.io/posts/d15d647b4c31/"/>
    <id>https://luoyu-ying.github.io/posts/d15d647b4c31/</id>
    <published>2022-07-13T05:26:11.000Z</published>
    <updated>2022-07-13T05:26:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 标准函数 <code>Standard.kt</code> 源码  <code>GitHub</code> 仓库地址:</p><ul><li><a href="https://github.com/JetBrains/kotlin/blob/1.5.30/libraries/stdlib/src/kotlin/util/Standard.kt">kotlin/Standard.kt at 1.5.30 · JetBrains/kotlin (github.com)</a></li></ul></blockquote><hr /><h1 id="初始代码"><a class="markdownIt-Anchor" href="#初始代码"></a> 初始代码</h1><blockquote><p>下方给出一份初始代码，并在接下来的部分标准函数中给出使用该标准函数的修改后代码。</p><p>初始代码摘自《第一行代码 Android 第3版》。</p></blockquote><p>比如有一个水果列表，现在我们想吃完所有水果，并将结果打印出来，就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">builder.append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">    builder.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">builder.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = builder.toString()</span><br><span class="line">println(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行的结果为：</span></span><br><span class="line">Start eating fruits.</span><br><span class="line">Apple</span><br><span class="line">Banana</span><br><span class="line">Orange</span><br><span class="line">Pear</span><br><span class="line">Grape</span><br><span class="line">Ate all fruits.</span><br></pre></td></tr></table></figure><hr /><h1 id="run"><a class="markdownIt-Anchor" href="#run"></a> <code>run</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] and returns its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">run</span><span class="params">(block: () -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = run &#123;</span><br><span class="line">    <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">    builder.append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        builder.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    builder.toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><hr /><h1 id="trun"><a class="markdownIt-Anchor" href="#trun"></a> <code>T.run</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with `this` value as its receiver and returns its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = StringBuilder().run &#123;</span><br><span class="line">    append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><hr /><h1 id="with"><a class="markdownIt-Anchor" href="#with"></a> <code>with</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> receiver.block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = with(StringBuilder()) &#123;</span><br><span class="line">    append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        append(fruit).append(<span class="string">&quot;\n&quot;</span>)          </span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><hr /><h1 id="tapply"><a class="markdownIt-Anchor" href="#tapply"></a> <code>T.apply</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with `this` value as its receiver and returns `this` value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = StringBuilder().apply &#123;</span><br><span class="line">    append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(result.toString())</span><br></pre></td></tr></table></figure><hr /><h1 id="talso"><a class="markdownIt-Anchor" href="#talso"></a> <code>T.also</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with `this` value as its argument and returns `this` value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">also</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = StringBuilder().also &#123;</span><br><span class="line">    it.append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        it.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    it.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(result.toString())</span><br></pre></td></tr></table></figure><hr /><h1 id="tlet"><a class="markdownIt-Anchor" href="#tlet"></a> <code>T.let</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with `this` value as its argument and returns its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = StringBuilder().let &#123;</span><br><span class="line">    it.append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        it.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    it.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    it.toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><hr /><h1 id="ttakeif"><a class="markdownIt-Anchor" href="#ttakeif"></a> <code>T.takeIf</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn&#x27;t.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">takeIf</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (predicate(<span class="keyword">this</span>)) <span class="keyword">this</span> <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="ttakeunless"><a class="markdownIt-Anchor" href="#ttakeunless"></a> <code>T.takeUnless</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">takeUnless</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (!predicate(<span class="keyword">this</span>)) <span class="keyword">this</span> <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="trepeat"><a class="markdownIt-Anchor" href="#trepeat"></a> <code>T.repeat</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the given function [action] specified number of [times].</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A zero-based index of current iteration is passed as a parameter to [action].</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@sample</span> samples.misc.ControlFlow.repeat</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">repeat</span><span class="params">(times: <span class="type">Int</span>, action: (<span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    contract &#123; callsInPlace(action) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until times) &#123;</span><br><span class="line">        action(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="部分函数比较"><a class="markdownIt-Anchor" href="#部分函数比较"></a> 部分函数比较</h1><table><thead><tr><th style="text-align:center">标准函数 形参</th><th style="text-align:center">Lambda 形参</th><th style="text-align:center">Lambda 返回值</th><th style="text-align:center">标准函数 返回值</th><th style="text-align:center">作用域 参数</th></tr></thead><tbody><tr><td style="text-align:center"><code>run &#123;&#125;</code></td><td style="text-align:center"><code>()</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>\</code></td></tr><tr><td style="text-align:center"><code>T.run &#123;&#125;</code></td><td style="text-align:center"><code>T.()</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>(this.)</code></td></tr><tr><td style="text-align:center"><code>with(obj : T) &#123;&#125;</code></td><td style="text-align:center"><code>T.()</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>(this.)</code></td></tr><tr><td style="text-align:center"><code>T.apply &#123;&#125;</code></td><td style="text-align:center"><code>T.()</code></td><td style="text-align:center"><code>Unit</code></td><td style="text-align:center"><code>T</code></td><td style="text-align:center"><code>(this.)</code></td></tr><tr><td style="text-align:center"><code>T.also &#123;&#125;</code></td><td style="text-align:center"><code>(T)</code></td><td style="text-align:center"><code>Unit</code></td><td style="text-align:center"><code>T</code></td><td style="text-align:center"><code>it.</code></td></tr><tr><td style="text-align:center"><code>T.let &#123;&#125;</code></td><td style="text-align:center"><code>(T)</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>it.</code></td></tr></tbody></table><p>使用时可以通过简单的规则作出⼀些判断：</p><ol><li><p>返回自身 -&gt; 从 <code>apply</code> 和 <code>also</code> 中选</p><ul><li>作用域中使用 <code>this</code> 作为参数 -&gt; 选择 <code>apply</code></li><li>作用域中使用 <code>it</code> 作为参数 -&gt; 选择 <code>also</code></li></ul></li><li><p>不需要返回自身（可以返回任意类型） -&gt; 从 <code>run</code> 和 <code>let</code> 中选择</p><ul><li>作用域中使用 <code>this</code> 作为参数 -&gt; 选择 <code>run</code></li><li>作用域中使用 <code>it</code> 作为参数 -&gt; 选择 <code>let</code></li></ul></li><li><p><code>apply</code> 适合对一个对象做附加操作的时候</p></li><li><p><code>let</code> 适合配合空判断的时候 (最好是成员变量，⽽不是局部变量，局部变量更适合用 <code>if</code> )</p></li><li><p><code>with</code> 适合对同一个对象进行多次操作的时候</p></li></ol>]]></content>
    
    
    <summary type="html">整理了 Kotlin 中的标准函数。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>AutoHotKey 类的定义与部分使用技巧</title>
    <link href="https://luoyu-ying.github.io/posts/61bd48ea70cc/"/>
    <id>https://luoyu-ying.github.io/posts/61bd48ea70cc/</id>
    <published>2022-07-12T09:33:37.000Z</published>
    <updated>2022-07-12T09:33:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文所使用的AHK版本为 AutoHotKey_v1 。</p></blockquote><hr /><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>本人想在 AHK 中使用面向对象的方式编写代码，但是发现在官方文档中仅有较少关于 class` 的操作代码示例，所以根据自己这两天的代码编写过程，整理出常用的一些使用技巧供大家参考。</p><hr /><h1 id="类的创建和使用"><a class="markdownIt-Anchor" href="#类的创建和使用"></a> 类的创建和使用</h1><p>类的创建使用 <code>class</code>  关键字。可以显式定义构造方法以及析构方法：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 类的创建</span></span><br><span class="line">class A &#123;</span><br><span class="line">    <span class="comment">; 静态变量的创建</span></span><br><span class="line">    static var1 := Expression1</span><br><span class="line">    <span class="comment">; 类字段的创建</span></span><br><span class="line">    var2 := Expression2</span><br><span class="line">    </span><br><span class="line">    <span class="comment">; 构造方法，可传入任意参数，也可不传入参数</span></span><br><span class="line">    __New(...) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">; 方法的创建</span></span><br><span class="line">    <span class="comment">; 可传入任意参数，参数支持默认参数值</span></span><br><span class="line">    <span class="comment">; 根据需要可不写 return</span></span><br><span class="line">    methodName(...) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">; 析构方法</span></span><br><span class="line">    __Delete() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的使用：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="keyword">new</span> A(...)   <span class="comment">; 类的实例化，根据构造方法传入对应的参数</span></span><br><span class="line">a.methodName(...) <span class="comment">; 使用变量的方法</span></span><br></pre></td></tr></table></figure><hr /><h1 id="在类中创建热键并绑定类方法"><a class="markdownIt-Anchor" href="#在类中创建热键并绑定类方法"></a> 在类中创建热键并绑定类方法</h1><p>使用面向对象的思想编写代码的话，我们或许需要在类中创建热键及其响应逻辑的方法：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    <span class="comment">; 自定义的一个方法，用于加载类中所有的热键</span></span><br><span class="line">    loadHotKey() &#123;</span><br><span class="line">        <span class="comment">; 创建响应方法的方法引用</span></span><br><span class="line">        varFunctionA := ObjBindMethod(this, <span class="string">&quot;functionA&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">; 创建 Alt + A 的热键以及绑定其响应方法</span></span><br><span class="line"><span class="built_in">        HotKey,</span> !A, % varFunctionA, On</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    functionA() &#123;</span><br><span class="line">    <span class="comment">; 热键的响应逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码便在类中创建了一个使用类中方法作为响应逻辑的热键。其中：</p><ol><li><code>varFunctionA := ObjBindMethod(this, &quot;functionA&quot;)</code> 部分：<ol><li><code>&quot;functionA&quot;</code> 中双引号必须保留，双引号中间内容为对应的方法名。</li><li><code>varFunctionName</code> 为自定义的变量名称，与第7行第3个参数相对应。</li></ol></li><li><code>HotKey, !A, % varFunctionA, On</code> 部分：<ol><li><code>!A</code> 为热键的内容，具体可以参考文档中 <strong>热键</strong> 部分内容。</li><li><code>% varFunctionA</code> 中百分号必须保留，后面的内容对应上面一行自定义的变量名。</li></ol></li></ol><p>热键的使用：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> A().loadHotKey()</span><br></pre></td></tr></table></figure><p>通过对该类的实例化并调用实例化对象的 <code>loadHotKey</code> 方法即可。</p><hr /><h1 id="在类中绘制-ui-并绑定类方法"><a class="markdownIt-Anchor" href="#在类中绘制-ui-并绑定类方法"></a> 在类中绘制 <code>UI</code> 并绑定类方法</h1><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class B &#123;</span><br><span class="line">    <span class="comment">; 自定义的一个方法，用于绘制 UI 以及绑定响应的方法</span></span><br><span class="line">    loadView() &#123;</span><br><span class="line">        <span class="comment">; 绘制了一个按钮</span></span><br><span class="line"><span class="built_in">        Gui,</span> Add, Button, w200 h35 hwndHFuncB, This is a button.</span><br><span class="line"></span><br><span class="line">        <span class="comment">; 创建了响应方法的方法引用</span></span><br><span class="line">        varFuncB := ObjBindMethod(this, <span class="string">&quot;functionB&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">; 通过 HWND 将按钮与方法绑定</span></span><br><span class="line"><span class="built_in">        GuiControl,</span> +g, <span class="variable">%HFuncB%</span>, % varFuncB</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    functionB() &#123;</span><br><span class="line">        <span class="comment">; 按钮的响应逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>Gui, Add, Button, w200 h35 hwndHFuncB, This is a button.</code> 中 <code>hwndHFuncB</code> 部分：<ol><li>形式为 <code>hwnd + 自定义变量名</code></li><li>自定义变量名与第9行中第3个参数相对应。</li></ol></li><li><code>varFuncB := ObjBindMethod(this, &quot;functionB&quot;)</code> 部分：<ol><li><code>varFuncB</code> 为另一个自定义变量名，与第9行中第4个变量名相对应。</li><li><code>&quot;functionB&quot;</code> 中双引号必须保留，双引号中间内容为对应的方法名。</li></ol></li><li><code>GuiControl, +g, %HFuncB%, % varFuncB</code> 中第3、4个参数分别为上述的两个自定义变量名。</li></ol><hr /><h1 id="代码示例"><a class="markdownIt-Anchor" href="#代码示例"></a> 代码示例</h1><blockquote><p>使用面向对象思想重构 <a href="https://luoyu-ying.github.io/posts/050a11a7817a/">通过 AutoHotKey 简化 Hexo 操作 | 洛语 の Blog (luoyu-ying.github.io)</a> 中 Deploy 部分的操作。</p></blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 加载类的 UI 以及热键</span></span><br><span class="line"><span class="keyword">new</span> Deploy().load()</span><br><span class="line"></span><br><span class="line"><span class="comment">; -------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 类的创建</span></span><br><span class="line">class Deploy &#123;</span><br><span class="line"></span><br><span class="line">    load() &#123;</span><br><span class="line">        this.loadView()</span><br><span class="line">        this.loadHotKey()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">; 本代码中 GAD -&gt; generate and deploy</span></span><br><span class="line">    </span><br><span class="line">    loadView() &#123;</span><br><span class="line"><span class="built_in">        Gui,</span> Add, Button, w200 h35 hwndHGAD, Generate &amp;&amp; Deploy</span><br><span class="line">        </span><br><span class="line">        varGAD := ObjBindMethod(this, <span class="string">&quot;generateDeploy&quot;</span>)</span><br><span class="line"><span class="built_in">        </span></span><br><span class="line"><span class="built_in">        GuiControl,</span> +g, <span class="variable">%HGAD%</span>, % varGAD</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadHotKey() &#123;</span><br><span class="line">        varGAD := ObjBindMethod(this, <span class="string">&quot;generateDeploy&quot;</span>)</span><br><span class="line"><span class="built_in">        </span></span><br><span class="line"><span class="built_in">        Hotkey,</span> CapsLock &amp; G, % varGAD, On</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    generateDeploy() &#123;</span><br><span class="line"><span class="built_in">        Run,</span> <span class="variable">%comSpec%</span> /c hexo g &amp;&amp; hexo d, , Min</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录一下自己在使用 AutoHotKey_v1 中类的方法绑定类中定义的热键以及 GUI 的方法。</summary>
    
    
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/categories/AutoHotKey/"/>
    
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/tags/AutoHotKey/"/>
    
  </entry>
  
  <entry>
    <title>AutoHotHey 问题解决记录</title>
    <link href="https://luoyu-ying.github.io/posts/8f286d636eff/"/>
    <id>https://luoyu-ying.github.io/posts/8f286d636eff/</id>
    <published>2022-07-11T06:41:25.000Z</published>
    <updated>2022-07-11T06:41:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>更多的资料请参考 AHK 官方技术文档以及 AHK 社区。</p></blockquote><hr /><h1 id="代码中有些代码总是无法运行"><a class="markdownIt-Anchor" href="#代码中有些代码总是无法运行"></a> 代码中有些代码总是无法运行</h1><blockquote><p>处理方法参考自：</p><ul><li><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Scripts.htm#auto">脚本 - 定义与使用 | AutoHotkey (autoahk.com)</a></li></ul></blockquote><blockquote><p>下文中的所有链接皆为 AHK 技术文档中该词条的链接，可正常使用。</p></blockquote><p><strong><font size="4"><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Scripts.htm#auto">脚本顶部(自动执行段)</a></font></strong></p><p>脚本加载完成后, 它会从顶行开始执行, 直到遇到 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Return.htm">Return</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Exit.htm">Exit</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Hotkeys.htm">热键/热字串标签</a> 或脚本的底部(无论最先遇到哪个). 脚本的这个顶端部分被称为 <em>自动执行段</em>.</p><blockquote><p><strong>注意:</strong> 虽然脚本的 <em>第一个</em> 热键/热字串标签与 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Return.htm">return(返回)</a> 的效果相同, 但其他热键和标签却没有.</p></blockquote><p>如果脚本不是<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/_Persistent.htm">持续运行的</a>, 它将在自动执行部分完成后终止. 否则, 它会以空闲状态持续运行, 从而对诸如<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Hotkeys.htm">热键</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Hotstrings.htm">热字串</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Gui.htm#label">GUI 事件</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Menu.htm">自定义菜单项</a>和<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/SetTimer.htm">计时器</a>等事件做出响应. 如果一个脚本包含了热键, 热字串, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/OnMessage.htm">OnMessage()</a> 或 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Gui.htm">GUI</a>, 以及一些其他情况, 它就会自动变为持续运行的. 也可以用 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/_Persistent.htm">#Persistent</a> 指令来显式地使脚本持续运行.</p><hr /><h1 id="通过函数创建热键"><a class="markdownIt-Anchor" href="#通过函数创建热键"></a> 通过函数创建热键</h1><p>通过 <code>HotKey</code> 函数动态的创建一个热键。</p><blockquote><p>具体参数可以查看文档：<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Hotkey.htm">Hotkey | AutoHotkey (autoahk.com)</a></p></blockquote><p>示例：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 创建一个 CapsLock + K 的一个热键，效果为 Sfunction Lable 中的内容</span></span><br><span class="line"><span class="built_in">HotKey,</span> CapsLocks &amp; K, function</span><br><span class="line"></span><br><span class="line">function() &#123;</span><br><span class="line"><span class="built_in">MsgBox,</span> <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="通过函数创建热字串"><a class="markdownIt-Anchor" href="#通过函数创建热字串"></a> 通过函数创建热字串</h1><p>通过 <code>HotString</code> 函数动态的创建一个热字串。</p><blockquote><p>具体的参数可以查看文档：<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Hotstring.htm">Hotstring() | AutoHotkey (autoahk.com)</a></p></blockquote><hr /><h1 id="无法正常使用分号注释符号"><a class="markdownIt-Anchor" href="#无法正常使用分号注释符号"></a> 无法正常使用分号（注释符号）</h1><p>当我们想要使用 分号 作为热键中的一部分时，我们可以使用 <code>SC027</code> 替换分号的位置，以达到分号的作用、</p><p>示例：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 创建一个 CapsLock + K 的一个热键，效果为 function Lable 中的内容</span></span><br><span class="line"><span class="built_in">HotKey,</span> CapsLocks &amp; SC027, function </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录了一些在编写 AutoHotKey 代码中遇到的问题以及解决的方案。</summary>
    
    
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/categories/AutoHotKey/"/>
    
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/tags/AutoHotKey/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Butterfly 添加相册</title>
    <link href="https://luoyu-ying.github.io/posts/aae775e24f21/"/>
    <id>https://luoyu-ying.github.io/posts/aae775e24f21/</id>
    <published>2022-07-10T14:33:28.000Z</published>
    <updated>2022-07-10T14:33:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://butterfly.js.org/posts/dc584b87/">Butterfly 安裝文檔(二) 主題頁面 | Butterfly</a></li></ul></blockquote><hr /><h1 id="gallery-相册图库"><a class="markdownIt-Anchor" href="#gallery-相册图库"></a> <code>Gallery</code> 相册图库</h1><p>图库页面只是普通的页面，你只需要：</p><ol><li><p><code>hexo n page xxxxx</code> 创建你的页面。</p></li><li><p>在 <code>index.md</code> 使用标签外挂 <code>galleryGroup</code>。</p></li></ol><h2 id="gallerygroup-模板"><a class="markdownIt-Anchor" href="#gallerygroup-模板"></a> <code>galleryGroup</code> 模板</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p>name：图库名字</p></li><li><p>description：图库描述</p></li><li><p>link：连接到对应相册的地址</p></li><li><p>img-url：图库封面的地址</p></li></ul><h2 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span><br><span class="line">&#123;% galleryGroup &#x27;封面图&#x27; &#x27;已发布文章的封面图&#x27; &#x27;/gallery/wallpaper&#x27; images/389.jpg %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/389.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">封面图</div>  <p>已发布文章的封面图</p>  <a href='/gallery/wallpaper'></a>  </figcaption>  </figure>  </div><hr /><h1 id="gallery-相册子页面"><a class="markdownIt-Anchor" href="#gallery-相册子页面"></a> <code>Gallery</code> 相册子页面</h1><p>子页面也是普通的页面，你只需要：</p><ol><li><code>hexo n page xxxxx</code> 创建你的页面。</li><li>然后使用标签外挂 <code>gallery</code>。</li></ol><h2 id="gallery-模板"><a class="markdownIt-Anchor" href="#gallery-模板"></a> <code>gallery</code> 模板</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>markdown 图片格式： <code>![]()</code> 或者 <code>&lt;img src = &quot;&quot;&gt;</code> 的格式皆可。</li></ul><h2 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](images/389.jpg)</span><br><span class="line">![](images/166.jpg)</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/250.jpg&quot;</span>&gt;</span></span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><div class="fj-gallery"><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/389.jpg" alt="" /></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/166.jpg" alt="" /></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/250.jpg">          </div><hr /><h1 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h1><p>如果你想要使用 <code>/gallery/wallpaper</code> 这样的链接显示你的图片内容。你可以把创建好的 <code>wallpaper</code> 整个文件夹移到 <code>gallery</code> 文件夹里中。</p>]]></content>
    
    
    <summary type="html">记录一下在 Hexo Butterfly 中相册的添加方法。</summary>
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Lambda 表达式</title>
    <link href="https://luoyu-ying.github.io/posts/0ca5222da5ff/"/>
    <id>https://luoyu-ying.github.io/posts/0ca5222da5ff/</id>
    <published>2022-07-10T03:19:09.000Z</published>
    <updated>2022-07-10T03:19:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li>《第一行代码 Android 第3版》</li><li><a href="https://time.geekbang.org/course/intro/100009801">快速上手 Kotlin 开发 (geekbang.org)</a></li><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li></ul></blockquote><hr /><h1 id="lambda-定义"><a class="markdownIt-Anchor" href="#lambda-定义"></a> <code>Lambda</code> 定义</h1><p><code>Lambda</code> 就是一小段可以作为参数传递的代码，也可以认为是函数的简写形式。</p><hr /><h1 id="lambda-表达式的语法结构"><a class="markdownIt-Anchor" href="#lambda-表达式的语法结构"></a> <code>Lambda</code> 表达式的语法结构</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;参数名<span class="number">1</span>: 参数类型, 参数名<span class="number">2</span>: 参数类型, ..., 参数名n: 参数类型 -&gt; 函数体&#125;</span><br></pre></td></tr></table></figure><p>这是 <code>Lambda</code> 表达式最完整的语法结构定义。</p><p>首先最外层是一对大括号，如果有参数传入到 <code>Lambda</code> 表达式中的话，我们还需要声明参数列表，参数列表的结尾使用一个 <code>-&gt;</code> 符号，表示参数列表的结束以及函数体的开始。</p><p>函数体中可以编写任意行代码（虽然不建议编写太长的代码)，<strong>并且最后一行代码会自动作为 <code>Lambda</code> 表达式的返回值</strong>，即 <code>return 最后一行代码</code>。</p><p>所以我们也可以用变量获取 <code>Lambda</code> 表达式的结果，即 <code>val result = &#123;... -&gt; ...&#125;</code> 。</p><hr /><h1 id="lambda-表达式的特点"><a class="markdownIt-Anchor" href="#lambda-表达式的特点"></a> <code>Lambda</code> 表达式的特点</h1><ol><li>最后一行代码会自动作为 <code>Lambda</code> 表达式的返回值（隐式 <code>return</code>）。</li><li>如果 <code>Lambda</code> 没有参数，那么可以省略箭头符号 <code>-&gt;</code>。</li><li>如果 <code>Lambda</code> 是函数的最后一个参数，那么可以将大括号放在小括号的外面。</li><li>如果函数只有一个参数并且这个参数就是 <code>Lambda</code> ，则可以省略小括号。</li></ol><hr /><h1 id="sam-转换"><a class="markdownIt-Anchor" href="#sam-转换"></a> <code>SAM</code> 转换</h1><blockquote><p>当一个函数的参数是 SAM 的情况下，我们同样也可以使用 Lambda 作为参数。</p><p>通过 SAM 转换，我们就可以在 Kotlin 中便携的编写如 setOnClickListener 之类的方法了。</p></blockquote><p><code>SAM</code> 是 Single Abstract Method 的缩写，意思就是只有一个抽象方法的类或者接口。但在 Kotlin 和 Java 8 里，<strong>SAM 代表着只有一个抽象方法的接口</strong>。只要是符合 SAM 要求的接口，编译器就能进行 SAM 转换，也就是我们可以使用 Lambda 表达式，来简写接口类的参数。</p><p>注意，Java 8 中的 SAM 有明确的名称，叫做函数式接口（FunctionalInterface）。FunctionalInterface 的限制如下，缺一不可：</p><ol><li>必须是接口，抽象类不行；</li><li>该接口有且仅有一个抽象的方法，抽象方法个数必须是 1，默认实现的方法可以有多个。</li></ol><p>也就是说，对于 View.java 来说，它虽然是 Java 代码，但 Kotlin 编译器知道它的参数 OnClickListener 符合 SAM 转换的条件，所以会自动做以下转换。</p><p>转换前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnClickListener</span><span class="params">(OnClickListener l)</span></span><br></pre></td></tr></table></figure><p>转换后：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(l: (<span class="type">View</span>) -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="comment">// 实际上是这样：</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(l: ((<span class="type">View</span>!) -&gt; <span class="type">Unit</span>)?)</span></span></span><br></pre></td></tr></table></figure><p>其中，((View!) -&gt; Unit)? 代表的是这个参数可能为空。</p><hr /><h1 id="lambda-表达式的写法"><a class="markdownIt-Anchor" href="#lambda-表达式的写法"></a> <code>Lambda</code> 表达式的写法</h1><p>当一个函数的参数是 <code>SAM</code> 的情况下，我们同样也可以使用 <code>Lambda</code> 作为参数。所以，我们既可以用匿名内部类的方式传参，也可以使用 <code>Lambda</code> 的方式传参。</p><p>从匿名内部类的写法到 <code>Lambda</code> 表达式最终的精简形式，在这两种写法的中间，还有 6 种“过渡状态”的写法。</p><p>下面将从匿名内部类的写法开始，一步步的过渡到 <code>Lambda</code> 的写法。</p><p><strong><font size="4">第 1 种写法</font></strong></p><p>这是原始代码，它的本质是用 <code>object</code> 关键字定义了一个匿名内部类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(<span class="keyword">object</span>: View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        gotoPreview(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 2 种写法</font></strong></p><p>在这种情况下，<code>object</code> 关键字可以被省略。这时候它在语法层面就不再是匿名内部类了，它更像是 <code>Lambda</code> 表达式了，因此它里面 <code>override</code> 的方法也要跟着删掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(View.OnClickListener &#123; v: View? -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的 <code>View.OnClickListener</code> 被称为 <code>SAM Constructor</code>（SAM 构造器），它是编译器为我们生成的。</p><p>这段代码明显简化了很多，既可以实现同样的功能，又不会造成任何歧义。因为 <code>View.OnClickListener</code> 中只有一个待实现方法,即使这里没有显式地重写 onClick() 方法，<code>Kotlin</code> 也能自动明白 <code>View.OnClickListener</code> 后面的 <code>Lambda</code> 表达式就是要在 <code>onClick()</code> 方法中实现的内容。</p><p><strong><font size="4">第 3 种写法</font></strong></p><p>如果一个 <code>Java</code> 方法的参数列表中不存在一个以上 <code>Java</code> 单抽象方法接口参数，我们还可以将接口名进行省略（且<code>Kotlin</code> 的 <code>Lambda</code> 表达式是不需要 <code>SAM Constructor</code> 的），所以它也可以被删掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123; v: View? -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 4 种写法</font></strong></p><p>由于 <code>Kotlin</code> 支持类型推导，所以 <code>View</code> 可以被删掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123; v -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 5 种写法</font></strong></p><p>当 <code>Kotlin</code> <code>Lambda</code> 表达式只有一个参数的时候，它可以被写成 <code>it</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123; it -&gt;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 6 种写法</font></strong></p><p><code>Kotlin</code> <code>Lambda</code> 的 <code>it</code> 是可以被省略的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 7 种写法</font></strong></p><p>当 <code>Kotlin</code> <code>Lambda</code> 作为函数的最后一个参数时，<code>Lambda</code> 可以被挪到外面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener() &#123;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 8 种写法</font></strong></p><p>当 <code>Kotlin</code> 只有一个 <code>Lambda</code> 作为函数参数时，<code>()</code> 可以被省略：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener &#123;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，将这 8 种写法的演进过程以动图的形式展现了出来，让你对 <code>Lambda</code> 这几种写法的差异有一个更加直观的认识。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/e441323968c0c061898257fd06db37bf.gif" alt="img" style="zoom: 50%;" />]]></content>
    
    
    <summary type="html">学习并整理了 Kotlin 中 Lambda 表达式的使用方法。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 函数嵌套</title>
    <link href="https://luoyu-ying.github.io/posts/47063eb1b5ed/"/>
    <id>https://luoyu-ying.github.io/posts/47063eb1b5ed/</id>
    <published>2022-07-09T15:24:11.000Z</published>
    <updated>2022-07-10T04:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li><li><a href="https://www.cnblogs.com/Anker/archive/2013/03/04/2943498.html">递归与尾递归总结 - Rabbit_Dale - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/zsp765098084/article/details/90901260">kotlin学习笔记之尾递归优化（tailrec）_mictoy_朱的博客-CSDN博客_kotlin tailrec</a></li></ul></blockquote><hr /><h1 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h1><p>在 <code>Kotlin</code> 中，我们可以在函数的代码块中创建另一个新的函数并使用该函数。并且该函数可以使用外部函数的变量。</p><p>如下方的代码；</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">outerMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算 1 + 2 + 3 + ...</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">innerMethod</span><span class="params">(c: <span class="type">Int</span> = <span class="number">10</span>)</span></span> &#123;</span><br><span class="line">        sum += c</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span>)</span><br><span class="line">        innerMethod(c - <span class="number">1</span>)</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    innerMethod()</span><br><span class="line">  println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    outerMethod()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h1><p>函数嵌套在工程中应尽量少的使用，容易造成代码可读性的降低。</p><p>但是在两种情况下可以创建内部函数：</p><ol><li>在某些情况下需要临时使用 <strong>递归</strong> 函数，如上文中的代码。</li><li>不希望被外部函数访问到的函数。</li></ol><hr /><h1 id="尾递归"><a class="markdownIt-Anchor" href="#尾递归"></a> 尾递归</h1><p>实际上，在函数式编程当中，我们有时候也会使用递归来替代循环。</p><p>我们知道，递归都是有调用栈开销的，所以我们应该尽量使用 <strong>尾递归</strong>。对于这种类型的递归，在经过栈复用优化以后，它的开销就可以忽略不计了，我们可以认为它的空间复杂度是 O(1)。</p><blockquote><p>尾递归就是从最后开始计算，每递归一次就算出相应的结果，也就是说, 函数调用出现在调用者函数的尾部，因为是尾部，所以根本没有必要去保存任何局部变量，直接让被调用的函数返回时越过调用者，返回到调用者的调用者去。</p><p><strong>尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数</strong>，深层函数所面对的不是越来越简单的问题，而是越来越复杂的问题，因为参数里带有前面若干步的运算路径。</p><p>尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。</p></blockquote><h2 id="尾递归的特点"><a class="markdownIt-Anchor" href="#尾递归的特点"></a> 尾递归的特点</h2><ul><li>递归的一种特殊形式</li><li>调用自身后无其他操作</li><li><code>tailrec</code> 关键字提示编译器尾递归优化</li></ul><p>示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>(<span class="keyword">val</span> value:<span class="built_in">Int</span>,<span class="keyword">var</span> next:ListNode? = <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findListNode</span><span class="params">(head:<span class="type">ListNode</span>?,value:<span class="type">Int</span>)</span></span>:ListNode?&#123; <span class="comment">//定义一个递归函数</span></span><br><span class="line">    head?:<span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (head.value == value) <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">return</span> findListNode(head.next,value)    <span class="comment">//return除了调用自己，没有多余的操作，所以是尾递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾递归优化的使用"><a class="markdownIt-Anchor" href="#尾递归优化的使用"></a> 尾递归优化的使用</h2><p>在 <code>Kotlin</code> 语言中，我们即使写出了符合尾递归的递归函数，编译器也不会自动帮我们进行优化。</p><p>我们需要在 <code>fun</code> 关键字前面加上 <code>tailrec</code> 关键字以表示我们需要进行尾递归优化。</p><p>示例代码1：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>(<span class="keyword">val</span> value:<span class="built_in">Int</span>,<span class="keyword">var</span> next:ListNode? = <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">findListNode</span><span class="params">(head:<span class="type">ListNode</span>?,value:<span class="type">Int</span>)</span></span>:ListNode?&#123; <span class="comment">//定义一个递归函数</span></span><br><span class="line">    head?:<span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (head.value == value) <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">return</span> findListNode(head.next,value)    <span class="comment">//return除了调用自己，没有多余的操作，所以是尾递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码2：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">recursionLoop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="comment">// 变化在这里</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line">    <span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">go</span><span class="params">(i: <span class="type">Int</span>, sum: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">10</span>) sum <span class="keyword">else</span> go(i + <span class="number">1</span>, sum + i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> go(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾递归优化的实质"><a class="markdownIt-Anchor" href="#尾递归优化的实质"></a> 尾递归优化的实质</h2><p>通过对上文中的 <code>findListNode</code> 方法对 <strong>加了 <code>tailrec</code> 关键字</strong> 与 <strong>去除 <code>tailrec</code> 关键字</strong> 的两份代码分别进行反编译，我们发现：</p><ul><li><p>没有优化的 <code>findListNode</code> 对应的 <code>Java</code> 代码依然是递归函数，并且递归运行次数较大时出现了 <code>StackOverflowError</code> 错误；</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135701617.png" alt="img" style="zoom: 90%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135611929.png" alt="img" style="zoom:87%;" /></li><li><p>优化后（即添加了 <code>tailrec</code> 关键字）的 <code>findListNode</code> 方法对应的 <code>Java</code> 代码已经不再是递归函数，而是通过循环来实现功能，这样就不会再出现 <code>stackoverflowerror</code> 了。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135710491.png" alt="img" style="zoom:90%;" /></li></ul><p>这样我们就在 <code>Kotlin</code> 中既实现了递归函数代码简洁的优势，又规避了在 <code>Java</code> 中使用递归函数容易出出现的问题。</p>]]></content>
    
    
    <summary type="html">学习了 Kotlin 中函数嵌套的使用方法。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 空指针检查</title>
    <link href="https://luoyu-ying.github.io/posts/4c7d77851d24/"/>
    <id>https://luoyu-ying.github.io/posts/4c7d77851d24/</id>
    <published>2022-07-09T11:32:31.000Z</published>
    <updated>2022-07-09T11:32:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li>《第一行代码 Android 第3版》</li></ul></blockquote><hr /><h1 id="可空类型系统"><a class="markdownIt-Anchor" href="#可空类型系统"></a> 可空类型系统</h1><p>因为 <code>Kotlin</code> 默认所有的参数和变量都不可为空，所以我们直接使用定义任何变量和参数并使用的话，是没有任何的空指针风险的。</p><p>例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>)</span></span> &#123;</span><br><span class="line">    study.readBooks()</span><br><span class="line">    study.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码是没有空指针异常的，如果我们尝试向 <code>doStudy</code> 函数中传递 <code>null</code> 参数，便会直接提示错误：<code>Null can not be a value of a non-null type Study</code>。</p><p>也就是说，<code>Kotlin</code> 将空指针异常的检查提前到了编译时期，如果我们的程序存在空指针异常的风险，那么在编译的时候会直接报错，修正之后才能成功运行，这样就可以保证程序在运行时期不会出现空指针异常了。</p><p>那么如何使得这些类型变为可为空的类型系统呢？</p><p><strong>很简单，就是在类名的后面加上一个问号。</strong></p><p>比如说，<code>Int</code> 表示不可为空的整形，而 <code>Int?</code> 则表示可为空的整形；<code>String</code> 表示不可为空的字符串，而 <code>String?</code> 就表示可以为空的字符串。</p><p>当我们希望上述的代码可以传入 <code>null</code> 参数，那么我们就需要将 <code>Study</code> 改成 <code>Study?</code> ，如下文所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    study.readBooks()</span><br><span class="line">    study.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上述的代码仍然有些许错误，即使我们能够正常的传入 <code>null</code> 参数，但是 <code>null</code> 是无法调用 <code>readBooks()</code> 以及 <code>doHomework()</code> 函数的。所以我们仍需要对 <code>study</code> 进行进一步的判断：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (study != <span class="literal">null</span>) &#123;</span><br><span class="line">        study.readBooks()</span><br><span class="line">        study.doHomework()    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样的写法，我们可能会在代码中写入大量的 <code>if</code> 语句仅仅只是为了判断变量或者参数是否为空，这样会让代码变得比较啰嗦。为此，<code>Kotlin</code> 专门提供了一系列的辅助工具，方便我们更加轻松以及快速地进行判空处理。</p><hr /><h1 id="判空辅助工具"><a class="markdownIt-Anchor" href="#判空辅助工具"></a> 判空辅助工具</h1><h2 id="操作符"><a class="markdownIt-Anchor" href="#操作符"></a> <code>?.</code> 操作符</h2><p><code>?.</code> 操作符的作用就是当对象不为空的时候正常调用相应的函数，当对象为空时则什么都不做。</p><p>如下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">    a.doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 <code>?.</code> 操作符，我们便可以将其简化成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a?.doSomething()</span><br></pre></td></tr></table></figure><p>现在我们便可以对上文中的代码进行优化了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    study?.readBooks()</span><br><span class="line">    study?.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作符-2"><a class="markdownIt-Anchor" href="#操作符-2"></a> <code>?:</code> 操作符</h2><p><code>?:</code> 操作符的左右两边都接受一个表达式，如果左边表达式的结果不为空就返回左边表达式的结果，否则就返回右边表达式的结果。</p><p>如下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = <span class="keyword">if</span> (a != <span class="literal">null</span>) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><p>便可以简化成为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = a ?: b</span><br></pre></td></tr></table></figure><h2 id="操作符-3"><a class="markdownIt-Anchor" href="#操作符-3"></a> <code>!!.</code> 操作符</h2><p>如果我们想要一遍变量在使用的过程中不进行空指针检查，并在遇到空指针的时候主动的抛出空指针异常（有的时候我们可能从逻辑上已经将空指针异常处理了，但是 <code>Kotlin</code> 的编译器并不知道，这个时候它还是会编译失败），那么我们可以通过使用 <code>!!.</code> 操作符（非空断言工具）强行通过编译。写法是在对象的后面加上 <code>!!.</code>。</p><p>例如以下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg: String? = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">        printUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printUpperCase</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> upperCase = msg!!.toUpperCase()</span><br><span class="line">    println(upperCase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上文中，<code>printUpperCase</code> 函数的调用一定发生在 <code>msg</code> 不为空的情况，所以我们可以使用非空断言工具让其不进行空指针判断。</p><p>这是一种有风险的写法，意在告诉 <code>Kotlin</code>，我非常确信这里的对象不会为空，所以不用你来帮我做空指针检查了，如果出现问题，你可以直接抛出空指针异常，后果由我自己承担。</p><p>虽然这样编写代码确实可以通过编译，但是当你想要使用非空断言工具的时候，最好提醒一下自己，是不是还有更好的实现方式。</p><p><strong>你最自信这个对象不会为空的时候，其实可能就是一个潜在空指针异常发生的时候。</strong></p><hr /><h1 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h1><p>标准函数中 <code>let</code> 函数是可以处理全局变量的判空问题的，而 <code>if</code> 语句则无法做到这一点。</p><p>比如我们将 <code>doStudy()</code> 中的参数变成一个全局变量，使用 <code>let</code> 函数仍然可以正常工作，但是使用 <code>if</code> 语句则会提示错误：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220709203415002.png" alt="image" style="zoom:80%;" /><p>之所以这里会报错，是因为全局变量的值随时都有可能被其他线程所修改，即使做了判空处理，仍然无法保证 <code>if</code> 语句中的<code>study</code> 变量没有空指针风险。从这一点上也能体现出 <code>let</code> 函数的优势。</p>]]></content>
    
    
    <summary type="html">学习了 Kotlin 中空指针相关的运算符。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 扩展函数与扩展属性</title>
    <link href="https://luoyu-ying.github.io/posts/ffb71c4ce53a/"/>
    <id>https://luoyu-ying.github.io/posts/ffb71c4ce53a/</id>
    <published>2022-07-09T04:22:03.000Z</published>
    <updated>2022-07-09T04:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li></ul></blockquote><hr /><p><code>Kotlin</code> 的扩展（<code>Extension</code>），主要分为两种语法：第一个是扩展函数，第二个是扩展属性。从语法上看，扩展看起来就像是我们从类的外部为它扩展了新的成员。</p><p>这在实际编程当中是非常有用的功能。我们可以来想象一个场景：我们想修改 <code>JDK</code> 当中的 <code>String</code>，想在它的基础上增加一个方法 <code>lastElement()</code> 来获取末尾元素，如果使用 <code>Java</code>，我们是无法通过常规手段实现的，因为我们没办法修改 <code>JDK</code> 的源代码。<strong>任何第三方提供的 <code>SDK</code>，我们都无权修改。</strong></p><p>不过，借助 <code>Kotlin</code> 的扩展函数，我们就完全可以在语义层面，来为第三方 <code>SDK</code> 的类扩展新的成员方法和成员属性。不管是为 <code>JDK</code> 的 <code>String</code> 增加新的成员方法，还是为 <code>Android SDK</code> 的 <code>View</code> 增加新成员属性，我们都可以实现。</p><hr /><h1 id="扩展函数"><a class="markdownIt-Anchor" href="#扩展函数"></a> 扩展函数</h1><p>扩展函数，就是从类的外部扩展出来的一个函数，这个函数看起来就像是类的成员函数一样。这里，我们就以 <code>JDK</code> 当中的 <code>String</code> 为例，来看看如何通过 <code>Kotlin</code> 的扩展特性，为它新增一个 <code>lastElement()</code> 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ext.kt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ①    ②       ③           ④</span></span><br><span class="line"><span class="comment"> ↓     ↓       ↓            ↓      */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;</span><br><span class="line">    <span class="comment">//    ⑤</span></span><br><span class="line">    <span class="comment">//    ↓</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用扩展函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> msg = <span class="string">&quot;Hello Wolrd&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// lastElement就像String的成员方法一样可以直接调用</span></span><br><span class="line">    <span class="keyword">val</span> last = msg.lastElement() <span class="comment">// last = d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先是定义了一个 <code>String</code> 的扩展函数 <code>lastElement()</code> ，然后在 <code>main</code> 函数当中调用了这个函数。并且，这个扩展函数是直接定义在 <code>Kotlin</code> 文件里的，而不是定义在某个类当中的。这种扩展函数，我们称之为**“顶层扩展”**，这么叫它是因为它并没有嵌套在任何的类当中，它自身就在最外层。</p><p>现在，我们依次来看看上面的五处注释：</p><ol><li><p>注释①，<code>fun</code> 关键字</p><p>代表我们要定义一个函数。也就是说，不管是定义普通 <code>Kotlin</code> 函数，还是定义扩展函数，我们都需要 <code>fun</code> 关键字。</p></li><li><p>注释②，“<code>String.</code>”</p><p>代表我们的扩展函数是为 <code>String</code> 这个类定义的。在 <code>Kotlin</code> 当中，它有一个名字，叫做接收者（<code>Receiver</code>），也就是扩展函数的接收方。</p></li><li><p>注释③，<code>lastElement()</code></p><p>是我们定义的扩展函数的名称。</p></li><li><p>注释④，“<code>Char?</code>”</p><p>代表扩展函数的返回值是可能为空的 <code>Char</code> 类型。</p></li><li><p>注释⑤，“<code>this.</code>”</p><p>代表“具体的 <code>String</code> 对象”，当我们调用 <code>msg.lastElement()</code> 的时候，<code>this</code> 就代表了 <code>msg</code>。</p></li></ol><p>需要注意的是，<strong>在整个扩展函数的方法体当中，<code>this</code> 都是可以省略的</strong>。这一点，<code>Kotlin</code> 和 <code>Java</code> 是一样的，<code>this</code> 代表当前作用域，它可写可不写。即例如以下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span> : <span class="built_in">Char</span>? = <span class="keyword">if</span> (isEmpty()) <span class="literal">null</span> <span class="keyword">else</span> <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">    println(str.lastElement())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，<code>Kotlin</code> 的扩展是允许我们为“<strong>可为空的类型</strong>”进行扩展的。比如说：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不为空的接收者类型</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可为空的接收者类型</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String?.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;&#125;</span><br></pre></td></tr></table></figure><p>接受者可空的扩展在遇到空对象调用时不会抛异常，并且允许可空对象调用。</p><hr /><h1 id="扩展属性"><a class="markdownIt-Anchor" href="#扩展属性"></a> 扩展属性</h1><p>在学习了 <code>Kotlin</code> 的扩展函数以后，扩展属性就很好理解了。</p><p>扩展函数，是在类的外部为它定义一个<strong>新的成员方法</strong>；而扩展属性，则是在类的外部为它定义一个<strong>新的成员属性</strong>。</p><p>那么，在研究了扩展的实现原理后，我们知道，我们从外部定义的成员方法和属性，都只是语法层面的，并没有实际修改那个类的源代码。</p><p>还是以 <code>lastElement</code> 为例，在之前的案例当中，我们是通过扩展函数来实现的，这次我们以扩展属性的方式来实现。扩展函数的定义对比普通函数，其实就只是多了一个“接收者类型”。类似的，扩展属性，也就是在普通属性定义的时候多加一个“接收者类型”即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收者类型</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="keyword">val</span> String.lastElement: <span class="built_in">Char</span>?</span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 this 关键字也可以写成：</span></span><br><span class="line"><span class="comment">val String.lastElement : Char?</span></span><br><span class="line"><span class="comment">    get() = if (isEmpty()) null else this[length - 1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> msg = <span class="string">&quot;Hello Wolrd&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// lastElement就像String的成员属性一样可以直接调用</span></span><br><span class="line">    <span class="keyword">val</span> last = msg.lastElement <span class="comment">// last = d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段的代码中，我们为 String 类型扩展了一个新的成员属性“<code>lastElement</code>”。然后在 <code>main</code> 函数当中，我们直接通过“<code>msg.lastElement</code>”方式使用了这个扩展属性，就好像它是一个成员一样。</p><hr /><h1 id="扩展与其反编译代码"><a class="markdownIt-Anchor" href="#扩展与其反编译代码"></a> 扩展与其反编译代码</h1><p>为了看得更加清晰，我们用一张图来描述它们之间的关系。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/2a38487b61ec06e437c1425b2a69ffed.png" alt="img" /></p><p>上面的两个箭头，说明了扩展函数与扩展属性，它们最终会被 <code>Kotlin</code> 编译器转换成静态方法；下面两个箭头，说明了扩展函数和扩展属性的调用代码，最终会被 <code>Kotlin</code> 编译器转换成静态方法的调用。</p><p>所以也就是说，<code>Kotlin</code> 的扩展表面上看起来是为一个类扩展了新的成员，<strong>但是本质上，它还是静态方法</strong>。而且，不管是扩展函数还是扩展属性，它本质上都会变成一个静态的方法。</p><p><strong>那么，到底什么时候该用扩展函数，什么时候该用扩展属性呢？</strong></p><p>其实，我们只需要看扩展在语义上更适合作为函数还是属性就够了。比如这里的 <code>lastElement</code>，它更适合作为一个扩展属性。这样设计的话，在语义上，<code>lastElement</code> 就像是 <code>String</code> 类当中的属性一样，它代表了字符串里的最后一个字符。</p><hr /><h1 id="扩展的优势与局限性"><a class="markdownIt-Anchor" href="#扩展的优势与局限性"></a> 扩展的优势与局限性</h1><h2 id="扩展的优势"><a class="markdownIt-Anchor" href="#扩展的优势"></a> 扩展的优势</h2><p>当我们想要从外部为一个类扩展一些方法和属性的时候，我们就可以通过扩展来实现了。<strong>在 <code>Kotlin</code> 当中，几乎所有的类都可以被扩展</strong>，包括普通类、单例类、密封类、枚举类、伴生对象，甚至还包括第三方提供的 <code>Java</code> 类。</p><p>唯有匿名内部类，由于它本身不存在名称，我们无法指定“接收者类型”，所以不能被扩展，当然了，它也没必要被扩展。</p><p>可以说，<code>Kotlin</code> 扩展的应用范围还是非常广的。它最主要的用途，就是用来取代 <code>Java</code> 当中的各种工具类，比如 <code>StringUtils</code>、<code>DateUtils</code> 等等。</p><p>所有 <code>Java</code> 工具类能做的事情，<code>Kotlin</code> 扩展函数都可以做，并且可以做得更好。扩展函数的优势在于，开发工具可以在编写代码的时候智能提示。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/239e540b768560c6cd119b1bb9e1eb9c.gif" alt="img" style="zoom: 40%;" /><h2 id="扩展的局限性"><a class="markdownIt-Anchor" href="#扩展的局限性"></a> 扩展的局限性</h2><p><code>Kotlin</code> 的扩展，由于它本质上并没有修改接收类型的源代码，所以它的行为是无法与“类成员”完全一致的。那么它对比普通的类成员，就会有以下几个限制。</p><p><strong>第一个限制，<code>Kotlin</code> 扩展不是真正的类成员，因此它无法被它的子类重写。</strong></p><p>举个例子，我们定义一个这样的 <code>Person</code> 类，并且分别为它扩展了一个 <code>isAdult</code> 属性和 <code>walk()</code> 方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> Person.isAdult: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = age &gt;= <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.<span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;walk&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>Person</code> 类有 <code>open</code> 关键字修饰，所以我们可以继承这个 <code>Person</code> 类。</p><p>不过，当我们尝试去重写它的成员时，会发现 <code>isAdult</code> 和 <code>walk()</code> 是无法被重写的，因为它们压根就不属于 <code>Person</code> 这个类。</p><p><strong>第二个限制，扩展属性无法存储状态。</strong></p><p>就如前面代码当中的 <code>isAdult</code> 属性一般，它的值是由 <code>age</code> 这个成员属性决定的，它本身没有状态，也无法存储状态。背后的根本原因，还是因为它们都是静态方法。</p><p><strong>第三个限制，扩展的<em>访问作用域</em>仅限于两个地方。</strong></p><ol><li><p>如果扩展是顶层的扩展。</p><p>那么扩展的访问域仅限于该 <code>Kotlin</code> 文件当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展是可以被全局使用的。</p></li><li><p>如果扩展是被定义在某个类当中的。</p><p>那么该扩展的访问域仅限于该类当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展仅能在该类当中使用。</p></li></ol><hr /><h1 id="扩展的使用场景"><a class="markdownIt-Anchor" href="#扩展的使用场景"></a> 扩展的使用场景</h1><p><strong><code>Kotlin</code> 扩展的第一个典型使用场景：关注点分离。主动使用扩展，通过它来优化软件架构。</strong></p><p>所谓关注点分离，就是将我们程序的逻辑划分成不同的部分，每一个部分，都只关注自己那部分的职责。以 <code>Kotlin</code> 源码中的 <code>String</code> 类为例，<code>String.kt</code> 这个类，只关注 <code>String</code> 的核心逻辑；而 <code>Strings.kt</code> 则只关注 <code>String</code> 的操作符逻辑。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String.kt (一共只有13行代码)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> : <span class="type">Comparable</span>&lt;<span class="type">String</span>&gt;, <span class="type">CharSequence &#123;</span></span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">val</span> length: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: <span class="built_in">Char</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">subSequence</span><span class="params">(startIndex: <span class="type">Int</span>, endIndex: <span class="type">Int</span>)</span></span>: CharSequence</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Strings.kt 部分代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CharSequence.<span class="title">trim</span><span class="params">()</span></span>: CharSequence = trim(<span class="built_in">Char</span>::isWhitespace)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">expect</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">lowercase</span><span class="params">()</span></span>: String</span><br></pre></td></tr></table></figure><p><strong>扩展的第二个核心使用场景：被动使用扩展，提升可读性与开发效率。</strong></p><p>当我们无法修改外部的 <code>SDK</code> 时，对于重复的代码模式，我们将其以扩展的方式封装起来，提供给对应的接收者类型。</p><hr /><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><ol><li><code>Kotlin</code> 的扩展，从 <strong>语法角度</strong> 来看，分为扩展函数和扩展属性。定义扩展的方式，只是比普通函数、属性多了一个“扩展接收者”而已。</li><li>从 <strong>作用域</strong> 角度来看，分为顶层扩展和类内扩展。</li><li>从 <strong>本质</strong> 上来看，扩展函数和扩展属性，它们都是 <code>Java</code> 静态方法，与 <code>Java</code> 当中的工具类别无二致。对比 <code>Java</code> 工具类，扩展最大的优势就在于，<code>IDE</code> 可以为我们提供代码补全功能。</li><li>从 <strong>能力</strong> 的角度来看，<code>Kotlin</code> 扩展一共有三个限制，分别是：扩展无法被重写；扩展属性无法存储状态；扩展的作用域有限，无法访问私有成员。</li><li>从 <strong>使用场景</strong> 的角度来看，<code>Kotlin</code> 扩展主要有两个使用场景，分别是：关注点分离，优化代码架构；消灭模板代码，提高可读性和开发效率。</li></ol><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/b4a3ce7c3e0b2228161faa4769618a10.jpg" alt="img" /></p>]]></content>
    
    
    <summary type="html">学习了 Kotlin 中扩展函数与扩展属性的使用方式。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 类的创建与继承</title>
    <link href="https://luoyu-ying.github.io/posts/8aab3d7fde77/"/>
    <id>https://luoyu-ying.github.io/posts/8aab3d7fde77/</id>
    <published>2022-07-08T04:41:57.000Z</published>
    <updated>2022-07-08T04:41:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Kotlin</code> 官方在线编程网址：</p><ul><li><a href="https://play.kotlinlang.org/">https://play.kotlinlang.org/</a></li></ul></blockquote><hr /><blockquote><p>本文参考自：</p><ul><li>《第一行代码  Android 第3版》</li><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li><li><a href="https://blog.csdn.net/c1392851600/article/details/80990570">Kotlin之类的继承及属性和方法的重写_c1392851600的博客-CSDN博客</a></li></ul></blockquote><hr /><h1 id="基本写法"><a class="markdownIt-Anchor" href="#基本写法"></a> 基本写法</h1><h2 id="创建"><a class="markdownIt-Anchor" href="#创建"></a> 创建</h2><p>通过 <code>class</code> 关键字创建一个类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is eating.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化方式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> person = Person()</span><br></pre></td></tr></table></figure><h2 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h2><p><strong>默认所有非抽象类都是不可以被继承的</strong>。</p><p>如果需要将其变为父类，则需要在 <code>class</code> 前使用 <code>open</code> 关键字。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is eating.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要继承另一个类，则使用 <code>:</code> 符号：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> grade = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重写"><a class="markdownIt-Anchor" href="#重写"></a> 重写</h2><h3 id="重写父类的方法"><a class="markdownIt-Anchor" href="#重写父类的方法"></a> 重写父类的方法</h3><p>需要注意的是如果父类的方法没有 <code>open</code> 声明，那么该方法是不允许被重写的。重写方法的时候需要使用 <code>override</code> 关键字注明。还有一点就是子类可以选择不重写父类的方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">shout</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;汪汪&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;萌萌哒&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Husky</span> : <span class="type">Dog</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 由于父类的shout方法没有写open, 也就是默认是final的, 所以这里不能重写shout方法</span></span><br><span class="line">    <span class="comment">// Error:(15, 5) Kotlin: &#x27;shout&#x27; in &#x27;Dog&#x27; is final and cannot be overridden  不能重写shout因为默认是final的</span></span><br><span class="line">    <span class="comment">/* override fun shout() &#123;</span></span><br><span class="line"><span class="comment">        println(&quot;玩明汪&quot;)</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重写父类方法的时候要加上override关键字, show方法也可以选择不进行重写</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;喵喵&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> husky =  Husky()</span><br><span class="line">    husky.shout()</span><br><span class="line">    husky.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次需要注意的是，如果一个类集成了多个类/接口，并且父类/接口中有相同名字的方法需要重写的时候，那么子类这时候必须重写该方法，并且如果子类想区分开父类的方法的时候，可以使用 <code>super</code> 关键字调用不同父类的方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">shout</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;汪汪&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;萌萌哒&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">WatchDog</span> </span>&#123;</span><br><span class="line">    <span class="comment">// interface里不用写open, 因为默认就是open的</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;看门电子狗&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用接口的时候不用写(), 是因为接口是没有构造函数的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Husky</span> : <span class="type">Dog</span></span>(), WatchDog &#123;</span><br><span class="line">    <span class="comment">// 由于父类的shout方法没有写open, 也就是默认是final的, 所以这里不能重写父类的方法</span></span><br><span class="line">    <span class="comment">// Error:(15, 5) Kotlin: &#x27;shout&#x27; in &#x27;Dog&#x27; is final and cannot be overridden  不能重写shout因为默认是final的</span></span><br><span class="line">    <span class="comment">/*override fun shout() &#123;</span></span><br><span class="line"><span class="comment">        println(&quot;玩明汪&quot;)</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重写父类方法的时候要加上override关键字</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 当重写的方法在父类中有多个实现的时候, 如果继承的多个类中, 有相同的方法需要重写的时候, 则子类必须重写该方法, 并且, 为了区分, 可以使用super关键字来调用不同的父类中的方法</span></span><br><span class="line">        <span class="keyword">super</span>&lt;WatchDog&gt;.show()  <span class="comment">// 看萌电子狗</span></span><br><span class="line">        <span class="keyword">super</span>&lt;Dog&gt;.show() <span class="comment">// 萌萌哒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> husky =  Husky()</span><br><span class="line">    husky.shout()   <span class="comment">// 汪汪</span></span><br><span class="line">    husky.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写父类的变量"><a class="markdownIt-Anchor" href="#重写父类的变量"></a> 重写父类的变量</h3><p>父类变量的重写的时候有几个需要注意的地方：</p><ol><li><p>被重写的变量也要有 <code>open</code> 的声明。</p></li><li><p>子类可以使用 <code>var</code> 类型的变量去重写父类 <code>val</code> 类型的变量，但是不能使用 <code>val</code> 类型的变量去重写父类 <code>var</code> 类型的变量。</p><p>如果使用 <code>val</code> 类型的变量去重写父类的 <code>var</code> 类型的变量, 那么子类这个 <code>val</code> 类型的变量会多一个 <code>set</code> 方法, 而 <code>val</code> 类型的变量是不允许有 <code>set</code> 方法的。</p></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> y : String = <span class="string">&quot;a&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> : <span class="type">A</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> y: String = <span class="string">&quot;b&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> : <span class="type">A</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span>  <span class="keyword">var</span> x : <span class="built_in">Int</span> = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> y : String = <span class="string">&quot;c&quot;</span> <span class="comment">// Error: Var-property public open val y: String defined in C cannot be overridden by val-property public open var y: String defined in A</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h1><p><code>Kotlin</code> 将构造函数分为了两种：主构造函数和次构造函数。</p><h2 id="主构造函数"><a class="markdownIt-Anchor" href="#主构造函数"></a> 主构造函数</h2><p>主构造函数是最常使用的构造函数，每个类默认都会有一个不带参数的主构造函数。</p><p>（特殊情况：如果在没有实现主构造函数的情况下实现了次构造函数，则会失去该不带参数的主构造函数。）</p><p>当然也是可以显式地为其指明参数。主构造函数的特点就是没有函数体，直接定义在类名的后面即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> studentNo: String, <span class="keyword">var</span> grade: <span class="built_in">Int</span>) : Person() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者可以写成</span></span><br><span class="line"><span class="comment">// class Student constructor(val studentNo: String, var grade: Int) : Person() &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>我们在实例化的时候需要传入构造函数中的所有的参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> student = Student(<span class="string">&quot;123456789&quot;</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>由于主构造函数没有函数体，所以我们无法直接在其中编写一些逻辑。但是 <code>Kotlin</code> 给我们提供了一个 <code>init</code> 结构体，所有主构造函数的逻辑都可以写在里面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> studentNo: String, <span class="keyword">var</span> grade: <span class="built_in">Int</span>) : Person() &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Student No is <span class="variable">$studentNo</span> AND grade is <span class="variable">$grade</span>.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 <code>Java</code> 语言继承特性中的一个规定：子类的构造函数必须调用父类中的构造函数。这个规定在 <code>Kotlin</code> 中也要遵守。</p><p>所以在上文中 <code>class Student : Person()</code> 以及 <code>class Student(val studentNo: String, var grade: Int) : Person()</code> 中 <code>Person</code> 类后面的一对空括号表示 <code>Student</code> 类的主构造函数在初始化的时候会调用 <code>Person</code> 类的无参数构造函数，即使在自身的主构造函数为默认的无参数的时候也是不能省略的。</p><p>现在我们将 <code>Person</code> 类改造一下，将姓名和年龄都放到主构造函数中，即：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is eating.&quot;</span>)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们自定义了主构造函数，所以默认提供的无参数的主构造函数就不存在了，所以我们也需要修改一下 <code>Student</code> 类的表示方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> studentNo: String, <span class="keyword">var</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>) :</span><br><span class="line">        Person(name, age) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Student No is <span class="variable">$studentNo</span> AND grade is <span class="variable">$grade</span>.&quot;</span>)</span><br><span class="line">    &#125;    </span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我们在 <code>Student</code> 类的主构造函数中增加 <code>name</code> 和 <code>age</code> 这两个字段时，不能再将它们声明成 <code>val</code>，因为在主构造函数中声明成 <code>val</code> 或者 <code>var</code> 的参数将自动成为该类的字段,这就会导致和父类中同名的 <code>name</code> 和 <code>age</code> 字段造成冲突。因此，<strong>这里的 <code>name</code> 和 <code>age</code> 参数前面我们不用加任何关键字,让它的作用域仅限定在主构造函数当中即可</strong> 。</p><p>现在就可以通过如下的代码来创建一个 <code>Student</code> 类的实例并使用了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> student = Student(<span class="string">&quot;123456789&quot;</span>, <span class="number">3</span>, <span class="string">&quot;LiHua&quot;</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><h2 id="次构造函数"><a class="markdownIt-Anchor" href="#次构造函数"></a> 次构造函数</h2><p>其实你几乎是用不到次构造函数的，<code>Kotlin</code> 提供了一个给函数设定参数默认值的功能，基本上可以替代次构造函数的作用。</p><p>任何一个类只能有一个主构造函数，但是可以有多个次构造函数。次构造函数也可以用于实例化一个类，这一点和主构造函数没有什么不同，只不过它是有函数体的。</p><p><code>Kotlin</code> 规定，当一个类既有主构造函数又有次构造函数时，所有的次构造函数都必须调用主构造函数（包括间接调用)。</p><p>比如以下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(name: String, age: <span class="built_in">Int</span>, <span class="keyword">val</span> studentNo: String, <span class="keyword">var</span> grade: <span class="built_in">Int</span>) : Person(name, age) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;name : <span class="variable">$name</span> AND age : <span class="variable">$age</span> AND studentNo : <span class="variable">$studentNo</span> AND grade : <span class="variable">$grade</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(name: String , age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(name, age, <span class="string">&quot;12345&quot;</span>, <span class="number">2</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="string">&quot;XiaoMei&quot;</span>, <span class="number">19</span>, <span class="string">&quot;1234567&quot;</span>, <span class="number">1</span>) &#123;&#125; <span class="comment">// 如果 &#123;&#125; 内没有内容的话，可以省略大括号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student1 = Student(<span class="string">&quot;LiHua&quot;</span>, <span class="number">20</span>, <span class="string">&quot;123456&quot;</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> student2 = Student(<span class="string">&quot;XiaoMing&quot;</span>, <span class="number">21</span>)</span><br><span class="line">    <span class="keyword">val</span> student3 = Student()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">name : LiHua AND age : <span class="number">20</span> AND studentNo : <span class="number">123456</span> AND grade : <span class="number">3</span></span><br><span class="line">name : XiaoMing AND age : <span class="number">21</span> AND studentNo : <span class="number">12345</span> AND grade : <span class="number">2</span></span><br><span class="line">name : XiaoMei AND age : <span class="number">19</span> AND studentNo : <span class="number">1234567</span> AND grade : <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>特殊情况：</strong></p><p>那么接下来我们就再来看一种非常特殊的情况：类中只有次构造函数，没有主构造函数。</p><p>这种情况真的十分少见，但在 <code>Kotlin</code> 中是允许的。</p><p><strong>当一个类没有显式地定义主构造函数且定义了次构造函数时，它就是没有主构造函数的。</strong></p><p>我们结合代码来看一下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person &#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">super</span>(name, age) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的代码变化，首先 <code>Student</code> 类的后面没有显式地定义主构造函数，同时又因为定义了次构造函数，所以现在 <code>Student</code> 类是没有主构造函数的。那么既然没有主构造函数，继承 <code>Person</code> 类的时候也就不需要再加上括号了（因为主构造函数会调用父类的构造函数）。</p><p>另外，由于没有主构造函数，次构造函数只能直接调用父类的构造函数，上述代码也是将 <code>this</code> 关键字换成了 <code>super</code> 关键字，这部分就很好理解了，因为和 <code>Java</code> 比较像，也就不再多说了。</p><hr /><h1 id="函数的命名参数以及参数默认值"><a class="markdownIt-Anchor" href="#函数的命名参数以及参数默认值"></a> 函数的命名参数以及参数默认值</h1><blockquote><p>类的构造函数同样适用于命名参数以及参数默认值，所以我们在极大多数的情况下通过这两个特性配合主构造函数来可以实现次构造函数的功能。</p></blockquote><h2 id="命名参数"><a class="markdownIt-Anchor" href="#命名参数"></a> 命名参数</h2><p>简单理解，就是它允许我们在调用函数的时候传入“形参的名字”。</p><p>如同以下形式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helloFunction(name = <span class="string">&quot;Kotlin&quot;</span>)</span><br></pre></td></tr></table></figure><p>让我们看一个更具体的使用场景：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createUser</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    age: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    gender: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    friendCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    feedCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    likeCount: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    commentCount: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过如下的方法使用函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">createUser(</span><br><span class="line">    name = <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    age = <span class="number">30</span>,</span><br><span class="line">    gender = <span class="number">1</span>,</span><br><span class="line">    friendCount = <span class="number">78</span>,</span><br><span class="line">    feedCount = <span class="number">2093</span>,</span><br><span class="line">    likeCount = <span class="number">10937</span>,</span><br><span class="line">    commentCount = <span class="number">3285</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到，在这段代码中，我们把函数的形参加了进来，形参和实参用 <code>=</code> 连接，建立了两者的对应关系。对比前面 <code>Java</code> 风格的写法，这样的代码可读性更强了。如果将来你想修改 <code>likeCount</code> 这个参数，也可以轻松做到。这其实就体现出了 <code>Kotlin</code> 命名参数的可读性与易维护性两个优势。</p><h2 id="参数默认值"><a class="markdownIt-Anchor" href="#参数默认值"></a> 参数默认值</h2><p>而除了命名参数这个特性，<code>Kotlin</code> 还支持参数默认值，这个特性在参数较多的情况下同样有很大的优势：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createUser</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    age: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    gender: <span class="type">Int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    friendCount: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    feedCount: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    likeCount: <span class="type">Long</span> = <span class="number">0</span>L,</span></span></span><br><span class="line"><span class="params"><span class="function">    commentCount: <span class="type">Int</span> = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，<code>gender</code>、<code>friendCount</code>、<code>feedCount</code>、<code>likeCount</code>、<code>commentCount</code> 这几个参数都被赋予了默认值。这样做的好处就在于，我们在调用的时候可以省很多事情。比如说，下面这段代码就只需要传 3 个参数，剩余的 4 个参数没有传，但是 <code>Kotlin</code> 编译器会自动帮我们填上默认值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">createUser(</span><br><span class="line">    name = <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    age = <span class="number">30</span>,</span><br><span class="line">    commentCount = <span class="number">3285</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于无默认值的参数，编译器会强制要求我们在调用处传参；对于有默认值的参数，则可传可不传。<code>Kotlin</code> 这样的特性，在一些场景下就可以极大地提升我们的开发效率。而如果是在 <code>Java</code> 当中要实现类似的事情，我们就必须手动定义“3 个参数的 <code>createUser</code> 函数”，或者是使用 <code>Builder</code> 设计模式。</p><h2 id="在构造函数中的使用案例"><a class="markdownIt-Anchor" href="#在构造函数中的使用案例"></a> 在构造函数中的使用案例</h2><p>通过写出如下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(</span><br><span class="line">    name: String = <span class="string">&quot;&quot;</span>, </span><br><span class="line">    age: <span class="built_in">Int</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="keyword">val</span> studentNo: String = <span class="string">&quot;&quot;</span>, </span><br><span class="line">    <span class="keyword">val</span> grade: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : Person(name, age) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在给主构造函数的每个参数都设定了默认值之后，我们就可以使用任何传参组合的方式来对 <code>Student</code> 类进行实例化，当然也包含了上文中的两种次构造函数的使用场景。</p><hr /><h1 id="函数的可见性修饰符"><a class="markdownIt-Anchor" href="#函数的可见性修饰符"></a> 函数的可见性修饰符</h1><p>熟悉 <code>Java</code> 的人一定知道，<code>Java</code> 中有 <code>public</code>、 <code>private</code>、 <code>protected</code> 和 <code>default</code>(什么都不写）这4种函数可见性修饰符。</p><p><code>Kotlin</code>中也有4种，分别是 <code>public</code>、 <code>private</code>、<code>protected</code> 和 <code>internal</code>，需要使用哪种修饰符时，直接定义在 <code>fun</code> 关键字的前面即可。</p><p>下面将详细介绍一下 <code>Java</code> 和 <code>Kotlin</code> 中这些函数可见性修饰符的异同。</p><ol><li><p><code>private</code> 修饰符在两种语言中的作用是一模一样的，都表示只对当前类内部可见。</p></li><li><p><code>public</code> 修饰符的作用虽然也是一致的，表示对所有类都可见，但是在 <code>Kotlin</code>中 <code>public</code> 修饰符是默认项，而在 <code>Java</code> 中 <code>default</code> 才是默认项。前面我们定义了那么多的函数，都没有加任何的修饰符，所以它们默认都是 <code>public</code> 的。</p></li><li><p><code>protected</code> 关键字在 <code>Java</code> 中表示对当前类、子类和同一包路径下的类可见，在 <code>Kotlin</code> 中则表示只对当前类和子类可见。</p></li><li><p><code>Kotlin</code> 抛弃了 <code>Java</code> 中的 <code>default</code> 可见性（同一包路径下的类可见），引人了一种新的可见性概念，只对同一模块中的类可见，使用的是 <code>internal</code> 修饰符。比如我们开发了一个模块给别人使用，但是有一些函数只允许在模块内部调用，不想暴露给外部，就可以将这些函数声明成 <code>internal</code> 。</p></li></ol><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220708221406391.png" alt="image" /></p><p>所以，我们可以通过 <code>private</code> 关键字将类的构造函数定义为私有属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 私有的主构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">val</span> studentNo: String, </span><br><span class="line">    <span class="keyword">var</span> grade: <span class="built_in">Int</span></span><br><span class="line">) : Person() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有的次构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>(grade: <span class="built_in">Int</span>) : <span class="keyword">this</span>(<span class="string">&quot;123&quot;</span>, grade) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录了 Kotlin 中类的创建与继承的语法。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
</feed>
