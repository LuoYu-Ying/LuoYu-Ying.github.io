<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洛语 の Blog</title>
  
  
  <link href="https://luoyu-ying.github.io/atom.xml" rel="self"/>
  
  <link href="https://luoyu-ying.github.io/"/>
  <updated>2022-07-10T14:33:28.000Z</updated>
  <id>https://luoyu-ying.github.io/</id>
  
  <author>
    <name>LuoYu-Ying</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo Butterfly 添加相册</title>
    <link href="https://luoyu-ying.github.io/posts/aae775e24f21/"/>
    <id>https://luoyu-ying.github.io/posts/aae775e24f21/</id>
    <published>2022-07-10T14:33:28.000Z</published>
    <updated>2022-07-10T14:33:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://butterfly.js.org/posts/dc584b87/">Butterfly 安裝文檔(二) 主題頁面 | Butterfly</a></li></ul></blockquote><hr /><h1 id="gallery-相册图库"><a class="markdownIt-Anchor" href="#gallery-相册图库"></a> <code>Gallery</code> 相册图库</h1><p>图库页面只是普通的页面，你只需要：</p><ol><li><p><code>hexo n page xxxxx</code> 创建你的页面。</p></li><li><p>在 <code>index.md</code> 使用标签外挂 <code>galleryGroup</code>。</p></li></ol><h2 id="gallerygroup-模板"><a class="markdownIt-Anchor" href="#gallerygroup-模板"></a> <code>galleryGroup</code> 模板</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p>name：图库名字</p></li><li><p>description：图库描述</p></li><li><p>link：连接到对应相册的地址</p></li><li><p>img-url：图库封面的地址</p></li></ul><h2 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span><br><span class="line">&#123;% galleryGroup &#x27;封面图&#x27; &#x27;已发布文章的封面图&#x27; &#x27;/gallery/wallpaper&#x27; images/389.jpg %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/389.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">封面图</div>  <p>已发布文章的封面图</p>  <a href='/gallery/wallpaper'></a>  </figcaption>  </figure>  </div><hr /><h1 id="gallery-相册子页面"><a class="markdownIt-Anchor" href="#gallery-相册子页面"></a> <code>Gallery</code> 相册子页面</h1><p>子页面也是普通的页面，你只需要：</p><ol><li><code>hexo n page xxxxx</code> 创建你的页面。</li><li>然后使用标签外挂 <code>gallery</code>。</li></ol><h2 id="gallery-模板"><a class="markdownIt-Anchor" href="#gallery-模板"></a> <code>gallery</code> 模板</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>markdown 图片格式： <code>![]()</code> 或者 <code>&lt;img src = &quot;&quot;&gt;</code> 的格式皆可。</li></ul><h2 id="示例-2"><a class="markdownIt-Anchor" href="#示例-2"></a> 示例</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](images/389.jpg)</span><br><span class="line">![](images/166.jpg)</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/250.jpg&quot;</span>&gt;</span></span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><div class="fj-gallery"><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/389.jpg" alt="" /></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/166.jpg" alt="" /></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/250.jpg">          </div><hr /><h1 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h1><p>如果你想要使用 <code>/gallery/wallpaper</code> 这样的链接显示你的图片内容。你可以把创建好的 <code>wallpaper</code> 整个文件夹移到 <code>gallery</code> 文件夹里中。</p>]]></content>
    
    
    <summary type="html">记录一下在 Hexo Butterfly 中相册的添加方法。</summary>
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Lambda 表达式</title>
    <link href="https://luoyu-ying.github.io/posts/0ca5222da5ff/"/>
    <id>https://luoyu-ying.github.io/posts/0ca5222da5ff/</id>
    <published>2022-07-10T03:19:09.000Z</published>
    <updated>2022-07-10T03:19:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li>《第一行代码 Android 第3版》</li><li><a href="https://time.geekbang.org/course/intro/100009801">快速上手 Kotlin 开发 (geekbang.org)</a></li><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li></ul></blockquote><hr /><h1 id="lambda-定义"><a class="markdownIt-Anchor" href="#lambda-定义"></a> <code>Lambda</code> 定义</h1><p><code>Lambda</code> 就是一小段可以作为参数传递的代码，也可以认为是函数的简写形式。</p><hr /><h1 id="lambda-表达式的语法结构"><a class="markdownIt-Anchor" href="#lambda-表达式的语法结构"></a> <code>Lambda</code> 表达式的语法结构</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;参数名<span class="number">1</span>: 参数类型, 参数名<span class="number">2</span>: 参数类型, ..., 参数名n: 参数类型 -&gt; 函数体&#125;</span><br></pre></td></tr></table></figure><p>这是 <code>Lambda</code> 表达式最完整的语法结构定义。</p><p>首先最外层是一对大括号，如果有参数传入到 <code>Lambda</code> 表达式中的话，我们还需要声明参数列表，参数列表的结尾使用一个 <code>-&gt;</code> 符号，表示参数列表的结束以及函数体的开始。</p><p>函数体中可以编写任意行代码（虽然不建议编写太长的代码)，<strong>并且最后一行代码会自动作为 <code>Lambda</code> 表达式的返回值</strong>，即 <code>return 最后一行代码</code>。</p><p>所以我们也可以用变量获取 <code>Lambda</code> 表达式的结果，即 <code>val result = &#123;... -&gt; ...&#125;</code> 。</p><hr /><h1 id="lambda-表达式的特点"><a class="markdownIt-Anchor" href="#lambda-表达式的特点"></a> <code>Lambda</code> 表达式的特点</h1><ol><li>最后一行代码会自动作为 <code>Lambda</code> 表达式的返回值（隐式 <code>return</code>）。</li><li>如果 <code>Lambda</code> 没有参数，那么可以省略箭头符号 <code>-&gt;</code>。</li><li>如果 <code>Lambda</code> 是函数的最后一个参数，那么可以将大括号放在小括号的外面。</li><li>如果函数只有一个参数并且这个参数就是 <code>Lambda</code> ，则可以省略小括号。</li></ol><hr /><h1 id="sam-转换"><a class="markdownIt-Anchor" href="#sam-转换"></a> <code>SAM</code> 转换</h1><blockquote><p>当一个函数的参数是 SAM 的情况下，我们同样也可以使用 Lambda 作为参数。</p><p>通过 SAM 转换，我们就可以在 Kotlin 中便携的编写如 setOnClickListener 之类的方法了。</p></blockquote><p><code>SAM</code> 是 Single Abstract Method 的缩写，意思就是只有一个抽象方法的类或者接口。但在 Kotlin 和 Java 8 里，<strong>SAM 代表着只有一个抽象方法的接口</strong>。只要是符合 SAM 要求的接口，编译器就能进行 SAM 转换，也就是我们可以使用 Lambda 表达式，来简写接口类的参数。</p><p>注意，Java 8 中的 SAM 有明确的名称，叫做函数式接口（FunctionalInterface）。FunctionalInterface 的限制如下，缺一不可：</p><ol><li>必须是接口，抽象类不行；</li><li>该接口有且仅有一个抽象的方法，抽象方法个数必须是 1，默认实现的方法可以有多个。</li></ol><p>也就是说，对于 View.java 来说，它虽然是 Java 代码，但 Kotlin 编译器知道它的参数 OnClickListener 符合 SAM 转换的条件，所以会自动做以下转换。</p><p>转换前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnClickListener</span><span class="params">(OnClickListener l)</span></span><br></pre></td></tr></table></figure><p>转换后：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(l: (<span class="type">View</span>) -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="comment">// 实际上是这样：</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(l: ((<span class="type">View</span>!) -&gt; <span class="type">Unit</span>)?)</span></span></span><br></pre></td></tr></table></figure><p>其中，((View!) -&gt; Unit)? 代表的是这个参数可能为空。</p><hr /><h1 id="lambda-表达式的写法"><a class="markdownIt-Anchor" href="#lambda-表达式的写法"></a> <code>Lambda</code> 表达式的写法</h1><p>当一个函数的参数是 <code>SAM</code> 的情况下，我们同样也可以使用 <code>Lambda</code> 作为参数。所以，我们既可以用匿名内部类的方式传参，也可以使用 <code>Lambda</code> 的方式传参。</p><p>从匿名内部类的写法到 <code>Lambda</code> 表达式最终的精简形式，在这两种写法的中间，还有 6 种“过渡状态”的写法。</p><p>下面将从匿名内部类的写法开始，一步步的过渡到 <code>Lambda</code> 的写法。</p><p><strong><font size="4">第 1 种写法</font></strong></p><p>这是原始代码，它的本质是用 <code>object</code> 关键字定义了一个匿名内部类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(<span class="keyword">object</span>: View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        gotoPreview(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 2 种写法</font></strong></p><p>在这种情况下，<code>object</code> 关键字可以被省略。这时候它在语法层面就不再是匿名内部类了，它更像是 <code>Lambda</code> 表达式了，因此它里面 <code>override</code> 的方法也要跟着删掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(View.OnClickListener &#123; v: View? -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的 <code>View.OnClickListener</code> 被称为 <code>SAM Constructor</code>（SAM 构造器），它是编译器为我们生成的。</p><p>这段代码明显简化了很多，既可以实现同样的功能，又不会造成任何歧义。因为 <code>View.OnClickListener</code> 中只有一个待实现方法,即使这里没有显式地重写 onClick() 方法，<code>Kotlin</code> 也能自动明白 <code>View.OnClickListener</code> 后面的 <code>Lambda</code> 表达式就是要在 <code>onClick()</code> 方法中实现的内容。</p><p><strong><font size="4">第 3 种写法</font></strong></p><p>如果一个 <code>Java</code> 方法的参数列表中不存在一个以上 <code>Java</code> 单抽象方法接口参数，我们还可以将接口名进行省略（且<code>Kotlin</code> 的 <code>Lambda</code> 表达式是不需要 <code>SAM Constructor</code> 的），所以它也可以被删掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123; v: View? -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 4 种写法</font></strong></p><p>由于 <code>Kotlin</code> 支持类型推导，所以 <code>View</code> 可以被删掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123; v -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 5 种写法</font></strong></p><p>当 <code>Kotlin</code> <code>Lambda</code> 表达式只有一个参数的时候，它可以被写成 <code>it</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123; it -&gt;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 6 种写法</font></strong></p><p><code>Kotlin</code> <code>Lambda</code> 的 <code>it</code> 是可以被省略的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 7 种写法</font></strong></p><p>当 <code>Kotlin</code> <code>Lambda</code> 作为函数的最后一个参数时，<code>Lambda</code> 可以被挪到外面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener() &#123;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 8 种写法</font></strong></p><p>当 <code>Kotlin</code> 只有一个 <code>Lambda</code> 作为函数参数时，<code>()</code> 可以被省略：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener &#123;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，将这 8 种写法的演进过程以动图的形式展现了出来，让你对 <code>Lambda</code> 这几种写法的差异有一个更加直观的认识。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/e441323968c0c061898257fd06db37bf.gif" alt="img" style="zoom: 50%;" />]]></content>
    
    
    <summary type="html">学习并整理了 Kotlin 中 Lambda 表达式的使用方法。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 函数嵌套</title>
    <link href="https://luoyu-ying.github.io/posts/47063eb1b5ed/"/>
    <id>https://luoyu-ying.github.io/posts/47063eb1b5ed/</id>
    <published>2022-07-09T15:24:11.000Z</published>
    <updated>2022-07-09T15:24:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li><li><a href="https://www.cnblogs.com/Anker/archive/2013/03/04/2943498.html">递归与尾递归总结 - Rabbit_Dale - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/zsp765098084/article/details/90901260">kotlin学习笔记之尾递归优化（tailrec）_mictoy_朱的博客-CSDN博客_kotlin tailrec</a></li></ul></blockquote><hr /><h1 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h1><p>在 <code>Kotlin</code> 中，我们可以在函数的代码块中创建另一个新的函数并使用该函数。并且该函数可以使用外部函数的变量。</p><p>如下方的代码；</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">outerMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算 1 + 2 + 3 + ...</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">innerMethod</span><span class="params">(c: <span class="type">Int</span> = <span class="number">10</span>)</span></span> &#123;</span><br><span class="line">        sum += c</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span>)</span><br><span class="line">        innerMethod(c - <span class="number">1</span>)</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    innerMethod()</span><br><span class="line">  println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    outerMethod()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h1><p>函数嵌套在工程中应尽量少的使用，容易造成代码可读性的降低。</p><p>但是在两种情况下可以创建内部函数：</p><ol><li>在某些情况下需要临时使用 <strong>递归</strong> 函数，如上文中的代码。</li><li>不希望被外部函数访问到的函数。</li></ol><hr /><h1 id="尾递归"><a class="markdownIt-Anchor" href="#尾递归"></a> 尾递归</h1><p>实际上，在函数式编程当中，我们有时候也会使用递归来替代循环。</p><p>我们知道，递归都是有调用栈开销的，所以我们应该尽量使用 <strong>尾递归</strong>。对于这种类型的递归，在经过栈复用优化以后，它的开销就可以忽略不计了，我们可以认为它的空间复杂度是 O(1)。</p><blockquote><p>尾递归就是从最后开始计算，每递归一次就算出相应的结果，也就是说, 函数调用出现在调用者函数的尾部，因为是尾部，所以根本没有必要去保存任何局部变量，直接让被调用的函数返回时越过调用者，返回到调用者的调用者去。</p><p><strong>尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数</strong>，深层函数所面对的不是越来越简单的问题，而是越来越复杂的问题，因为参数里带有前面若干步的运算路径。</p><p>尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。</p></blockquote><h2 id="尾递归的特点"><a class="markdownIt-Anchor" href="#尾递归的特点"></a> 尾递归的特点</h2><ul><li>递归的一种特殊形式</li><li>调用自身后无其他操作</li><li><code>tailrec</code> 关键字提示编译器尾递归优化</li></ul><p>示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>(<span class="keyword">val</span> value:<span class="built_in">Int</span>,<span class="keyword">var</span> next:ListNode? = <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findListNode</span><span class="params">(head:<span class="type">ListNode</span>?,value:<span class="type">Int</span>)</span></span>:ListNode?&#123; <span class="comment">//定义一个递归函数</span></span><br><span class="line">    head?:<span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (head.value == value) <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">return</span> findListNode(head.next,value)    <span class="comment">//return除了调用自己，没有多余的操作，所以是尾递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾递归优化的使用"><a class="markdownIt-Anchor" href="#尾递归优化的使用"></a> 尾递归优化的使用</h2><p>在 <code>Kotlin</code> 语言中，我们即使写出了符合尾递归的递归函数，编译器也不会自动帮我们进行优化。</p><p>我们需要在 <code>fun</code> 关键字前面加上 <code>tailrec</code> 关键字以表示我们需要进行尾递归优化。</p><p>示例代码1：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>(<span class="keyword">val</span> value:<span class="built_in">Int</span>,<span class="keyword">var</span> next:ListNode? = <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">findListNode</span><span class="params">(head:<span class="type">ListNode</span>?,value:<span class="type">Int</span>)</span></span>:ListNode?&#123; <span class="comment">//定义一个递归函数</span></span><br><span class="line">    head?:<span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (head.value == value) <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">return</span> findListNode(head.next,value)    <span class="comment">//return除了调用自己，没有多余的操作，所以是尾递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码2：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">recursionLoop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="comment">// 变化在这里</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line">    <span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">go</span><span class="params">(i: <span class="type">Int</span>, sum: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">10</span>) sum <span class="keyword">else</span> go(i + <span class="number">1</span>, sum + i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> go(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾递归优化实质"><a class="markdownIt-Anchor" href="#尾递归优化实质"></a> 尾递归优化实质</h2><p>通过对上文中的 <code>findListNode</code> 方法对 <strong>加了 <code>tailrec</code> 关键字</strong> 与 <strong>去除 <code>tailrec</code> 关键字</strong> 的两份代码分别进行反编译，我们发现：</p><ul><li><p>没有优化的 <code>findListNode</code> 对应的 <code>Java</code> 代码依然是递归函数，并且递归运行次数较大时出现了 <code>StackOverflowError</code> 错误；</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135701617.png" alt="img" style="zoom: 90%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135611929.png" alt="img" style="zoom:87%;" /></li><li><p>优化后（即添加了 <code>tailrec</code> 关键字）的 <code>findListNode</code> 方法对应的 <code>Java</code> 代码已经不再是递归函数，而是通过循环来实现功能，这样就不会再出现 <code>stackoverflowerror</code> 了。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135710491.png" alt="img" style="zoom:90%;" /></li></ul><p>这样我们就在 <code>Kotlin</code> 中既实现了递归函数代码简洁的优势，又规避了在 <code>Java</code> 中使用递归函数容易出出现的问题。</p>]]></content>
    
    
    <summary type="html">学习了 Kotlin 中函数嵌套的使用方法。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 空指针检查</title>
    <link href="https://luoyu-ying.github.io/posts/4c7d77851d24/"/>
    <id>https://luoyu-ying.github.io/posts/4c7d77851d24/</id>
    <published>2022-07-09T11:32:31.000Z</published>
    <updated>2022-07-09T11:32:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li>《第一行代码 Android 第3版》</li></ul></blockquote><hr /><h1 id="可空类型系统"><a class="markdownIt-Anchor" href="#可空类型系统"></a> 可空类型系统</h1><p>因为 <code>Kotlin</code> 默认所有的参数和变量都不可为空，所以我们直接使用定义任何变量和参数并使用的话，是没有任何的空指针风险的。</p><p>例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>)</span></span> &#123;</span><br><span class="line">    study.readBooks()</span><br><span class="line">    study.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码是没有空指针异常的，如果我们尝试向 <code>doStudy</code> 函数中传递 <code>null</code> 参数，便会直接提示错误：<code>Null can not be a value of a non-null type Study</code>。</p><p>也就是说，<code>Kotlin</code> 将空指针异常的检查提前到了编译时期，如果我们的程序存在空指针异常的风险，那么在编译的时候会直接报错，修正之后才能成功运行，这样就可以保证程序在运行时期不会出现空指针异常了。</p><p>那么如何使得这些类型变为可为空的类型系统呢？</p><p><strong>很简单，就是在类名的后面加上一个问号。</strong></p><p>比如说，<code>Int</code> 表示不可为空的整形，而 <code>Int?</code> 则表示可为空的整形；<code>String</code> 表示不可为空的字符串，而 <code>String?</code> 就表示可以为空的字符串。</p><p>当我们希望上述的代码可以传入 <code>null</code> 参数，那么我们就需要将 <code>Study</code> 改成 <code>Study?</code> ，如下文所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    study.readBooks()</span><br><span class="line">    study.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上述的代码仍然有些许错误，即使我们能够正常的传入 <code>null</code> 参数，但是 <code>null</code> 是无法调用 <code>readBooks()</code> 以及 <code>doHomework()</code> 函数的。所以我们仍需要对 <code>study</code> 进行进一步的判断：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (study != <span class="literal">null</span>) &#123;</span><br><span class="line">        study.readBooks()</span><br><span class="line">        study.doHomework()    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样的写法，我们可能会在代码中写入大量的 <code>if</code> 语句仅仅只是为了判断变量或者参数是否为空，这样会让代码变得比较啰嗦。为此，<code>Kotlin</code> 专门提供了一系列的辅助工具，方便我们更加轻松以及快速地进行判空处理。</p><hr /><h1 id="判空辅助工具"><a class="markdownIt-Anchor" href="#判空辅助工具"></a> 判空辅助工具</h1><h2 id="操作符"><a class="markdownIt-Anchor" href="#操作符"></a> <code>?.</code> 操作符</h2><p><code>?.</code> 操作符的作用就是当对象不为空的时候正常调用相应的函数，当对象为空时则什么都不做。</p><p>如下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">    a.doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 <code>?.</code> 操作符，我们便可以将其简化成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a?.doSomething()</span><br></pre></td></tr></table></figure><p>现在我们便可以对上文中的代码进行优化了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    study?.readBooks()</span><br><span class="line">    study?.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作符-2"><a class="markdownIt-Anchor" href="#操作符-2"></a> <code>?:</code> 操作符</h2><p><code>?:</code> 操作符的左右两边都接受一个表达式，如果左边表达式的结果不为空就返回左边表达式的结果，否则就返回右边表达式的结果。</p><p>如下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = <span class="keyword">if</span> (a != <span class="literal">null</span>) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><p>便可以简化成为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = a ?: b</span><br></pre></td></tr></table></figure><h2 id="操作符-3"><a class="markdownIt-Anchor" href="#操作符-3"></a> <code>!!.</code> 操作符</h2><p>如果我们想要一遍变量在使用的过程中不进行空指针检查，并在遇到空指针的时候主动的抛出空指针异常（有的时候我们可能从逻辑上已经将空指针异常处理了，但是 <code>Kotlin</code> 的编译器并不知道，这个时候它还是会编译失败），那么我们可以通过使用 <code>!!.</code> 操作符（非空断言工具）强行通过编译。写法是在对象的后面加上 <code>!!.</code>。</p><p>例如以下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg: String? = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">        printUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printUpperCase</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> upperCase = msg!!.toUpperCase()</span><br><span class="line">    println(upperCase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上文中，<code>printUpperCase</code> 函数的调用一定发生在 <code>msg</code> 不为空的情况，所以我们可以使用非空断言工具让其不进行空指针判断。</p><p>这是一种有风险的写法，意在告诉 <code>Kotlin</code>，我非常确信这里的对象不会为空，所以不用你来帮我做空指针检查了，如果出现问题，你可以直接抛出空指针异常，后果由我自己承担。</p><p>虽然这样编写代码确实可以通过编译，但是当你想要使用非空断言工具的时候，最好提醒一下自己，是不是还有更好的实现方式。</p><p><strong>你最自信这个对象不会为空的时候，其实可能就是一个潜在空指针异常发生的时候。</strong></p><hr /><h1 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h1><p>标准函数中 <code>let</code> 函数是可以处理全局变量的判空问题的，而 <code>if</code> 语句则无法做到这一点。</p><p>比如我们将 <code>doStudy()</code> 中的参数变成一个全局变量，使用 <code>let</code> 函数仍然可以正常工作，但是使用 <code>if</code> 语句则会提示错误：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220709203415002.png" alt="image" style="zoom:80%;" /><p>之所以这里会报错，是因为全局变量的值随时都有可能被其他线程所修改，即使做了判空处理，仍然无法保证 <code>if</code> 语句中的<code>study</code> 变量没有空指针风险。从这一点上也能体现出 <code>let</code> 函数的优势。</p>]]></content>
    
    
    <summary type="html">学习了 Kotlin 中空指针相关的运算符。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 扩展函数与扩展属性</title>
    <link href="https://luoyu-ying.github.io/posts/ffb71c4ce53a/"/>
    <id>https://luoyu-ying.github.io/posts/ffb71c4ce53a/</id>
    <published>2022-07-09T04:22:03.000Z</published>
    <updated>2022-07-09T04:22:03.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li></ul></blockquote><hr /><p><code>Kotlin</code> 的扩展（<code>Extension</code>），主要分为两种语法：第一个是扩展函数，第二个是扩展属性。从语法上看，扩展看起来就像是我们从类的外部为它扩展了新的成员。</p><p>这在实际编程当中是非常有用的功能。我们可以来想象一个场景：我们想修改 <code>JDK</code> 当中的 <code>String</code>，想在它的基础上增加一个方法 <code>lastElement()</code> 来获取末尾元素，如果使用 <code>Java</code>，我们是无法通过常规手段实现的，因为我们没办法修改 <code>JDK</code> 的源代码。<strong>任何第三方提供的 <code>SDK</code>，我们都无权修改。</strong></p><p>不过，借助 <code>Kotlin</code> 的扩展函数，我们就完全可以在语义层面，来为第三方 <code>SDK</code> 的类扩展新的成员方法和成员属性。不管是为 <code>JDK</code> 的 <code>String</code> 增加新的成员方法，还是为 <code>Android SDK</code> 的 <code>View</code> 增加新成员属性，我们都可以实现。</p><hr /><h1 id="扩展函数"><a class="markdownIt-Anchor" href="#扩展函数"></a> 扩展函数</h1><p>扩展函数，就是从类的外部扩展出来的一个函数，这个函数看起来就像是类的成员函数一样。这里，我们就以 <code>JDK</code> 当中的 <code>String</code> 为例，来看看如何通过 <code>Kotlin</code> 的扩展特性，为它新增一个 <code>lastElement()</code> 方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ext.kt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> ①    ②       ③           ④</span></span><br><span class="line"><span class="comment"> ↓     ↓       ↓            ↓      */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;</span><br><span class="line">    <span class="comment">//    ⑤</span></span><br><span class="line">    <span class="comment">//    ↓</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用扩展函数</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> msg = <span class="string">&quot;Hello Wolrd&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// lastElement就像String的成员方法一样可以直接调用</span></span><br><span class="line">    <span class="keyword">val</span> last = msg.lastElement() <span class="comment">// last = d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先是定义了一个 <code>String</code> 的扩展函数 <code>lastElement()</code> ，然后在 <code>main</code> 函数当中调用了这个函数。并且，这个扩展函数是直接定义在 <code>Kotlin</code> 文件里的，而不是定义在某个类当中的。这种扩展函数，我们称之为**“顶层扩展”**，这么叫它是因为它并没有嵌套在任何的类当中，它自身就在最外层。</p><p>现在，我们依次来看看上面的五处注释：</p><ol><li><p>注释①，<code>fun</code> 关键字</p><p>代表我们要定义一个函数。也就是说，不管是定义普通 <code>Kotlin</code> 函数，还是定义扩展函数，我们都需要 <code>fun</code> 关键字。</p></li><li><p>注释②，“<code>String.</code>”</p><p>代表我们的扩展函数是为 <code>String</code> 这个类定义的。在 <code>Kotlin</code> 当中，它有一个名字，叫做接收者（<code>Receiver</code>），也就是扩展函数的接收方。</p></li><li><p>注释③，<code>lastElement()</code></p><p>是我们定义的扩展函数的名称。</p></li><li><p>注释④，“<code>Char?</code>”</p><p>代表扩展函数的返回值是可能为空的 <code>Char</code> 类型。</p></li><li><p>注释⑤，“<code>this.</code>”</p><p>代表“具体的 <code>String</code> 对象”，当我们调用 <code>msg.lastElement()</code> 的时候，<code>this</code> 就代表了 <code>msg</code>。</p></li></ol><p>需要注意的是，<strong>在整个扩展函数的方法体当中，<code>this</code> 都是可以省略的</strong>。这一点，<code>Kotlin</code> 和 <code>Java</code> 是一样的，<code>this</code> 代表当前作用域，它可写可不写。即例如以下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span> : <span class="built_in">Char</span>? = <span class="keyword">if</span> (isEmpty()) <span class="literal">null</span> <span class="keyword">else</span> <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> str = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">    println(str.lastElement())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，<code>Kotlin</code> 的扩展是允许我们为“<strong>可为空的类型</strong>”进行扩展的。比如说：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不为空的接收者类型</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可为空的接收者类型</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String?.<span class="title">lastElement</span><span class="params">()</span></span>: <span class="built_in">Char</span>? &#123;&#125;</span><br></pre></td></tr></table></figure><p>接受者可空的扩展在遇到空对象调用时不会抛异常，并且允许可空对象调用。</p><hr /><h1 id="扩展属性"><a class="markdownIt-Anchor" href="#扩展属性"></a> 扩展属性</h1><p>在学习了 <code>Kotlin</code> 的扩展函数以后，扩展属性就很好理解了。</p><p>扩展函数，是在类的外部为它定义一个<strong>新的成员方法</strong>；而扩展属性，则是在类的外部为它定义一个<strong>新的成员属性</strong>。</p><p>那么，在研究了扩展的实现原理后，我们知道，我们从外部定义的成员方法和属性，都只是语法层面的，并没有实际修改那个类的源代码。</p><p>还是以 <code>lastElement</code> 为例，在之前的案例当中，我们是通过扩展函数来实现的，这次我们以扩展属性的方式来实现。扩展函数的定义对比普通函数，其实就只是多了一个“接收者类型”。类似的，扩展属性，也就是在普通属性定义的时候多加一个“接收者类型”即可。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收者类型</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line"><span class="keyword">val</span> String.lastElement: <span class="built_in">Char</span>?</span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 this 关键字也可以写成：</span></span><br><span class="line"><span class="comment">val String.lastElement : Char?</span></span><br><span class="line"><span class="comment">    get() = if (isEmpty()) null else this[length - 1]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> msg = <span class="string">&quot;Hello Wolrd&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// lastElement就像String的成员属性一样可以直接调用</span></span><br><span class="line">    <span class="keyword">val</span> last = msg.lastElement <span class="comment">// last = d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段的代码中，我们为 String 类型扩展了一个新的成员属性“<code>lastElement</code>”。然后在 <code>main</code> 函数当中，我们直接通过“<code>msg.lastElement</code>”方式使用了这个扩展属性，就好像它是一个成员一样。</p><hr /><h1 id="扩展与其反编译代码"><a class="markdownIt-Anchor" href="#扩展与其反编译代码"></a> 扩展与其反编译代码</h1><p>为了看得更加清晰，我们用一张图来描述它们之间的关系。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/2a38487b61ec06e437c1425b2a69ffed.png" alt="img" /></p><p>上面的两个箭头，说明了扩展函数与扩展属性，它们最终会被 <code>Kotlin</code> 编译器转换成静态方法；下面两个箭头，说明了扩展函数和扩展属性的调用代码，最终会被 <code>Kotlin</code> 编译器转换成静态方法的调用。</p><p>所以也就是说，<code>Kotlin</code> 的扩展表面上看起来是为一个类扩展了新的成员，<strong>但是本质上，它还是静态方法</strong>。而且，不管是扩展函数还是扩展属性，它本质上都会变成一个静态的方法。</p><p><strong>那么，到底什么时候该用扩展函数，什么时候该用扩展属性呢？</strong></p><p>其实，我们只需要看扩展在语义上更适合作为函数还是属性就够了。比如这里的 <code>lastElement</code>，它更适合作为一个扩展属性。这样设计的话，在语义上，<code>lastElement</code> 就像是 <code>String</code> 类当中的属性一样，它代表了字符串里的最后一个字符。</p><hr /><h1 id="扩展的优势与局限性"><a class="markdownIt-Anchor" href="#扩展的优势与局限性"></a> 扩展的优势与局限性</h1><h2 id="扩展的优势"><a class="markdownIt-Anchor" href="#扩展的优势"></a> 扩展的优势</h2><p>当我们想要从外部为一个类扩展一些方法和属性的时候，我们就可以通过扩展来实现了。<strong>在 <code>Kotlin</code> 当中，几乎所有的类都可以被扩展</strong>，包括普通类、单例类、密封类、枚举类、伴生对象，甚至还包括第三方提供的 <code>Java</code> 类。</p><p>唯有匿名内部类，由于它本身不存在名称，我们无法指定“接收者类型”，所以不能被扩展，当然了，它也没必要被扩展。</p><p>可以说，<code>Kotlin</code> 扩展的应用范围还是非常广的。它最主要的用途，就是用来取代 <code>Java</code> 当中的各种工具类，比如 <code>StringUtils</code>、<code>DateUtils</code> 等等。</p><p>所有 <code>Java</code> 工具类能做的事情，<code>Kotlin</code> 扩展函数都可以做，并且可以做得更好。扩展函数的优势在于，开发工具可以在编写代码的时候智能提示。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/239e540b768560c6cd119b1bb9e1eb9c.gif" alt="img" style="zoom: 40%;" /><h2 id="扩展的局限性"><a class="markdownIt-Anchor" href="#扩展的局限性"></a> 扩展的局限性</h2><p><code>Kotlin</code> 的扩展，由于它本质上并没有修改接收类型的源代码，所以它的行为是无法与“类成员”完全一致的。那么它对比普通的类成员，就会有以下几个限制。</p><p><strong>第一个限制，<code>Kotlin</code> 扩展不是真正的类成员，因此它无法被它的子类重写。</strong></p><p>举个例子，我们定义一个这样的 <code>Person</code> 类，并且分别为它扩展了一个 <code>isAdult</code> 属性和 <code>walk()</code> 方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: String = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> Person.isAdult: <span class="built_in">Boolean</span></span><br><span class="line">    <span class="keyword">get</span>() = age &gt;= <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Person.<span class="title">walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;walk&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>Person</code> 类有 <code>open</code> 关键字修饰，所以我们可以继承这个 <code>Person</code> 类。</p><p>不过，当我们尝试去重写它的成员时，会发现 <code>isAdult</code> 和 <code>walk()</code> 是无法被重写的，因为它们压根就不属于 <code>Person</code> 这个类。</p><p><strong>第二个限制，扩展属性无法存储状态。</strong></p><p>就如前面代码当中的 <code>isAdult</code> 属性一般，它的值是由 <code>age</code> 这个成员属性决定的，它本身没有状态，也无法存储状态。背后的根本原因，还是因为它们都是静态方法。</p><p><strong>第三个限制，扩展的<em>访问作用域</em>仅限于两个地方。</strong></p><ol><li><p>如果扩展是顶层的扩展。</p><p>那么扩展的访问域仅限于该 <code>Kotlin</code> 文件当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展是可以被全局使用的。</p></li><li><p>如果扩展是被定义在某个类当中的。</p><p>那么该扩展的访问域仅限于该类当中的所有成员，以及被扩展类型的公开成员，这种方式定义的扩展仅能在该类当中使用。</p></li></ol><hr /><h1 id="扩展的使用场景"><a class="markdownIt-Anchor" href="#扩展的使用场景"></a> 扩展的使用场景</h1><p><strong><code>Kotlin</code> 扩展的第一个典型使用场景：关注点分离。主动使用扩展，通过它来优化软件架构。</strong></p><p>所谓关注点分离，就是将我们程序的逻辑划分成不同的部分，每一个部分，都只关注自己那部分的职责。以 <code>Kotlin</code> 源码中的 <code>String</code> 类为例，<code>String.kt</code> 这个类，只关注 <code>String</code> 的核心逻辑；而 <code>Strings.kt</code> 则只关注 <code>String</code> 的操作符逻辑。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String.kt (一共只有13行代码)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> : <span class="type">Comparable</span>&lt;<span class="type">String</span>&gt;, <span class="type">CharSequence &#123;</span></span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">plus</span><span class="params">(other: <span class="type">Any</span>?)</span></span>: String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">val</span> length: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">(index: <span class="type">Int</span>)</span></span>: <span class="built_in">Char</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">subSequence</span><span class="params">(startIndex: <span class="type">Int</span>, endIndex: <span class="type">Int</span>)</span></span>: CharSequence</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">compareTo</span><span class="params">(other: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Strings.kt 部分代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> CharSequence.<span class="title">trim</span><span class="params">()</span></span>: CharSequence = trim(<span class="built_in">Char</span>::isWhitespace)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">expect</span> <span class="function"><span class="keyword">fun</span> String.<span class="title">lowercase</span><span class="params">()</span></span>: String</span><br></pre></td></tr></table></figure><p><strong>扩展的第二个核心使用场景：被动使用扩展，提升可读性与开发效率。</strong></p><p>当我们无法修改外部的 <code>SDK</code> 时，对于重复的代码模式，我们将其以扩展的方式封装起来，提供给对应的接收者类型。</p><hr /><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><ol><li><code>Kotlin</code> 的扩展，从 <strong>语法角度</strong> 来看，分为扩展函数和扩展属性。定义扩展的方式，只是比普通函数、属性多了一个“扩展接收者”而已。</li><li>从 <strong>作用域</strong> 角度来看，分为顶层扩展和类内扩展。</li><li>从 <strong>本质</strong> 上来看，扩展函数和扩展属性，它们都是 <code>Java</code> 静态方法，与 <code>Java</code> 当中的工具类别无二致。对比 <code>Java</code> 工具类，扩展最大的优势就在于，<code>IDE</code> 可以为我们提供代码补全功能。</li><li>从 <strong>能力</strong> 的角度来看，<code>Kotlin</code> 扩展一共有三个限制，分别是：扩展无法被重写；扩展属性无法存储状态；扩展的作用域有限，无法访问私有成员。</li><li>从 <strong>使用场景</strong> 的角度来看，<code>Kotlin</code> 扩展主要有两个使用场景，分别是：关注点分离，优化代码架构；消灭模板代码，提高可读性和开发效率。</li></ol><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/b4a3ce7c3e0b2228161faa4769618a10.jpg" alt="img" /></p>]]></content>
    
    
    <summary type="html">学习了 Kotlin 中扩展函数与扩展属性的使用方式。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 类的创建与继承</title>
    <link href="https://luoyu-ying.github.io/posts/8aab3d7fde77/"/>
    <id>https://luoyu-ying.github.io/posts/8aab3d7fde77/</id>
    <published>2022-07-08T04:41:57.000Z</published>
    <updated>2022-07-08T04:41:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Kotlin</code> 官方在线编程网址：</p><ul><li><a href="https://play.kotlinlang.org/">https://play.kotlinlang.org/</a></li></ul></blockquote><hr /><blockquote><p>本文参考自：</p><ul><li>《第一行代码  Android 第3版》</li><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li><li><a href="https://blog.csdn.net/c1392851600/article/details/80990570">Kotlin之类的继承及属性和方法的重写_c1392851600的博客-CSDN博客</a></li></ul></blockquote><hr /><h1 id="基本写法"><a class="markdownIt-Anchor" href="#基本写法"></a> 基本写法</h1><h2 id="创建"><a class="markdownIt-Anchor" href="#创建"></a> 创建</h2><p>通过 <code>class</code> 关键字创建一个类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is eating.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化方式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> person = Person()</span><br></pre></td></tr></table></figure><h2 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h2><p><strong>默认所有非抽象类都是不可以被继承的</strong>。</p><p>如果需要将其变为父类，则需要在 <code>class</code> 前使用 <code>open</code> 关键字。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is eating.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要继承另一个类，则使用 <code>:</code> 符号：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person</span></span>() &#123;</span><br><span class="line">    <span class="keyword">var</span> grade = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重写"><a class="markdownIt-Anchor" href="#重写"></a> 重写</h2><h3 id="重写父类的方法"><a class="markdownIt-Anchor" href="#重写父类的方法"></a> 重写父类的方法</h3><p>需要注意的是如果父类的方法没有 <code>open</code> 声明，那么该方法是不允许被重写的。重写方法的时候需要使用 <code>override</code> 关键字注明。还有一点就是子类可以选择不重写父类的方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">shout</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;汪汪&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;萌萌哒&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Husky</span> : <span class="type">Dog</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 由于父类的shout方法没有写open, 也就是默认是final的, 所以这里不能重写shout方法</span></span><br><span class="line">    <span class="comment">// Error:(15, 5) Kotlin: &#x27;shout&#x27; in &#x27;Dog&#x27; is final and cannot be overridden  不能重写shout因为默认是final的</span></span><br><span class="line">    <span class="comment">/* override fun shout() &#123;</span></span><br><span class="line"><span class="comment">        println(&quot;玩明汪&quot;)</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重写父类方法的时候要加上override关键字, show方法也可以选择不进行重写</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;喵喵&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> husky =  Husky()</span><br><span class="line">    husky.shout()</span><br><span class="line">    husky.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次需要注意的是，如果一个类集成了多个类/接口，并且父类/接口中有相同名字的方法需要重写的时候，那么子类这时候必须重写该方法，并且如果子类想区分开父类的方法的时候，可以使用 <code>super</code> 关键字调用不同父类的方法。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">shout</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;汪汪&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;萌萌哒&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">WatchDog</span> </span>&#123;</span><br><span class="line">    <span class="comment">// interface里不用写open, 因为默认就是open的</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;看门电子狗&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用接口的时候不用写(), 是因为接口是没有构造函数的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Husky</span> : <span class="type">Dog</span></span>(), WatchDog &#123;</span><br><span class="line">    <span class="comment">// 由于父类的shout方法没有写open, 也就是默认是final的, 所以这里不能重写父类的方法</span></span><br><span class="line">    <span class="comment">// Error:(15, 5) Kotlin: &#x27;shout&#x27; in &#x27;Dog&#x27; is final and cannot be overridden  不能重写shout因为默认是final的</span></span><br><span class="line">    <span class="comment">/*override fun shout() &#123;</span></span><br><span class="line"><span class="comment">        println(&quot;玩明汪&quot;)</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 重写父类方法的时候要加上override关键字</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">show</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// 当重写的方法在父类中有多个实现的时候, 如果继承的多个类中, 有相同的方法需要重写的时候, 则子类必须重写该方法, 并且, 为了区分, 可以使用super关键字来调用不同的父类中的方法</span></span><br><span class="line">        <span class="keyword">super</span>&lt;WatchDog&gt;.show()  <span class="comment">// 看萌电子狗</span></span><br><span class="line">        <span class="keyword">super</span>&lt;Dog&gt;.show() <span class="comment">// 萌萌哒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> husky =  Husky()</span><br><span class="line">    husky.shout()   <span class="comment">// 汪汪</span></span><br><span class="line">    husky.show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写父类的变量"><a class="markdownIt-Anchor" href="#重写父类的变量"></a> 重写父类的变量</h3><p>父类变量的重写的时候有几个需要注意的地方：</p><ol><li><p>被重写的变量也要有 <code>open</code> 的声明。</p></li><li><p>子类可以使用 <code>var</code> 类型的变量去重写父类 <code>val</code> 类型的变量，但是不能使用 <code>val</code> 类型的变量去重写父类 <code>var</code> 类型的变量。</p><p>如果使用 <code>val</code> 类型的变量去重写父类的 <code>var</code> 类型的变量, 那么子类这个 <code>val</code> 类型的变量会多一个 <code>set</code> 方法, 而 <code>val</code> 类型的变量是不允许有 <code>set</code> 方法的。</p></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">open</span> <span class="keyword">var</span> y : String = <span class="string">&quot;a&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> : <span class="type">A</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> x: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> y: String = <span class="string">&quot;b&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> : <span class="type">A</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span>  <span class="keyword">var</span> x : <span class="built_in">Int</span> = <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> y : String = <span class="string">&quot;c&quot;</span> <span class="comment">// Error: Var-property public open val y: String defined in C cannot be overridden by val-property public open var y: String defined in A</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="构造函数"><a class="markdownIt-Anchor" href="#构造函数"></a> 构造函数</h1><p><code>Kotlin</code> 将构造函数分为了两种：主构造函数和次构造函数。</p><h2 id="主构造函数"><a class="markdownIt-Anchor" href="#主构造函数"></a> 主构造函数</h2><p>主构造函数是最常使用的构造函数，每个类默认都会有一个不带参数的主构造函数。</p><p>（特殊情况：如果在没有实现主构造函数的情况下实现了次构造函数，则会失去该不带参数的主构造函数。）</p><p>当然也是可以显式地为其指明参数。主构造函数的特点就是没有函数体，直接定义在类名的后面即可：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> studentNo: String, <span class="keyword">var</span> grade: <span class="built_in">Int</span>) : Person() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者可以写成</span></span><br><span class="line"><span class="comment">// class Student constructor(val studentNo: String, var grade: Int) : Person() &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>我们在实例化的时候需要传入构造函数中的所有的参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> student = Student(<span class="string">&quot;123456789&quot;</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>由于主构造函数没有函数体，所以我们无法直接在其中编写一些逻辑。但是 <code>Kotlin</code> 给我们提供了一个 <code>init</code> 结构体，所有主构造函数的逻辑都可以写在里面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> studentNo: String, <span class="keyword">var</span> grade: <span class="built_in">Int</span>) : Person() &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Student No is <span class="variable">$studentNo</span> AND grade is <span class="variable">$grade</span>.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据 <code>Java</code> 语言继承特性中的一个规定：子类的构造函数必须调用父类中的构造函数。这个规定在 <code>Kotlin</code> 中也要遵守。</p><p>所以在上文中 <code>class Student : Person()</code> 以及 <code>class Student(val studentNo: String, var grade: Int) : Person()</code> 中 <code>Person</code> 类后面的一对空括号表示 <code>Student</code> 类的主构造函数在初始化的时候会调用 <code>Person</code> 类的无参数构造函数，即使在自身的主构造函数为默认的无参数的时候也是不能省略的。</p><p>现在我们将 <code>Person</code> 类改造一下，将姓名和年龄都放到主构造函数中，即：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="variable">$name</span> is eating.&quot;</span>)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们自定义了主构造函数，所以默认提供的无参数的主构造函数就不存在了，所以我们也需要修改一下 <code>Student</code> 类的表示方法：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">val</span> studentNo: String, <span class="keyword">var</span> grade: <span class="built_in">Int</span>, name: String, age: <span class="built_in">Int</span>) :</span><br><span class="line">        Person(name, age) &#123;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Student No is <span class="variable">$studentNo</span> AND grade is <span class="variable">$grade</span>.&quot;</span>)</span><br><span class="line">    &#125;    </span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，我们在 <code>Student</code> 类的主构造函数中增加 <code>name</code> 和 <code>age</code> 这两个字段时，不能再将它们声明成 <code>val</code>，因为在主构造函数中声明成 <code>val</code> 或者 <code>var</code> 的参数将自动成为该类的字段,这就会导致和父类中同名的 <code>name</code> 和 <code>age</code> 字段造成冲突。因此，<strong>这里的 <code>name</code> 和 <code>age</code> 参数前面我们不用加任何关键字,让它的作用域仅限定在主构造函数当中即可</strong> 。</p><p>现在就可以通过如下的代码来创建一个 <code>Student</code> 类的实例并使用了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> student = Student(<span class="string">&quot;123456789&quot;</span>, <span class="number">3</span>, <span class="string">&quot;LiHua&quot;</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><h2 id="次构造函数"><a class="markdownIt-Anchor" href="#次构造函数"></a> 次构造函数</h2><p>其实你几乎是用不到次构造函数的，<code>Kotlin</code> 提供了一个给函数设定参数默认值的功能，基本上可以替代次构造函数的作用。</p><p>任何一个类只能有一个主构造函数，但是可以有多个次构造函数。次构造函数也可以用于实例化一个类，这一点和主构造函数没有什么不同，只不过它是有函数体的。</p><p><code>Kotlin</code> 规定，当一个类既有主构造函数又有次构造函数时，所有的次构造函数都必须调用主构造函数（包括间接调用)。</p><p>比如以下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">var</span> age: <span class="built_in">Int</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(name: String, age: <span class="built_in">Int</span>, <span class="keyword">val</span> studentNo: String, <span class="keyword">var</span> grade: <span class="built_in">Int</span>) : Person(name, age) &#123;</span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;name : <span class="variable">$name</span> AND age : <span class="variable">$age</span> AND studentNo : <span class="variable">$studentNo</span> AND grade : <span class="variable">$grade</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(name: String , age: <span class="built_in">Int</span>) : <span class="keyword">this</span>(name, age, <span class="string">&quot;12345&quot;</span>, <span class="number">2</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>() : <span class="keyword">this</span>(<span class="string">&quot;XiaoMei&quot;</span>, <span class="number">19</span>, <span class="string">&quot;1234567&quot;</span>, <span class="number">1</span>) &#123;&#125; <span class="comment">// 如果 &#123;&#125; 内没有内容的话，可以省略大括号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> student1 = Student(<span class="string">&quot;LiHua&quot;</span>, <span class="number">20</span>, <span class="string">&quot;123456&quot;</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> student2 = Student(<span class="string">&quot;XiaoMing&quot;</span>, <span class="number">21</span>)</span><br><span class="line">    <span class="keyword">val</span> student3 = Student()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">name : LiHua AND age : <span class="number">20</span> AND studentNo : <span class="number">123456</span> AND grade : <span class="number">3</span></span><br><span class="line">name : XiaoMing AND age : <span class="number">21</span> AND studentNo : <span class="number">12345</span> AND grade : <span class="number">2</span></span><br><span class="line">name : XiaoMei AND age : <span class="number">19</span> AND studentNo : <span class="number">1234567</span> AND grade : <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>特殊情况：</strong></p><p>那么接下来我们就再来看一种非常特殊的情况：类中只有次构造函数，没有主构造函数。</p><p>这种情况真的十分少见，但在 <code>Kotlin</code> 中是允许的。</p><p><strong>当一个类没有显式地定义主构造函数且定义了次构造函数时，它就是没有主构造函数的。</strong></p><p>我们结合代码来看一下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> : <span class="type">Person &#123;</span></span></span><br><span class="line">    <span class="keyword">constructor</span>(name: String, age: <span class="built_in">Int</span>) : <span class="keyword">super</span>(name, age) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的代码变化，首先 <code>Student</code> 类的后面没有显式地定义主构造函数，同时又因为定义了次构造函数，所以现在 <code>Student</code> 类是没有主构造函数的。那么既然没有主构造函数，继承 <code>Person</code> 类的时候也就不需要再加上括号了（因为主构造函数会调用父类的构造函数）。</p><p>另外，由于没有主构造函数，次构造函数只能直接调用父类的构造函数，上述代码也是将 <code>this</code> 关键字换成了 <code>super</code> 关键字，这部分就很好理解了，因为和 <code>Java</code> 比较像，也就不再多说了。</p><hr /><h1 id="函数的命名参数以及参数默认值"><a class="markdownIt-Anchor" href="#函数的命名参数以及参数默认值"></a> 函数的命名参数以及参数默认值</h1><blockquote><p>类的构造函数同样适用于命名参数以及参数默认值，所以我们在极大多数的情况下通过这两个特性配合主构造函数来可以实现次构造函数的功能。</p></blockquote><h2 id="命名参数"><a class="markdownIt-Anchor" href="#命名参数"></a> 命名参数</h2><p>简单理解，就是它允许我们在调用函数的时候传入“形参的名字”。</p><p>如同以下形式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helloFunction(name = <span class="string">&quot;Kotlin&quot;</span>)</span><br></pre></td></tr></table></figure><p>让我们看一个更具体的使用场景：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createUser</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    age: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    gender: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    friendCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    feedCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    likeCount: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    commentCount: <span class="type">Int</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过如下的方法使用函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">createUser(</span><br><span class="line">    name = <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    age = <span class="number">30</span>,</span><br><span class="line">    gender = <span class="number">1</span>,</span><br><span class="line">    friendCount = <span class="number">78</span>,</span><br><span class="line">    feedCount = <span class="number">2093</span>,</span><br><span class="line">    likeCount = <span class="number">10937</span>,</span><br><span class="line">    commentCount = <span class="number">3285</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以看到，在这段代码中，我们把函数的形参加了进来，形参和实参用 <code>=</code> 连接，建立了两者的对应关系。对比前面 <code>Java</code> 风格的写法，这样的代码可读性更强了。如果将来你想修改 <code>likeCount</code> 这个参数，也可以轻松做到。这其实就体现出了 <code>Kotlin</code> 命名参数的可读性与易维护性两个优势。</p><h2 id="参数默认值"><a class="markdownIt-Anchor" href="#参数默认值"></a> 参数默认值</h2><p>而除了命名参数这个特性，<code>Kotlin</code> 还支持参数默认值，这个特性在参数较多的情况下同样有很大的优势：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">createUser</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    name: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    age: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    gender: <span class="type">Int</span> = <span class="number">1</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    friendCount: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    feedCount: <span class="type">Int</span> = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    likeCount: <span class="type">Long</span> = <span class="number">0</span>L,</span></span></span><br><span class="line"><span class="params"><span class="function">    commentCount: <span class="type">Int</span> = <span class="number">0</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，<code>gender</code>、<code>friendCount</code>、<code>feedCount</code>、<code>likeCount</code>、<code>commentCount</code> 这几个参数都被赋予了默认值。这样做的好处就在于，我们在调用的时候可以省很多事情。比如说，下面这段代码就只需要传 3 个参数，剩余的 4 个参数没有传，但是 <code>Kotlin</code> 编译器会自动帮我们填上默认值。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">createUser(</span><br><span class="line">    name = <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    age = <span class="number">30</span>,</span><br><span class="line">    commentCount = <span class="number">3285</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>对于无默认值的参数，编译器会强制要求我们在调用处传参；对于有默认值的参数，则可传可不传。<code>Kotlin</code> 这样的特性，在一些场景下就可以极大地提升我们的开发效率。而如果是在 <code>Java</code> 当中要实现类似的事情，我们就必须手动定义“3 个参数的 <code>createUser</code> 函数”，或者是使用 <code>Builder</code> 设计模式。</p><h2 id="在构造函数中的使用案例"><a class="markdownIt-Anchor" href="#在构造函数中的使用案例"></a> 在构造函数中的使用案例</h2><p>通过写出如下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(</span><br><span class="line">    name: String = <span class="string">&quot;&quot;</span>, </span><br><span class="line">    age: <span class="built_in">Int</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="keyword">val</span> studentNo: String = <span class="string">&quot;&quot;</span>, </span><br><span class="line">    <span class="keyword">val</span> grade: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">) : Person(name, age) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在给主构造函数的每个参数都设定了默认值之后，我们就可以使用任何传参组合的方式来对 <code>Student</code> 类进行实例化，当然也包含了上文中的两种次构造函数的使用场景。</p><hr /><h1 id="函数的可见性修饰符"><a class="markdownIt-Anchor" href="#函数的可见性修饰符"></a> 函数的可见性修饰符</h1><p>熟悉 <code>Java</code> 的人一定知道，<code>Java</code> 中有 <code>public</code>、 <code>private</code>、 <code>protected</code> 和 <code>default</code>(什么都不写）这4种函数可见性修饰符。</p><p><code>Kotlin</code>中也有4种，分别是 <code>public</code>、 <code>private</code>、<code>protected</code> 和 <code>internal</code>，需要使用哪种修饰符时，直接定义在 <code>fun</code> 关键字的前面即可。</p><p>下面将详细介绍一下 <code>Java</code> 和 <code>Kotlin</code> 中这些函数可见性修饰符的异同。</p><ol><li><p><code>private</code> 修饰符在两种语言中的作用是一模一样的，都表示只对当前类内部可见。</p></li><li><p><code>public</code> 修饰符的作用虽然也是一致的，表示对所有类都可见，但是在 <code>Kotlin</code>中 <code>public</code> 修饰符是默认项，而在 <code>Java</code> 中 <code>default</code> 才是默认项。前面我们定义了那么多的函数，都没有加任何的修饰符，所以它们默认都是 <code>public</code> 的。</p></li><li><p><code>protected</code> 关键字在 <code>Java</code> 中表示对当前类、子类和同一包路径下的类可见，在 <code>Kotlin</code> 中则表示只对当前类和子类可见。</p></li><li><p><code>Kotlin</code> 抛弃了 <code>Java</code> 中的 <code>default</code> 可见性（同一包路径下的类可见），引人了一种新的可见性概念，只对同一模块中的类可见，使用的是 <code>internal</code> 修饰符。比如我们开发了一个模块给别人使用，但是有一些函数只允许在模块内部调用，不想暴露给外部，就可以将这些函数声明成 <code>internal</code> 。</p></li></ol><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220708221406391.png" alt="image" /></p><p>所以，我们可以通过 <code>private</code> 关键字将类的构造函数定义为私有属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 私有的主构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>(</span><br><span class="line">    <span class="keyword">val</span> studentNo: String, </span><br><span class="line">    <span class="keyword">var</span> grade: <span class="built_in">Int</span></span><br><span class="line">) : Person() &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 私有的次构造函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>(grade: <span class="built_in">Int</span>) : <span class="keyword">this</span>(<span class="string">&quot;123&quot;</span>, grade) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录了 Kotlin 中类的创建与继承的语法。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统 练习题整理</title>
    <link href="https://luoyu-ying.github.io/posts/a88955f1c30b/"/>
    <id>https://luoyu-ying.github.io/posts/a88955f1c30b/</id>
    <published>2022-06-25T12:03:26.000Z</published>
    <updated>2022-06-30T12:03:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>整理并分析了上课时的部分练习题。</p><p>题目持续更新中~</p></blockquote><h1 id="第一章"><a class="markdownIt-Anchor" href="#第一章"></a> 第一章</h1><hr /><blockquote><p>一个程序的原来使用单线程的CPU的总运行时间为1。程序中不能并行执行的部分占比40%，可以并行执行的部分为60%。如果使用一个2线程的CPU执行该程序（不考虑其他额外开销），程序运行时间为（  A  ）</p><p>A. 0.7</p><p>B. 0.6</p><p>C. 0.9</p><p>D. 0.4</p></blockquote><p>Amdahl 定律：</p><p>若系统执行某应用程序需要时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。 假设系统某部分所需执行时间与该时间的比例为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>, 而该部分性能提升比例为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>。即该部分初始所需时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>×</mo><msub><mi>T</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">a \times T_{old}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> , 现在所需时间为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>a</mi><mo>×</mo><msub><mi>T</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub></mrow><mi>k</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{a \times T_{old}}{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.239191em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.894191em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.41586em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">×</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3487714285714287em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15122857142857138em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。则加速比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mfrac><msub><mi>T</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><msub><mi>T</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>a</mi><mo stretchy="false">)</mo><mo>+</mo><mfrac><mi>a</mi><mi>k</mi></mfrac></mrow></mfrac></mrow><annotation encoding="application/x-tex">S = \frac{T_{old}}{T_{new}} = \frac{1}{(1-a)+ \frac{a}{k}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.35244em;vertical-align:-1.0310000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.695392em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.0310000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mn>0.6</mn><mo separator="true">,</mo><mi>k</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">a = 0.6, k = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 带入公式中，即可得到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">T_{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的值为 0.7。答案为A。</p><hr /><blockquote><p>接上题，如果使用一个5线程的CPU执行该程序，计算加速比为(  B  )</p><p>A. 1/0.73</p><p>B. 1/0.52</p><p>C. 1/0.84</p><p>D. 1/0.41</p></blockquote><p>将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mn>0.6</mn><mo separator="true">,</mo><mi>k</mi><mo>=</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">a = 0.6, k = 5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span> 带入上述公式中，即可得到选项 B。</p><hr /><blockquote>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a= <span class="number">1e20</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f + %f - %f = %f\n&quot;</span>, a, b, a, a + b - a);</span><br></pre></td></tr></table></figure><p>的执行结果为(  B  )</p><p>A. 3.14</p><p>B. 0</p><p>C. 3</p><p>D. 0.01</p></blockquote><ol><li><code>float</code> 有效数字位为8位，超过第8位的数字将四舍五入。</li><li>浮点数加法第一步为调整两个浮点数的阶数，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mn>1.00</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>20</mn></msup><mo separator="true">,</mo><mtext> </mtext><mi>b</mi><mo>=</mo><mo stretchy="false">(</mo><mn>3.14</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>20</mn></mrow></msup><mo stretchy="false">)</mo><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>20</mn></msup><mo>≈</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a = 1.00 \times 10^{20}, \space b = (3.14 \times 10^{-20}) \times 10^{20} \approx 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">3</span><span class="mord">.</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>=</mo><mo stretchy="false">(</mo><mn>1.00</mn><mo>+</mo><mn>3.14</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>20</mn></mrow></msup><mo stretchy="false">)</mo><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>20</mn></msup><mo>≈</mo><mn>1</mn><mi>e</mi><mn>20</mn></mrow><annotation encoding="application/x-tex">a + b = (1.00 + 3.14 \times 10^{-20}) \times 10^{20} \approx 1e20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">.</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord">.</span><span class="mord">1</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">2</span><span class="mord">0</span></span></span></span>。</li><li>故 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>b</mi><mo>−</mo><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a + b - a = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</li></ol><hr /><blockquote>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">float</span> b = <span class="number">3.14159265358979</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f + %f - %f = %f\n&quot;</span>, a, b, a, a + b - a);</span><br></pre></td></tr></table></figure><p>的执行结果为(  A  )</p><p>A. 3.14</p><p>B. 0</p><p>C. 3</p><p>D. 0.01</p></blockquote><p>a 的值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>e</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">1e5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault">e</span><span class="mord">5</span></span></span></span>，小于 <code>float</code> 的有效位数，所以可以正常进行数值运算。</p><hr /><blockquote><p>单CPU中可以通过线程进行并行操作。(  A  )</p><p>A. 错误</p><p>B. 正确</p></blockquote><hr /><h1 id="第二章"><a class="markdownIt-Anchor" href="#第二章"></a> 第二章</h1><hr /><blockquote><p>十进制数：136 对应的十六进制数为（ A ）</p><p>A. 0x88</p><p>B. 0x66</p><p>C. 0x96</p><p>D. 0x78</p></blockquote><p>可以通过 <strong>除k取余法</strong> 计算 十进制转k进制问题。</p><hr /><blockquote>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">0x12345678</span>;</span><br><span class="line">byte_pointer valp = (byte_pointer) &amp; val; </span><br><span class="line">show_bytes(valp, <span class="number">1</span>); </span><br></pre></td></tr></table></figure><p>上述程序在小端法机器上调用show_bytes的输出值为（ C ）</p><p>A. 56</p><p>B. 34</p><p>C. 78</p><p>D. 12</p></blockquote><p><code>show_bytes(byte_pointer, int x)</code> 函数的作用为输出 <code>byte_pointer</code> 的第 <code>x</code> 个字节。</p><hr /><blockquote><p>已知x和y的字节值分别为0x69和0x55。计算C表达式 x &amp; y 的字节值为（  B ）</p><p>A. 0x00</p><p>B. 0x41</p><p>C. 0x01</p><p>D. 0x20</p></blockquote><p>通过计算便可得到结果。</p><hr /><blockquote><p>接上题，计算C表达式 x &amp;&amp; y 的字节值为(  C  )</p><p>A. 0x00</p><p>B. 0x41</p><p>C. 0x01</p><p>D. 0x20</p></blockquote><p><code>&amp;&amp;</code> 为逻辑判断符号，结果只能为 0 或 1。</p><hr /><blockquote><p>假设一个8位整数的补码表示为 0xef，则这个整数的真值为 (  A  )</p><p>A. -17</p><p>B. -239</p><p>C. 17</p><p>D. 239</p></blockquote><p>0xef 的二进制表示为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1110</mn><mtext> </mtext><mn>1111</mn></mrow><annotation encoding="application/x-tex">1110\space 1111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span>，高一位为符号位，表示负数，低7位通过 <strong>反码+1</strong> 可以得出值为 17。所以这个补码的真值为 -17。</p><hr /><blockquote><p>假设一个整数数据类型为4位，已知x = -5 ，函数 T2U = (  A  )</p><p>A. 11</p><p>B. -5</p><p>C. 16</p><p>D. 5</p></blockquote><p>-5 的补码为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1011</mn></mrow><annotation encoding="application/x-tex">1011</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span></span></span></span>，无符号数为 11，选项 A 正确。</p><hr /><blockquote><p>在采用补码运算的32位机器上对表达式： -2147483647-1U &gt; 2147483647   的求值结果为(  D  )</p><p>A. -1</p><p>B. 0</p><p>C. 不确定</p><p>D. 1</p></blockquote><p>由于强制类型转换，-2147483647 和 2147483647 都会处理成 无符号数。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>2147483647</mn><mo>−</mo><mn>1</mn><mi>U</mi></mrow><annotation encoding="application/x-tex">-2147483647 - 1U</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span><span class="mord">7</span><span class="mord">4</span><span class="mord">8</span><span class="mord">3</span><span class="mord">6</span><span class="mord">4</span><span class="mord">7</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span></span> 的值为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1110</mn></mrow><annotation encoding="application/x-tex">1111\space 1111\space 1111\space 1111\space 1111\space 1111\space 1111\space 1110</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span></span></span></span>；</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2147483647</mn></mrow><annotation encoding="application/x-tex">2147483647</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">1</span><span class="mord">4</span><span class="mord">7</span><span class="mord">4</span><span class="mord">8</span><span class="mord">3</span><span class="mord">6</span><span class="mord">4</span><span class="mord">7</span></span></span></span> 的值为  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn><mtext> </mtext><mn>1111</mn></mrow><annotation encoding="application/x-tex">0111\space 1111\space 1111\space 1111\space 1111\space 1111\space 1111\space 1111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span>。</p><p>可以得出选项 D。</p><hr /><blockquote><p>已知x = -15，y = -12，计算字长 w = 5 的补码加法：x + y = (  D  )</p><p>A. -5</p><p>B. -27</p><p>C. 27</p><p>D. 5</p></blockquote><p>x + y = -27，其补码为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>10</mn><mtext> </mtext><mn>0101</mn></mrow><annotation encoding="application/x-tex">10\space 0101</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span></span></span></span>，由于 w = 5，所以截取低5位，得到的结果为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mtext> </mtext><mn>0101</mn></mrow><annotation encoding="application/x-tex">0\space 0101</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span></span></span></span>，值为 5 ，选项 D 正确。</p><hr /><blockquote>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">2</span>; </span><br><span class="line"><span class="type">int</span> y = <span class="number">2</span>; </span><br><span class="line">x &lt;&lt;= <span class="number">6</span>; </span><br><span class="line">x -= y; </span><br><span class="line">y &lt;&lt;= <span class="number">3</span>; </span><br><span class="line">x -= y; </span><br></pre></td></tr></table></figure><p>上述程序 x 的输出值为（  B  ）</p><p>A. 128</p><p>B. 110</p><p>C. 55</p><p>D. 64</p></blockquote><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><msup><mn>2</mn><mn>6</mn></msup><mo>−</mo><mn>2</mn><mo>−</mo><mn>2</mn><mo>×</mo><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>110</mn></mrow><annotation encoding="application/x-tex">2 \times 2^6 - 2 - 2 \times 2^3 = 110</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">1</span><span class="mord">0</span></span></span></span>，选项 B 正确。</p><hr /><blockquote><p>二进制小数 11.0011 对应的十进制数为（  C  ）</p><p>A. 3.3</p><p>B. 11.1875</p><p>C. 3.1875</p><p>D. 11.3</p></blockquote><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>×</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mn>0</mn></msup><mo>+</mo><mn>0</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mn>0</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>2</mn></mrow></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>3</mn></mrow></msup><mo>+</mo><mn>1</mn><mo>×</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>4</mn></mrow></msup><mo>=</mo><mn>3.1875</mn></mrow><annotation encoding="application/x-tex">1 \times 2^1 + 1 \times 2^0 + 0 \times 2^{-1} + 0 \times 2^{-2} + 1 \times 2^{-3} + 1 \times 2^{-4} = 3.1875</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">.</span><span class="mord">1</span><span class="mord">8</span><span class="mord">7</span><span class="mord">5</span></span></span></span>，选项 C 正确。</p><hr /><h1 id="第三章"><a class="markdownIt-Anchor" href="#第三章"></a> 第三章</h1><hr /><blockquote><p>算术右移指令是（ A ）</p><p>A. sar</p><p>B. shl</p><p>C. shr</p><p>D. sal</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625211226169.png" alt="image-20220625211226169" style="zoom:80%;" /><hr /><blockquote><p>假设<code>%rax holds x</code>,   <code>%rcx holds y</code>，则<code>leaq (%rax, %rcx, 4), %rdx</code>的结果为（  D ）</p><p>A. <code>( x + y ) * 4</code></p><p>B. <code>4 * x + y</code></p><p>C. <code>x + y + 4</code></p><p>D. <code>x + 4 * y</code></p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625211452247.png" alt="image-20220625211452247" style="zoom: 67%;" /><hr /><blockquote><p>关于条件码，下面描述错误的是 (  C  )</p><p>A.这些位描述和记录了最近算术运算或者逻辑运算的操作结果状态。</p><p>B.该序列在专门的状态寄存器FLAGS 或者EFLAGS。</p><p>C.以8086的状态寄存器FLAGS寄存器共8位。</p><p>D.一些bit位构成的序列</p></blockquote><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/weixin_42109012/article/details/100148721">8086标志寄存器（Flag Register）_有人_295的博客-CSDN博客_8086标志寄存器</a></li></ul></blockquote><p>标志寄存器设计为16位，实际使用9位，其中6位用以存放算术逻辑单元运算后的结果特征，称为<strong>状态标志</strong>；另外3位通过人为设置，用以控制8086的三种特定操作，称为<strong>控制标志</strong>。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190829223517134.png" alt="在这里插入图片描述" style="zoom:67%;" /><p>6个状态标志位定义如下：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190830001628834.png" alt="在这里插入图片描述" style="zoom:67%;" /><p><strong>进位标志：</strong> 用于反映运算是否产生进位或借位。如果运算结果的最高位产生一个进位或借位，则CF置1，否则置0。运算结果的最高位包括字操作的第15位和字节操作的第7位。移位指令也会将操作数的最高位或最低位移入CF。</p><p><strong>奇偶标志：</strong> 用于反映运算结果低8位中“1”的个数。“1”的个数为偶数，则PF置1，否则置0。</p><p><strong>辅助进位标志：</strong> 算数操作结果的第三位（从0开始计数）如果产生了进位或者借位则将其置为1，否则置为0，常在BCD(binary-code decimal)算术运算中被使用。</p><p><strong>零标志：</strong> 用于判断结果是否为0。运算结果0，ZF置1，否则置0。</p><p><strong>符号标志：</strong> 用于反映运算结果的符号，运算结果为负，SF置1，否则置0。因为有符号数采用补码的形式表示，所以SF与运算结果的最高位相同。</p><p><strong>溢出标志：</strong> 反映有符号数加减运算是否溢出。如果运算结果超过了8位或者16位有符号数的表示范围，则OF置1，否则置0。</p><hr /><blockquote><p>关于C语言的跳转及分支，下面描述正确的是(   D   )</p><p>A. 稀疏的 switch 语句使用跳转表</p><p>B. C语言不允许 switch 语句根据一个整数索引值进行多重分支</p><p>C. 大的 switch 语句使用决策树</p><p>D. C允许使用 goto 语句</p></blockquote><p>GCC 根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句。当开关情况数量比较多（例如 4 个以上），并且值的范围跨度比较小时，就会使用跳转表。情况数量较少或者值的范围跨度比较大时，会使用非常多的 <code>CMP</code> 指令，其实在这种情况下和使用多个 <code>if-else if</code> 一样。</p><hr /><blockquote><p>对指令 <code>linux&gt; objdump -d mstore.o</code>，说法最正确的是 (  C  )</p><p>A. 与mstore.exe等价的汇编语言代码</p><p>B. 与mstore.c等价的汇编语言代码</p><p>C. 与mstore.o等价的汇编语言代码</p><p>D. 以上说法都不对</p></blockquote><hr /><blockquote><p><code>xorl</code> 指令对条件码的影响描述正确的是(  B  )</p><p>A. CF被设置为移出的最后一位</p><p>B. CF和OF置零</p><p>C. ZF和OF置零</p><p>D. 对条件码无影响</p></blockquote><hr /><blockquote><p>对于x86,指令 <code>pushq %rax</code>，描述错误的是：(  A  )</p><p>A.该指令能一次压入4个bytes</p><p>B.该指令的功能是将寄存器ax的值存在堆栈中</p><p>C.与 <code>popq %rax</code>指令操作方向相反</p><p>D.该指令能增大堆栈</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621113704881.png" alt="image-20220621113704881" style="zoom: 33%;" /><p><code>pushq</code> 能一次压入 8 个 bytes。</p><hr /><blockquote><p>下列汇编指令，错误的是(  C  )</p><p>A. movb   (%rdi, %rcx), %al</p><p>B. movw  %bp, %sp</p><p>C. movb  (%rbx), (%rsp)</p><p>D. movl    $0x4050, %eax</p></blockquote><p><code>MOV</code> 指令中源操作数和目的操作数不能同时为寄存器地址。</p><hr /><blockquote><p>对命令行：<code>linux&gt;gcc -Og -S mstore.c</code>，使用 -S 选项的作用是（ D ）</p><p>A. GCC运行编译器，并进行反汇编</p><p>B. GCC运行编译器，产生一个汇编文件 mstore.s，且会产生目标文件</p><p>C. GCC运行编译器，并进行一个标准优化</p><p>D. GCC运行编译器，产生一个汇编文件 mstore.s，但是不做其他进一步的工作</p></blockquote><hr /><blockquote><p>用C语言调用有参函数，关于其机器级代码中的参数传递，以下描述正确的是（ A ）</p><p>A. 参数传递遵循调用约定，与目标机CPU和编译器都相关</p><p>B. 参数全部用栈传送，传递顺序只能由右向左进栈</p><p>C. 参数传递只与CPU相关，与编译器没有关系</p><p>D. 参数全部用固定的寄存器传递</p></blockquote><p>x8086 架构中，前6个参数存放在寄存器中，后所有参数都存放在栈中。</p><p>参数传递遵循调用约定，与目标机CPU和编译器都相关。</p><hr /><blockquote><p>x86-64的机器代码和原始的C代码差别非常大。一些通常对C语言程序员隐藏的处理器状态都是可见的，下面描述正确的是 ( A B C D )</p><p>A. 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现if和 while语句。</p><p>B. 整数寄存器文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址(对应于C语言的指针)或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。</p><p>C. 一组向量寄存器可以存放一个或多个整数或浮点数值。</p><p>D. 程序计数器(通常称为 “PC”，在x86-64中用 %rip 表示)给出将要执行的下一条指令在内存中的地址。</p></blockquote><hr /><blockquote><p>关于C语言函数对应机器代码中寄存器，正确的是（ A D ）</p><p>A. 有的寄存器调用函数不保护，由被调用函数负责保护</p><p>B. 所有寄存器都由调用函数保护，被调用函数可以自由使用</p><p>C. 所有寄存器都由被调用函数保护，调用函数可以自由使用</p><p>D. 有的寄存器由调用函数保护，被调用函数可以自由使用</p></blockquote><p>寄存器分为调用者寄存器和被调用者寄存器。</p><hr /><blockquote><p>对命令行：<code>linux&gt; gcc -Og -c mstore.c</code>，说法正确的是（ C D ）</p><p>A. 会产生exe文件，可执行文件是汇编格式的</p><p>B. 目标代码文件在机器中是十六进制的</p><p>C. GCC会编译并汇编该代码</p><p>D. 这会产生目标代码文件mstore.o</p></blockquote><p>可执行文件是二进制文件。</p><hr /><blockquote><p>C语言的一次函数调用包含的操作有（ A B C D ）</p><p>A. 跳转到被调函数的入口</p><p>B. 从栈中弹出调用函数的返回地址</p><p>C. 跳转到调用函数的返回地址</p><p>D. 保存调用函数的返回地址到栈中</p></blockquote><hr /><h1 id="第四章"><a class="markdownIt-Anchor" href="#第四章"></a> 第四章</h1><hr /><blockquote><p>能够被硬件识别并执行的程序是（   D  ）</p><p>A. 汇编语言程序</p><p>B. 高级语言程序</p><p>C. 人工智能语言程序</p><p>D. 机器指令程序</p></blockquote><hr /><blockquote><p>从计算机系统结构上讲，机器语言程序员能看到的机器属性是（  A ）</p><p>A. 编程要用到的硬件组织</p><p>B. 计算机各部件的硬件实现</p><p>C. 计算机软件所要完成的功能</p><p>D. 计算机硬件的全部组成</p></blockquote><hr /><blockquote><p>在CPU执行指令的过程中，数据的地址由什么给出？(   B   )</p><p>A. 操作系统</p><p>B. 指令的地址码字段</p><p>C. 程序员</p><p>D. 程序计数器PC</p></blockquote><hr /><blockquote><p>下列关于指令的功能及分类叙述正确的是 (  B  )</p><p>A. 转移指令，子程序调用与返回指令，用于解决数据调用次序的需要</p><p>B. 移位操作指令，通常用于把目的操作数DEST左移或右移OPRD位</p><p>C. 特权指令，通常仅用于系统软件，这类指令一般不提供给用户</p><p>D. 算术与逻辑运算指令，通常完成算术运算或逻辑运算，都需要两个数据</p></blockquote><p>特权指令指具有特殊权限的指令。. 这类指令只用于操作系统或其他系统软件，一般不直接提供给用户使用。</p><p>转移指令是指不按程序的语句流程执行的指令，如跳转指令， call 指令、 jmp 指令等。</p><hr /><blockquote><p>关于Y86-64指令的叙述中，不正确的是 (   A   )</p><p>A. 每条指令都有寄存器指示符</p><p>B. 指令的第1个字节高4位是指令代码，低4位是功能码</p><p>C. 有些指令有一个附加的8字节常数字</p><p>D. 每条指令的第1个字节表示指令的类型</p></blockquote><p><code>ret</code>、<code>nop</code>、<code>halt</code> 指令无需操作数。</p><hr /><blockquote><p>以下关于CISC和RISC的叙述中，不正确的是(   B   )</p><p>A. CISC有些指令的延迟很差，RISC没有较长延迟的指令</p><p>B. CISC和RISC都是可变长度</p><p>C. CISC有条件码，RISC没有条件码</p><p>D. CISC指令数量多，RISC指令数量少</p></blockquote><blockquote><p>答案参考自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/346864380">简述risc和cisc的区别（转发） - 知乎 (zhihu.com)</a></li><li>《深入理解计算机系统》</li></ul></blockquote><p>CISC的英文全称为“Complex Instruction Set Computer”，即“复杂指令系统计算机”，从计算机诞生以来，人们一直沿用CISC指令集方式。目前，桌面计算机流行的x86体系结构即使用CISC。在CISC微处理器中，程序的各条指令是按顺序串行执行的，每条指令中的各个操作也是按顺序串行执行的。顺序执行的优点是控制简单，但计算机各部分的利用率不高，执行速度慢。</p><p>RISC的英文全称为“Reduced Instruction Set Computer”，即“精简指令集计算机”，是一种执行较少类型计算机指令的微处理器，RISC机中采用的微处理器统称RISC处理器。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220626154912809.png" alt="image-20220626154912809" style="zoom:67%;" /><hr /><blockquote><p>Y86-64中用十六进制表示指令 <code>rmmovq %rsp, 0x123456789abcd(%rdx)</code>的字节编码(   C   )</p><p>A. 4042000123456789abcd</p><p>B. 40420123456789abcd</p><p>C. 4042cdab896745230100</p><p>D. 4042cdab8967452301</p></blockquote><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/Chauncyxu/article/details/121943734"> CSPP学习笔记-Ch4 借助 Y86-64 理解处理器是如何工作的_Life Commander的博客-CSDN博客_硬件寄存器和程序寄存器</a></li></ul></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/B1TZjXLRgPqYd2x.png" alt="img" style="zoom: 13%;" /><p>程序寄存器存在CPU中的一个寄存器文件中。<br />在指令编码中以及在硬件设计中，当需要指明不应访问任何寄存器时，就用 ID 值 0xF 来表示。</p><table><thead><tr><th>数字</th><th>寄存器名字</th><th>数字</th><th>寄存器名字</th></tr></thead><tbody><tr><td>0</td><td><code>%rax</code></td><td>8</td><td><code>%r8</code></td></tr><tr><td>1</td><td><code>%rcx</code></td><td>9</td><td><code>%r9</code></td></tr><tr><td>2</td><td><code>%rdx</code></td><td>A</td><td><code>%r10</code></td></tr><tr><td>3</td><td><code>%rbx</code></td><td>B</td><td><code>%r11</code></td></tr><tr><td>4</td><td><code>%rsp</code></td><td>C</td><td><code>%.r12</code></td></tr><tr><td>5</td><td><code>%rbp</code></td><td>D</td><td><code>%r13</code></td></tr><tr><td>6</td><td><code>%rsi</code></td><td>E</td><td><code>%r14</code></td></tr><tr><td>7</td><td><code>%rdi</code></td><td>F</td><td>No register</td></tr></tbody></table><p>从图可以看到，<code>rmmovq</code> 的第一个字节为 <code>40</code>。源寄存器 <code>%rsp</code> 应该编码放在 <code>rA</code> 字段中，而基址寄存器 <code>%rdx</code> 应该编码放在 <code>rB</code> 字段中。</p><p>根据表中的寄存器编号，得到寄存器指示符字节 4 和 2。</p><p>偏移量编码放在 8 字节的常数中：首先在 <code>0x123456789abcd</code> 的前面填充上 0 变成 8 个字节，变成字节序列 <code>00 01 23 45 67 89 ab cd</code>，由于<strong>小端法编码</strong>，写成按字节反序就是 <code>cd ab 89 67 45 23 01 00</code>。</p><p>最后，将它们都连接起来就得到指令的编码 <code>4042cdab896745230100</code>。</p><hr /><blockquote><p>输入a和b，写出信号 xor的HCL表达式(   B   )</p><p>A. bool xor =（!a &amp;&amp; !b) || (a &amp;&amp; b)</p><p>B. bool xor =（!a &amp;&amp; b) || (a &amp;&amp; !b)</p><p>C. bool xor =（a &amp;&amp; b) || (a &amp;&amp; b)</p><p>D. bool xor =（a &amp;&amp; b) || (!a &amp;&amp; b)</p></blockquote><p>可以通过类似真值表的方式判断正确答案。</p><hr /><blockquote><p>输入a和b，控制信号输入位s，写出信号MUX的HCL表达式（  D ）</p><p>A. bool out = (s &amp;&amp; a) || (s &amp;&amp; b)</p><p>B. bool out = (!s &amp;&amp; a) || (!s &amp;&amp; b)</p><p>C. bool out = (s &amp;&amp; !a) || (s &amp;&amp; !b)</p><p>D. bool out = (s &amp;&amp; a) || (!s &amp;&amp; b)</p></blockquote><p><code>MUX</code> 为多路复用器，对 s 的不同输入情况采取不同的信号输出。</p><hr /><blockquote><p>Y86-64处理器执行一条完整指令所需的步骤有 （ A B C D E ）</p><p>A.访存</p><p>B.译码</p><p>C.执行</p><p>D.写回和更新PC</p><p>E.取指</p></blockquote><p>几乎所有的冯·诺伊曼型计算机的CPU，其工作都可以分为5个阶段：取指令、指令译码、执行指令、访存取数、结果写回。</p><p>各个阶段具体内容参考：<a href="https://blog.csdn.net/aigoogle/article/details/23750257">一条指令在cpu中的执行流程（理解CPU组成）_编码那些事儿的博客-CSDN博客</a></p><hr /><h1 id="第六章"><a class="markdownIt-Anchor" href="#第六章"></a> 第六章</h1><hr /><blockquote><p>主存储器和 CPU之间增加cache的目的是（ D ）。</p><p>A.扩大CPU中通用寄存器的数量</p><p>B.扩大主存储器的容量</p><p>C.既扩大主存容量又扩大CPU通用寄存器数量</p><p>D.解决CPU和主存之间的速度匹配问题</p></blockquote><hr /><blockquote><p>下列因素下，与cache的命中率无关的是（  D  ）。</p><p>A. cache 的组织方式</p><p>B. 块的大小</p><p>C. cache的容量</p><p>D. 主存的存取时间</p></blockquote><hr /><blockquote><p>以下哪一种情况能很好地发挥cache的作用? （  A  ）</p><p>A. 程序具有较好的访问局部性</p><p>B. 程序的大小不超过实际的内存容量</p><p>C. 程序的指令间相关度不高</p><p>D. 程序中不含有过多的I/O操作</p></blockquote><hr /><blockquote><p>在当前微机中，使用cache提高了计算机运行速度，主要是因为（  A  ）</p><p>A. cache缩短了CPU的等待时间</p><p>B. cache扩大了硬盘的容量</p><p>C. cache可以存放程序和数据</p><p>D. cache增大了内存的容量</p></blockquote><hr /><blockquote><p>在存储器层次结构中，存储器速度从最快到最慢的排列顺序是(   C   )</p><p>A.寄存器  -&gt; cache -&gt; 辅存 -&gt; 主存</p><p>B.寄存器 -&gt; 主存 -&gt; 辅存 -&gt; cache</p><p>C.寄存器 -&gt; cache -&gt; 主存 -&gt; 辅存</p><p>D.寄存器 -&gt; 主存 -&gt; cache -&gt; 辅存</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220626191551044.png" alt="image-20220626191551044" style="zoom:67%;" /><hr /><blockquote><p>在cache的地址映射中，若主存中的任意一块均可映射到cache内的任意一块的位置上，则这种方法称为（ D ）。</p><p>A. 组相联映射</p><p>B. 直接映射</p><p>C. 混合映射</p><p>D. 全相联映射</p></blockquote><hr /><blockquote><p>某计算机的cache共有16行,采用2路组相联映射方式(即每组2行)。每个主存块大小为32字节,按字节编址。主存135号单元所在主存块应装入到的cache组号是（ A ）。</p><p>A. 4</p><p>B. 2</p><p>C. 6</p><p>D. 0</p></blockquote><p>通过题目可以得出：该计算机的 cache 总共有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn><mi mathvariant="normal">/</mi><mn>2</mn><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">16 / 2 = 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord">/</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 组，每组 2 行，每块 32 字节。</p><p>135 的二进制为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mtext> </mtext><mn>1000</mn><mtext> </mtext><mn>0111</mn></mrow><annotation encoding="application/x-tex">0 \space 1000 \space 0111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span>，重新调整排版后为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mtext> </mtext><mn>100</mn><mtext> </mtext><mn>00111</mn></mrow><annotation encoding="application/x-tex">0 \space 100 \space 00111</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace"> </span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mord">1</span><span class="mord">1</span></span></span></span>。</p><p>从低位向高位看：</p><ol><li>低 5 位表示每块 32 字节，即每行的偏移值。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>5</mn></msup><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">2^5 = 32</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span></span></span></span>）</li><li>中 3 位表示共有 8 个组，即组索引。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mn>3</mn></msup><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">2^3=8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>）</li><li>高 t 位表示标记位，即说明这个组的哪一行包括了相关内容。</li></ol><p>所以 cache 组号为中 3 位，即为 4。</p><hr /><blockquote><p>假定主存按字节编址，cache 共有64行，采用直接映射方式，主存块大小为32字节，所有编号都从0开始。问主存第2593号单元所在主存块对应的cache行号是（ B ）</p><p>A.34</p><p>B.17</p><p>C.81</p><p>D.1</p></blockquote><p>得出的信息：</p><ol><li>共有 64 组，每组 1 行。 -&gt;  二进制中间部分位数为 6。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn><mo>=</mo><msup><mn>2</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">64 = 2^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span>）</li><li>每块 32 字节。 -&gt; 二进制后面部分位数为 5。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn><mo>=</mo><msup><mn>2</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">32=2^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>）</li></ol><p>2593 的二进制为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mtext> </mtext><mn>010001</mn><mtext> </mtext><mn>00001</mn></mrow><annotation encoding="application/x-tex">1 \space 010001 \space 00001</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span></span></span></span>，所以 cache 行号为二进制中间部分，即为 17。选项 B 正确。</p><hr /><blockquote><p>假定主存按字节编址，cache 共有64行，采用4路组相联映射方式，主存块大小为32字节，所有编号都从0开始。问主存第2593号单元所在主存块对应的cache组号是（ D ）</p><p>A.34</p><p>B.17</p><p>C.81</p><p>D.1</p></blockquote><p>得出的信息：</p><ol><li>共有 16 组，每组 4 行。 -&gt;  二进制中间部分位数为 4。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>16</mn><mo>=</mo><msup><mn>2</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">16 = 2^4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span>）</li><li>每块 32 字节。 -&gt; 二进制后面部分位数为 5。（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn><mo>=</mo><msup><mn>2</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">32=2^5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span>）</li></ol><p>2593 的二进制为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>101</mn><mtext> </mtext><mn>0001</mn><mtext> </mtext><mn>00001</mn></mrow><annotation encoding="application/x-tex">101 \space 0001 \space 00001</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span><span class="mspace"> </span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">1</span></span></span></span>，所以 cache 行号为二进制中间部分，即为 1。选项 D 正确。</p><hr /><blockquote><p>下面的叙述中，不正确的是( B C D )。</p><p>A.重复引用相同变量的程序有良好的时间局部性</p><p>B.在CPU和主存间加入了多个cache，计算机总存储量就增加了</p><p>C.CPU要找的指令和数据都能在cache中访问到</p><p>D.主存和cache之间按主存块为单位传送数据时，主存块越大越好</p></blockquote>]]></content>
    
    
    <summary type="html">整理并分析了上课时的部分练习题。</summary>
    
    
    
    <category term="计算机系统" scheme="https://luoyu-ying.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="深入理解计算机系统" scheme="https://luoyu-ying.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Android 自定义 Toast [转载]</title>
    <link href="https://luoyu-ying.github.io/posts/e8e9356f3f9b/"/>
    <id>https://luoyu-ying.github.io/posts/e8e9356f3f9b/</id>
    <published>2022-06-24T06:17:11.000Z</published>
    <updated>2022-06-24T06:17:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章转载自：</p><ul><li><a href="https://blog.csdn.net/liuwan1992/article/details/52710652">Android 自定义Toast，修改Toast样式和显示时长_liuwan1992的博客-CSDN博客</a></li></ul></blockquote><hr /><p>Android 中有一个 Toast 控件，可以用来显示提示信息，还是非常好用的，但是样式和显示时长比较局限。所以我们来自定义一个 Toast ，让它可以显示我们想要的效果，并能设置显示时长。</p><p>首先，在 res\layout 文件夹下创建自定义 Toast 的布局文件 custom_toast.xml，用来设置 Toast 的样式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:id</span>=<span class="string">&quot;@+id/toast_custom_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;fill_parent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:id</span>=<span class="string">&quot;@+id/tvToastContent&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_height</span>=<span class="string">&quot;46dp&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:layout_marginBottom</span>=<span class="string">&quot;75dp&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:background</span>=<span class="string">&quot;@drawable/toast_customer_style&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:gravity</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">android:textColor</span>=<span class="string">&quot;#FFFFFF&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的自定义 Toast 其实就是一个TextView ，其中引用了 res\drawable 文件夹下的一个 shape 样式文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shape</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:shape</span>=<span class="string">&quot;rectangle&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置背景透明度和颜色 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">solid</span> <span class="attr">android:color</span>=<span class="string">&quot;#99000000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置四个角为弧形 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">corners</span> <span class="attr">android:radius</span>=<span class="string">&quot;23dp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">padding</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:left</span>=<span class="string">&quot;23dp&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">android:right</span>=<span class="string">&quot;23dp&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shape</span>&gt;</span></span><br></pre></td></tr></table></figure><p>到这里，所有的布局就已经设计好了，也就是实现了自定义样式，接下来就是在代码中实现自定义 Toast 了，以及实现设置显示时长：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomToast</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">canceled</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler handler;</span><br><span class="line">    <span class="keyword">private</span> Toast toast;</span><br><span class="line">    <span class="keyword">private</span> TimeCount time;</span><br><span class="line">    <span class="keyword">private</span> TextView toast_content;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomToast</span><span class="params">(Context context, ViewGroup viewGroup)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(context, viewGroup, <span class="keyword">new</span> <span class="title class_">Handler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomToast</span><span class="params">(Context context, ViewGroup viewGroup, Handler handler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line"></span><br><span class="line">        <span class="type">View</span> <span class="variable">layout</span> <span class="operator">=</span> LayoutInflater.from(context).inflate(R.layout.custom_toast, viewGroup);</span><br><span class="line">        toast_content = (TextView) layout.findViewById(R.id.tvToastContent);</span><br><span class="line">        <span class="keyword">if</span> (toast == <span class="literal">null</span>) &#123;</span><br><span class="line">            toast = <span class="keyword">new</span> <span class="title class_">Toast</span>(context);</span><br><span class="line">        &#125;</span><br><span class="line">        toast.setGravity(Gravity.BOTTOM, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        toast.setDuration(Toast.LENGTH_LONG);</span><br><span class="line">        toast.setView(layout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text     要显示的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> duration 显示的时间长</span></span><br><span class="line"><span class="comment">     *                 根据LENGTH_MAX进行判断</span></span><br><span class="line"><span class="comment">     *                 如果不匹配，进行系统显示</span></span><br><span class="line"><span class="comment">     *                 如果匹配，永久显示，直到调用hide()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String text, <span class="type">int</span> duration)</span> &#123;</span><br><span class="line">        time = <span class="keyword">new</span> <span class="title class_">TimeCount</span>(duration, <span class="number">1000</span>);</span><br><span class="line">        toast_content.setText(text);</span><br><span class="line">        <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">            time.start();</span><br><span class="line">            canceled = <span class="literal">false</span>;</span><br><span class="line">            showUntilCancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 隐藏Toast</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hide</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (toast != <span class="literal">null</span>) &#123;</span><br><span class="line">            toast.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        canceled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">showUntilCancel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        toast.show();</span><br><span class="line">        handler.postDelayed(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                showUntilCancel();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计时器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TimeCount</span> <span class="keyword">extends</span> <span class="title class_">CountDownTimer</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TimeCount</span><span class="params">(<span class="type">long</span> millisInFuture, <span class="type">long</span> countDownInterval)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(millisInFuture, countDownInterval); <span class="comment">// 总时长,计时的时间间隔</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFinish</span><span class="params">()</span> &#123; <span class="comment">// 计时完毕时触发</span></span><br><span class="line">            hide();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onTick</span><span class="params">(<span class="type">long</span> millisUntilFinished)</span> &#123; <span class="comment">// 计时过程显示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要通过一个倒计时器和异步线程来实现设置显示时长。TimeCount 有两个参数，第一个是倒计时时长，也就是 Toast 要显示的时长，第二个是间隔时间，在倒计时内每隔一定时间会回调一次 onTick 方法，倒计时结束后回调 onFinish 方法。在倒计时器中我 们要设置的只有倒计时时长，即显示时长，时间到了就 cancel() 掉 Toast。在对 Toast 初始化时，默认设置的显示时长是LENGTH_LONG ，为2.5s。那么问题来了，3s以内倒计时器可以控制显示时长，但是超过3s Toast 就自行结束了，如果我们想要显示超过三秒怎么办，所以这里通过一个异步线程，并设置一个 postDelayed 任务，推迟3s执行，在线程中调用自身的方法，实现循环调用。 这样每隔3s显示一次 Toast ，达到了一直显示的效果。然后通过 canceled 属性，将倒计时器和异步线程联系到一起，这样就可以通过 Handler 让 Toast 一直显示，再通过 TimeCount 让 Toast 结束显示，达到了自定义显示时长的效果。</p><p>具体调用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CustomToast toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">toastMessage</span><span class="params">(String content)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (toast != <span class="literal">null</span>) &#123;</span><br><span class="line">        toast.hide();</span><br><span class="line">    &#125;</span><br><span class="line">    toast = <span class="keyword">new</span> <span class="title class_">CustomToast</span>(LoginActivity.<span class="built_in">this</span>,</span><br><span class="line">                            (ViewGroup) <span class="built_in">this</span>.findViewById(R.id.toast_custom_parent));</span><br><span class="line">    toast.show(content, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以在 onClick 等事件中通过调用 toastMessage(&quot;自定义 Toast 的显示内容 &quot;); 来显示你想要给用户看到的提示内容了。</p>]]></content>
    
    
    <summary type="html">转载了一篇可以自定义样式和显示时长的自定义Toast类。</summary>
    
    
    
    <category term="Android" scheme="https://luoyu-ying.github.io/categories/Android/"/>
    
    
    <category term="Toast" scheme="https://luoyu-ying.github.io/tags/Toast/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解计算机系统》 第三章 学习笔记</title>
    <link href="https://luoyu-ying.github.io/posts/9d9a45889a2d/"/>
    <id>https://luoyu-ying.github.io/posts/9d9a45889a2d/</id>
    <published>2022-06-21T02:57:28.000Z</published>
    <updated>2022-06-21T02:57:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li>《深入理解计算机系统》</li><li><a href="https://zhuanlan.zhihu.com/p/94406822">「抄书笔记」Machine Level Programming - 知乎 (zhihu.com)</a></li><li><a href="https://space.bilibili.com/354767108">九曲阑干的个人空间_哔哩哔哩_bilibili</a></li></ul><h1 id="寄存器"><a class="markdownIt-Anchor" href="#寄存器"></a> 寄存器</h1><h2 id="调用者保存"><a class="markdownIt-Anchor" href="#调用者保存"></a> 调用者保存</h2><p>调用者保存是指当P函数调用Q函数时，该寄存器中的内容由调用者P负责保存，Q可以直接使用该寄存器。</p><h2 id="被调用者保存"><a class="markdownIt-Anchor" href="#被调用者保存"></a> 被调用者保存</h2><p>被调用者保存是指当P函数调用Q函数时，该寄存器中的内容由被调用者Q负责保存。</p><h2 id="调用者保存寄存器caller-saved-registers"><a class="markdownIt-Anchor" href="#调用者保存寄存器caller-saved-registers"></a> 调用者保存寄存器（<code>caller saved registers</code>）</h2><p>也叫<strong>易失性寄存器</strong>，在程序调用的过程中，这些寄存器中的值不需要被保存（即压入到栈中再从栈中取出），如果某一个程序需要保存这个寄存器的值，需要调用者自己压入栈；</p><h2 id="被调用者保存寄存器callee-saved-registers"><a class="markdownIt-Anchor" href="#被调用者保存寄存器callee-saved-registers"></a> 被调用者保存寄存器（<code>callee saved registers</code>）</h2><p>也叫<strong>非易失性寄存器</strong>，在程序调用过程中，这些寄存器中的值需要被保存，不能被覆盖；当某个程序调用这些寄存器，被调用寄存器会先保存这些值然后再进行调用，且在调用结束后恢复被调用之前的值；</p><h2 id="寄存器及其功能"><a class="markdownIt-Anchor" href="#寄存器及其功能"></a> 寄存器及其功能</h2><p>其中，<code>rsp</code> 表示的是运行时栈结束的位置，即栈顶的位置。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-909063cd57cd5b2136ff8ed4d04bc5e6_1440w.jpg" alt="img" style="zoom:57%;" /><h1 id="汇编指令后缀"><a class="markdownIt-Anchor" href="#汇编指令后缀"></a> 汇编指令后缀</h1><p>如 <code>movq</code>，<code>callq</code>，<code>movl</code> 等等。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621113704881.png" alt="image-20220621113704881" style="zoom:40%;" /><h1 id="操作数格式"><a class="markdownIt-Anchor" href="#操作数格式"></a> 操作数格式</h1><p>比例因子的取值和源代码中存储对象的类型有关，且只能为1，2，4，8（分别对应着 <code>char</code>，<code>short</code>，<code>int</code>，<code>long</code>四个数据类型）。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625211452247.png" alt="image-20220625211452247" style="zoom:80%;" /><h1 id="mov-指令"><a class="markdownIt-Anchor" href="#mov-指令"></a> <code>MOV</code> 指令</h1><p>源操作数和目的操作数不能同时为寄存器地址。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621180210624.png" alt="image-20220621180210624" style="zoom: 80%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621182452659.png" alt="image-20220621182452659" style="zoom:67%;" /><h2 id="movq-movabsq"><a class="markdownIt-Anchor" href="#movq-movabsq"></a> <code>MOVQ</code> &amp; <code>MOVABSQ</code></h2><p>当出现 <code>MOVQ $Imm Destination</code> 指令时，该立即数只能是32位的补码表示，然后对该数值进行符号位扩展之后，将得到的64位数传送到目的位置。</p><p>这个限制会带来一个问题，就是如果立即数是64位时该如何处理？</p><p>这里引入了一个新的指令 <code>MOVABSQ $Imm Register</code> ，这里存放的可以是任意的64位立即数，但是目的操作数只能是寄存器。</p><h2 id="movl"><a class="markdownIt-Anchor" href="#movl"></a> <code>MOVL</code></h2><p>当 <code>MOVL</code> 的目的操作数是寄存器时，它会把该寄存器的高4字节设置为0，这是64位处理器的一个规定。即任何为寄存器生成32位值的指令都会把该寄存器的高位部分置为0。</p><h2 id="movz-movs"><a class="markdownIt-Anchor" href="#movz-movs"></a> <code>MOVZ</code> &amp; <code>MOVS</code></h2><p>当源操作数的数位小于目的操作数时，便会对目的操作数剩余的字节进行扩展。</p><p>指令的最后两个字符表示了源操作数的大小以及目的操作数的大小。</p><p>零扩展中没有的 <code>movzlq</code> 指令可以通过 <code>movl</code> 指令实现。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-f59c8e900d14a5597a87959a6df649c7_720w.jpg" alt="img" style="zoom: 90%;" /><h1 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h1><h2 id="栈的结构"><a class="markdownIt-Anchor" href="#栈的结构"></a> 栈的结构</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621183231538.png" alt="image-20220621183231538" style="zoom: 67%;" /><p>栈的顶部在图中的底部，栈顶的元素时所有栈中元素地址最低的。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-429b736ec876e982f38a9f651303e9fa_720w.jpg" alt="img" style="zoom: 80%;" /><h2 id="push"><a class="markdownIt-Anchor" href="#push"></a> <code>PUSH</code></h2><p>使用 <code>push</code> 指令将数据压入栈内。</p><p>例如 <code>pushq %rax</code> 指令执行的过程可以分为两步：</p><ol><li>指向栈顶的寄存器 <code>rsp</code> 进行一个减法操作 <code>subq $8, %rsp</code>。</li><li>将需要保存的元素复制到新的栈顶位置 <code>movq %rax, (%rsp)</code>。</li></ol><h2 id="pop"><a class="markdownIt-Anchor" href="#pop"></a> <code>POP</code></h2><p>使用 <code>pop</code> 指令从内存中读取数据，并且修改栈顶指针。</p><p>例如 <code>popq %rbx</code> 指令就是将栈顶保存的数据复制到寄存器<code>rbx</code>中，该指令同样也可以分解成两步：</p><ol><li>从栈顶的位置读出数据，复制到寄存器 <code>rbx</code>：<code>movq (%rsp), %rbx</code>。</li><li>将栈顶的指针加8（因为 <code>q</code> 表示的是8个字节）：<code>addq $8, %rsp</code>。</li></ol><h1 id="算数和逻辑运算指令"><a class="markdownIt-Anchor" href="#算数和逻辑运算指令"></a> 算数和逻辑运算指令</h1><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-af64fab6c6832e1d6f6ff4dcebb0a07a_720w.jpg" alt="img" style="zoom: 80%;" /><h2 id="lea"><a class="markdownIt-Anchor" href="#lea"></a> <code>LEA</code></h2><p>实现的功能为加载有效的地址，即将计算出的源操作数的值直接写入到目的寄存器中。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621184454652.png" alt="image-20220621184454652" style="zoom: 67%;" /><p>其中，<code>q</code>表示为加载的地址的长度为8个字节。因为64位系统中地址的长度都是64位，所以不存在 <code>leab</code>，<code>leaw</code>这类有关大小的变种。</p><p>例如，<code>leaq 7(%rdx, %rdx, 4), %rax</code> ，它表示的含义是把有效地址复制到寄存器<code>rax</code>中。其中，有效地址的计算方式与之前讲到的内存地址的计算方式一致。</p><p>除了加载有效地址的功能，<code>leaq</code> 指令还可以用来表示加法和有限的乘法运算（比例因子的取值只能为1，2，4，8这四个数中的一个）。</p><h2 id="一元操作"><a class="markdownIt-Anchor" href="#一元操作"></a> 一元操作</h2><p>第一个操作数既是源操作数，也是目的操作数，可以是寄存器，也可以是内存地址。</p><h2 id="二元操作"><a class="markdownIt-Anchor" href="#二元操作"></a> 二元操作</h2><p>第二个操作数既是源操作数，也是目的操作数，但是其不能是立即数。</p><p>需要注意，<code>sub</code> 指令的减数和被减数的操作数位置，为第二个操作数减第一个操作数。</p><h2 id="移位操作"><a class="markdownIt-Anchor" href="#移位操作"></a> 移位操作</h2><p>两个左移的指令效果相同。</p><p>对于移位量k，可以是一个立即数，<strong>或者是放在寄存器 <code>cl</code> 中的数</strong>。</p><p>对于移位指令，只允许以特定的寄存器cl作为操作数，其他的寄存器不行，这里需要特别注意。</p><h2 id="其他特殊的算数指令"><a class="markdownIt-Anchor" href="#其他特殊的算数指令"></a> 其他特殊的算数指令</h2><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621195341299.png" alt="image-20220621195341299" /></p><h1 id="条件码寄存器"><a class="markdownIt-Anchor" href="#条件码寄存器"></a> 条件码寄存器</h1><p>ALU（算数执行单元）除了执行算数和逻辑运算指令外，还会根据该运算的结果去设置条件码寄存器。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621192149338.png" alt="image-20220621192149338" style="zoom:67%;" /><p>CPU 维护一组单个位的条件码寄存器，检测条件分支指令，描述了最近执行操作的属性。</p><ul><li><p>CF</p><blockquote><p><code>Carry Flag</code> —— 进位标志</p></blockquote><p>最近的操作让最高位进位，可以检查无符号操作数的溢出。</p></li><li><p>ZF</p><blockquote><p><code>Zero Flag</code> —— 零标志</p></blockquote><p>当最近操作的结果等于0时，需标志(ZF)会被置为1。</p></li><li><p>SF</p><blockquote><p><code>Sign Flag</code> —— 符号标志</p></blockquote><p>当最近的操作结果小于零时，符号标志(SF)会被置为1。</p></li><li><p>OF</p><blockquote><p><code>Overflow Flag</code> —— 溢出标志</p></blockquote><p>针对有符号数，最近的操作导致正溢出或者负溢出时，溢出标志(OF)会被置1（操作导致补码溢出）。</p></li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621192305450.png" alt="image-20220621192305450" style="zoom:67%;" /><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621195556936.png" alt="image-20220621195556936" /></p><h2 id="cmp"><a class="markdownIt-Anchor" href="#cmp"></a> <code>CMP</code></h2><p><code>cmp</code>指令是根据两个操作数的差来设置条件码寄存器，为第二个操作数减去第一个操作数。</p><p><code>cmp</code>指合和减法指令(<code>sub</code>)类似，也是根据两个操作数的差来设置条件码。二者不同的是cmp指令只是设置条件码寄存器，并不会更新目的寄存器的值。</p><p>指令<code>cmp</code>会根据差的结果来设置符号标志(SF)和溢出标志(OF)。</p><p>如果与 <code>CMOV</code> 指令一起使用的话，那么这个指令的含义便可以理解为，<strong>将第二个操作数与第一个操作数进行比较</strong>，比较的内容为 <code>CMOV</code> 指令中的内容。注意，一定是第二个操作数在比较符号之前，第一个操作数在符号之后。</p><h2 id="test"><a class="markdownIt-Anchor" href="#test"></a> <code>TEST</code></h2><p><code>test</code>指令和 <code>and</code> 指令类似，同样 <code>test</code> 指令只是设置条件码寄存器，并不会更新目的寄存器的值。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625160659795.png" alt="image-20220625160659795" style="zoom:67%;" /><h2 id="set"><a class="markdownIt-Anchor" href="#set"></a> <code>SET</code></h2><p>使用 <code>set</code> 指令，根据条件码寄存器中不同组合的对应的计算结果，将结果值复制到目的寄存器中。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621195516682.png" alt="SET 指令" /></p><h1 id="跳转指令与循环"><a class="markdownIt-Anchor" href="#跳转指令与循环"></a> 跳转指令与循环</h1><p>在汇编代码中，判断、循环语句的实现基本采用C语言中<code>goto</code>语句的实现方式。所以了解<code>goto</code>语句，能够更加容易掌握这部分知识。</p><h2 id="jump"><a class="markdownIt-Anchor" href="#jump"></a> <code>JUMP</code></h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621211143827.png" alt="image-20220621211143827" style="zoom:67%;" /><h3 id="跳转指令的编码"><a class="markdownIt-Anchor" href="#跳转指令的编码"></a> 跳转指令的编码</h3><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621211915713.png" alt="image-20220621211915713" /></p><h2 id="cmov"><a class="markdownIt-Anchor" href="#cmov"></a> <code>CMOV</code></h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625183509367.png" alt="image-20220625183509367" style="zoom:80%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621211422154.png" alt="image-20220621211422154" style="zoom:80%;" /><h2 id="判断语句"><a class="markdownIt-Anchor" href="#判断语句"></a> 判断语句</h2><h3 id="if-语句"><a class="markdownIt-Anchor" href="#if-语句"></a> <code>if</code> 语句</h3><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621212901469.png" alt="image-20220621212901469" style="zoom: 50%;" /><p><strong>使用例</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621212656994.png" alt="image-20220621212656994" style="zoom: 80%;" /><p>判断语句除了可以使用传统的 <code>jump</code> 指令，也可以通过更加高效的 <code>cmov</code> 指令实现。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621213135058.png" alt="image-20220621213135058" style="zoom: 67%;" /><h3 id="switch-语句"><a class="markdownIt-Anchor" href="#switch-语句"></a> <code>switch</code> 语句</h3><blockquote><p>switch（开关）语句可以根据一个整数索引值进行多重分支 (multiway branching) 。在 处理具有多种可能结果的测试时，这种语句特别有用。</p><p>它们不仅提高了 C 代码的可读性， 而且通过使用跳转表(jump table) 这种数据结构使得实现更加高效。</p><p>跳转表是一个数组，表项 i 是一个代码段的地址，这个代码段实现当开关索引值等于 i 时程序应该采取的动作。</p><p>和使用一 组很长的 if-else 语句相比，使用跳转表的优点是执行开关语句的时间与开关情况的数量无关。 当 switch 语句有上百种情况的时候，也可以只用一次跳转表访问去处理。</p><p>GCC 根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句。当开关情况数量比较多（例如 4 个以上），并且值的范围跨度比较小时，就会使用跳转表。情况数量较少或者值的范围跨度比较大时，会使用非常多的 <code>CMP</code> 指令，其实在这种情况下和使用多个 <code>if-else if</code> 一样。</p></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625191557467.png" alt="image-20220625191557467" style="zoom:80%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625191608408.png" alt="image-20220625191608408" style="zoom:80%;" /><h2 id="循环结构"><a class="markdownIt-Anchor" href="#循环结构"></a> 循环结构</h2><p>循环语句是通过条件测试和跳转语句的结合来实现的。</p><h3 id="do-while循环"><a class="markdownIt-Anchor" href="#do-while循环"></a> <code>do-while</code>循环</h3><p>    <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625183700482.png" alt="image-20220625183700482" style="zoom:80%;" />    <br><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625183817630.png" alt="image-20220625183817630" style="zoom:80%;" /></p><p><strong>使用例</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220621213819867.png" alt="image-20220621213819867" style="zoom: 60%;" /><h3 id="while-循环"><a class="markdownIt-Anchor" href="#while-循环"></a> <code>while</code> 循环</h3><p>    <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625184638266.png" alt="image-20220625184638266" style="zoom:80%;" /></p> <p><strong>第一种翻译方法</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625184745056.png" alt="image-20220625184745056" style="zoom: 77%;" /><p><strong>第一种使用例</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625184927353.png" alt="image-20220625184927353" style="zoom:80%;" /><p><strong>第二种翻译方法</strong></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625185034919.png" alt="image-20220625185034919" style="zoom:80%;" /><br><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625185056071.png" alt="image-20220625185056071" style="zoom:80%;" /></p><p><strong>第二种使用例</strong></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625185240724.png" alt="image-20220625185240724" style="zoom:80%;" /><br><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625185305176.png" alt="image-20220625185305176" style="zoom:80%;" /><br><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625185319542.png" alt="image-20220625185319542" style="zoom:80%;" /></p><h3 id="for-循环"><a class="markdownIt-Anchor" href="#for-循环"></a> <code>for</code> 循环</h3><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625185948500.png" alt="image-20220625185948500" style="zoom:80%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220625190037921.png" alt="image-20220625190037921" style="zoom:80%;" />]]></content>
    
    
    <summary type="html">《深入理解计算机系统》的第三章学习笔记。</summary>
    
    
    
    <category term="计算机系统" scheme="https://luoyu-ying.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="深入理解计算机系统" scheme="https://luoyu-ying.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解计算机系统》 第二章 学习笔记</title>
    <link href="https://luoyu-ying.github.io/posts/c0ead3b585d4/"/>
    <id>https://luoyu-ying.github.io/posts/c0ead3b585d4/</id>
    <published>2022-06-14T00:30:41.000Z</published>
    <updated>2022-06-19T00:30:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><ul><li>《深入理解计算机操作系统》</li><li><a href="https://space.bilibili.com/354767108">九曲阑干</a> 大佬的一系列视频<ul><li><a href="https://www.bilibili.com/video/BV1tV411U7N3">【CSAPP-深入理解计算机系统】2-1.信息的存储(上)_哔哩哔哩_bilibili</a></li><li>…</li></ul></li></ul><h1 id="信息存储"><a class="markdownIt-Anchor" href="#信息存储"></a> 信息存储</h1><h2 id="系统程序向后兼容"><a class="markdownIt-Anchor" href="#系统程序向后兼容"></a> 系统程序向后兼容</h2><ul><li>64位系统可以生成并使用32位程序。</li><li>32位系统无法使用64位程序。</li></ul><h2 id="c语言中数据类型所占用的字节数"><a class="markdownIt-Anchor" href="#c语言中数据类型所占用的字节数"></a> C语言中数据类型所占用的字节数</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614091625732.png" alt="image" style="zoom: 40%;" /><p>注意：</p><ol><li><code>long</code> 数据类型的取值范围与机器字长相关。</li></ol><h2 id="数据在内存中的存储顺序"><a class="markdownIt-Anchor" href="#数据在内存中的存储顺序"></a> 数据在内存中的存储顺序</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614091915842.png" alt="image" style="zoom: 67%;" /><ul><li>图中左边为低有效字节，右边为高有效字节。</li><li>大多数 Intel 兼容机、Linux、Android、IOS 都是采用小端模式。</li><li>IBM 和 SUN 公司的大多数机器都是采用的大端模式。</li><li>基于 ARM 架构的处理器则支持双端法，即同时支持上述两个模式。</li></ul><h2 id="布尔运算"><a class="markdownIt-Anchor" href="#布尔运算"></a> 布尔运算</h2><table><thead><tr><th>操作</th><th>符号</th></tr></thead><tbody><tr><td>与</td><td>AND</td></tr><tr><td>或</td><td>OR</td></tr><tr><td>非</td><td>NOT</td></tr><tr><td>异或</td><td>XOR</td></tr></tbody></table><h2 id="掩码"><a class="markdownIt-Anchor" href="#掩码"></a> 掩码</h2><p>掩码是一串二进制代码。对目标字段进行位与运算，从而屏蔽当前的输入位。</p><h2 id="逻辑运算"><a class="markdownIt-Anchor" href="#逻辑运算"></a> 逻辑运算</h2><table><thead><tr><th>操作</th><th>符号</th></tr></thead><tbody><tr><td>与</td><td>AND</td></tr><tr><td>或</td><td>OR</td></tr><tr><td>非</td><td>NOT</td></tr></tbody></table><p>注意：</p><ol><li>逻辑运算的结果只有 true 和 false。</li></ol><h2 id="位移运算"><a class="markdownIt-Anchor" href="#位移运算"></a> 位移运算</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614102822234.png" alt="image" style="zoom: 67%;" /><p>注意：</p><ol><li><p>算术右移高位填充的是原来数字的符号位。</p></li><li><p>几乎所有的编译器以及及其的组合都是对有符号数使用算术右移。</p></li></ol><h1 id="整数表示"><a class="markdownIt-Anchor" href="#整数表示"></a> 整数表示</h1><h2 id="无符号数编码"><a class="markdownIt-Anchor" href="#无符号数编码"></a> 无符号数编码</h2><p>无符号数只能表示非负数。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614103830722.png" alt="image" style="zoom:67%;" /><p>B2U：Binary to unsigned。</p><p>下图为无符号数的图形化表示。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614104406695.png" alt="image" style="zoom:40%;" /><h2 id="负数的编码补码"><a class="markdownIt-Anchor" href="#负数的编码补码"></a> 负数的编码（补码）</h2><p>计算机系统中存储负数基本采用补码的形式。<strong>补码 = 反码 + 1。</strong></p><p>     <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614105129560.png" alt="image" style="zoom:53%;" />    <center><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614105643185.png" alt="image" style="zoom:40%;" /></center></p><p>需要注意的是最高位的权重为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><msup><mn>2</mn><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">-2^{w-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 。当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_{w-1} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，表示非负数；当 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>w</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x_{w-1} = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，表示负数。</p><p>不能仅仅把最高位当成符号位看待，我们需要着重理解 <strong>负权重</strong> 的概念。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614105801516.png" alt="image" style="zoom:50%;" /><p>下图为图形化表示法，可以更加清晰的看到补码的计算过程。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614110234849.png" alt="image" style="zoom:40%;" /><p>注意：</p><ol><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> 的补码和无符号数的最大数有着相同的表示形式。</li><li>对于相同的位模式，映射函数的不同，得到的数值也会不同。</li></ol><h2 id="有符号数转换为无符号数"><a class="markdownIt-Anchor" href="#有符号数转换为无符号数"></a> 有符号数转换为无符号数</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614112013343.png" alt="image-20220614" style="zoom:40%;" /><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 表示有符号数的二进制位数。</p><h2 id="无符号数转换为有符号数"><a class="markdownIt-Anchor" href="#无符号数转换为有符号数"></a> 无符号数转换为有符号数</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220614112202660.png" alt="image-20220614" style="zoom:40%;" /><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span> 表示无符号数的二进制位数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>T</mi><mtext> </mtext><mi>M</mi><mi>a</mi><msub><mi>x</mi><mi>w</mi></msub></mrow><annotation encoding="application/x-tex">T \space Max_{w}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示有符号数的最大值。</p><h2 id="强制类型转换"><a class="markdownIt-Anchor" href="#强制类型转换"></a> 强制类型转换</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/usual_arithmetic_conversion.png" alt="Usual Arithmetic Conversion" style="zoom:80%;" /><h1 id="整数运算"><a class="markdownIt-Anchor" href="#整数运算"></a> 整数运算</h1><h2 id="加法运算"><a class="markdownIt-Anchor" href="#加法运算"></a> 加法运算</h2><h3 id="无符号数加法"><a class="markdownIt-Anchor" href="#无符号数加法"></a> 无符号数加法</h3><p>例如，两个 <code>unsigned char</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>127</mn><mi mathvariant="normal">、</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">127、1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">7</span><span class="mord cjk_fallback">、</span><span class="mord">1</span></span></span></span> 相加，得到的结果不为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>128</mn></mrow><annotation encoding="application/x-tex">128</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord">8</span></span></span></span> ，而是为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p><p>我们定义符号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mo>+</mo><mi>w</mi><mi>u</mi></msubsup><mi>y</mi></mrow><annotation encoding="application/x-tex">+^u_{w}y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.911392em;vertical-align:-0.247em;"></span><span class="mord"><span class="mbin">+</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 表示 <code>unsigned</code> 类型、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位的整数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619194945095.png" alt="image-20220619" style="zoom: 60%;" /><p>通过程序判定是否溢出：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619195136224.png" alt="image-20220619" style="zoom:60%;" /><h3 id="有符号数加法"><a class="markdownIt-Anchor" href="#有符号数加法"></a> 有符号数加法</h3><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619195234384.png" alt="image-20220619" style="zoom:50%;" /><p>判断是否发生了溢出：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619195512632.png" alt="image" style="zoom:50%;" /><h2 id="减法运算"><a class="markdownIt-Anchor" href="#减法运算"></a> 减法运算</h2><p>减法操作在计算机中通过使用 <strong>加法逆元</strong> 实现。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619200901107.png" alt="image-20220619200901107" style="zoom:57%;" /><p>在上图中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">x&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> 就是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 的加法逆元，其中满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><msup><mi>x</mi><mo mathvariant="normal">′</mo></msup><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x + x&#x27; = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p><h3 id="无符号数减法"><a class="markdownIt-Anchor" href="#无符号数减法"></a> 无符号数减法</h3><p>无符号数的加法逆元为：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619201018960.png" alt="image-20220619201018960" style="zoom:67%;" /><p>由于无符号数中没有负数，我们通过溢出的方式使得两个无符号数相加和为 0。</p><h3 id="有符号数减法"><a class="markdownIt-Anchor" href="#有符号数减法"></a> 有符号数减法</h3><p>有符号数的加法逆元如下图：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619201235671.png" alt="image-20220619201235671" style="zoom:57%;" /><p>注意，有符号数的正负数表示范围并非对称，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>T</mi><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub><mi mathvariant="normal">∣</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>T</mi><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>w</mi></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|T min_w|=|T max_w| + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，所以对最小值进行单独计算，得出 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∣</mi><mi>T</mi><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>w</mi></msub><mi mathvariant="normal">∣</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∣</mi><mi>T</mi><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>w</mi></msub><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">-(|T max_w| + 1) = |T min_w|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mopen">(</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span></span></span></span> ，即最小值的加法逆元为其本身。</p><h2 id="乘法运算"><a class="markdownIt-Anchor" href="#乘法运算"></a> 乘法运算</h2><p>对于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位的无符号数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>，两者的乘积可能需要 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>w</mi></mrow><annotation encoding="application/x-tex">2w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位来表示。在 C 语言中，定义了无符号数乘法所产生的结果为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位，所以运行结果会截取 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mi>w</mi></mrow><annotation encoding="application/x-tex">2w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 中的低 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> 位。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220619202338552.png" alt="image-20220619202324281" style="zoom:60%;" />]]></content>
    
    
    <summary type="html">整理了《深入理解计算机系统》第二章的部分知识点。</summary>
    
    
    
    <category term="计算机系统" scheme="https://luoyu-ying.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="深入理解计算机系统" scheme="https://luoyu-ying.github.io/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Microsoft Word 使用自定义论文样式集</title>
    <link href="https://luoyu-ying.github.io/posts/9fff5beeee26/"/>
    <id>https://luoyu-ying.github.io/posts/9fff5beeee26/</id>
    <published>2022-06-09T00:19:33.000Z</published>
    <updated>2022-06-13T00:19:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ol><li>本文仅提供设置方法，每一项的具体的字体字号根据学校的要求请另行更改。</li><li>本文将修改部分源文件，请<strong>及时备份相关文件</strong> 。</li></ol></blockquote><h1 id="效果"><a class="markdownIt-Anchor" href="#效果"></a> 效果</h1><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220609083109777.png" alt="image" style="zoom: 67%;" /><h1 id="样式设置方法"><a class="markdownIt-Anchor" href="#样式设置方法"></a> 样式设置方法</h1><h2 id="打开设置文件必做"><a class="markdownIt-Anchor" href="#打开设置文件必做"></a> 打开设置文件(必做)</h2><blockquote><p><strong>注意及时备份源文件!</strong></p></blockquote><ol><li><p>进入以下目录文件夹：<code>C:\Users\XXX\AppData\Roaming\Microsoft\Templates</code>。</p><p>如果 Microsoft Word 被安装在其他路径，请自行寻找。</p></li><li><p>打开其中的<code>Normal.dotm</code>文件。</p></li><li><p><strong>删除样式栏中所有已存在的样式。</strong></p></li></ol><h2 id="更改正文样式"><a class="markdownIt-Anchor" href="#更改正文样式"></a> 更改正文样式</h2><p>待添加…</p><h2 id="更改标题样式"><a class="markdownIt-Anchor" href="#更改标题样式"></a> 更改标题样式</h2><p>待添加…</p><h2 id="更改表格样式"><a class="markdownIt-Anchor" href="#更改表格样式"></a> 更改表格样式</h2><p>待添加…</p><h2 id="添加标题序号"><a class="markdownIt-Anchor" href="#添加标题序号"></a> 添加标题序号</h2><p>待添加…</p><h2 id="添加自定义题注"><a class="markdownIt-Anchor" href="#添加自定义题注"></a> 添加自定义题注</h2><p>待添加…</p><h1 id="其他-word-使用技巧"><a class="markdownIt-Anchor" href="#其他-word-使用技巧"></a> 其他 Word 使用技巧</h1><h2 id="页码设置"><a class="markdownIt-Anchor" href="#页码设置"></a> 页码设置</h2><p>待添加…</p><h2 id="去除标题前的小黑点"><a class="markdownIt-Anchor" href="#去除标题前的小黑点"></a> 去除标题前的小黑点</h2><p>我们以下图 <strong>标题3</strong> 前的小黑点为例：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220613184750085.png" alt="image" style="zoom: 80%;" /><ol><li><p>右击样式栏中对应的样式。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220613184856465.png" alt="image" style="zoom:67%;" /></li><li><p>依次选择：</p><p><strong>修改 &gt;&gt; 格式 &gt;&gt; 段落 &gt;&gt; 换行和分页</strong></p><p>进入下图中页面。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220613185044904.png" alt="image" style="zoom:67%;" /></li><li><p>将上图中的 <strong>与下段相同</strong> 和 <strong>段中不分页</strong> 前面的两个对号取消。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220613185210761.png" alt="image" style="zoom: 67%;" /></li><li><p>依次点击：</p><p><strong>确认 &gt;&gt; 确认</strong></p><p>返回文档编辑页面，即可发现 <strong>标题3</strong> 前面的小黑点已经消失了。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220613185459976.png" alt="image" style="zoom:80%;" /></li></ol><h1 id="如何将设置好的样式分享"><a class="markdownIt-Anchor" href="#如何将设置好的样式分享"></a> 如何将设置好的样式分享</h1><ol><li>发送该<code>Normal.dotm</code>文件到接收方。</li><li>在接收方的电脑上替换该文件。</li><li>重启 Microsoft Word，新建文档即可使用。</li></ol><h1 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h1><ol><li><p>已经创建的文档内的样式无法自动更改。</p><p>可以通过新建文档并复制原文档中的内容获取论文样式集。</p></li></ol>]]></content>
    
    
    <summary type="html">能够让自己以后每次打开 Word 都可以直接使用论文的样式集。</summary>
    
    
    
    <category term="Microsoft Applications" scheme="https://luoyu-ying.github.io/categories/Microsoft-Applications/"/>
    
    <category term="Windows OS" scheme="https://luoyu-ying.github.io/categories/Windows-OS/"/>
    
    
    <category term="Microsoft Office" scheme="https://luoyu-ying.github.io/tags/Microsoft-Office/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Butterfly 修改侧边栏分类排序规则</title>
    <link href="https://luoyu-ying.github.io/posts/bd6604dc1b1f/"/>
    <id>https://luoyu-ying.github.io/posts/bd6604dc1b1f/</id>
    <published>2022-06-08T12:51:35.000Z</published>
    <updated>2022-06-08T12:51:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> 问题</h1><p><code>Hexo Butterfly</code> 主题中，主页侧边栏中的 <code>categories</code> 默认显示顺序是按 <code>name</code> 排序，导致某些分类下虽然文章数量较少，但却排序靠前。并且默认设置下，主题中侧边 <code>categories</code> 只显示8条（如需修改可以修改<strong>主题配置文件</strong>）。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220608210201564.png" alt="image" style="zoom:67%;" /><p>便想将其修改为 <strong>按照分类内文章的数量进行降序排序</strong> 。</p><h1 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h1><blockquote><p>该方法需要修改源代码，建议及时备份需要修改的文件。</p></blockquote><ol><li><p>找到 <code>themes\butterfly\scripts\helpers\aside_categories.js</code> 文件，并修改源代码。</p></li><li><p>修改以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const orderby = options.orderby || &#x27;name&#x27; // 默认-&gt;name-&gt;按categories字母顺序</span></span><br><span class="line"><span class="keyword">const</span> orderby = options.<span class="property">orderby</span> || <span class="string">&#x27;length&#x27;</span>  <span class="comment">// length-&gt;按categories下文章数量排序</span></span><br><span class="line"><span class="comment">// const order = options.order || 1  // 默认-&gt;1-&gt;升序 -1-&gt;逆序</span></span><br><span class="line"><span class="keyword">const</span> order = options.<span class="property">order</span> || -<span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>执行 <code>hexo g &amp;&amp; hexo d</code> 查看修改效果。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220608205749969.png" alt="image" style="zoom: 67%;" /></li></ol><h1 id="参考教程"><a class="markdownIt-Anchor" href="#参考教程"></a> 参考教程</h1><ul><li><a href="https://www.yanchengxu.top/hexo-categories-sort/">【Hexo-Butterfly】修改侧边栏分类排序规则 | yanchengxu</a></li></ul>]]></content>
    
    
    <summary type="html">记录了修改侧边栏分类模块的排序规则的方法。</summary>
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Butterfly 字体修改</title>
    <link href="https://luoyu-ying.github.io/posts/01f186841de9/"/>
    <id>https://luoyu-ying.github.io/posts/01f186841de9/</id>
    <published>2022-06-07T13:17:24.000Z</published>
    <updated>2022-06-07T13:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备字体"><a class="markdownIt-Anchor" href="#准备字体"></a> 准备字体</h1><blockquote><p>注意字体的版权！</p></blockquote><p>自行下载需要的字体。</p><p>本文使用的是 <code>Intellij IDEA</code> 文件中的 <code>JetBrainsMono-Regular.ttf</code>。</p><p>在 <code>themes/butterfly/source/</code> 下创建 <code>font</code> 文件夹，将下载好的字体放入 <code>font</code> 文件夹中。</p><p>其中，<code>Hexo Butterfly</code> 已默认支持 <strong><code>Microsoft YaHei</code></strong> ，无需另行下载。</p><h1 id="创建-css-文件"><a class="markdownIt-Anchor" href="#创建-css-文件"></a> 创建 <code>CSS</code> 文件</h1><p>在<code>themes/butterfly/source/css/</code>下创建<code>article-font.css</code> 并编辑该文件。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;JetBrainsMono&#x27;</span>;</span><br><span class="line">    <span class="attribute">font-display</span>: swap;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;../font/JetBrainsMono-Regular.ttf&#x27;</span>) <span class="built_in">format</span>(<span class="string">&quot;truetype&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将所有非代码部分的文字更改为自定义字体 */</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;JetBrainsMono&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 仅将博客正文中的非代码部分的文字更改为自定义字体 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#article-container &#123;</span></span><br><span class="line"><span class="comment">    font-family: &#x27;JetBrainsMono&#x27;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>第一段代码必须写入 <code>CSS</code> 文件中。</p><ul><li><strong><code>font-family</code> ：</strong> 其他文件引用该字体的名称，更改为自己所需的名称。</li><li><strong><code>src: url()</code> ：</strong> 更改为自己准备的字体的路径。</li></ul><p>第二段和第三段代码根据自己所需的改变范围自行选择其中一个。其中第二段代码改变的范围为所有页面的所有非代码部分的文字。</p><h1 id="引入-css-文件"><a class="markdownIt-Anchor" href="#引入-css-文件"></a> 引入 <code>CSS</code> 文件</h1><p>编辑 <code>_config.butterfly.yml</code>，引入 <code>article-font.css</code>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Inject</span></span><br><span class="line"><span class="comment"># Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)</span></span><br><span class="line"><span class="comment"># 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/article-font.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>修改完成后，重新 <code>generate</code> 便可修改非代码部分的文字的字体了。</p><h1 id="改变代码部分的文字字体可选"><a class="markdownIt-Anchor" href="#改变代码部分的文字字体可选"></a> 改变代码部分的文字字体（可选）</h1><p>若需修改代码部分的文字的字体，编辑 <code>_config.butterfly.yml</code>，找到以下代码并将 <code>font-family</code> 中定义的名称加入<code>code-font-family</code>，重新<code>generate</code>即可。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global font settings</span></span><br><span class="line"><span class="comment"># Don&#x27;t modify the following settings unless you know how they work (非必要不要修改)</span></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">global-font-size:</span></span><br><span class="line">  <span class="attr">code-font-size:</span></span><br><span class="line">  <span class="attr">font-family:</span></span><br><span class="line">  <span class="attr">code-font-family:</span> <span class="string">JetBrainsMono</span></span><br></pre></td></tr></table></figure><h1 id="参考博客"><a class="markdownIt-Anchor" href="#参考博客"></a> 参考博客</h1><ul><li><a href="https://www.yanchengxu.top/hexo-font-modification/">【Hexo-Butterfly】字体修改 | yanchengxu</a></li></ul>]]></content>
    
    
    <summary type="html">记录使用 Hexo Butterfly 时字体修改的过程。</summary>
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>PicGo 问题解决记录</title>
    <link href="https://luoyu-ying.github.io/posts/052b259f25f7/"/>
    <id>https://luoyu-ying.github.io/posts/052b259f25f7/</id>
    <published>2022-06-07T11:42:00.000Z</published>
    <updated>2022-06-07T11:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>更多 FAQ 请查看官方文档：</p><ul><li><a href="https://github.com/Molunerfinn/PicGo/blob/dev/FAQ.md">PicGo/FAQ.md at dev · Molunerfinn/PicGo (github.com)</a></li><li><a href="https://github.com/Molunerfinn/PicGo/issues">Issues · Molunerfinn/PicGo (github.com)</a></li></ul></blockquote><h1 id="相册突然无法显示图片或者上传后相册不更新"><a class="markdownIt-Anchor" href="#相册突然无法显示图片或者上传后相册不更新"></a> 相册突然无法显示图片或者上传后相册不更新</h1><p>这个原因可能是相册存储文件损坏导致的。可以找到 PicGo 配置文件所在路径下的 <code>picgo.db</code> ，将其删掉（删掉前建议备份一遍），再重启 PicGo 试试。 注意同时看看日志文件里有没有什么error，必要时可以提issue。</p><h1 id="github-图床有时能上传有时上传失败"><a class="markdownIt-Anchor" href="#github-图床有时能上传有时上传失败"></a> GitHub 图床有时能上传，有时上传失败</h1><ol><li>GitHub 图床不支持上传同名文件，如果有同名文件上传，会报错。建议开启 <code>时间戳重命名</code> 避免同名文件。</li><li>GitHub 服务器和国内 GFW 的问题会导致有时上传成功，有时上传失败，无解。想要稳定请使用付费云存储，如阿里云、腾讯云等，价格也不会贵。</li></ol><h1 id="上传失败或者是服务器出错"><a class="markdownIt-Anchor" href="#上传失败或者是服务器出错"></a> 上传失败，或者是服务器出错</h1><ol><li>PicGo 自带的图床都经过测试，上传出错一般都不是 PicGo 自身的原因。如果你用的是 GitHub 图床请参考上面的问题。</li><li>检查 PicGo 的日志（报错日志可以在 PicGo 设置 -&gt; 设置日志文件 -&gt; 点击打开 后找到），看看 <code>[PicGo Error]</code> 的报错信息里有什么关键信息<ol><li>先自行搜索 error 里的报错信息，往往你能百度或者谷歌出问题原因，不必开 issue。</li><li>如果有带有 <code>401</code> 、<code>403</code> 等 <code>40X</code> 状态码字样的，不用怀疑，就是你配置写错了，仔细检查配置，看看是否多了空格之类的。</li><li>如果带有 <code>HttpError</code>、<code>RequestError</code> 、 <code>socket hang up</code> 等字样的说明这是网络问题，我无法帮你解决网络问题，请检查你自己的网络，是否有代理，DNS 设置是否正常等。</li></ol></li></ol>]]></content>
    
    
    <summary type="html">记录一下在使用 PicGo 中遇到的问题和解决方法。</summary>
    
    
    
    <category term="PicGo" scheme="https://luoyu-ying.github.io/categories/PicGo/"/>
    
    
    <category term="PicGo" scheme="https://luoyu-ying.github.io/tags/PicGo/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络 - Android校招面试整理2022</title>
    <link href="https://luoyu-ying.github.io/posts/a00ca8ffea9b/"/>
    <id>https://luoyu-ying.github.io/posts/a00ca8ffea9b/</id>
    <published>2022-06-07T00:06:33.000Z</published>
    <updated>2022-06-07T00:06:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>答案参考自：</p><ul><li><a href="http://www.cyc2018.xyz/">CS-Notes (cyc2018.xyz)</a></li></ul></blockquote><h1 id="主机之间的通信方式"><a class="markdownIt-Anchor" href="#主机之间的通信方式"></a> 主机之间的通信方式</h1><ul><li>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/914894c2-0bc4-46b5-bef9-0316a69ef521.jpg" alt="img" style="zoom: 67%;" /><ul><li>对等（P2P）：不区分客户和服务器。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/42430e94-3137-48c0-bdb6-3cebaf9102e3.jpg" alt="img" style="zoom: 67%;" /><h1 id="计算机网络体系结构"><a class="markdownIt-Anchor" href="#计算机网络体系结构"></a> 计算机网络体系结构</h1><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" alt="img" style="zoom: 67%;" /><h2 id="五层协议"><a class="markdownIt-Anchor" href="#五层协议"></a> 五层协议</h2><ul><li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</li><li><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：<strong>传输控制协议 TCP</strong> ，提供面向连接、可靠的数据传输服务，数据单位为报文段：<strong>用户数据报协议 UDP</strong> ，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li><li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><h2 id="osi"><a class="markdownIt-Anchor" href="#osi"></a> OSI</h2><p>其中表示层和会话层用途如下：</p><ul><li><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li><li><strong>会话层</strong> ：建立及管理会话。</li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><h2 id="tcpip"><a class="markdownIt-Anchor" href="#tcpip"></a> TCP/IP</h2><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/48d79be8-085b-4862-8a9d-18402eb93b31.png" alt="img" style="zoom:67%;" /><h2 id="数据在各层之间的传递过程"><a class="markdownIt-Anchor" href="#数据在各层之间的传递过程"></a> 数据在各层之间的传递过程</h2><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p><h1 id="物理层"><a class="markdownIt-Anchor" href="#物理层"></a> 物理层</h1><h2 id="通信方式"><a class="markdownIt-Anchor" href="#通信方式"></a> 通信方式</h2><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h1 id="数据链路层"><a class="markdownIt-Anchor" href="#数据链路层"></a> 数据链路层</h1><h2 id="封装成帧"><a class="markdownIt-Anchor" href="#封装成帧"></a> 封装成帧</h2><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/29a14735-e154-4f60-9a04-c9628e5d09f4.png" alt="img" style="zoom:67%;" /><h2 id="透明传输"><a class="markdownIt-Anchor" href="#透明传输"></a> 透明传输</h2><p>透明表示一个实际存在的事物看起来好像不存在一样。</p><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/e738a3d2-f42e-4755-ae13-ca23497e7a97.png" alt="img" style="zoom: 50%;" /><h2 id="差错检测"><a class="markdownIt-Anchor" href="#差错检测"></a> 差错检测</h2><p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p><h2 id="信道分类"><a class="markdownIt-Anchor" href="#信道分类"></a> 信道分类</h2><h3 id="广播信道"><a class="markdownIt-Anchor" href="#广播信道"></a> 广播信道</h3><p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p><h3 id="点对点信道"><a class="markdownIt-Anchor" href="#点对点信道"></a> 点对点信道</h3><p>一对一通信。</p><p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p><h2 id="信道复用技术"><a class="markdownIt-Anchor" href="#信道复用技术"></a> 信道复用技术</h2><h3 id="频分复用"><a class="markdownIt-Anchor" href="#频分复用"></a> 频分复用</h3><p>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/4aa5e057-bc57-4719-ab57-c6fbc861c505.png" alt="img" style="zoom:50%;" /><h3 id="时分复用"><a class="markdownIt-Anchor" href="#时分复用"></a> 时分复用</h3><p>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/67582ade-d44a-46a6-8757-3c1296cc1ef9.png" alt="img" style="zoom:50%;" /><p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，<strong>因此这两种方式对信道的利用率都不高</strong> 。</p><h3 id="统计时分复用"><a class="markdownIt-Anchor" href="#统计时分复用"></a> 统计时分复用</h3><p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/6283be2a-814a-4a10-84bf-9592533fe6bc.png" alt="img" style="zoom:50%;" /><h3 id="波分复用"><a class="markdownIt-Anchor" href="#波分复用"></a> 波分复用</h3><p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p><h3 id="码分复用"><a class="markdownIt-Anchor" href="#码分复用"></a> 码分复用</h3><h1 id="网络层"><a class="markdownIt-Anchor" href="#网络层"></a> 网络层</h1><p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><h2 id="ip-数据报格式"><a class="markdownIt-Anchor" href="#ip-数据报格式"></a> IP 数据报格式</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" alt="img" style="zoom: 67%;" /><ul><li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li><li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li><li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li><li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li></ul><h1 id="传输层"><a class="markdownIt-Anchor" href="#传输层"></a> 传输层</h1><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。</p><h2 id="udp-和-tcp-的特点"><a class="markdownIt-Anchor" href="#udp-和-tcp-的特点"></a> UDP 和 TCP 的特点</h2><ul><li><strong>用户数据报协议 UDP（User Datagram Protocol）</strong> 是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），<strong>支持一对一、一对多、多对一和多对多的交互通信</strong> 。</li><li><strong>传输控制协议 TCP（Transmission Control Protocol）</strong> 是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），<strong>每一条 TCP 连接只能是点对点的（一对一）</strong> 。</li></ul><h2 id="udp-首部格式"><a class="markdownIt-Anchor" href="#udp-首部格式"></a> UDP 首部格式</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" alt="img" style="zoom: 50%;" /><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><h2 id="tcp-首部格式"><a class="markdownIt-Anchor" href="#tcp-首部格式"></a> TCP 首部格式</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" alt="img" style="zoom: 50%;" /><ul><li><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li><li><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li><li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li><li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li><li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ul><h2 id="tcp-的三次握手"><a class="markdownIt-Anchor" href="#tcp-的三次握手"></a> TCP 的三次握手</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="img" style="zoom: 50%;" /><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20191129144820655.png" alt="TCP三次握手" style="zoom:80%;" /><p><strong>三次握手的原因</strong></p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p><p><strong>为什么不能只 进行两次挥手</strong></p><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/lengxiao1993/article/details/82771768">TCP 为什么三次握手而不是两次握手（正解版）_萧萧九宸的博客-CSDN博客_tcp为什么是三次握手不是两次握手</a></li></ul></blockquote><ul><li><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。</p></li><li><p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。少了第三次，服务端就没法确认客户端有没有收到数据包。</p></li></ul><h2 id="tcp-的四次挥手"><a class="markdownIt-Anchor" href="#tcp-的四次挥手"></a> TCP 的四次挥手</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg" alt="img" style="zoom: 67%;" /><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><p><strong>四次挥手的原因</strong></p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p><strong>TIME_WAIT</strong></p><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><p><strong>为什么不能是三次挥手?</strong></p><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/King___Ding/article/details/114873506">TCP 四次挥手的过程，为什么是四次挥手而不是三次_King-Ding的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/bytebai/article/details/22191677">TCP：半关闭_ByteBai的博客-CSDN博客_tcp 半关闭</a></li></ul></blockquote><p>因为服务端在接收到FIN, 往往不会立即返回FIN, 必须等到服务端所有的报文都发送完毕了，才能发FIN。因此先发一个ACK表示已经收到客户端的FIN，延迟一段时间才发FIN。这就造成了四次挥手。</p><p>如果是三次挥手会有什么问题？</p><p>等于说服务端将ACK和FIN的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为FIN没有到达客户端，从而让客户端不断的重发FIN。 不断的进行数据包重发。</p><blockquote><p>TODO : 客户端处于半关闭状态时能够主动发出消息？如不能，如何回复第三次FIN消息？</p></blockquote><h2 id="tcp-可靠传输"><a class="markdownIt-Anchor" href="#tcp-可靠传输"></a> TCP 可靠传输</h2><p>TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。</p><h2 id="tcp-滑动窗口"><a class="markdownIt-Anchor" href="#tcp-滑动窗口"></a> TCP 滑动窗口</h2><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg" alt="img" style="zoom: 67%;" /><h2 id="tcp-流量控制"><a class="markdownIt-Anchor" href="#tcp-流量控制"></a> TCP 流量控制</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</p><p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h1 id="http"><a class="markdownIt-Anchor" href="#http"></a> HTTP</h1><h2 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念"></a> 基础概念</h2><h3 id="请求和响应报文"><a class="markdownIt-Anchor" href="#请求和响应报文"></a> 请求和响应报文</h3><p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。</p><p>请求报文结构：</p><ul><li>第一行是包含了请求方法、URL、协议版本；</li><li>接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。</li><li>一个空行用来分隔首部和内容主体 Body</li><li>最后是请求的内容主体</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">http://www.example.com/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=0</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">If-Modified-Since</span><span class="punctuation">: </span>Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line"><span class="attribute">If-None-Match</span><span class="punctuation">: </span>&quot;3147526947+gzip&quot;</span><br><span class="line"><span class="attribute">Proxy-Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 xxx</span><br><span class="line"></span><br><span class="line"><span class="language-apache"><span class="attribute">param1</span>=<span class="number">1</span>&amp;param2=<span class="number">2</span></span></span><br></pre></td></tr></table></figure><p>响应报文结构：</p><ul><li>第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了</li><li>接下来多行也是首部内容</li><li>一个空行分隔首部和内容主体</li><li>最后是响应的内容主体</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Age</span><span class="punctuation">: </span>529651</span><br><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=604800</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Content-Encoding</span><span class="punctuation">: </span>gzip</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>648</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html; charset=UTF-8</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Mon, 02 Nov 2020 17:53:39 GMT</span><br><span class="line"><span class="attribute">Etag</span><span class="punctuation">: </span>&quot;3147526947+ident+gzip&quot;</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Mon, 09 Nov 2020 17:53:39 GMT</span><br><span class="line"><span class="attribute">Keep-Alive</span><span class="punctuation">: </span>timeout=4</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Thu, 17 Oct 2019 07:18:26 GMT</span><br><span class="line"><span class="attribute">Proxy-Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>ECS (sjc/16DF)</span><br><span class="line"><span class="attribute">Vary</span><span class="punctuation">: </span>Accept-Encoding</span><br><span class="line"><span class="attribute">X-Cache</span><span class="punctuation">: </span>HIT</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example Domain<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">// 省略... </span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="url"><a class="markdownIt-Anchor" href="#url"></a> URL</h3><p>HTTP 使用 URL（ <strong>U</strong> niform <strong>R</strong>esource <strong>L</strong>ocator，统一资源定位符）来定位资源，它是 URI（<strong>U</strong>niform <strong>R</strong>esource <strong>I</strong>dentifier，统一资源标识符）的子集，URL 在 URI 的基础上增加了定位能力。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png" alt="img" style="zoom: 67%;" /><h2 id="http-方法"><a class="markdownIt-Anchor" href="#http-方法"></a> HTTP 方法</h2><h3 id="get"><a class="markdownIt-Anchor" href="#get"></a> GET</h3><blockquote><p>获取资源</p></blockquote><p>当前网络请求中，绝大部分使用的是 GET 方法。</p><h3 id="post"><a class="markdownIt-Anchor" href="#post"></a> POST</h3><blockquote><p>传输实体主体</p></blockquote><p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p><h3 id="put"><a class="markdownIt-Anchor" href="#put"></a> PUT</h3><blockquote><p>上传文件</p></blockquote><p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p><h3 id="delete"><a class="markdownIt-Anchor" href="#delete"></a> DELETE</h3><blockquote><p>删除文件</p></blockquote><p>与 PUT 功能相反，并且同样不带验证机制。</p><h2 id="http-状态码"><a class="markdownIt-Anchor" href="#http-状态码"></a> HTTP 状态码</h2><p>服务器返回的 <strong>响应报文</strong> 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">类别</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">1XX</td><td style="text-align:center">Informational（信息性状态码）</td><td style="text-align:center">接收的请求正在处理</td></tr><tr><td style="text-align:center">2XX</td><td style="text-align:center">Success（成功状态码）</td><td style="text-align:center">请求正常处理完毕</td></tr><tr><td style="text-align:center">3XX</td><td style="text-align:center">Redirection（重定向状态码）</td><td style="text-align:center">需要进行附加操作以完成请求</td></tr><tr><td style="text-align:center">4XX</td><td style="text-align:center">Client Error（客户端错误状态码）</td><td style="text-align:center">服务器无法处理请求</td></tr><tr><td style="text-align:center">5XX</td><td style="text-align:center">Server Error（服务器错误状态码）</td><td style="text-align:center">服务器处理请求出错</td></tr></tbody></table><h3 id="1xx-信息"><a class="markdownIt-Anchor" href="#1xx-信息"></a> 1XX 信息</h3><ul><li><strong>100 Continue</strong> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><h3 id="2xx-成功"><a class="markdownIt-Anchor" href="#2xx-成功"></a> 2XX 成功</h3><ul><li><strong>200 OK</strong></li></ul><h3 id="3xx-重定向"><a class="markdownIt-Anchor" href="#3xx-重定向"></a> 3XX 重定向</h3><ul><li><strong>301 Moved Permanently</strong> ：永久性重定向</li><li><strong>302 Found</strong> ：临时性重定向</li></ul><h3 id="4xx-客户端错误"><a class="markdownIt-Anchor" href="#4xx-客户端错误"></a> 4XX 客户端错误</h3><ul><li><strong>400 Bad Request</strong> ：请求报文中存在语法错误。</li><li><strong>401 Unauthorized</strong> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden</strong> ：请求被拒绝。</li><li><strong>404 Not Found</strong></li></ul><h3 id="5xx-服务器错误"><a class="markdownIt-Anchor" href="#5xx-服务器错误"></a> 5XX 服务器错误</h3><ul><li><strong>500 Internal Server Error</strong> ：服务器正在执行请求时发生错误。</li></ul><h2 id="连接管理"><a class="markdownIt-Anchor" href="#连接管理"></a> 连接管理</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/HTTP1_x_Connections.png" alt="img" style="zoom:67%;" /><h3 id="短连接与长连接"><a class="markdownIt-Anchor" href="#短连接与长连接"></a> 短连接与长连接</h3><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p><p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p><ul><li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li><li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li></ul><h3 id="流水线"><a class="markdownIt-Anchor" href="#流水线"></a> 流水线</h3><p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p><p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p><h2 id="cookie"><a class="markdownIt-Anchor" href="#cookie"></a> Cookie</h2><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><h3 id="用途"><a class="markdownIt-Anchor" href="#用途"></a> 用途</h3><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h3 id="创建过程"><a class="markdownIt-Anchor" href="#创建过程"></a> 创建过程</h3><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><h2 id="缓存"><a class="markdownIt-Anchor" href="#缓存"></a> 缓存</h2><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><ul><li>缓解服务器压力；</li><li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li></ul><h3 id="实现方法"><a class="markdownIt-Anchor" href="#实现方法"></a> 实现方法</h3><ul><li>让代理服务器进行缓存；</li><li>让客户端浏览器进行缓存。</li></ul><h3 id="cache-control"><a class="markdownIt-Anchor" href="#cache-control"></a> Cache-Control</h3><p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p><h2 id="通信数据转发"><a class="markdownIt-Anchor" href="#通信数据转发"></a> 通信数据转发</h2><h3 id="代理"><a class="markdownIt-Anchor" href="#代理"></a> 代理</h3><p>代理服务器接受客户端的请求，并且转发给其它服务器。</p><h3 id="网关"><a class="markdownIt-Anchor" href="#网关"></a> 网关</h3><p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。</p><h3 id="隧道"><a class="markdownIt-Anchor" href="#隧道"></a> 隧道</h3><p>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</p><h2 id="http-的安全性问题"><a class="markdownIt-Anchor" href="#http-的安全性问题"></a> HTTP  的安全性问题</h2><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><h1 id="https"><a class="markdownIt-Anchor" href="#https"></a> HTTPS</h1><p>HTTP 有以下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p><p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ssl-offloading.jpg" alt="img" style="zoom:67%;" /><h2 id="加密"><a class="markdownIt-Anchor" href="#加密"></a> 加密</h2><h3 id="对称密钥加密"><a class="markdownIt-Anchor" href="#对称密钥加密"></a> 对称密钥加密</h3><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p><ul><li>优点：运算速度快；</li><li>缺点：无法安全地将密钥传输给通信方。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/7fffa4b8-b36d-471f-ad0c-a88ee763bb76.png" alt="img" style="zoom:67%;" /><h3 id="非对称密钥加密"><a class="markdownIt-Anchor" href="#非对称密钥加密"></a> 非对称密钥加密</h3><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p><p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p><ul><li>优点：可以更安全地将公开密钥传输给通信发送方；</li><li>缺点：运算速度慢。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/39ccb299-ee99-4dd1-b8b4-2f9ec9495cb4.png" alt="img" style="zoom: 67%;" /><h3 id="https-采用的加密方式"><a class="markdownIt-Anchor" href="#https-采用的加密方式"></a> HTTPS 采用的加密方式</h3><p>上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：</p><ul><li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;</li><li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/How-HTTPS-Works.png" alt="img" style="zoom: 33%;" /><h2 id="https-的缺点"><a class="markdownIt-Anchor" href="#https-的缺点"></a> HTTPS 的缺点</h2><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高额费用。</li></ul><h1 id="从-url-输入到页面展现到底发生什么"><a class="markdownIt-Anchor" href="#从-url-输入到页面展现到底发生什么"></a> 从 URL 输入到页面展现到底发生什么？</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/57895541">经典面试题：从 URL 输入到页面展现到底发生什么？ - 知乎 (zhihu.com)</a></li></ul></blockquote><p>总体来说分为以下几个过程:</p><ol><li><p>DNS 解析:将域名解析成 IP 地址</p></li><li><p>TCP 连接：TCP 三次握手</p></li><li><p>发送 HTTP 请求</p></li><li><p>服务器处理请求并返回 HTTP 报文</p></li><li><p>浏览器解析渲染页面</p></li><li><p>断开连接：TCP 四次挥手</p></li></ol><p><strong><font size="5">DNS解析</font></strong></p><p>在浏览器输入网址后，首先要经过域名解析，因为浏览器并不能直接通过域名找到对应的服务器，而是要通过 IP 地址。</p><p><strong><font size="4">IP地址</font></strong></p><p>IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址是一个 32 位的二进制数，比如 127.0.0.1 为本机 IP。</p><p><strong><font size="4">域名解析</font></strong></p><p>DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。</p><p><strong><font size="4">浏览器如何通过域名去查询 URL 对应的 IP 呢</font></strong></p><ul><li>浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。</li><li>操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统中找。</li><li>路由缓存：路由器也有 DNS 缓存。</li><li>ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。</li><li>根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS <a href="http://xn--44qr6aba96ld4eda63xey2cfa111ap36q.com">服务器先问根域名服务器.com</a> 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）</li></ul><p><strong><font size="4">小结</font></strong></p><p>浏览器通过向 DNS 服务器发送域名，DNS 服务器查询到与域名相对应的 IP 地址，然后返回给浏览器，浏览器再将 IP 地址打在协议上，同时请求参数也会在协议搭载，然后一并发送给对应的服务器。接下来介绍向服务器发送 HTTP 请求阶段，HTTP 请求分为三个部分：TCP 三次握手、http 请求响应信息、关闭 TCP 连接。</p>]]></content>
    
    
    <summary type="html">整理了面试需要的部分计算机网络知识点。</summary>
    
    
    
    <category term="2022校招面试整理" scheme="https://luoyu-ying.github.io/categories/2022%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="计算机网络" scheme="https://luoyu-ying.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="2022校招面试整理" scheme="https://luoyu-ying.github.io/tags/2022%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="计算机网络" scheme="https://luoyu-ying.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 美化教程 博客整理</title>
    <link href="https://luoyu-ying.github.io/posts/07af833ec811/"/>
    <id>https://luoyu-ying.github.io/posts/07af833ec811/</id>
    <published>2022-06-06T14:19:47.000Z</published>
    <updated>2022-06-06T14:19:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>本文持续更新中~</em></p></blockquote><h1 id="字体更改"><a class="markdownIt-Anchor" href="#字体更改"></a> 字体更改</h1><ul><li><a href="https://www.yanchengxu.top/hexo-font-modification/">【Hexo-Butterfly】字体修改 | yanchengxu</a></li></ul><h1 id="博客相关插件-网页"><a class="markdownIt-Anchor" href="#博客相关插件-网页"></a> 博客相关插件、网页</h1><blockquote><p>以下表格来源：</p><ul><li><a href="https://imbhj.com/link-favorites/">我早就忘了该如何开心的笑了《黑执事》 | Ordis’Blog (imbhj.com)</a></li></ul></blockquote><h2 id="博客插件"><a class="markdownIt-Anchor" href="#博客插件"></a> 博客插件</h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://github.com/jerryc127/hexo-theme-butterfly">博客主题</a></td><td style="text-align:center">本博客主题，Hexo-Butterfly</td></tr><tr><td style="text-align:center"><a href="https://www.gulpjs.com.cn/">gulp-cli 压缩插件</a></td><td style="text-align:center">Gulp 压缩</td></tr><tr><td style="text-align:center"><a href="https://www.npmjs.com/package/workbox-build">PWA 构建插件 workbox-build</a></td><td style="text-align:center">Workbox Build</td></tr><tr><td style="text-align:center"><a href="https://github.com/HCLonely/hexo-bilibili-bangumi">hexo-bilibili-bangumi: 哔哩哔哩追番页面插件</a></td><td style="text-align:center">在 Hexo 中生成哔哩哔哩追番页面</td></tr><tr><td style="text-align:center"><a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search: 本地搜索插件</a></td><td style="text-align:center">开启本地搜索插件</td></tr><tr><td style="text-align:center"><a href="https://github.com/MoePlayer/hexo-tag-aplayer">hexo-tag-aplayer: 音乐页面插件</a></td><td style="text-align:center">音乐页面的插件</td></tr><tr><td style="text-align:center"><a href="https://github.com/willin/hexo-wordcount">hexo-wordcount: 字数统计插件</a></td><td style="text-align:center">文章字数统计</td></tr><tr><td style="text-align:center"><a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed: RSS 生成插件</a></td><td style="text-align:center">RSS 生成</td></tr><tr><td style="text-align:center"><a href="https://github.com/netcan/hexo-generator-index-pin-top">hexo-generator-index-pin-top: 文章置顶插件</a></td><td style="text-align:center">实现文章置顶</td></tr><tr><td style="text-align:center"><a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git: Git 推送插件</a></td><td style="text-align:center">一键 Gti 推送</td></tr><tr><td style="text-align:center"><a href="https://github.com/coneycode/hexo-generator-baidu-sitemap">hexo-generator-baidu-sitemap: 百度 sitemap 生成插件</a></td><td style="text-align:center">如题，百度 sitemap 生成</td></tr><tr><td style="text-align:center"><a href="https://github.com/Rozbo/hexo-abbrlink">hexo-abbrlink: 永久链接生成插件</a></td><td style="text-align:center">精简文章链接</td></tr><tr><td style="text-align:center"><a href="https://github.com/huiwang/hexo-baidu-url-submit">hexo-baidu-url-submit: 百度主动推送</a></td><td style="text-align:center">百度主动链接提交</td></tr><tr><td style="text-align:center"><a href="https://github.com/hexojs/hexo-generator-sitemap">hexo-generator-sitemap: Sitemap 生成插件</a></td><td style="text-align:center">如题</td></tr></tbody></table><h2 id="无版权图库"><a class="markdownIt-Anchor" href="#无版权图库"></a> 无版权图库</h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">简介</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://www.pexels.com/zh-cn/">Pexels</a></td><td style="text-align:center">每一张都高清大图，无版权可任性下载</td></tr><tr><td style="text-align:center"><a href="https://www.sitebuilderreport.com/stock-up">Stock Up</a></td><td style="text-align:center">一个收集了来自 27 个免版权图库的神奇网站，图片数量之大，超乎你的想象</td></tr><tr><td style="text-align:center"><a href="https://unsplash.com/">Unsplash</a></td><td style="text-align:center">主要是生活中的景象作品</td></tr><tr><td style="text-align:center"><a href="https://pixabay.com/">Pixabay</a></td><td style="text-align:center">支持中文搜索的免费可商用图库</td></tr><tr><td style="text-align:center"><a href="https://stocksnap.io/">StockSnap</a></td><td style="text-align:center">最先进的检索功能，瞬间拥有高质量的免费高清图片</td></tr><tr><td style="text-align:center"><a href="https://magdeleine.co/">Magdeleine</a></td><td style="text-align:center">主要类别有自然、城市建筑、动物、视频风格偏厚重，比较艺术化</td></tr><tr><td style="text-align:center"><a href="https://visualhunt.com/">Visual Hunt</a></td><td style="text-align:center">通过颜色找图片，更精准的满足用户需求</td></tr></tbody></table><h2 id="无版权字体"><a class="markdownIt-Anchor" href="#无版权字体"></a> 无版权字体</h2><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://www.fontspace.com/">Free Fonts 字体</a></td><td style="text-align:center">emm。忘了介绍是啥了，自己打开看看吧</td></tr><tr><td style="text-align:center"><a href="http://www.googlefonts.net/">Google Fonts 谷歌字体中文版</a></td><td style="text-align:center">谷歌字体（暂时无法使用中文字体，请访问旧版）</td></tr><tr><td style="text-align:center"><a href="https://github.com/adobe-fonts">Adobe Fonts</a></td><td style="text-align:center">Adobe 的免费开源字体</td></tr><tr><td style="text-align:center"><a href="https://www.zcool.com.cn/special/zcoolfonts/">站酷字库 - 付费字体 &amp; 免费字体 - 站酷 (ZCOOL)</a></td><td style="text-align:center">站酷字体</td></tr><tr><td style="text-align:center"><a href="http://www.fonts.net.cn/">字体天下 - 提供各类字体的免费下载和在线预览服务</a></td><td style="text-align:center">这个里面的免费字体好像只能用于设计，比如 PS 什么的</td></tr></tbody></table><h2 id="文章封面设计"><a class="markdownIt-Anchor" href="#文章封面设计"></a> 文章封面设计</h2><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://nav.rdonly.com/laboratory/bgimage/backimage.html">文章封面生成工具</a></td><td style="text-align:center"><a href="http://GitHub.io">GitHub.io</a> 的，某些地区可能无法访问</td></tr><tr><td style="text-align:center"><a href="https://stories.freepik.com/">Stories 免费插图设计</a></td><td style="text-align:center">自定义更改插图颜色、插图背景、隐藏元素等，插图动画化，完全免费，但必须注明来源。</td></tr><tr><td style="text-align:center"><a href="https://icons8.com/vector-creator/">Vector Creator 插图设计</a></td><td style="text-align:center">有人物、动物、植物等类别的元素，而且每种类型的插图还有不同的风格，无需注册即可免费设计并下载 PNG 格式的插图，不付费使用时需要遵循免费使用条款</td></tr><tr><td style="text-align:center"><a href="https://undraw.co/">unDraw - 插图设计</a></td><td style="text-align:center">风格单一，但完全免费，不用担心版权，可任意使用不用担心律师函</td></tr><tr><td style="text-align:center"><a href="https://www.manypixels.co/gallery/">ManyPixels 插图设计</a></td><td style="text-align:center">可以说是另一个版本的 <strong>unDraw</strong> 插图库，完全免费，不用担心版权</td></tr></tbody></table><h2 id="acg-无版权图库"><a class="markdownIt-Anchor" href="#acg-无版权图库"></a> ACG 无版权图库</h2><table><thead><tr><th style="text-align:center">地址</th><th style="text-align:center">简述</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://alphacoders.com/">Alpha Coders ACG 无版权图片</a></td><td style="text-align:center">偏向游戏、人物</td></tr><tr><td style="text-align:center"><a href="https://www.gamewallpapers.com/index.php">GameWallpapers. ACG 无版权图库</a></td><td style="text-align:center">同上</td></tr></tbody></table><h2 id="代码托管"><a class="markdownIt-Anchor" href="#代码托管"></a> 代码托管</h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><a href="https://git-scm.com/">Git</a></td><td style="text-align:center">分布式版本管理工具，程序员必会技能</td></tr><tr><td style="text-align:center"><a href="https://gitee.com/">码云 Gitee</a></td><td style="text-align:center">国内版的 Github，支持静态站点配置，不过付费才嫩自动部署，自定义域名</td></tr><tr><td style="text-align:center"><a href="https://coding.net/">Coding</a></td><td style="text-align:center">也是国内的，支持静态站点、自定义域名、强制 https、自动部署，非常好用</td></tr><tr><td style="text-align:center"><a href="https://github.com/">GitHub</a></td><td style="text-align:center">国外的，功能非常全，程序员最爱的 “交友” 网站，唯一的缺点是在国外，访问有点慢</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">记录了自己在美化博客时收集的各个大佬的教程。</summary>
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>计算机操作系统 - Android校招面试整理2022</title>
    <link href="https://luoyu-ying.github.io/posts/f4f7590eb984/"/>
    <id>https://luoyu-ying.github.io/posts/f4f7590eb984/</id>
    <published>2022-06-02T08:41:53.000Z</published>
    <updated>2022-06-05T08:41:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理自：</p><ul><li><a href="http://www.cyc2018.xyz/">CS-Notes (cyc2018.xyz)</a></li></ul></blockquote><h1 id="四个基本特征"><a class="markdownIt-Anchor" href="#四个基本特征"></a> 四个基本特征</h1><ol><li><p>并发</p><p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p><p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p></li><li><p>共享</p><p>共享是指系统中的资源可以被多个并发进程共同使用。</p><p>有两种共享方式：互斥共享和同时共享。</p><p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p></li><li><p>虚拟</p><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p><p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p></li><li><p>异步</p><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p></li></ol><h1 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h1><ol><li><p>进程管理</p><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p></li><li><p>内存管理</p><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p></li><li><p>文件管理</p><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p></li><li><p>设备管理</p><p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p><p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p></li></ol><h1 id="系统调用"><a class="markdownIt-Anchor" href="#系统调用"></a> 系统调用</h1><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/tGPV0.png" alt="img" /></p><h1 id="进程和线程"><a class="markdownIt-Anchor" href="#进程和线程"></a> 进程和线程</h1><h2 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h2><p><strong>进程是资源分配的最小单位。</strong></p><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p><p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/a6ac2b08-3861-4e85-baa8-382287bfee9f.png" alt="img" /></p><h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2><p><strong>线程是独立调度的基本单位。</strong></p><p>一个进程中可以有多个线程，它们共享进程资源。</p><h2 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h2><ol><li><p>拥有资源</p><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p></li><li><p>调度</p><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p></li><li><p>系统开销</p><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。</p></li><li><p>通信方面</p><p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p></li></ol><h1 id="进程状态的切换"><a class="markdownIt-Anchor" href="#进程状态的切换"></a> 进程状态的切换</h1><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ProcessState.png" alt="img" /></p><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源</li></ul><p>注意：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是由于缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h1 id="进程调度算法"><a class="markdownIt-Anchor" href="#进程调度算法"></a> 进程调度算法</h1><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h2 id="交互式系统"><a class="markdownIt-Anchor" href="#交互式系统"></a> 交互式系统</h2><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><h3 id="时间片轮转"><a class="markdownIt-Anchor" href="#时间片轮转"></a> 时间片轮转</h3><blockquote><p><strong>先来先服务 first-come first-serverd（FCFS）</strong></p><p>批处理系统中非抢占式的调度算法，按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p></blockquote><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><h3 id="优先级调度"><a class="markdownIt-Anchor" href="#优先级调度"></a> 优先级调度</h3><p>为每个进程分配一个优先级，按优先级进行调度。</p><p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><h3 id="多级反馈队列"><a class="markdownIt-Anchor" href="#多级反馈队列"></a> 多级反馈队列</h3><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,…。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/042cf928-3c8e-4815-ae9c-f2780202c68f.png" alt="img" /></p><h2 id="批处理系统-实时系统"><a class="markdownIt-Anchor" href="#批处理系统-实时系统"></a> 批处理系统、实时系统</h2><p>具体内容查看本文上方的参考文章。</p><h1 id="进程同步"><a class="markdownIt-Anchor" href="#进程同步"></a> 进程同步</h1><h2 id="临界区"><a class="markdownIt-Anchor" href="#临界区"></a> 临界区</h2><p>对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section;</span><br><span class="line">// exit section</span><br></pre></td></tr></table></figure><h2 id="同步与互斥"><a class="markdownIt-Anchor" href="#同步与互斥"></a> 同步与互斥</h2><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><h2 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h2><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P2</span><span class="params">()</span> &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="管程"><a class="markdownIt-Anchor" href="#管程"></a> 管程</h2><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p><p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><h1 id="经典同步问题"><a class="markdownIt-Anchor" href="#经典同步问题"></a> 经典同步问题</h1><h2 id="哲学家进餐问题"><a class="markdownIt-Anchor" href="#哲学家进餐问题"></a> 哲学家进餐问题</h2><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><p>一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p><p>为了防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul><h2 id="读者-写者问题"><a class="markdownIt-Anchor" href="#读者-写者问题"></a> 读者-写者问题</h2><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><h1 id="进程通信"><a class="markdownIt-Anchor" href="#进程通信"></a> 进程通信</h1><p>进程同步与进程通信很容易混淆，它们的区别在于：</p><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><h2 id="共享存储"><a class="markdownIt-Anchor" href="#共享存储"></a> 共享存储</h2><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p><h2 id="信号量-2"><a class="markdownIt-Anchor" href="#信号量-2"></a> 信号量</h2><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p><h1 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h1><h2 id="死锁的必要条件"><a class="markdownIt-Anchor" href="#死锁的必要条件"></a> 死锁的必要条件</h2><ol><li>互斥</li><li>占有且等待</li><li>不可抢占</li><li>循环等待</li></ol><h2 id="已发生死锁后的处理方法"><a class="markdownIt-Anchor" href="#已发生死锁后的处理方法"></a> 已发生死锁后的处理方法</h2><p>主要有以下四种方法：</p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防</li><li>死锁避免</li></ul><h3 id="鸵鸟策略"><a class="markdownIt-Anchor" href="#鸵鸟策略"></a> 鸵鸟策略</h3><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p><h3 id="死锁检测与死锁恢复"><a class="markdownIt-Anchor" href="#死锁检测与死锁恢复"></a> 死锁检测与死锁恢复</h3><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><p><strong>死锁检测：</strong></p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><p><strong>死锁恢复：</strong></p><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><h2 id="死锁预防"><a class="markdownIt-Anchor" href="#死锁预防"></a> 死锁预防</h2><p>我们只要<strong>破坏产生死锁的四个条件中的其中一个就可以了</strong>。</p><ol><li><p><strong>破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p></li><li><p><strong>破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p></li><li><p><strong>破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p></li><li><p><strong>破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p></li></ol><h2 id="死锁避免"><a class="markdownIt-Anchor" href="#死锁避免"></a> 死锁避免</h2><h3 id="安全状态"><a class="markdownIt-Anchor" href="#安全状态"></a> 安全状态</h3><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ed523051-608f-4c3f-b343-383e2d194470.png" alt="img" /></p><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p><h3 id="单个资源的银行家算法"><a class="markdownIt-Anchor" href="#单个资源的银行家算法"></a> 单个资源的银行家算法</h3><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png" alt="img" /></p><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p><h3 id="多个资源的银行家算法"><a class="markdownIt-Anchor" href="#多个资源的银行家算法"></a> 多个资源的银行家算法</h3><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png" alt="img" /></p><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p><p><strong>检查一个状态是否安全的算法如下：</strong></p><ul><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ul><p>如果一个状态不是安全的，需要拒绝进入这个状态。</p><h1 id="虚拟内存"><a class="markdownIt-Anchor" href="#虚拟内存"></a> 虚拟内存</h1><blockquote><p>参考视频：</p><ul><li><a href="https://www.bilibili.com/video/BV18v411a7Vk">【操作系统】内存管理——虚拟内存 _ 哔哩哔哩_bilibili</a></li></ul></blockquote><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/7b281b1e-0595-402b-ae35-8c91084c33c1.png" alt="img" /></p><h1 id="分页系统地址映射"><a class="markdownIt-Anchor" href="#分页系统地址映射"></a> 分页系统地址映射</h1><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p><p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p><p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" alt="img" style="zoom:67%;" /><h1 id="页面置换算法"><a class="markdownIt-Anchor" href="#页面置换算法"></a> 页面置换算法</h1><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h2 id="最佳"><a class="markdownIt-Anchor" href="#最佳"></a> 最佳</h2><blockquote><p>OPT, Optimal replacement algorithm</p></blockquote><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p><p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p><h2 id="最近最久未使用"><a class="markdownIt-Anchor" href="#最近最久未使用"></a> 最近最久未使用</h2><blockquote><p>LRU, Least Recently Used</p></blockquote><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p><p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p><h2 id="先进先出"><a class="markdownIt-Anchor" href="#先进先出"></a> 先进先出</h2><blockquote><p>FIFO, First In First Out</p></blockquote><p>选择换出的页面是最先进入的页面。</p><p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p><h2 id="第二次机会算法"><a class="markdownIt-Anchor" href="#第二次机会算法"></a> 第二次机会算法</h2><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png" alt="img" /></p><h2 id="时钟"><a class="markdownIt-Anchor" href="#时钟"></a> 时钟</h2><blockquote><p>Clock</p></blockquote><p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png" alt="img" /></p><h2 id="最近未使用"><a class="markdownIt-Anchor" href="#最近未使用"></a> 最近未使用</h2><blockquote><p>NRU, Not Recently Used</p></blockquote><p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p><ul><li>R=0，M=0</li><li>R=0，M=1</li><li>R=1，M=0</li><li>R=1，M=1</li></ul><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p><p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p><h1 id="分段"><a class="markdownIt-Anchor" href="#分段"></a> 分段</h1><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p><p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/22de0538-7c6e-4365-bd3b-8ce3c5900216.png" alt="img" /></p><p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><h1 id="段页式"><a class="markdownIt-Anchor" href="#段页式"></a> 段页式</h1><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><h1 id="分页与分段的比较"><a class="markdownIt-Anchor" href="#分页与分段的比较"></a> 分页与分段的比较</h1><ul><li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li><li>地址空间的维度：分页是一维地址空间，分段是二维的。</li><li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li><li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul>]]></content>
    
    
    <summary type="html">整理了面试中常见的部分计算机操作系统的知识点。</summary>
    
    
    
    <category term="2022校招面试整理" scheme="https://luoyu-ying.github.io/categories/2022%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="计算机系统" scheme="https://luoyu-ying.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="2022校招面试整理" scheme="https://luoyu-ying.github.io/tags/2022%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="计算机操作系统" scheme="https://luoyu-ying.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 一篇文章添加多个分类</title>
    <link href="https://luoyu-ying.github.io/posts/08fcea026748/"/>
    <id>https://luoyu-ying.github.io/posts/08fcea026748/</id>
    <published>2022-05-29T14:13:34.000Z</published>
    <updated>2022-05-29T14:13:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类和标签"><a class="markdownIt-Anchor" href="#分类和标签"></a> 分类和标签</h1><p>Hexo 博客中只有文章支持分类和标签，您可以在 Front-matter 中设置。</p><p>在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">Diary</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PS3</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Games</span></span><br></pre></td></tr></table></figure><h1 id="分类方法的分歧"><a class="markdownIt-Anchor" href="#分类方法的分歧"></a> 分类方法的分歧</h1><p>如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Diary</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Life</span></span><br></pre></td></tr></table></figure><p>会使分类 Life 成为 Diary 的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p><p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="string">Diary</span>, <span class="string">PlayStation</span>]</span><br><span class="line">  <span class="bullet">-</span> [<span class="string">Diary</span>, <span class="string">Games</span>]</span><br><span class="line">  <span class="bullet">-</span> [<span class="string">Life</span>]</span><br></pre></td></tr></table></figure><p>此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://hexo.io/zh-cn/docs/front-matter.html">Front-matter | Hexo</a></li></ul>]]></content>
    
    
    <summary type="html">记录了如何使得 Hexo 的一篇文章可以添加多个分类。</summary>
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Front-matter 格式</title>
    <link href="https://luoyu-ying.github.io/posts/a6d8264a3704/"/>
    <id>https://luoyu-ying.github.io/posts/a6d8264a3704/</id>
    <published>2022-05-29T13:53:32.000Z</published>
    <updated>2022-05-29T13:53:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-front-matter"><a class="markdownIt-Anchor" href="#什么是-front-matter"></a> 什么是 Front-matter</h1><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2013/7/13 20:46:25</span><br><span class="line">---</span><br></pre></td></tr></table></figure><hr /><h1 id="部分参数"><a class="markdownIt-Anchor" href="#部分参数"></a> 部分参数</h1><blockquote><p>以下参数不一定全部适用于所有主题的博客，请自行尝试。</p></blockquote><h2 id="page-front-matter"><a class="markdownIt-Anchor" href="#page-front-matter"></a> Page Front-matter</h2><table><thead><tr><th style="text-align:center">Type</th><th style="text-align:center">Explanation</th><th style="text-align:center">Example</th></tr></thead><tbody><tr><td style="text-align:center">title</td><td style="text-align:center">标题</td><td style="text-align:center">title: hello, world</td></tr><tr><td style="text-align:center">date</td><td style="text-align:center">创建日期，默认系统时间</td><td style="text-align:center">date: 2020-7-19</td></tr><tr><td style="text-align:center">updated</td><td style="text-align:center">更新日期，默认再次创建日期</td><td style="text-align:center">update: 2020-7-20</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">页面类型，tags、link、categories 这三个页面需要配置</td><td style="text-align:center">type: tags</td></tr><tr><td style="text-align:center">comments</td><td style="text-align:center">是否显示评论，默认 true</td><td style="text-align:center">comments: false</td></tr><tr><td style="text-align:center">description</td><td style="text-align:center">描述，没使用过，暂时不太清楚效果</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">top_img</td><td style="text-align:center">顶部图，默认为系统default配置的图</td><td style="text-align:center">top_img: 图片URL或者博客相对路径</td></tr><tr><td style="text-align:center">mathjax</td><td style="text-align:center">数学公式是否显示，默认为 false ，不显示</td><td style="text-align:center">mathjax: true</td></tr><tr><td style="text-align:center">katex</td><td style="text-align:center">数学公式是否显示，默认为 false ，不显示</td><td style="text-align:center">mathjax: true</td></tr><tr><td style="text-align:center">aside</td><td style="text-align:center">true 表示显示右边信息卡片，默认值；false 表示不显示</td><td style="text-align:center">aside: true</td></tr><tr><td style="text-align:center">aplayer</td><td style="text-align:center">在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">highlight_shrink</td><td style="text-align:center">配置代码框是否展开，默认为设置中 highlight_shrink 的配置</td><td style="text-align:center">–</td></tr></tbody></table><h2 id="post-front-matter"><a class="markdownIt-Anchor" href="#post-front-matter"></a> Post Front-matter</h2><table><thead><tr><th style="text-align:center">Type</th><th style="text-align:center">Explanation</th><th style="text-align:center">Example</th></tr></thead><tbody><tr><td style="text-align:center">title</td><td style="text-align:center">标题</td><td style="text-align:center">title: Hello,World！</td></tr><tr><td style="text-align:center">date</td><td style="text-align:center">创建日期，默认系统时间</td><td style="text-align:center">date: 2020-7-19</td></tr><tr><td style="text-align:center">updated</td><td style="text-align:center">更新日期，默认再次创建日期</td><td style="text-align:center">update: 2020-7-20</td></tr><tr><td style="text-align:center">tags</td><td style="text-align:center">标签，用 - 列出标签，一个 - 表示一个标签，注意换行以及 - 后面有个空格</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">categories</td><td style="text-align:center">分类，同样用 - 区别多个分类，注意换行以及 - 后面有个空格</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">keywords</td><td style="text-align:center">关键字</td><td style="text-align:center">keywords: ‘a, b’</td></tr><tr><td style="text-align:center">description</td><td style="text-align:center">描述，没使用过，暂时不太清楚效果</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">top_img</td><td style="text-align:center">顶部图，可选项，不写则按缩略图的图片显示</td><td style="text-align:center">top_img: 图片URL或者博客中图片的相对路径</td></tr><tr><td style="text-align:center">comments</td><td style="text-align:center">是否显示评论，默认 true。</td><td style="text-align:center">comments: false</td></tr><tr><td style="text-align:center">cover</td><td style="text-align:center">缩略图</td><td style="text-align:center">cover: 图片URL或者博客中图片的相对路径</td></tr><tr><td style="text-align:center">toc</td><td style="text-align:center">是否显示 toc ，默认 true 显示</td><td style="text-align:center">toc: false</td></tr><tr><td style="text-align:center">toc_number</td><td style="text-align:center">是否显示 toc 数字，默认 true 显示</td><td style="text-align:center">toc_number: false</td></tr><tr><td style="text-align:center">auto_open</td><td style="text-align:center">是否自动打开 TOC (默认为设置中 toc 的 auto_open 配置)</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">copyright</td><td style="text-align:center">是否显示版权，默认 true 显示</td><td style="text-align:center">copyright: false</td></tr><tr><td style="text-align:center">mathjax</td><td style="text-align:center">数学公式是否显示，默认为 false ，不显示</td><td style="text-align:center">mathjax: true</td></tr><tr><td style="text-align:center">katex</td><td style="text-align:center">数学公式是否显示，默认为 false ，不显示</td><td style="text-align:center">mathjax: true</td></tr><tr><td style="text-align:center">hidden或hide</td><td style="text-align:center">是否隐藏，需安装hide或者indexed插件，true表示隐藏</td><td style="text-align:center">hidden: true</td></tr><tr><td style="text-align:center">sticky</td><td style="text-align:center">文章置顶，数值越大越靠前，需安装indexed插件，默认值为0</td><td style="text-align:center">sticky: 10</td></tr><tr><td style="text-align:center">top</td><td style="text-align:center">文章置顶，需安装index-pin-top 插件，默认值为false，同时为置顶则按时间先后顺序</td><td style="text-align:center">top: true</td></tr><tr><td style="text-align:center">aplayer</td><td style="text-align:center">在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">highlight_shrink</td><td style="text-align:center">配置代码框是否展开，默认为设置中 highlight_shrink 的配置</td><td style="text-align:center">–</td></tr></tbody></table><hr /><h1 id="butterfly-主题-参数"><a class="markdownIt-Anchor" href="#butterfly-主题-参数"></a> Butterfly 主题 参数</h1><h2 id="page-front-matter-2"><a class="markdownIt-Anchor" href="#page-front-matter-2"></a> Page Front-matter</h2><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220710205859893.png" alt="image-20220710205859893" /></p><h2 id="post-front-matter-2"><a class="markdownIt-Anchor" href="#post-front-matter-2"></a> Post Front-matter</h2><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220710205932635.png" alt="image-20220710205932635" /></p><hr /><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><p><a href="https://hexo.io/zh-cn/docs/front-matter.html">Front-matter | Hexo</a></p></li><li><p><a href="https://caczhtus.github.io/posts/64237/">【Hexo】关于 Hexo-ButterFly 主题的使用记录 | Caczhtus</a></p></li><li><p><a href="https://blog.csdn.net/qq_42549254/article/details/102721177">hexo学习——文章 Front-matter_WMXNLFD的博客-CSDN博客</a></p></li><li><p><a href="https://butterfly.js.org/posts/dc584b87/">Butterfly 安裝文檔(二) 主題頁面 | Butterfly</a></p></li></ul>]]></content>
    
    
    <summary type="html">记录了 Hexo 博客的 Front-matter 格式，以及其中的部分参数。</summary>
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>多线程-Android校招面试整理2022</title>
    <link href="https://luoyu-ying.github.io/posts/6797cb29bf4c/"/>
    <id>https://luoyu-ying.github.io/posts/6797cb29bf4c/</id>
    <published>2022-05-29T01:44:28.000Z</published>
    <updated>2022-06-09T00:07:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java中创建线程的方式"><a class="markdownIt-Anchor" href="#java中创建线程的方式"></a> <code>Java</code>中创建线程的方式</h1><blockquote><p><code>Future</code>, <code>FutureTask</code>的实现方式暂未学习，待补充。</p></blockquote><ol><li>写一个类继承自<code>Thread</code>类，重写<code>run</code>方法。用<code>start</code>方法启动线程。</li><li>写一个类实现<code>Runnable</code>接口，实现<code>run</code>方法。用<code>new Thread(Runnable target).start</code>方法来启动。</li></ol><h1 id="线程的几种状态"><a class="markdownIt-Anchor" href="#线程的几种状态"></a> 线程的几种状态</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/pange1991/article/details/53860651/">Java线程的6种状态及切换(透彻讲解)_潘建南的博客-CSDN博客_线程状态</a></li></ul></blockquote><p><code>Java</code>中的线程的状态总共有6种。</p><blockquote><ol><li><strong>初始(<code>NEW</code>)：</strong> 新创建了一个线程对象，但还没有调用start()方法。</li><li><strong>运行(<code>RUNNABLE</code>)：</strong> Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br />线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li><li><strong>阻塞(<code>BLOCKED</code>)：</strong> 表示线程阻塞于锁。</li><li><strong>等待(<code>WAITING</code>)：</strong> 进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li><strong>超时等待(<code>TIMED_WAITING</code>)：</strong> 该状态不同于<code>WAITING</code>，它可以在指定的时间后自行返回。</li><li><strong>终止(<code>TERMINATED</code>)：</strong> 表示该线程已经执行完毕。</li></ol></blockquote><p>这6种状态定义在<code>Thread</code>类的<code>State</code>枚举中，可查看源码进行一一对应。</p><p><strong><font size="4">线程状态图</font></strong></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20181120173640764.jpeg" alt="线程状态图" /></p><p><strong><font size="4">状态详细说明</font></strong></p><ol><li><p><strong>初始状态(<code>NEW</code>)</strong><br />实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</p></li><li><p><strong>运行状态(<code>RUNNABLE</code>)</strong></p><ol><li><strong>就绪状态(<code>RUNNABLE</code>之<code>READY</code>)</strong><ul><li>就绪状态只是说你有资格运行，调度程序没有挑选到你，你就永远是就绪状态。</li><li>调用线程的start()方法，此线程进入就绪状态。</li><li>当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。</li><li>当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。</li><li>锁池里的线程拿到对象锁后，进入就绪状态。</li></ul></li><li><strong>运行中状态(<code>RUNNABLE</code>之<code>RUNNING</code>)</strong><br />线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一的一种方式。</li></ol></li><li><p><strong>阻塞状态(<code>BLOCKED</code>)</strong><br />阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。</p></li><li><p><strong>等待(<code>WAITING</code>)</strong><br />处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</p></li><li><p><strong>超时等待(<code>TIMED_WAITING</code>)</strong><br />处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</p></li><li><p><strong>终止状态(<code>TERMINATED</code>)</strong><br />当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。<br />在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p></li></ol><h1 id="threadsleep与objectwait的区别"><a class="markdownIt-Anchor" href="#threadsleep与objectwait的区别"></a> <code>Thread#sleep</code>与<code>Object#wait</code>的区别</h1><p><strong><font size="4"><code>Thread#sleep</code></font></strong></p><p><code>Thread.sleep(long millis)</code>，一定是当前线程调用此方法，当前线程进入<code>TIMED_WAITING</code>状态，但<strong>不释放对象锁</strong>，<code>millis</code>后线程自动苏醒进入就绪状态。</p><p>作用：给其它线程执行机会的最佳方式。</p><p><strong><font size="4"><code>Object#wait</code></font></strong></p><p>当前线程调用对象的<code>wait</code>方法，当前线程<strong>释放对象锁</strong>，进入等待队列。</p><p>依靠<code>notify/notifyAll</code>唤醒或者<code>wait(long timeout)</code>， <code>timeout</code>时间到自动唤醒。</p><p><strong><font size="4">总结</font></strong></p><p>可以发现，两者的区别为当前的线程是否会释放对象锁。</p><h1 id="objectnotify和objectnotifyall的区别"><a class="markdownIt-Anchor" href="#objectnotify和objectnotifyall的区别"></a> <code>Object#notify</code>和<code>Object#notifyAll</code>的区别</h1><p><code>Object#notify</code>唤醒在此对象监视器上等待的<strong>单个线程</strong>，<strong>选择是任意性的</strong>。</p><p><code>Object#notifyAll</code>唤醒在此对象监视器上等待的<strong>所有线程</strong>。</p><h1 id="锁池和等待池"><a class="markdownIt-Anchor" href="#锁池和等待池"></a> 锁池和等待池</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/javaddd/p/13611981.html">多线程的“锁池”和“等待池” - suncl123 - 博客园 (cnblogs.com)</a></li></ul></blockquote><p>每个对象都有自己的“锁池”和“等待池”，用来存放线程。线程进入“锁池”，会处于竞争锁状态，当其他线程释放锁以后，才可能竞争到锁，然后执行同步块代码。线程进入”等待池“，会等待其他线程调用notify或者notifyAll方法，来进入“锁池”状态。</p><p>synchronized修饰的方法，在执行的时候，线程会被排序依次执行。这时，线程会被阻塞在对象的“锁池”中，只有一个线程会被执行。至于哪个线程被执行，需根据不同的虚拟机实现机制不同。</p><p>进入synchronized方法块的线程，会立即持有该对象的锁，并从“锁池”中移除。执行完毕，会释放锁，“锁池”中的线程依据一定规则会有一个线程依次执行该synchronized代码块。</p><p>进入synchronized代码块的线程，如果执行wait方法，就会释放改对象锁，该线程进入“等待池”，直到其他线程调用该对象的notify方法时，才有可能被唤醒继续执行后续代码，线程被唤醒以后，该线程从“等待池”中移除。</p><h1 id="threadrun和threadstart的区别"><a class="markdownIt-Anchor" href="#threadrun和threadstart的区别"></a> <code>Thread#run</code>和<code>Thread#start</code>的区别</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/renhui/p/6066750.html">Java Thread 的 run() 与 start() 的区别 - 灰色飘零 - 博客园 (cnblogs.com)</a></li></ul></blockquote><ol><li><p>调用<code>start</code>方法方可启动线程，而<code>run</code>方法只是<code>Thread</code>的一个普通方法调用，还是在主线程里执行。</p></li><li><p>把需要并行处理的代码放在<code>run</code>方法中，<code>start</code>方法启动线程将自动调用 <code>run</code>方法，这是由<code>JVM</code>的内存机制规定的。并且<code>run</code>方法必须是<code>public</code>访问权限，返回值类型为<code>void</code>。</p></li></ol><hr /><h1 id="线程死锁如何有效的避免线程死锁"><a class="markdownIt-Anchor" href="#线程死锁如何有效的避免线程死锁"></a> 线程死锁，如何有效的避免线程死锁？</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://developer.aliyun.com/article/763004">什么是线程死锁？形成条件是什么？如何避免？-阿里云开发者社区 (aliyun.com)</a></li></ul></blockquote><h2 id="什么是线程死锁"><a class="markdownIt-Anchor" href="#什么是线程死锁"></a> 什么是线程死锁</h2><p>死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/cff16df19c2ffe9621333dd219990df69664a007.png" alt="image" /></p><p>如上图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><h2 id="形成死锁的四个必要条件"><a class="markdownIt-Anchor" href="#形成死锁的四个必要条件"></a> 形成死锁的四个必要条件</h2><ol><li><strong>互斥条件：</strong> 线程(进程)对于所分配到的资源具有排它性，即一个资源只能被一个线程(进程)占用，直到被该线程(进程)释放。</li><li><strong>请求与保持条件：</strong> 一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</li><li><strong>不可剥夺条件：</strong> 线程(进程)已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li><strong>循环等待条件：</strong> 当发生死锁时，所等待的线程(进程)必定会形成一个环路（类似于死循环），造成永久阻塞。</li></ol><h2 id="如何避免线程死锁"><a class="markdownIt-Anchor" href="#如何避免线程死锁"></a> 如何避免线程死锁</h2><p>我们只要<strong>破坏产生死锁的四个条件中的其中一个就可以了</strong>。</p><ol><li><p><strong>破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p></li><li><p><strong>破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p></li><li><p><strong>破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p></li><li><p><strong>破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p></li></ol><hr /><h1 id="如何保证线程安全"><a class="markdownIt-Anchor" href="#如何保证线程安全"></a> 如何保证线程安全</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/qq_26545305/article/details/79516610">【多线程】如何保证线程安全_LemmonTreelss的博客-CSDN博客</a></li></ul></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20180315101631748.png" alt="img" style="zoom: 80%;" /><ol><li><p>互斥同步</p><p>互斥同步是最常见的一种并发正确性保障手段。同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只被一个线程使用（同一时刻，只有一个线程在操作共享数据）。</p><p>在java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码质量，这两个字节码指令都需要一个reference类型的参数来指明要锁定和解锁的对象。</p><p>此外，ReentrantLock 也是通过互斥来实现同步。在基本用法上，ReentrantLock 与 synchronized 很相似，他们都具备一样的线程重入特性。</p><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也成为阻塞同步。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确地同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁。</p></li><li><p>非阻塞同步</p><p>随着硬件指令集的发展，出现了基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采用其他的补偿措施。（最常见的补偿错误就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。</p><p>实现非阻塞同步的方式为CAS。</p></li></ol><h1 id="如何实现多线程中的同步"><a class="markdownIt-Anchor" href="#如何实现多线程中的同步"></a> 如何实现多线程中的同步</h1><blockquote><p><strong>同步(synchronization)<strong>就是</strong>指一个线程访问数据时，其它线程不得对同一个数据进行访问，即同一时刻只能有一个线程访问该数据，当这一线程访问结束时其它线程才能对这它进行访问</strong> 。同步最常见的方式就是使用锁(Lock)，也称为<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E9%94%81&amp;spm=1001.2101.3001.7020">线程锁</a>。锁是一种非强制机制，每一个线程在访问数据或资源之前，首先试图获取(Acquire)锁，并在访问结束之后释放(Release)锁。 <strong>在锁被占用时试图获取锁，线程会进入等待状态，直到锁被释放再次变为可用。</strong></p></blockquote><h2 id="synchronized"><a class="markdownIt-Anchor" href="#synchronized"></a> synchronized</h2><h2 id="lock"><a class="markdownIt-Anchor" href="#lock"></a> Lock</h2><h1 id="volatile"><a class="markdownIt-Anchor" href="#volatile"></a> <code>volatile</code></h1><blockquote><p>答案参考自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/138819184">volatile 关键字，你真的理解吗？ - 知乎 (zhihu.com)</a></li></ul></blockquote><h2 id="volatile-的作用"><a class="markdownIt-Anchor" href="#volatile-的作用"></a> volatile 的作用</h2><ul><li>保证了变量的内存可见性。</li><li>禁止指令的重排序。</li></ul><h2 id="java-内存模型jmm"><a class="markdownIt-Anchor" href="#java-内存模型jmm"></a> Java 内存模型（JMM）</h2><p>JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。</p><p><strong><font size="4">JMM 的规定：</font></strong></p><ul><li><p>所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p></li><li><p>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p></li><li><p>线程对变量的所有的操作（读，取）都必须在工作内存中完成，而不能直接读写主内存中的变量。</p></li><li><p>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</p></li></ul><p><strong><font size="4">JMM 的抽象示意图：</font></strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-3d312429710bd6a11eca171858f67751_720w.jpg" alt="img" style="zoom:80%;" /><h2 id="内存可见性"><a class="markdownIt-Anchor" href="#内存可见性"></a> 内存可见性</h2><p>内存可见性是指当一个线程修改了某个变量的值，其它线程总是能知道这个变量变化。</p><p>也就是说，如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。</p><h2 id="内存可见行的解决方案"><a class="markdownIt-Anchor" href="#内存可见行的解决方案"></a> 内存可见行的解决方案</h2><p>使用 <code>volatile</code> 关键字，或者加锁。</p><p><strong><font size="4">加锁</font></strong></p><blockquote><p><strong>为什么加锁后就保证了变量的内存可见性了？</strong></p></blockquote><p>因为当一个线程进入 <code>synchronized</code> 代码块后，线程获取到锁，会清空本地内存，然后从主内存中拷贝共享变量的最新值到本地内存作为副本，执行代码，又将修改后的副本值刷新到主内存中，最后线程释放锁。</p><p>这里除了 <code>synchronized</code> 外，其它锁也能保证变量的内存可见性。</p><p><strong><font size="4">使用 volatile 关键字</font></strong></p><p>使用 <code>volatile</code> 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，当线程操作变量副本并写回主内存后，会通过 <strong><code>CPU</code> 总线嗅探机制</strong>告知其他线程该变量副本已经失效，需要重新从主内存中读取。</p><p><code>volatile</code> 保证了不同线程对共享变量操作的可见性，也就是说一个线程修改了 <code>volatile</code> 修饰的变量，当修改后的变量写回主内存时，其他线程能立即看到最新值。</p><p><strong><font size="4">总结</font></strong></p><p>使用 <code>volatile</code> 和 <code>synchronized</code> 锁都可以保证共享变量的可见性。相比 <code>synchronized</code> 而言，<code>volatile</code> 可以看作是一个轻量级锁，所以使用 <code>volatile</code> 的成本更低，因为它不会引起线程上下文的切换和调度。</p><p>但 <code>volatile</code> 无法像 <code>synchronized</code> 一样保证操作的原子性。</p><h2 id="volatile-的原子性问题"><a class="markdownIt-Anchor" href="#volatile-的原子性问题"></a> <code>volatile</code> 的原子性问题</h2><blockquote><p>原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。</p></blockquote><p>在多线程环境下，<code>volatile</code> 关键字可以保证共享数据的可见性，但是并不能保证对数据操作的原子性。也就是说，多线程环境下，使用 <code>volatile</code> 修饰的变量是<strong>线程不安全的</strong>。</p><p>要解决这个问题，我们可以使用锁机制，或者使用原子类（如 <code>AtomicInteger</code>）。</p><p>这里特别说一下，对任意单个使用 <code>volatile</code> 修饰的变量的读 / 写是具有原子性，但类似于 <code>flag = !flag</code> 这种复合操作不具有原子性。简单地说就是，<strong>单纯的赋值操作是原子性的</strong>。</p><h2 id="重排序"><a class="markdownIt-Anchor" href="#重排序"></a> 重排序</h2><p>为了提高性能，在遵守 <code>as-if-serial</code> 语义（即不管怎么重排序，单线程下程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守。）的情况下，编译器和处理器常常会对指令做重排序。</p><p>一般重排序可以分为如下三种类型：</p><ul><li>编译器优化重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul> <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-8655d85c8a9df1bc2262485248b07d4d_720w.jpg" alt="img" style="zoom: 80%;" /><h2 id="happen-before-原则"><a class="markdownIt-Anchor" href="#happen-before-原则"></a> happen-before 原则</h2><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p><p><strong><font size="4">单一线程原则</font></strong></p><blockquote><p>Single Thread rule</p></blockquote><p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/874b3ff7-7c5c-4e7a-b8ab-a82a3e038d20.png" alt="img" style="zoom: 67%;" /><p><strong><font size="4">管程锁定规则</font></strong></p><blockquote><p>Monitor Lock Rule</p></blockquote><p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/8996a537-7c4a-4ec8-a3b7-7ef1798eae26.png" alt="img" style="zoom:67%;" /><p><strong><font size="4">volatile 变量规则</font></strong></p><blockquote><p>Volatile Variable Rule</p></blockquote><p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/942f33c9-8ad9-4987-836f-007de4c21de0.png" alt="img" style="zoom:67%;" /><p><strong><font size="4">线程启动规则</font></strong></p><blockquote><p>Thread Start Rule</p></blockquote><p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/6270c216-7ec0-4db7-94de-0003bce37cd2.png" alt="img" style="zoom:67%;" /><p><strong><font size="4">线程加入规则</font></strong></p><blockquote><p>Thread Join Rule</p></blockquote><p>Thread 对象的结束先行发生于 join() 方法返回。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/233f8d89-31d7-413f-9c02-042f19c46ba1.png" alt="img" style="zoom:67%;" /><p><strong><font size="4">线程中断规则</font></strong></p><blockquote><p>Thread Interruption Rule</p></blockquote><p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p><p><strong><font size="4">对象终结规则</font></strong></p><blockquote><p>Finalizer Rule</p></blockquote><p>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p><p><strong><font size="4">传递性</font></strong></p><blockquote><p>Transitivity</p></blockquote><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p><h1 id="synchronized和volatile的区别"><a class="markdownIt-Anchor" href="#synchronized和volatile的区别"></a> synchronized和volatile的区别？</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/suifeng3051/article/details/52611233">volatile和synchronized的区别_Heaven-Wang的博客-CSDN博客_synchronized和volatile区别</a></li></ul></blockquote><ol><li><p>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p></li><li><p>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的</p></li><li><p>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性</p></li><li><p>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</p></li><li><p>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</p></li></ol><h1 id="为何不用volatile替代synchronized"><a class="markdownIt-Anchor" href="#为何不用volatile替代synchronized"></a> 为何不用volatile替代synchronized？</h1><p>因为 volatile 不能保证原子性，当有多个线程修改同一个变量时，例如++操作，无法保证线程同步。</p><hr /><h1 id="synchronized和lock的比较"><a class="markdownIt-Anchor" href="#synchronized和lock的比较"></a> synchronized和Lock的比较</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/b343a9637f95">Synchronized和Lock的区别 - 简书 (jianshu.com)</a></li></ul></blockquote><p><strong>两种锁的底层实现</strong></p><blockquote><p>Synchronized：底层使用指令码方式来控制锁的，映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当线程执行遇到monitorenter指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到monitorexit指令时锁计数器-1，如果计数器为0则释放锁。</p></blockquote><blockquote><p>Lock：底层是CAS乐观锁，依赖AbstractQueuedSynchronizer类，把所有的请求线程构成一个CLH队列。而对该队列的操作均通过Lock-Free（CAS）操作。</p></blockquote><p><strong>两种锁的区别</strong></p><ol><li><p>Synchronized是关键字，内置语言实现，Lock是接口。</p></li><li><p>Synchronized在线程发生异常时会自动释放锁，因此不会发生异常死锁。Lock异常时不会自动释放锁，所以需要在finally中实现释放锁。</p></li><li><p>Lock是可以中断锁，Synchronized是非中断锁，必须等待线程执行完成释放锁。</p></li><li><p>Lock可以使用读锁提高多线程读效率。</p></li></ol><h1 id="锁的分类"><a class="markdownIt-Anchor" href="#锁的分类"></a> 锁的分类</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/qifengshi/p/6831055.html">Java中的锁分类 - byhieg - 博客园 (cnblogs.com)</a></li></ul></blockquote><h2 id="公平锁非公平锁"><a class="markdownIt-Anchor" href="#公平锁非公平锁"></a> 公平锁/非公平锁</h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁。<br />非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。<br />对于Java <code>ReentrantLock</code>而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。<br />对于<code>Synchronized</code>而言，也是一种非公平锁。由于其并不像<code>ReentrantLock</code>是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</p><h2 id="可重入锁"><a class="markdownIt-Anchor" href="#可重入锁"></a> 可重入锁</h2><p>可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。说的有点抽象，下面会有一个代码的示例。<br />对于Java <code>ReentrantLock</code>而言, 他的名字就可以看出是一个可重入锁，其名字是<code>Re entrant Lock</code>重新进入锁。<br />对于<code>Synchronized</code>而言,也是一个可重入锁。可重入锁的一个好处是可一定程度避免死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">setB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，<code>setB()</code> 可能不会被当前线程执行，可能造成死锁。</p><h2 id="独享锁共享锁"><a class="markdownIt-Anchor" href="#独享锁共享锁"></a> 独享锁/共享锁</h2><p>独享锁是指该锁一次只能被一个线程所持有。</p><p>共享锁是指该锁可被多个线程所持有。</p><p>对于<code>Java</code> 的 <code>ReentrantLock</code>而言，其是独享锁。但是对于Lock的另一个实现类<code>ReadWriteLock</code>，其读锁是共享锁，其写锁是独享锁。</p><p>读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p><p>对于<code>Synchronized</code>而言，当然是独享锁。</p><h2 id="互斥锁读写锁"><a class="markdownIt-Anchor" href="#互斥锁读写锁"></a> 互斥锁/读写锁</h2><p>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。</p><p>互斥锁在Java中的具体实现就是<code>ReentrantLock</code>。</p><p>读写锁在Java中的具体实现就是<code>ReadWriteLock</code>。</p><h2 id="乐观锁悲观锁"><a class="markdownIt-Anchor" href="#乐观锁悲观锁"></a> 乐观锁/悲观锁</h2><p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。</p><p>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。</p><p>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</p><p>从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。</p><p>悲观锁在Java中的使用，就是利用各种锁。</p><p>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</p><h2 id="分段锁"><a class="markdownIt-Anchor" href="#分段锁"></a> 分段锁</h2><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于<code>ConcurrentHashMap</code>而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p><p>我们以<code>ConcurrentHashMap</code>来说一下分段锁的含义以及设计思想，<code>ConcurrentHashMap</code>中的分段锁称为<code>Segment</code>，它即类似于<code>HashMap</code>（JDK7与JDK8中<code>HashMap</code>的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个<code>ReentrantLock</code>（<code>Segment</code>继承了<code>ReentrantLock</code>)。</p><p>当需要<code>put</code>元素的时候，并不是对整个<code>HashMap</code>进行加锁，而是先通过<code>hashcode</code>来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程<code>put</code>的时候，只要不是放在一个分段中，就实现了真正的并行的插入。</p><p>但是，在统计<code>size</code>的时候，可就是获取<code>hashmap</code>全局信息的时候，就需要获取所有的分段锁才能统计。</p><p>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p><h2 id="自旋锁"><a class="markdownIt-Anchor" href="#自旋锁"></a> 自旋锁</h2><p>在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU。</p><p>典型的自旋锁实现的例子，可以参考<a href="http://ifeve.com/java_lock_see1/">自旋锁的实现</a>。</p><h2 id="偏向锁轻量级锁重量级锁"><a class="markdownIt-Anchor" href="#偏向锁轻量级锁重量级锁"></a> 偏向锁/轻量级锁/重量级锁</h2><p>这三种锁是指锁的状态，并且是针对<code>Synchronized</code>。在Java 5通过引入锁升级的机制来实现高效<code>Synchronized</code>。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。</p><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p><p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p><h1 id="锁的几种状态-jdk-16-对-synchronized-的优化"><a class="markdownIt-Anchor" href="#锁的几种状态-jdk-16-对-synchronized-的优化"></a> 锁的几种状态 / JDK 1.6 对 synchronized 的优化</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/zmh458/article/details/93053867"> java中锁的四种状态_Hi-Sunshine的博客-CSDN博客</a></li></ul></blockquote><p>锁有四种状态：无锁状态、偏向锁、轻量级锁、重量级锁。具体细节可以参考上一个问题。</p><p>随着锁的竞争，锁的状态会从偏向锁到轻量级锁，再到重量级锁。而且锁的状态只有升级，没有降级。也就是只有偏向锁-&gt;轻量级锁-&gt;重量级锁，没有重量级锁-&gt;轻量级锁-&gt;偏向锁。</p><p>锁状态的改变是根据竞争激烈程度进行的，在几乎无竞争的条件下，会使用偏向锁，在轻度竞争的条件下，会由偏向锁升级为轻量级锁， 在重度竞争的情况下，会升级到重量级锁。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190620153844690.png" alt="在这里插入图片描述" style="zoom: 80%;" /><hr /><h1 id="cas原理"><a class="markdownIt-Anchor" href="#cas原理"></a> CAS原理</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://github.com/LRH1993/android_interview/blob/master/java/concurrence/CAS.md">android_interview/CAS.md at master · LRH1993/android_interview (github.com)</a></li></ul></blockquote><p><strong>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。</strong></p><p>举个CAS操作的应用场景的一个例子，当一个线程需要修改共享变量的值。完成这个操作，先取出共享变量的值赋给A，然后基于A的基础进行计算，得到新值B，完了需要更新共享变量的值了，这个时候就可以调用CAS方法更新变量值了。</p><h2 id="cas的问题"><a class="markdownIt-Anchor" href="#cas的问题"></a> CAS的问题</h2><p>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。</p><ol><li><p>ABA问题。</p><p>因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A－2B－3A。从Java1.5开始JDK的atomic包里提供了一个类 <code>AtomicStampedReference</code> 来解决ABA问题。这个类的 <code>compareAndSet</code> 方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p></li><li><p>循环时间长开销大。</p><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p></li><li><p>只能保证一个共享变量的原子操作。</p><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量<code>i＝2, j=a</code>，合并一下<code>i, j=2a</code>，然后用CAS来操作<code>i, j</code>。从Java1.5开始 JDK 提供了 <code>AtomicReference</code> 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。</p></li></ol><hr /><h1 id="java-线程池"><a class="markdownIt-Anchor" href="#java-线程池"></a> Java 线程池</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://github.com/LRH1993/android_interview/blob/master/java/concurrence/thread-pool.md">android_interview/thread-pool.md at master · LRH1993/android_interview (github.com)</a></li></ul></blockquote><h2 id="为什么java用线程池"><a class="markdownIt-Anchor" href="#为什么java用线程池"></a> 为什么Java用线程池</h2><ol><li><p>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗；</p></li><li><p>提高系统响应速度，当有任务到达时，无需等待新线程的创建便能立即执行；</p></li><li><p>方便线程并发数的管控，线程若是无限制的创建，不仅会额外消耗大量系统资源，更是占用过多资源而阻塞系统或 OOM 等状况，从而降低系统的稳定性。线程池能有效管控线程，统一分配、调优，提供资源使用率；</p></li><li><p>更强大的功能，线程池提供了定时、定期以及可控线程数等功能的线程池，使用方便简单。</p></li></ol><h2 id="线程池参数"><a class="markdownIt-Anchor" href="#线程池参数"></a> 线程池参数</h2><p>我们可以通过 <code>ThreadPoolExecutor</code> 来创建一个线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(....);</span><br></pre></td></tr></table></figure><p>下面我们就来看一下 <code>ThreadPoolExecutor</code> 中的一个构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">   <span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params"><span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params"><span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">TimeUnit unit,</span></span><br><span class="line"><span class="params">BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">RejectedExecutionHandler handler</span></span><br><span class="line"><span class="params">)</span> </span><br></pre></td></tr></table></figure><h3 id="threadpoolexecutor-参数含义"><a class="markdownIt-Anchor" href="#threadpoolexecutor-参数含义"></a> <code>ThreadPoolExecutor</code> 参数含义</h3><p><strong>1. corePoolSize</strong></p><p>线程池中的核心线程数，默认情况下，核心线程一直存活在线程池中，即便他们在线程池中处于闲置状态。除非我们将ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这时候处于闲置的核心线程在等待新任务到来时会有超时策略，这个超时时间由keepAliveTime来指定。一旦超过所设置的超时时间，闲置的核心线程就会被终止。</p><p><strong>2. maximumPoolSize</strong></p><p>线程池中所容纳的最大线程数，如果活动的线程达到这个数值以后，后续的新任务将会被阻塞。包含核心线程数+非核心线程数。</p><p><strong>3. keepAliveTime</strong></p><p>非核心线程闲置时的超时时长，对于非核心线程，闲置时间超过这个时间，非核心线程就会被回收。只有对 ThreadPoolExecutor 的 allowCoreThreadTimeOut 属性设为 true 的时候，这个超时时间才会对核心线程产生效果。</p><p><strong>4. unit</strong></p><p>用于指定 <code>keepAliveTime</code> 参数的时间单位。他是一个枚举，可以使用的单位有七种：</p><table><thead><tr><th style="text-align:center">时间单位</th><th style="text-align:center">变量名</th></tr></thead><tbody><tr><td style="text-align:center">天</td><td style="text-align:center"><code>TimeUnit.DAYS</code></td></tr><tr><td style="text-align:center">小时</td><td style="text-align:center"><code>TimeUnit.HOURS</code></td></tr><tr><td style="text-align:center">分钟</td><td style="text-align:center"><code>TimeUnit.MINUTES</code></td></tr><tr><td style="text-align:center">秒</td><td style="text-align:center"><code>TimeUnit.SECONDS</code></td></tr><tr><td style="text-align:center">毫秒</td><td style="text-align:center"><code>TimeUnit.MILLISECONDS</code></td></tr><tr><td style="text-align:center">微秒(千分之一毫秒)</td><td style="text-align:center"><code>TimeUnit.MICROSECONDS</code></td></tr><tr><td style="text-align:center">毫微秒(千分之一微秒)</td><td style="text-align:center"><code>TimeUnit.NANOSECONDS</code></td></tr></tbody></table><p><strong>5. workQueue</strong></p><p>线程池中保存等待执行的任务的阻塞队列。通过线程池中的execute方法提交的Runable对象都会存储在该队列中。我们可以选择下面几个阻塞队列。</p><table><thead><tr><th>阻塞队列</th><th>说明</th></tr></thead><tbody><tr><td>ArrayBlockingQueue</td><td>基于数组实现的有界的阻塞队列,该队列按照FIFO（先进先出）原则对队列中的元素进行排序。</td></tr><tr><td>LinkedBlockingQueue</td><td>基于链表实现的阻塞队列，该队列按照FIFO（先进先出）原则对队列中的元素进行排序。</td></tr><tr><td>SynchronousQueue</td><td>内部没有任何容量的阻塞队列。在它内部没有任何的缓存空间。对于 SynchronousQueue 中的数据元素只有当我们试着取走的时候才可能存在。</td></tr><tr><td>PriorityBlockingQueue</td><td>具有优先级的无限阻塞队列。</td></tr></tbody></table><p>我们还能够通过实现 BlockingQueue 接口来自定义我们所需要的阻塞队列。</p><p><strong>6. threadFactory</strong></p><p>线程工厂，为线程池提供新线程的创建。ThreadFactory是一个接口，里面只有一个newThread方法。 默认为DefaultThreadFactory类。</p><p><strong>7. handler</strong></p><p>是 RejectedExecutionHandler 对象，而 RejectedExecutionHandler 是一个接口，里面只有一个 rejectedExecution 方法。</p><p>当任务队列已满并且线程池中的活动线程已经达到所限定的最大值或者是无法成功执行任务，这时候 ThreadPoolExecutor 会调用 RejectedExecutionHandler 中的  rejectedExecution 方法。在 ThreadPoolExecutor 中有四个内部类实现了 RejectedExecutionHandler 接口。在线程池中它默认是 AbortPolicy ，在无法处理新任务时抛出 RejectedExecutionException 异常。</p><p>下面是在 ThreadPoolExecutor 中提供的四个可选值。</p><table><thead><tr><th>可选值</th><th>说明</th></tr></thead><tbody><tr><td>CallerRunsPolicy</td><td>只用调用者所在线程来运行任务。</td></tr><tr><td>AbortPolicy</td><td>直接抛出RejectedExecutionException异常。</td></tr><tr><td>DiscardPolicy</td><td>丢弃掉该任务，不进行处理。</td></tr><tr><td>DiscardOldestPolicy</td><td>丢弃队列里最近的一个任务，并执行当前任务。</td></tr></tbody></table><p>我们也可以通过实现RejectedExecutionHandler接口来自定义我们自己的handler。如记录日志或持久化不能处理的任务。</p><p><strong>创建用例</strong></p><p><code>OkHttp</code> 中线程池的创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">executorService = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">0</span>, </span><br><span class="line">    Integer.MAX_VALUE, </span><br><span class="line">    <span class="number">60</span>, </span><br><span class="line">    TimeUnit.SECONDS, </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(), </span><br><span class="line">    Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="literal">false</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>该线程池的核心线程数为 0，线程池最有能容纳 <code>Integer.MAX_VALUE</code> 个线程，且线程的空闲存活时间为 60s（可以理解为 okhttp 随时可以创建新的线程来满足需要。可以保证网络的 I/O 任务有线程来处理，不被阻塞）。</p><h2 id="线程池的关闭"><a class="markdownIt-Anchor" href="#线程池的关闭"></a> 线程池的关闭</h2><p>调用线程池的 <code>shutdown()</code> 或 <code>shutdownNow()</code> 方法来关闭线程池</p><p><code>shutdown</code>原理：将线程池状态设置成 <code>SHUTDOWN</code> 状态，然后中断所有没有正在执行任务的线程。</p><p><code>shutdownNow</code>原理：将线程池的状态设置成 <code>STOP</code> 状态，然后中断所有任务(包括正在执行的)的线程，并返回等待执行任务的列表。</p><h2 id="有几种线程池"><a class="markdownIt-Anchor" href="#有几种线程池"></a> 有几种线程池</h2><p>Java中四种具有不同功能常见的线程池。他们都是直接或者间接配置 ThreadPoolExecutor 来实现他们各自的功能。这四种线程池分别是</p><ol><li>newFixedThreadPool</li><li>newCachedThreadPool</li><li>newScheduledThreadPool</li><li>newSingleThreadExecutor</li></ol><p>这四个线程池可以通过Executors类获取。</p><hr /><h1 id="android-多线程通信"><a class="markdownIt-Anchor" href="#android-多线程通信"></a> Android 多线程通信</h1><ol><li><code>Handler</code> 机制</li><li><code>AsyncTask</code> 类</li></ol><hr /><h1 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> TODO</h1><ol><li>CLH 与 AQS</li><li>其他并发容器</li></ol>]]></content>
    
    
    <summary type="html">整理了关于多线程的部分面试题目。</summary>
    
    
    
    <category term="Java" scheme="https://luoyu-ying.github.io/categories/Java/"/>
    
    <category term="2022校招面试整理" scheme="https://luoyu-ying.github.io/categories/2022%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
    <category term="2022校招面试整理" scheme="https://luoyu-ying.github.io/tags/2022%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="多线程" scheme="https://luoyu-ying.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
