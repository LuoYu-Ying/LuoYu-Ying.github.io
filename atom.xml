<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洛语 の Blog</title>
  
  
  <link href="https://luoyu-ying.github.io/atom.xml" rel="self"/>
  
  <link href="https://luoyu-ying.github.io/"/>
  <updated>2022-12-12T15:42:02.000Z</updated>
  <id>https://luoyu-ying.github.io/</id>
  
  <author>
    <name>LuoYu-Ying</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MYSQL 密码修改</title>
    <link href="https://luoyu-ying.github.io/posts/baf45ef94c85/"/>
    <id>https://luoyu-ying.github.io/posts/baf45ef94c85/</id>
    <published>2022-12-12T15:42:02.000Z</published>
    <updated>2022-12-12T15:42:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>文章参考：</p><ul><li><a href="http://c.biancheng.net/view/7152.html">MySQL修改密码的3种方式 (biancheng.net)</a></li></ul></blockquote><hr /><h1 id="使用-mysqladmin-指令修改密码"><a class="markdownIt-Anchor" href="#使用-mysqladmin-指令修改密码"></a> 使用 <code>mysqladmin</code> 指令修改密码</h1><blockquote><p><code>mysqladmin</code> 指令形式：<code>mymysqladmin -u用户名 -p旧密码 password 新密码</code></p><p>注意：下图修改密码的命令中 <code>-uroot</code> 和 <code>-proot</code> 是整体，不要写成 <code>-u</code> <code>root</code> <code>-p</code> <code>root</code>，<code>-u</code> 和 <code>root</code> 间可以加空格，但是会有警告出现，所以就不要加空格了。</p></blockquote><ol><li>打开 <strong>管理员:命令提示符</strong> 。</li><li>输入 <code>mysqladmin</code> 命令修改密码。</li><li>使用 <code>mysql -u用户名 -p</code> 的命令进入数据库。</li></ol><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/5-20011Q60KGc.png" alt="img" /></p>]]></content>
    
    
    <summary type="html">记录了 MYSQL 修改数据库密码的方式。</summary>
    
    
    
    <category term="MYSQL" scheme="https://luoyu-ying.github.io/categories/MYSQL/"/>
    
    
    <category term="MYSQL" scheme="https://luoyu-ying.github.io/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统 第5-10章 练习题整理</title>
    <link href="https://luoyu-ying.github.io/posts/ab3c0562c28c/"/>
    <id>https://luoyu-ying.github.io/posts/ab3c0562c28c/</id>
    <published>2022-11-25T15:32:30.000Z</published>
    <updated>2022-11-25T15:32:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章"><a class="markdownIt-Anchor" href="#第五章"></a> 第五章</h1><hr /><blockquote>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">&#123;</span><br><span class="line">    *xp += *yp; </span><br><span class="line">    *xp += *yp;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">&#123;</span><br><span class="line">    *xp += <span class="number">2</span> * (*yp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论何种情况下，以上两个代码块行为相同（ B ）</p><p>A. 对</p><p>B. 错</p></blockquote><p>当 <code>xp</code> 和 <code>yp</code> 同时指向同一个地址时，第一个代码块的结果为 <code>4(*xp)</code>，而第二个代码块的结果为 <code>3(*xp)</code>。</p><hr /><blockquote><p><code>f1</code> 和 <code>f2</code> 是两个浮点数，关于下面两条语句，说法正确的是（ D ）</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1 =（f1 + f2) + f2; <span class="comment">// 第一条 </span></span><br><span class="line">f1 = f1 + (f2 + f2); <span class="comment">// 第二条</span></span><br></pre></td></tr></table></figure><p>A. 第一条执行时间快</p><p>B. 第二条执行时间快</p><p>C. 两条语句执行结果相同</p><p>D. 两条语句执行结果可能不同</p></blockquote><p>具体内容可重新查看书中第一、二章内容。</p><hr /><blockquote><p>关于现代微处理器，下面描述正确的是（ A B C D ）</p><p>A. 可以在每个时钟周期执行多个操作。</p><p>B. 指令执行的顺序不一定要与他们在机器级程序中的顺序一致。</p><p>C. 指令控制单元负责从内存中读出指令序列，并据其生成一组针对程序数据的基本操作。</p><p>D. 执行单元执行指令控制单元生成的操作。</p></blockquote><p>《深入理解计算机系统》5.7 理解现代处理器：</p><p>​现代微处理器取得的了不起的功绩之一是：它们采用复杂而奇异的微处理器结构，其中，<strong>多条指令可以并行地执行</strong>，同时又呈现出一种简单的顺序执行指令的表象。</p><p>​这些处理器在工业界称为超标量 (superscalar) , 意思是 <strong>它可以在每个时钟周期执行多个操作</strong>，而且是乱序的 (out-of-order) , 意思就是<strong>指令执行的顺序不一定要与它们在机器级程序中的顺序一致</strong>。</p><p>​整个设计有两个主要部分：<strong>指令控制单元</strong> (Instruction Control Unit, ICU) 和 <strong>执行单元</strong> (Execution Unit, EU) 。<strong>前者负责从内存中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作；而后者执行这些操作。</strong></p><hr /><blockquote><p>下列说法正确的是（ A B D ）</p><p>A. 现代处理器有专门的功能单元来执行加载和存储操作。</p><p>B. 对于寄存器操作，在指令被译码成操作的时候，处理器就可以确定哪些指令会影响其他哪些指令。</p><p>C. 对于内存操作，在指令被译码成操作的时候，处理器就可以确定哪些指令会影响其他哪些指令。</p><p>D. 对于内存操作，只有到加载和存储的地址被计算出来以后，处理器才能确定哪些指令会影响其他哪些指令。</p></blockquote><ul><li><p>5.7 理解现代处理器：</p><p>Intel Core i7 Haswell 参考机有 8 个功能单元，编号为 0~7。下面部分列出了每个单元的功能：</p><table><thead><tr><th style="text-align:right">编号</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:right">0</td><td>整数运算、浮点乘、整数和浮点数除法、分支</td></tr><tr><td style="text-align:right">1</td><td>整数运算、浮点加、整数乘、浮点乘</td></tr><tr><td style="text-align:right">2</td><td><strong>加载</strong>、地址计算</td></tr><tr><td style="text-align:right">3</td><td><strong>加载</strong>、地址计算</td></tr><tr><td style="text-align:right">4</td><td><strong>存储</strong></td></tr><tr><td style="text-align:right">5</td><td>整数运算</td></tr><tr><td style="text-align:right">6</td><td>整数运算、分支</td></tr><tr><td style="text-align:right">7</td><td><strong>存储</strong>、地址计算</td></tr></tbody></table></li><li><p>5.12.2 存储的性能</p><p>对于 <strong>寄存器操作</strong>，在指令被译码成操作的时候，处理器就可以确定哪些指令会影响其他哪些指令。</p><p>另一方面，对于 <strong>内存操作</strong>，只有到计算出加载和存储的地址被计算出来以后，处理器才能确定哪些指令会影响其他的哪些。</p></li></ul><hr /><blockquote><p>编写高效程序，下列说法正确的是（ A C ）</p><p>A. 程序员必须选择一组适当的算法和数据结构。</p><p>B. 大多数编译器会优化程序员给出的算法和数据结构。</p><p>C. 程序员必须编写出编译器能够有效优化以转换成高效可执行代码的源代码。</p><p>D. 大多数编译器可以轻易优化C语言的指针运算。</p></blockquote><p>《深入理解计算机系统》第五章 优化程序性能：</p><p>​编写高效程序需要做到以下几点：第一，<strong>我们必须选择一组适当的算法和数据结构</strong>。第二，<strong>我们必须编写出编译器能够有效优化以转换成高效可执行代码的源代码</strong>。C 语言的有些特性，例如<strong>执行指针运算</strong>和强制类型转换的能力，<strong>使得编译器很难对它进行优化</strong>。</p><p>​优化编译器会试着进行代码移动。不幸的是，就像前面讨论过的那样，对于会改变在哪里调用函数或调用多少次的变换，编译器通常会非常小心。<strong>它们不能可靠地发现一个函数是否会有副作用</strong>，因而假设函数会有副作用，并保持所有的函数调用不变。</p><hr /><h1 id="第七章"><a class="markdownIt-Anchor" href="#第七章"></a> 第七章</h1><hr />]]></content>
    
    
    <summary type="html">《深入理解计算机系统》第五章-第十章练习题整理。</summary>
    
    
    
    <category term="计算机系统" scheme="https://luoyu-ying.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机系统" scheme="https://luoyu-ying.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>AutoHotKey 萌新学习笔记 热键</title>
    <link href="https://luoyu-ying.github.io/posts/e7ba750d9a41/"/>
    <id>https://luoyu-ying.github.io/posts/e7ba750d9a41/</id>
    <published>2022-11-15T15:25:47.000Z</published>
    <updated>2022-11-15T15:25:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><h2 id="autohotkey-是什么"><a class="markdownIt-Anchor" href="#autohotkey-是什么"></a> <code>AutoHotKey</code> 是什么</h2><p><code>AutoHotkey</code> 是一门 <code>Windows</code> 平台下的脚本语言，支持热键、热字符、Windows API，能够快捷或自动执行重复性任务。</p><h2 id="autohotkey-官网"><a class="markdownIt-Anchor" href="#autohotkey-官网"></a> <code>AutoHotKey</code> 官网</h2><p><a href="https://www.autohotkey.com/">AutoHotkey</a></p><h2 id="使用的-autohotkey-版本"><a class="markdownIt-Anchor" href="#使用的-autohotkey-版本"></a> 使用的 <code>AutoHotKey</code> 版本</h2><p>1.1.35.00</p><hr /><h1 id="热键是什么"><a class="markdownIt-Anchor" href="#热键是什么"></a> 热键是什么</h1><blockquote><p>官网文档：<a href="https://wyagd001.github.io/zh-cn/docs/Hotkeys.htm">热键 - 定义与使用 | AutoHotkey (wyagd001.github.io)</a></p></blockquote><p>热键是用来触发某些动作的按键或组合按键。有时也称为快捷键，因为它们能简便地触发动作(例如运行程序或键盘宏)。</p><hr /><h1 id="热键形式"><a class="markdownIt-Anchor" href="#热键形式"></a> 热键形式</h1><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">热键::</span></span><br><span class="line">    代码块</span><br><span class="line"><span class="keyword">Return</span></span><br></pre></td></tr></table></figure><p>形如以上代码的代码片段可以被理解为一个热键的实现。</p><p>通常快捷键组合由可选的前缀/修饰键(<code>Ctrl</code>, <code>Alt</code>, <code>Shift</code> 和 <code>LWin</code>/<code>RWin</code>) 和单个后缀键组成，标准的修饰键就是这样设计的，所以按下时通常没有立即效果。</p><hr /><h1 id="热键修饰符"><a class="markdownIt-Anchor" href="#热键修饰符"></a> 热键修饰符</h1><blockquote><p>在 <code>Windows</code> 操作系统中，默认可以使用 <code>Win + D</code> 的快捷键来显示桌面。其中 <code>Win</code> 就为修饰符，在 <code>AutoHotKey</code> 中使用 <code>#</code> 来表示作为修饰符的 <code>Win</code>。</p></blockquote><p><strong>在定义热键时您可以使用下列常见的修饰符：</strong></p><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">#</td><td style="text-align:left"><code>Win</code></td></tr><tr><td style="text-align:center">!</td><td style="text-align:left"><code>Alt</code></td></tr><tr><td style="text-align:center">^</td><td style="text-align:left"><code>Ctrl</code></td></tr><tr><td style="text-align:center">+</td><td style="text-align:left"><code>Shift</code></td></tr><tr><td style="text-align:center">&amp;</td><td style="text-align:left">合并两个按键（含鼠标按键）成为一个自定义热键。</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:left">使用成对按键中左边的那个. 例如 <code>&lt;!a</code> 相当于 <code>!a</code>, 只是使用左边的 <code>Alt</code> 才可以触发。</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:left">使用成对按键中右边的按键来触发效果。</td></tr><tr><td style="text-align:center">*</td><td style="text-align:left">通配符，只要当前的快捷键输入中包含通配符之后的热键便也会触发该热键效果。<br />如使用<code>*#c::Run Calc.exe</code>，那么<code>Win+C</code>, <code>Shift+Win+C</code>, <code>Ctrl+Win+C</code> 等都会触发此热键。</td></tr><tr><td style="text-align:center">~</td><td style="text-align:left">触发热键时，热键中按键原有的功能不会被屏蔽。</td></tr><tr><td style="text-align:center">$</td><td style="text-align:left">通常只在脚本使用 <code>Send</code> 命令发送包含了热键自身的按键时才需要使用此符号，否则可能会导致热键触发自己。</td></tr><tr><td style="text-align:center"><code>UP</code></td><td style="text-align:left">单词 <code>UP</code> 可以跟在热键名后面使得在释放按键时触发热键，而不是按下时。</td></tr></tbody></table><p><strong>下面将对其中的部分修饰符进行更加详细的解释和用法：</strong></p><hr /><h1 id="自定义组合键"><a class="markdownIt-Anchor" href="#自定义组合键"></a> 自定义组合键</h1>]]></content>
    
    
    <summary type="html">关于 AutoHotKey 热键的学习</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hexo Butterfly 美化-修改分割线的样式</title>
    <link href="https://luoyu-ying.github.io/posts/53768a5482ee/"/>
    <id>https://luoyu-ying.github.io/posts/53768a5482ee/</id>
    <published>2022-10-24T11:50:09.000Z</published>
    <updated>2022-11-15T08:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>查看大佬们的博客的时候，并没有看到详细自定义分割线样式的博客，所以想记录一下自己美化分割线的过程。</p><blockquote><p><strong>Butterfly 主题默认分割线样式</strong></p>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221024200848426.png" alt="Butterfly 主题默认分割线样式" style="zoom:80%;" /><p><strong>通过修改后的分割线样式</strong></p>  <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026222103059.png" alt="通过修改后的分割线样式" style="zoom:90%;" /></blockquote><hr /><blockquote><p><strong>更改设置后需要进行 <code>hexo clean</code> 操作哦~</strong></p></blockquote><hr /><h1 id="修改浮动图标图片"><a class="markdownIt-Anchor" href="#修改浮动图标图片"></a> 修改浮动图标图片</h1><p>将剪刀图片修改为其他的图片，如上文中的小汽车图片。</p><p>两种方式可以修改：</p><ol><li><p>修改 <code>_config.butterfly.yml</code> 文件中的 <code>hr_icon -&gt; icon</code> 内容（推荐）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The setting of divider icon (水平分隔線圖標設置)</span></span><br><span class="line"><span class="attr">hr_icon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">&#x27;\f5e4&#x27;</span> <span class="comment"># the unicode value of Font Awesome icon, such as &#x27;\3423&#x27;</span></span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br></pre></td></tr></table></figure></li><li><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>hr -&gt; &amp;:before -&gt; content</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hr</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attribute">content</span>: <span class="variable">$hr</span>-icon // 同样修改为如 <span class="string">&#x27;\3423&#x27;</span> 形式</span><br></pre></td></tr></table></figure></li></ol><p>如果想去除浮动图标，仅需将参数修改为 <code>''</code> 即可，例如 <code>icon: ''</code>。</p><blockquote><p><strong><code>the unicode value of Font Awesome icon</code> 获取方法：</strong></p><ol><li><p>打开 <code>Font Awesome</code> 网址：<a href="https://fontawesome.com/v5/search">Search v5 Icons | Font Awesome</a></p></li><li><p>通过搜索栏选择并点击自己心仪的图标</p></li><li><p>下图中箭头所指内容即为 <code>the unicode value of Font Awesome icon</code></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026225602023.png" alt="the unicode value of Font Awesome icon" style="zoom:60%;" /></li></ol></blockquote><hr /><h1 id="修改浮动图标颜色"><a class="markdownIt-Anchor" href="#修改浮动图标颜色"></a> 修改浮动图标颜色</h1><p>修改浮动图标的颜色，同样可以有两种方法进行更改：</p><ol><li><p>修改 <code>_config.butterfly.yml</code> 中的 <code>theme_color -&gt; hr_color</code> 内容（推荐）</p><p><strong>可能会将分割线横线的颜色同时进行更改。</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme_color:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br><span class="line">  <span class="attr">hr_color:</span> <span class="string">&quot;#A4D8FA&quot;</span> <span class="string">//</span> <span class="string">修改此处内容</span></span><br></pre></td></tr></table></figure></li><li><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>hr -&gt; &amp;:before -&gt; color</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hr</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attribute">color</span>: var(--hr-before-color) // 修改为如 <span class="number">#A4D8FA</span> 形式</span><br></pre></td></tr></table></figure></li></ol><hr /><h1 id="修改浮动图标相对于横线的位置"><a class="markdownIt-Anchor" href="#修改浮动图标相对于横线的位置"></a> 修改浮动图标相对于横线的位置</h1><p>可以通过两种方式进行修改：</p><ol><li><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>hr -&gt; &amp;:before -&gt; line-height</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hr</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="selector-pseudo">&amp;:before</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1</span> // 图标浮于横线中间，其他参数见下文</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>line-height</code> 参数说明：</strong></p><ul><li><p><code>1</code></p><p>图标浮于横线中间</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026230524821.png" style="zoom:80%;" /></li><li><p><code>0</code></p><p>图标浮于横线上方</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026230609189.png" style="zoom:80%;" /></li><li><p><code>-1</code></p><p>图标浮于横线下方</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026230634557.png" style="zoom:80%;" /></li></ul></blockquote></li><li><p>修改 <code>_config.butterfly.yml</code> 文件中的 <code>hr_icon -&gt; icon-top</code> 内容</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The setting of divider icon (水平分隔線圖標設置)</span></span><br><span class="line"><span class="attr">hr_icon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br><span class="line">  <span class="attr">icon-top:</span></span><br></pre></td></tr></table></figure></li></ol><hr /><h1 id="修改横线虚实"><a class="markdownIt-Anchor" href="#修改横线虚实"></a> 修改横线虚实</h1><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>hr -&gt; border</code> 中的 <code>dashed</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hr</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> dashed var(--hr-border)</span><br></pre></td></tr></table></figure><blockquote><p><strong>其中第二个参数说明：</strong></p><ul><li><p><code>dashed</code></p><p>虚线效果</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026222103059.png" alt="通过修改后的分割线样式" style="zoom:90%;" /></li><li><p><code>solid</code></p><p>实线效果</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221115165404929.png" alt="pic" style="zoom:80%;" /></li></ul></blockquote><hr /><h1 id="修改横线粗细"><a class="markdownIt-Anchor" href="#修改横线粗细"></a> 修改横线粗细</h1><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>hr -&gt; border</code> 中的 <code>2px</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hr</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> dashed var(--hr-border)</span><br></pre></td></tr></table></figure><blockquote><p><strong>数字效果对比：</strong></p><ul><li><p><code>2px</code></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221026222103059.png" alt="通过修改后的分割线样式"  /></li><li><p><code>5px</code></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221115174052677.png" alt="image-20221115174052677" style="zoom:90%;" /></li></ul></blockquote><hr /><h1 id="修改横线颜色"><a class="markdownIt-Anchor" href="#修改横线颜色"></a> 修改横线颜色</h1><ol><li><p>修改 <code>_config.butterfly.yml</code> 中的 <code>theme_color -&gt; hr_color</code> 内容（推荐）</p><p><strong>可能会将分割线横线的颜色同时进行更改。</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme_color:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="string">//</span> <span class="string">...</span></span><br><span class="line">  <span class="attr">hr_color:</span> <span class="string">&quot;#A4D8FA&quot;</span> <span class="string">//</span> <span class="string">修改此处内容</span></span><br></pre></td></tr></table></figure></li><li><p>修改 <code>themes\butterfly\source\css\_global\index.styl</code> 文件中的 <code>:root -&gt; --hr-border</code> 内容</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">--hr-border</span>: <span class="built_in">lighten</span>(<span class="variable">$theme</span>-hr-<span class="attribute">color</span>,;<span class="number">50%</span>)</span><br></pre></td></tr></table></figure><p>将 <code>lighten($theme-hr-color,;50%)</code> 部分修改为<strong>十六进制颜色表示方式</strong>即可。</p></li></ol>]]></content>
    
    
    <summary type="html">记录一下自己修改 Butterfly 主题的分割线样式修改过程。</summary>
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>《图解HTTP》阅读笔记（一）</title>
    <link href="https://luoyu-ying.github.io/posts/c6d0698aa12b/"/>
    <id>https://luoyu-ying.github.io/posts/c6d0698aa12b/</id>
    <published>2022-09-29T06:17:45.000Z</published>
    <updated>2022-09-29T06:17:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-了解web及网络基础"><a class="markdownIt-Anchor" href="#第一章-了解web及网络基础"></a> 第一章 了解Web及网络基础</h1><h2 id="http-诞生"><a class="markdownIt-Anchor" href="#http-诞生"></a> HTTP 诞生</h2><h3 id="为知识共享而规划-web"><a class="markdownIt-Anchor" href="#为知识共享而规划-web"></a> 为知识共享而规划 Web</h3><p>现在已经提出了 3 项 WWW （万维网）构建技术，分别是：</p><ol><li>作为页面的文本标记语言的 HTML（超文本标记语言）</li><li>所谓文档传递协议的 HTTP（超文本传输协议）</li><li>指定文档所在地址的 URL（统一资源定位符）</li></ol><h3 id="驻足不前的-http"><a class="markdownIt-Anchor" href="#驻足不前的-http"></a> 驻足不前的 HTTP</h3><ol><li>HTTP/0.9</li><li>HTTP/1.0</li><li>HTTP/1.1</li></ol><h2 id="网络基础-tcpip"><a class="markdownIt-Anchor" href="#网络基础-tcpip"></a> 网络基础 TCP/IP</h2><blockquote><p>不同的硬件、操作系统之间 的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议 （protocol）。</p><p><strong>TCP/IP 是互联网相关的各类协议族的总称。</strong></p></blockquote><h3 id="tcpip-的分层管理"><a class="markdownIt-Anchor" href="#tcpip-的分层管理"></a> TCP/IP 的分层管理</h3><p>TCP/IP 协议族按层次分别 分为以下 4 层：应用层、传输层、网络层和数据链路层。TCP/IP 协议族各层的作用如下。</p><p><strong>应用层</strong></p><p>应用层决定了向用户提供应用服务时通信的活动。HTTP 协议也处于该层。</p><p><strong>传输层</strong></p><p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的 数据传输。</p><p>在传输层有两个性质不同的协议：TCP（Transmission Control  Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据 报协议）。</p><p><strong>网络层</strong></p><p>网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。</p><p>网络层 所起的作用就是在众多的选项内选择一条传输路线</p><p><strong>链路层</strong></p><p>硬件上的范畴 均在链路层的作用范围之内。</p><h3 id="tcpip-通信传输流"><a class="markdownIt-Anchor" href="#tcpip-通信传输流"></a> TCP/IP 通信传输流</h3><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221006225838653.png" alt="image-1" style="zoom:67%;" /><p>利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221006225940392.png" alt="image-2" style="zoom: 67%;" /><p>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个 该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层 时会把对应的首部消去。</p><p>这种把数据信息包装起来的做法称为封装（encapsulate）。</p><h2 id="理解-ip-tcp-和-dns-协议"><a class="markdownIt-Anchor" href="#理解-ip-tcp-和-dns-协议"></a> 理解 IP、TCP 和 DNS 协议</h2><h3 id="负责传输的-ip-协议"><a class="markdownIt-Anchor" href="#负责传输的-ip-协议"></a> 负责传输的 IP 协议</h3><p>按层次分，IP（Internet Protocol）网际协议位于网络层。TCP/IP 协议族中的 IP 指的就是网际协议。</p><p>可能有人会 把 “IP” 和 “IP 地址” 搞混，“IP” 其实是一种协议的名称。</p><ul><li><strong>IP 协议</strong> 的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。</li><li><strong>IP 地址</strong> 指明了节点被分配到的地址，MAC 地址是指网卡所属的固 定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。</li></ul><p><strong>使用 ARP 协议凭借 MAC 地址进行通信</strong></p><p>IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网 （LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。</p><p>这时，会采用 ARP 协议（Address Resolution  Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。</p><p><strong>没有人能够全面掌握互联网中的传输状况</strong></p><p>在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线。</p><p>这种机制称为路由选择（routing），无论哪台计算机、哪台网络设备，它 们都无法全面掌握互联网中的细节。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20221006230911597.png" alt="image-3" style="zoom:67%;" /><h3 id="确保可靠性的-tcp-协议"><a class="markdownIt-Anchor" href="#确保可靠性的-tcp-协议"></a> 确保可靠性的 TCP 协议</h3>]]></content>
    
    
    <summary type="html">《图解HTTP》 第一章、第二章</summary>
    
    
    
    <category term="HTTP" scheme="https://luoyu-ying.github.io/categories/HTTP/"/>
    
    
    <category term="HTTP" scheme="https://luoyu-ying.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 在同一行中声明多个变量</title>
    <link href="https://luoyu-ying.github.io/posts/d5b7437105b8/"/>
    <id>https://luoyu-ying.github.io/posts/d5b7437105b8/</id>
    <published>2022-09-28T11:26:57.000Z</published>
    <updated>2022-09-28T11:26:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>注：尽管在 <code>Kotlin</code> 中可以达到一行中声明多个变量的效果，但是不推荐如此做。</p></blockquote><hr /><p>在 <code>Kotlin</code> 中，正常情况下无法做到将多个变量放在同一行中声明。</p><p>我们可以通过取巧的方法达到我们所需要的效果，<strong>但是不适用与 <code>lateinit</code> 前缀</strong>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">18</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 声明了 8 个变量，支持 val / var</span></span><br><span class="line">    <span class="keyword">var</span> (a, b, c, d) = listOf(<span class="string">&quot;fly&quot;</span>, <span class="number">9</span>, <span class="number">55.9</span>, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">val</span> (e, f) = listOf(<span class="string">&#x27;c&#x27;</span>, person)</span><br><span class="line">    <span class="keyword">val</span> (name, age) = person</span><br><span class="line">    </span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$a</span> <span class="variable">$b</span> <span class="variable">$c</span> <span class="variable">$d</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$e</span> <span class="variable">$f</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$name</span> <span class="variable">$age</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fly <span class="number">9</span> <span class="number">55.9</span> <span class="literal">true</span></span><br><span class="line">c Person(name=Jack, age=<span class="number">18</span>)</span><br><span class="line">Jack <span class="number">18</span></span><br></pre></td></tr></table></figure><hr /><p>可以发现，该方法本用于取出一个类变量的主构造方法中的所有参数，但是我们仍然可以使用该方法完成我们想要的效果。</p><p>我们使用 <code>listOf</code> 创建了类型为 <code>Object</code> 的列表，并且一一对应的将其赋值给了前面我们定义的变量的顺序，这样我们就完成了一行中进行多个变量的声明的操作了。</p><p><strong>此方法不适用于含有 <code>lateinit</code> 前缀的变量声明。</strong></p><p>相较于其他的语言，如 <code>double a, b, c, d;</code>，这种方法可以在一行中声明不同的类型的变量。</p>]]></content>
    
    
    <summary type="html">探索如何在同一行中声明多个属性。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>英语 编程命名 单词规范表 [自用]</title>
    <link href="https://luoyu-ying.github.io/posts/03b86e3ef474/"/>
    <id>https://luoyu-ying.github.io/posts/03b86e3ef474/</id>
    <published>2022-09-13T06:30:07.000Z</published>
    <updated>2022-09-13T06:30:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命名规范"><a class="markdownIt-Anchor" href="#命名规范"></a> 命名规范</h1><ol><li>属性使用名词性短语。</li><li>动作使用动词或者一个描述当前函数功能的一个动作短语。</li><li>函数命名无需使用任何时态，皆使用一般形式即可。</li><li>编写函数时，尽量满足函数单一职责以及不变性原则。</li></ol><hr /><h1 id="单词表"><a class="markdownIt-Anchor" href="#单词表"></a> 单词表</h1><table><thead><tr><th style="text-align:center">单词</th><th style="text-align:center">词性</th><th style="text-align:center">中文</th></tr></thead><tbody><tr><td style="text-align:center">landscape</td><td style="text-align:center">n.</td><td style="text-align:center">横屏</td></tr><tr><td style="text-align:center">portrait</td><td style="text-align:center">n.</td><td style="text-align:center">竖屏</td></tr><tr><td style="text-align:center">start</td><td style="text-align:center">v.</td><td style="text-align:center">开始、启动</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">规范和整理一下自己在写代码时命名的统一和规范。(持续更新)</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Android Studio 调试断点类型</title>
    <link href="https://luoyu-ying.github.io/posts/624cb914d8f1/"/>
    <id>https://luoyu-ying.github.io/posts/624cb914d8f1/</id>
    <published>2022-09-04T12:31:36.000Z</published>
    <updated>2022-09-04T12:31:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>更多内容待完善~ ( •̀ ω •́ )✧</p></blockquote><p>在 <code>Intellj IDEA</code> 和 <code>Android Studio</code> 两个软件中调试 <code>Kotlin</code> 代码的时候，肯定会与断点打交道，那么扩充关于断点的知识可以让我们进行更加方便和快速的工作。</p><hr /><h1 id="调试的两种方法"><a class="markdownIt-Anchor" href="#调试的两种方法"></a> 调试的两种方法</h1><h2 id="debug-app"><a class="markdownIt-Anchor" href="#debug-app"></a> <code>Debug App</code></h2><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220912113808254.png" alt="image-20220912113808254" /></p><p>会重新进行一次编译，并使用新打出的 debug 包进行调试，对于较大项目来说，可能会使得调试的等待时间大幅增加。</p><h2 id="attach-debugger-to-android-process"><a class="markdownIt-Anchor" href="#attach-debugger-to-android-process"></a> <code>Attach Debugger to Android Process</code></h2><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220912120636190.png" alt="image-20220912120636190" /></p><p>可使用已经编译好的程序直接进行调试，降低等待调试的时间。推荐优先使用该方式。</p><hr /><h1 id="断点的-7-种类型"><a class="markdownIt-Anchor" href="#断点的-7-种类型"></a> 断点的 7 种类型</h1><p>断点从功能方面来看一共有 7 种：</p><ol><li><code>Line Breakpoint</code></li><li><code>Field Watchpoint</code></li><li><code>Method Watchpoint</code></li><li><code>Exception Watchpoint</code></li><li><code>Conditional Breakpoint</code></li><li><code>Log Breakpoint</code></li><li><code>Dependent Breakpoint</code></li></ol><p>后面将对以上 7 种进行详细的介绍。</p><hr /><blockquote><p>一般情况下，我们都可以在断点设置中选择 <code>Suspend: All</code>。下文中并没有统一更改为此配置。</p></blockquote><hr /><h1 id="line-breakpoint"><a class="markdownIt-Anchor" href="#line-breakpoint"></a> <code>Line Breakpoint</code></h1><p>最普通的断点，在我们设置后，当我们调试时程序运行到此处时会自动暂停执行。</p><hr /><h1 id="field-watchpoint"><a class="markdownIt-Anchor" href="#field-watchpoint"></a> <code>Field Watchpoint</code></h1><blockquote><p>让我们想想一个这样的场景：某个变量的值在我们看不到的地方莫名其妙的被更改了？</p></blockquote><p><strong>定义</strong></p><p><code>Field Watchpoint</code> 就可以在每个 <code>Field</code> 被创建、访问、修改的时候触发断点。</p><p>我们只需要在变量处添加断点，无需在其他该变量值变化处添加行断点，当改值按照我们设置的触发条件变化后会自动在对应行停止。</p><p><strong>使用方法</strong></p><ol><li>在变量所在行的行号后面添加断点时，选择 <code>Kotlin Field Watchpoint</code>。</li></ol><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220905011919.png" style="zoom:80%;" /><ol start="2"><li>进入断点设置界面，便可以在 <code>Watch</code> 分类中选择我们需要触发断点的条件。</li></ol><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220905010035.png" alt="Field Watchpoint" style="zoom: 80%;" /><hr /><h1 id="method-watchpoint"><a class="markdownIt-Anchor" href="#method-watchpoint"></a> <code>Method Watchpoint</code></h1><p>待添加……</p><hr /><h1 id="exception-watchpoint"><a class="markdownIt-Anchor" href="#exception-watchpoint"></a> <code>Exception Watchpoint</code></h1><p>待添加……</p><hr /><h1 id="conditional-breakpoint"><a class="markdownIt-Anchor" href="#conditional-breakpoint"></a> <code>Conditional Breakpoint</code></h1><p>待添加……</p><hr /><h1 id="log-breakpoint"><a class="markdownIt-Anchor" href="#log-breakpoint"></a> <code>Log Breakpoint</code></h1><p>待添加……</p><hr /><h1 id="dependent-breakpoint"><a class="markdownIt-Anchor" href="#dependent-breakpoint"></a> <code>Dependent Breakpoint</code></h1><p>待添加……</p>]]></content>
    
    
    <summary type="html">梳理了使用 Android Studio 调试时断点的种类、作用以及使用方法。</summary>
    
    
    
    <category term="Android" scheme="https://luoyu-ying.github.io/categories/Android/"/>
    
    
    <category term="Android Studio" scheme="https://luoyu-ying.github.io/tags/Android-Studio/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 集合遍历方式梳理</title>
    <link href="https://luoyu-ying.github.io/posts/b928600a96ee/"/>
    <id>https://luoyu-ying.github.io/posts/b928600a96ee/</id>
    <published>2022-09-03T12:04:46.000Z</published>
    <updated>2022-09-03T12:04:46.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>仅在 LeetCode 中使用，在工程代码中可能并不适合。</p></blockquote><hr /><h1 id="for-i-in-indices"><a class="markdownIt-Anchor" href="#for-i-in-indices"></a> <code>for (i in indices)</code></h1><blockquote><p><strong><code>indices</code></strong></p>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> &lt;T&gt; Array&lt;<span class="keyword">out</span> T&gt;.indices: IntRange</span><br><span class="line"><span class="keyword">val</span> Collection&lt;*&gt;.indices: IntRange</span><br></pre></td></tr></table></figure><p>返回数组或集合的有效索引范围。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intArray = IntArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> intArray.indices) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="comment">// for (i in 0 until intArray.size) &#123;&#125;</span></span><br></pre></td></tr></table></figure><hr /><h1 id="foreach"><a class="markdownIt-Anchor" href="#foreach"></a> <code>forEach</code></h1><blockquote>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;out T&gt;</span>.<span class="title">forEach</span><span class="params">(action: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;K, V&gt;</span> Map<span class="type">&lt;out K, V&gt;</span>.<span class="title">forEach</span><span class="params">(action: (<span class="type">Entry</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterator<span class="type">&lt;T&gt;</span>.<span class="title">forEach</span><span class="params">(operation: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span></span><br></pre></td></tr></table></figure><p><code>Lambda</code> 中使用 <code>it</code> 表示每一项的值，而非下标。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intArray = IntArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">intArray.forEach &#123;</span><br><span class="line">    println(<span class="string">&quot;Value is <span class="variable">$it</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// Value is 1</span></span><br><span class="line"><span class="comment">// Value is 2</span></span><br><span class="line"><span class="comment">// Value is 3</span></span><br></pre></td></tr></table></figure><hr /><h1 id="foreachindexed"><a class="markdownIt-Anchor" href="#foreachindexed"></a> <code>forEachIndexed</code></h1><blockquote>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;out T&gt;</span>.<span class="title">forEachIndexed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    action: (<span class="type">index</span>: <span class="type">Int</span>, <span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Iterable<span class="type">&lt;T&gt;</span>.<span class="title">forEachIndexed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    action: (<span class="type">index</span>: <span class="type">Int</span>, <span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span></span><br></pre></td></tr></table></figure><p><code>forEachIndexed</code> 遍历数组中的元素并且打印出 index 索引值。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> intArray = arrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">intArray.forEachIndexed &#123; index, value -&gt;</span><br><span class="line">    println(<span class="string">&quot;Index <span class="variable">$index</span> &#x27;s value is <span class="variable">$value</span>&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output</span></span><br><span class="line"><span class="comment">// Index 0 &#x27;s value is 1</span></span><br><span class="line"><span class="comment">// Index 1 &#x27;s value is 2</span></span><br><span class="line"><span class="comment">// Index 2 &#x27;s value is 3</span></span><br></pre></td></tr></table></figure><hr /><h1 id="reverse"><a class="markdownIt-Anchor" href="#reverse"></a> <code>reverse</code></h1><blockquote>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;T&gt;</span>.<span class="title">reverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> Array<span class="type">&lt;T&gt;</span>.<span class="title">reverse</span><span class="params">(fromIndex: <span class="type">Int</span>, toIndex: <span class="type">Int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> MutableList<span class="type">&lt;T&gt;</span>.<span class="title">reverse</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p><code>reverse</code> 返回反转之后的数组或者列表。</p></blockquote>]]></content>
    
    
    <summary type="html">梳理一下可能会在 LeetCode 做题中使用到的集合遍历的方法。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
    <category term="LeetCode" scheme="https://luoyu-ying.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 字符串常用算法</title>
    <link href="https://luoyu-ying.github.io/posts/e6b5f22ff8f5/"/>
    <id>https://luoyu-ying.github.io/posts/e6b5f22ff8f5/</id>
    <published>2022-09-01T05:04:02.000Z</published>
    <updated>2022-09-01T05:04:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是一个分割线</p></blockquote><h1 id="字符串哈希"><a class="markdownIt-Anchor" href="#字符串哈希"></a> 字符串哈希</h1><blockquote><p>更多关于字符串哈希的使用请看：<a href="https://luoyu-ying.github.io/posts/bb54934ff9ed/">XCPC 字符串哈希 | 洛语 の Blog (luoyu-ying.github.io)</a></p></blockquote><h2 id="clang"><a class="markdownIt-Anchor" href="#clang"></a> <code>Clang</code></h2><p>使用单哈希且自然溢出的方法，质数选用 131。</p><h2 id="kotlin"><a class="markdownIt-Anchor" href="#kotlin"></a> <code>Kotlin</code></h2>]]></content>
    
    
    <summary type="html">整理了自己之前学习到的一些字符串相关算法</summary>
    
    
    
    <category term="LeetCode" scheme="https://luoyu-ying.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://luoyu-ying.github.io/tags/LeetCode/"/>
    
    <category term="字符串" scheme="https://luoyu-ying.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode C++ sort 食用方法</title>
    <link href="https://luoyu-ying.github.io/posts/43b3ec0d3402/"/>
    <id>https://luoyu-ying.github.io/posts/43b3ec0d3402/</id>
    <published>2022-08-06T16:51:05.000Z</published>
    <updated>2022-08-07T04:08:25.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="出现的问题"><a class="markdownIt-Anchor" href="#出现的问题"></a> 出现的问题</h1><p>在 LeetCode 中做题的时候，使用 <code>sort</code> 函数，并使用另一个比较函数的使用，出现以下的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(...)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; G;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="built_in">sort</span>(G.<span class="built_in">begin</span>(), G.<span class="built_in">end</span>(), comp);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行上述代码的时候，便会出现编译错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: reference to non-static member function must be called </span><br><span class="line">    sort(G.begin(), G.end(), comp); </span><br><span class="line">                             ^~~ </span><br><span class="line">1 error generated.</span><br></pre></td></tr></table></figure><hr /><h1 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h1><p>使用 <code>static</code> 修饰比较函数，即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">comp</span><span class="params">(...)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>即可在类中使用比较函数。</p>]]></content>
    
    
    <summary type="html">记录一下在 LeetCode 中使用 C++ 中的 sort 函数遇到的 reference to non-static member function 问题。</summary>
    
    
    
    <category term="LeetCode" scheme="https://luoyu-ying.github.io/categories/LeetCode/"/>
    
    
  </entry>
  
  <entry>
    <title>英语 横屏与竖屏</title>
    <link href="https://luoyu-ying.github.io/posts/225ab1cafae6/"/>
    <id>https://luoyu-ying.github.io/posts/225ab1cafae6/</id>
    <published>2022-07-30T02:45:44.000Z</published>
    <updated>2022-07-30T02:45:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>在公司实习的时候，看到代码中的 <code>landscape</code> 以及  <code>portrait</code> 两个单词的时候，并没有意识到这两个单词的含义 。</p><p>还是英语单词的储备量太少了 (´。＿。｀)。</p><hr /><h1 id="landscape"><a class="markdownIt-Anchor" href="#landscape"></a> <code>LANDSCAPE</code></h1><p>手机横屏。代码中可以简写成 <code>land</code>。</p><p>本意为风景、风景画等。</p><p>可能因为这类画作通常以横幅的形式展现，所以便使用了 <code>landscape</code> 这个英语单词表示手机的横屏。</p><hr /><h1 id="portrait"><a class="markdownIt-Anchor" href="#portrait"></a> <code>PORTRAIT</code></h1><p>手机竖屏。代码中可以简写成 <code>port</code>。</p><p>本意为肖像、肖像画等。</p><p>可能因为这类画作基本以竖幅的形式展现，所以使用了 <code>portrait</code> 这个单词表示了手机的竖屏。</p>]]></content>
    
    
    <summary type="html">记录一下英语中手机横屏与竖屏的表达。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Android Gradle 学习笔记</title>
    <link href="https://luoyu-ying.github.io/posts/a3b80f176756/"/>
    <id>https://luoyu-ying.github.io/posts/a3b80f176756/</id>
    <published>2022-07-23T14:10:28.000Z</published>
    <updated>2022-07-24T06:10:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>主要讨论 Gradle 构建项目中的细节，而非构建 Gradle 的语言 Groovy 本身。</p></blockquote><hr /><blockquote><p>建议配合以下文章阅读：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/139685763">理解Android Studio中的Gradle - 知乎 (zhihu.com)</a></li></ul></blockquote><hr /><h1 id="gradle-是什么"><a class="markdownIt-Anchor" href="#gradle-是什么"></a> Gradle 是什么</h1><ol><li><p>Gradle 是一个构建工具。</p><p>Android Studio 构建系统以 Gradle 为基础，并且 Android Gradle 插件添加了几项专用于构建 Android 应用的功能。</p><p><strong>要注意的是</strong>，Gradle 它并不是独属于 Android。Gradle 本身也没有提供多少对 Android 程序构建的功能。</p><p>Gradle 是 Android Studio 默认的构建工具，它提高了 Android 的开发效率，它的作用就是管理项目中的依赖、打包、编译……</p></li><li><p>Gradle 并非一门语言，它是使用了 Groovy 语言创造出的一个 DSL。</p></li></ol><h1 id="gradle-如何构建"><a class="markdownIt-Anchor" href="#gradle-如何构建"></a> Gradle 如何构建</h1><p>我们通过 Gradle 的语法，在下列文件中指定 Gradle 的规则：</p><ol><li><code>build.gradle</code></li><li><code>settings.gradle</code></li><li><code>gradle-warpper</code></li><li>……</li></ol><hr /><h1 id="groovy-语言部分特性"><a class="markdownIt-Anchor" href="#groovy-语言部分特性"></a> Groovy 语言部分特性</h1><ol><li><p>使用函数时，函数名称后面的括号可以不写。</p></li><li><p>可以通过闭包传递函数以及其他的属性。</p><blockquote><p>闭包</p><ol><li>可以理解为 Groovy 中的 Lambda 表达式。</li><li>在功能上，和 Kotlin 的 Lambda ⽐较相似，都是⼀个「可以传递的代码块」，但是具体的功能⽐ Kotlin 的 Lambda 更强⼀些，但基本的概念是⼀样的。都是由大括号包含代码块组成。</li></ol></blockquote></li><li><p>如果函数定义的最后一个参数为闭包，那么闭包便可以写在括号外面；如果该函数只有一个参数且该参数为闭包，那么小括号可以省略。</p></li><li><p>可以在每个类中定义 <code>methodMissing</code> 函数，如果在脚本中执行了一个未在该类中定义的一个函数，Groovy 便会调用该类的 <code>methodMissing</code> 函数，并在该函数中寻找我们写入的解决方案。</p><blockquote><p>例如，<code>build.gradle</code> 中的 <code>classpath</code> 便是通过调用 <code>methodMissing</code> 函数实现依赖添加的功能。</p></blockquote></li><li><p>单引号和双引号都可以表达字符串的概念。</p></li></ol><h1 id="为什么-groovy-可以写出类似-json-格式的配置"><a class="markdownIt-Anchor" href="#为什么-groovy-可以写出类似-json-格式的配置"></a> 为什么 Groovy 可以写出类似 JSON 格式的配置？</h1><p>因为它们其实都是方法调用，只是省略了括号，以及用闭包来写成了看起来像是 JSON 型的格式。</p><hr /><h1 id="buildgradle"><a class="markdownIt-Anchor" href="#buildgradle"></a> <code>build.gradle</code></h1><h2 id="buildtypes"><a class="markdownIt-Anchor" href="#buildtypes"></a> <code>buildTypes</code></h2><p>通常有 <code>release</code>、<code>debug</code>、<code>develop</code>等等版本，也可以自定义版本。</p><p>通过 Project 形式查看文件结构，可以清楚的发现，当我们在 <code>src</code> 文件夹下面，创建类似 <code>main</code> 的层级文件夹 <code>debug</code> ，并在 <code>Build Varians</code> 选项卡中，选择 <code>debug</code> 构建模式时，AS 便会将 <code>main</code> 下方的文件以及 <code>debug</code> 下方的文件整合到一起执行，其他版本同理。</p><p>所以我们可以通过创建不同版本特有的文件夹，以达到不同版本使用、开发人员的差异化显示以及功能等区别。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220724160910544.png" alt="image" style="zoom: 80%;" /><h2 id="productflavors"><a class="markdownIt-Anchor" href="#productflavors"></a> <code>productFlavors</code></h2><p>为我们软件的版本提供更多的分类与维度，需要与 <code>flavorDimensions</code> 函数配合使用。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">flavorDimensions <span class="string">&#x27;dimension1&#x27;</span>, <span class="string">&#x27;dimension2&#x27;</span> <span class="comment">// 确认具体的分类项</span></span><br><span class="line"></span><br><span class="line">productFlavors &#123;</span><br><span class="line">    flavor1 &#123;                              <span class="comment">// 每个具体的属性</span></span><br><span class="line">        dimension <span class="string">&#x27;dimension1&#x27;</span>             <span class="comment">// 属性所属的分类项</span></span><br><span class="line">    &#125;</span><br><span class="line">    flavor2 &#123;</span><br><span class="line">        dimension <span class="string">&#x27;dimension1&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    flavor3 &#123;</span><br><span class="line">        dimension <span class="string">&#x27;dimension2&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    flavor4 &#123;</span><br><span class="line">        dimension <span class="string">&#x27;dimension2&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的示例代码，我们可以发现共有 4 种组合方式：</p><ol><li><code>flavor1</code> + <code>flavor3</code></li><li><code>flavor1</code> + <code>flavor4</code></li><li><code>flavor2</code> + <code>flavor3</code></li><li><code>flavor2</code> + <code>flavor4</code></li></ol><p>若结合上面 <code>buildTypes</code> 种的版本数量，最终共有 8 种组合方式（2 种 <code>dimension1</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 2 种 <code>dimension2</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>×</mo></mrow><annotation encoding="application/x-tex">\times</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">×</span></span></span></span> 2 种 <code>buildTypes</code>），需要使用到某种版本时，同样可以在 <code>Build Varians</code> 选项卡中进行更改。</p><p>如果文件夹创建齐全，则上述 <code>flavor2Flavor3Debug</code> 版本的软件就会将所有与该版本有关的文件夹：</p><ol><li><code>main</code></li><li><code>debug</code></li><li><code>flavor2</code></li><li><code>flavor3</code></li><li><code>flavor2Debug</code></li><li><code>flavor3Debug</code></li><li><code>flavor2Flavor3</code></li><li><code>flavor2Flavor3Debug</code></li></ol><p>这 8 个文件夹下面的所有代码文件全部汇总后编译出最终的文件。如果存在没有创建的文件夹则忽略。</p><hr /><h1 id="compile-implementation-和-api"><a class="markdownIt-Anchor" href="#compile-implementation-和-api"></a> <code>compile</code>、<code>implementation</code> 和 <code>api</code></h1><blockquote><p>以下内容：</p><p>| 0 级项目 | --依赖–&gt; | 1 级依赖 | --依赖–&gt; | 2 级依赖 |</p></blockquote><ul><li><p><code>implementation</code>：</p><ol><li>不会传递依赖 。</li><li>0 级项目只能使用 1 级依赖提供的内容。</li></ol></li><li><p><code>compile</code> / <code>api</code>：</p><ol><li>会传递依赖；<code>api</code> 是 <code>compile</code> 的替代品，效果完全等同。</li><li>0 级项目可以直接使用 2 级依赖中的代码内容。</li></ol></li><li><p>0 级项目的修改不会影响其他项目，所以 <code>| 0 级项目 | --依赖--&gt; | 1 级依赖 |</code> 时可以使用任意函数。</p><p>推荐仍使用 <code>implementation</code> ，因为 0 级项目不需要传递依赖。</p></li><li><p><code>| 1 级依赖 | --依赖--&gt; | 2 级依赖 |</code> 中的依赖关系需要仔细考虑：</p><ul><li><p>当依赖被传递时(<code>compile</code> / <code>api</code>)，认为 0 级项目同样直接依赖 2 级依赖，2 级依赖的。改动会导致 0 级项目重新编译。</p></li><li><p>当依赖不传递时(<code>implementation</code>)，2 级依赖的改动不会导致 0 级项目重新编译，常用于本地项目，方便短时间对 0 级项目快速重写编译，减少打包时间。</p><blockquote><p>编译只是打包过程中的其中一个步骤。</p></blockquote></li></ul></li></ul><hr /><h1 id="gradle-wrapper"><a class="markdownIt-Anchor" href="#gradle-wrapper"></a> <code>Gradle Wrapper</code></h1><p>即 <code>gradlew</code>，用于 gradle 自动配置。</p><p>使用 <code>gradlew</code> 发现如果我们的电脑里有了已经配置好的 gradle ，那么就会直接使用，否则的话，就会通过互联网下载我们需要的 gradle 并使用。</p><p>如果我们的项目中有多个模块需要一样的 gradle 配置，那么我们就可以通过 gradlew 让所有的模块都去使用同一个 gradle 而不是为每个模块单独、分别下载一份一模一样的文件。</p><p>通过「只同步版本，不同步文件」的方式来减小协作项目的大小。我们可以通过指定 gradle 版本的方式，让对方的电脑主动下载我们需要的版本的 gradle，而不是我们将自己电脑的 gradle 打包进项目中，减少了项目的大小。</p><p>每个⼈电脑上的 Gradle 存放在固定位置，然后使用 Gradle Wrapper 的配置来取用对应的版本就行了。</p><p>使用方式：命令行中：<code>./gradlew</code>。</p><h2 id="gradle-wrapperproperties"><a class="markdownIt-Anchor" href="#gradle-wrapperproperties"></a> gradle-wrapper.properties</h2><p>是对 gradle wrapper 的配置文件，用于显示的表示 gradle wrapper 的存放位置，以及找不到对应的 gradle wrapper ，从而去网络下载的网络地址。</p><hr /><h1 id="settingsgradle"><a class="markdownIt-Anchor" href="#settingsgradle"></a> <code>settings.gradle</code></h1><p>整个项目的结构，说明我们整个项目中有哪几个子项目。</p><hr /><h1 id="task"><a class="markdownIt-Anchor" href="#task"></a> <code>task</code></h1><ul><li><p>使用方法： <code>./gradlew taskName</code></p></li><li><p><code>task</code> 的结构：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> taskName &#123;</span><br><span class="line">    初始化代码</span><br><span class="line">    <span class="keyword">doFirst</span> &#123;</span><br><span class="line">        <span class="keyword">task</span> 代码</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">doLast</span> &#123;</span><br><span class="line">        <span class="keyword">task</span> 代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>doFirst</code> 以及 <code>doLast</code> 和普通代码段的区别：</p><ul><li><p>普通代码段：在 <code>task</code> 创建过程中就会被执⾏，发⽣在 configuration 阶段。</p></li><li><p><code>doFirst</code> 和 <code>doLast</code>：在 task 执行过程中被执⾏，发生在 execution 阶段。</p><p>如果用户没有直接或间接执行 <code>task</code>，那么它的 <code>doLast</code>、 <code>doFirst</code> 代码不会被执行。</p></li><li><p><code>doFirst</code> 和 <code>doLast</code> 都是 <code>task</code> 代码，其中 <code>doFirst</code> 是往队列的前面插⼊代码，<code>doLast</code> 是往队列的后面插⼊代码。</p><p>一个 <code>task</code> 里面可以写入多个 <code>doFirst</code> 以及 <code>doLast</code>。</p></li></ul></li><li><p><code>task</code> 的依赖：</p><p>可以使用 <code>task taskA(dependsOn: taskB)</code> 的形式来指定依赖。 指定依赖后，<code>taskA</code> 会在自己执行前先执行自己依赖的 <code>taskB</code>。</p><p>将所有的 task 通过一条有向边连接到其依赖 task 后，可以得到一个由所有 task 所组成的有向无环图。</p></li></ul><hr /><h1 id="gradle-执行的生命周期"><a class="markdownIt-Anchor" href="#gradle-执行的生命周期"></a> Gradle 执行的生命周期</h1><h2 id="三个阶段"><a class="markdownIt-Anchor" href="#三个阶段"></a> 三个阶段</h2><p>Gradle 执行的生命周期一共有三个阶段：</p><ol><li><p>初始化阶段</p><p>执行 settings.gradle，确定主 project 和子 project。</p></li><li><p>定义阶段（配置阶段）：</p><p>配置每个 project 的 bulid.gradle，确定出所有 task 所组成的有向无环图。</p></li><li><p>执行阶段：</p><p>按照上一阶段所确定出的有向无环图来执行指定的 task。</p></li></ol><h2 id="在阶段之间插入代码"><a class="markdownIt-Anchor" href="#在阶段之间插入代码"></a> 在阶段之间插⼊代码</h2><p>一二阶段之间：</p><ul><li>在 <code>settings.gradle</code> 的末尾写入插入的代码。</li></ul><p>二三阶段之间：</p><ul><li><p>在 <code>build.gradle</code> 文件中使用 <code>afterEvaluate</code> 函数：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">afterEvaluate &#123;</span><br><span class="line">    <span class="comment">// 插入的代码，例如网络、文件相关的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">Android 中 Gradle 配置文件浅淡</summary>
    
    
    
    <category term="Gradle" scheme="https://luoyu-ying.github.io/categories/Gradle/"/>
    
    
    <category term="Gradle" scheme="https://luoyu-ying.github.io/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>AutoHotKey 变量和字符串</title>
    <link href="https://luoyu-ying.github.io/posts/82303f29c0e9/"/>
    <id>https://luoyu-ying.github.io/posts/82303f29c0e9/</id>
    <published>2022-07-23T08:23:08.000Z</published>
    <updated>2022-07-23T08:23:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Variables.htm">变量和表达式 | AutoHotkey (autoahk.com)</a></li><li><a href="https://www.autohotkey.com/boards/viewtopic.php?t=14633">String literal that spans multiple lines? - AutoHotkey Community</a></li></ul></blockquote><hr /><blockquote><p>下文中的链接皆指向 AHK 技术文档，可放心查看。</p></blockquote><hr /><h1 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h1><p>有关一般说明和变量如何工作的详细信息, 请参阅<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Concepts.htm#variables">变量</a>.</p><h2 id="给变量赋值"><a class="markdownIt-Anchor" href="#给变量赋值"></a> <strong>给变量赋值</strong></h2><p>要将字符串或数字存储在变量中, 有两种方法: <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#legacy-syntax">传统方式</a>和<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#expressions">表达式</a>. 传统方法使用<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/SetEnv.htm">等号运算符(=)</a> 来指定<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#unquoted-text"><strong>不加引号的</strong>原义字符串</a>或用百分号括起来的变量. 例如:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyNumber = <span class="number">123</span></span><br><span class="line">MyString = This is a literal string.</span><br><span class="line">CopyOfVar = <span class="variable">%Var%</span>  <span class="comment">; 和 = 运算符一起使用时, 需要使用百分号来获取变量的内容.</span></span><br></pre></td></tr></table></figure><p>与之相比, 表达式方法使用<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/SetExpression.htm">冒号等号运算符(:=)</a> 来保存数字, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#strings"><strong>加引号的</strong>字符串</a>和其他类型的<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#expressions">表达式</a>. 以下示例在功能上与前面的例子相同:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyNumber := <span class="number">123</span></span><br><span class="line">MyString := <span class="string">&quot;This is a literal string.&quot;</span></span><br><span class="line">CopyOfVar := Var  <span class="comment">; 和前面段落中与其作用相同的语句不同, 百分号不和 := 运算符一起使用.</span></span><br></pre></td></tr></table></figure><p><strong>后一种方法由于其更清晰并且与其他许多语言几乎一致的<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#expressions">表达式语法</a>成为大多数人的首选方法.</strong></p><p>从上面的例子中您可能已经想到了有两种方法来清除变量的内容(即让变量为空):</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyVar =</span><br><span class="line">MyVar := <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>上面的这对空引号只能和 := 运算符一起使用, 因为和 = 运算符一起使用时, 则会在变量中保存两个原义的引号字符.</p><h2 id="获取变量的内容"><a class="markdownIt-Anchor" href="#获取变量的内容"></a> <strong>获取变量的内容</strong></h2><p>如同赋值有两种方法, 获取变量的内容也有两种方法: <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#legacy-syntax">传统方法</a>和<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#variables">表达式方法</a>. 传统方法需要将变量名包围在百分号中来获取变量的内容. 例如:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MsgBox The value in the variable named Var is <span class="variable">%Var%</span>.</span><br><span class="line">CopyOfVar = <span class="variable">%Var%</span></span><br></pre></td></tr></table></figure><p>与之相比, 表达式方法省去了变量名两边的百分号, 但<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#strings">原义的字符串</a>必须包围在双引号中. 所以, 下面的表达式作用等同于上面的例子:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MsgBox %</span> <span class="string">&quot;The value in the variable named Var is &quot;</span> . Var . <span class="string">&quot;.&quot;</span>  <span class="comment">; 使用句点连接(join 拼接) 两个字符串.</span></span><br><span class="line">CopyOfVar := Var</span><br></pre></td></tr></table></figure><p>在上面的 MsgBox 这行, 通过使用<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Language.htm#-expression">百分号和空格</a>把参数从传统模式改变为表达式模式. 因为所有的命令默认情况下使用传统模式(除了另外注明的那些), 所以这是必须的.</p><h2 id="变量的比较"><a class="markdownIt-Anchor" href="#变量的比较"></a> <strong>变量的比较</strong></h2><p>请阅读下面表达式部分中关于不同类型变量比较的重要提示, 尤其是关于何时使用小括号的内容.</p><hr /><h1 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h1><h2 id="保存带有引号的字符串"><a class="markdownIt-Anchor" href="#保存带有引号的字符串"></a> 保存带有引号的字符串</h2><p>如果我们想用变量保存一个带有双引号的字符串，需要使用 = 操作符：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var = this is <span class="string">&quot; ; 输出的字符串中包含双引号</span></span><br></pre></td></tr></table></figure><h2 id="保存多行字符串"><a class="markdownIt-Anchor" href="#保存多行字符串"></a> 保存多行字符串</h2><p>如果我们想要保存多行的字符串，可以使用 <code>()</code> 包含文本内容并使用 <code>=</code> 且 <strong>不加 <code>&quot;&quot;</code></strong> 的方式（文本中每行的字符串形式与使用 <code>=</code> 操作符保存单行字符串的形式相同）：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var = string</span><br><span class="line"></span><br><span class="line">exampleString =</span><br><span class="line">(                      <span class="comment">; 左括号右侧的字符会被自动忽略，正文从下行开始</span></span><br><span class="line">    multiple</span><br><span class="line">        lines          <span class="comment">; 该行字符的所有字符（包括空格）会全部输出</span></span><br><span class="line">                       <span class="comment">; 空行也会如实输出  </span></span><br><span class="line"><span class="built_in">    of</span></span><br><span class="line"><span class="built_in">        %</span>var%</span><br><span class="line">)                      <span class="comment">; 右括号左侧不能有其他字符，否则将报错</span></span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">MsgBox,</span> % exampleString</span><br></pre></td></tr></table></figure><p>输出结果截图（第一个非空字符前的空格将忽略）：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220723170233064.png" alt="image-20220723170233064" style="zoom: 50%;" /><p><strong>注意：</strong></p><ol><li>该方式中的 <code>()</code> 必须分别、单独在一行，不能接在其他语句末尾。且文本将严格按照输入形式输出，两个括号之间的空行和空格也会如实输出，但是第一个非空字符前的空格将忽略。</li><li>左括号右侧的字符会被自动忽略，正文从下行开始；右括号左侧不能有其他字符，否则将报错。</li><li>如果需要使用 <code>:=</code> 操作符进行多行字符串保存，请使用 `n 转义字符进行换行操作。</li></ol>]]></content>
    
    
    <summary type="html">记录了 AutoHotKey 中变量以及字符串的基本概念与使用方法。</summary>
    
    
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/categories/AutoHotKey/"/>
    
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/tags/AutoHotKey/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 标准函数</title>
    <link href="https://luoyu-ying.github.io/posts/d15d647b4c31/"/>
    <id>https://luoyu-ying.github.io/posts/d15d647b4c31/</id>
    <published>2022-07-13T05:26:11.000Z</published>
    <updated>2022-07-13T05:26:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin 标准函数 <code>Standard.kt</code> 源码  <code>GitHub</code> 仓库地址:</p><ul><li><a href="https://github.com/JetBrains/kotlin/blob/1.5.30/libraries/stdlib/src/kotlin/util/Standard.kt">kotlin/Standard.kt at 1.5.30 · JetBrains/kotlin (github.com)</a></li></ul></blockquote><hr /><h1 id="初始代码"><a class="markdownIt-Anchor" href="#初始代码"></a> 初始代码</h1><blockquote><p>下方给出一份初始代码，并在接下来的部分标准函数中给出使用该标准函数的修改后代码。</p><p>初始代码摘自《第一行代码 Android 第3版》。</p></blockquote><p>比如有一个水果列表，现在我们想吃完所有水果，并将结果打印出来，就可以这样写：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">builder.append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">    builder.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">builder.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = builder.toString()</span><br><span class="line">println(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行的结果为：</span></span><br><span class="line">Start eating fruits.</span><br><span class="line">Apple</span><br><span class="line">Banana</span><br><span class="line">Orange</span><br><span class="line">Pear</span><br><span class="line">Grape</span><br><span class="line">Ate all fruits.</span><br></pre></td></tr></table></figure><hr /><h1 id="run"><a class="markdownIt-Anchor" href="#run"></a> <code>run</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] and returns its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;R&gt;</span> <span class="title">run</span><span class="params">(block: () -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = run &#123;</span><br><span class="line">    <span class="keyword">val</span> builder = StringBuilder()</span><br><span class="line">    builder.append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        builder.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    builder.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    builder.toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><hr /><h1 id="trun"><a class="markdownIt-Anchor" href="#trun"></a> <code>T.run</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with `this` value as its receiver and returns its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">run</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = StringBuilder().run &#123;</span><br><span class="line">    append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><hr /><h1 id="with"><a class="markdownIt-Anchor" href="#with"></a> <code>with</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> <span class="title">with</span><span class="params">(receiver: <span class="type">T</span>, block: <span class="type">T</span>.() -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> receiver.block()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = with(StringBuilder()) &#123;</span><br><span class="line">    append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        append(fruit).append(<span class="string">&quot;\n&quot;</span>)          </span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><hr /><h1 id="tapply"><a class="markdownIt-Anchor" href="#tapply"></a> <code>T.apply</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with `this` value as its receiver and returns `this` value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">apply</span><span class="params">(block: <span class="type">T</span>.() -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = StringBuilder().apply &#123;</span><br><span class="line">    append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(result.toString())</span><br></pre></td></tr></table></figure><hr /><h1 id="talso"><a class="markdownIt-Anchor" href="#talso"></a> <code>T.also</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with `this` value as its argument and returns `this` value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">also</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">Unit</span>)</span></span>: T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = StringBuilder().also &#123;</span><br><span class="line">    it.append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        it.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    it.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">println(result.toString())</span><br></pre></td></tr></table></figure><hr /><h1 id="tlet"><a class="markdownIt-Anchor" href="#tlet"></a> <code>T.let</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Calls the specified function [block] with `this` value as its argument and returns its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T, R&gt;</span> T.<span class="title">let</span><span class="params">(block: (<span class="type">T</span>) -&gt; <span class="type">R</span>)</span></span>: R &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> block(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改后的示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Grape&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> result = StringBuilder().let &#123;</span><br><span class="line">    it.append(<span class="string">&quot;Start eating fruits.\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (fruit <span class="keyword">in</span> list) &#123;</span><br><span class="line">        it.append(fruit).append(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    it.append(<span class="string">&quot;Ate all fruits.&quot;</span>)</span><br><span class="line">    it.toString()</span><br><span class="line">&#125;</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><hr /><h1 id="ttakeif"><a class="markdownIt-Anchor" href="#ttakeif"></a> <code>T.takeIf</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn&#x27;t.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">takeIf</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (predicate(<span class="keyword">this</span>)) <span class="keyword">this</span> <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="ttakeunless"><a class="markdownIt-Anchor" href="#ttakeunless"></a> <code>T.takeUnless</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="meta">@SinceKotlin(<span class="string">&quot;1.1&quot;</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> T.<span class="title">takeUnless</span><span class="params">(predicate: (<span class="type">T</span>) -&gt; <span class="type">Boolean</span>)</span></span>: T? &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (!predicate(<span class="keyword">this</span>)) <span class="keyword">this</span> <span class="keyword">else</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="trepeat"><a class="markdownIt-Anchor" href="#trepeat"></a> <code>T.repeat</code></h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the given function [action] specified number of [times].</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A zero-based index of current iteration is passed as a parameter to [action].</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@sample</span> samples.misc.ControlFlow.repeat</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@kotlin</span>.<span class="keyword">internal</span>.InlineOnly</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">inline</span> <span class="function"><span class="keyword">fun</span> <span class="title">repeat</span><span class="params">(times: <span class="type">Int</span>, action: (<span class="type">Int</span>) -&gt; <span class="type">Unit</span>)</span></span> &#123;</span><br><span class="line">    contract &#123; callsInPlace(action) &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">0</span> until times) &#123;</span><br><span class="line">        action(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="部分函数比较"><a class="markdownIt-Anchor" href="#部分函数比较"></a> 部分函数比较</h1><table><thead><tr><th style="text-align:center">标准函数 形参</th><th style="text-align:center">Lambda 形参</th><th style="text-align:center">Lambda 返回值</th><th style="text-align:center">标准函数 返回值</th><th style="text-align:center">作用域 参数</th></tr></thead><tbody><tr><td style="text-align:center"><code>run &#123;&#125;</code></td><td style="text-align:center"><code>()</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>\</code></td></tr><tr><td style="text-align:center"><code>T.run &#123;&#125;</code></td><td style="text-align:center"><code>T.()</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>(this.)</code></td></tr><tr><td style="text-align:center"><code>with(obj : T) &#123;&#125;</code></td><td style="text-align:center"><code>T.()</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>(this.)</code></td></tr><tr><td style="text-align:center"><code>T.apply &#123;&#125;</code></td><td style="text-align:center"><code>T.()</code></td><td style="text-align:center"><code>Unit</code></td><td style="text-align:center"><code>T</code></td><td style="text-align:center"><code>(this.)</code></td></tr><tr><td style="text-align:center"><code>T.also &#123;&#125;</code></td><td style="text-align:center"><code>(T)</code></td><td style="text-align:center"><code>Unit</code></td><td style="text-align:center"><code>T</code></td><td style="text-align:center"><code>it.</code></td></tr><tr><td style="text-align:center"><code>T.let &#123;&#125;</code></td><td style="text-align:center"><code>(T)</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>R</code></td><td style="text-align:center"><code>it.</code></td></tr></tbody></table><p>使用时可以通过简单的规则作出⼀些判断：</p><ol><li><p>返回自身 -&gt; 从 <code>apply</code> 和 <code>also</code> 中选</p><ul><li>作用域中使用 <code>this</code> 作为参数 -&gt; 选择 <code>apply</code></li><li>作用域中使用 <code>it</code> 作为参数 -&gt; 选择 <code>also</code></li></ul></li><li><p>不需要返回自身（可以返回任意类型） -&gt; 从 <code>run</code> 和 <code>let</code> 中选择</p><ul><li>作用域中使用 <code>this</code> 作为参数 -&gt; 选择 <code>run</code></li><li>作用域中使用 <code>it</code> 作为参数 -&gt; 选择 <code>let</code></li></ul></li><li><p><code>apply</code> 适合对一个对象做附加操作的时候</p></li><li><p><code>let</code> 适合配合空判断的时候 (最好是成员变量，⽽不是局部变量，局部变量更适合用 <code>if</code> )</p></li><li><p><code>with</code> 适合对同一个对象进行多次操作的时候</p></li></ol>]]></content>
    
    
    <summary type="html">整理了 Kotlin 中的标准函数。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>AutoHotKey 类的定义与部分使用技巧</title>
    <link href="https://luoyu-ying.github.io/posts/61bd48ea70cc/"/>
    <id>https://luoyu-ying.github.io/posts/61bd48ea70cc/</id>
    <published>2022-07-12T09:33:37.000Z</published>
    <updated>2022-07-12T09:33:37.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文所使用的AHK版本为 AutoHotKey_v1 。</p></blockquote><hr /><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>本人想在 AHK 中使用面向对象的方式编写代码，但是发现在官方文档中仅有较少关于 class` 的操作代码示例，所以根据自己这两天的代码编写过程，整理出常用的一些使用技巧供大家参考。</p><hr /><h1 id="类的创建和使用"><a class="markdownIt-Anchor" href="#类的创建和使用"></a> 类的创建和使用</h1><p>类的创建使用 <code>class</code>  关键字。可以显式定义构造方法以及析构方法：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 类的创建</span></span><br><span class="line">class A &#123;</span><br><span class="line">    <span class="comment">; 静态变量的创建</span></span><br><span class="line">    static var1 := Expression1</span><br><span class="line">    <span class="comment">; 类字段的创建</span></span><br><span class="line">    var2 := Expression2</span><br><span class="line">    </span><br><span class="line">    <span class="comment">; 构造方法，可传入任意参数，也可不传入参数</span></span><br><span class="line">    __New(...) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">; 方法的创建</span></span><br><span class="line">    <span class="comment">; 可传入任意参数，参数支持默认参数值</span></span><br><span class="line">    <span class="comment">; 根据需要可不写 return</span></span><br><span class="line">    methodName(...) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">; 析构方法</span></span><br><span class="line">    __Delete() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的使用：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="keyword">new</span> A(...)   <span class="comment">; 类的实例化，根据构造方法传入对应的参数</span></span><br><span class="line">a.methodName(...) <span class="comment">; 使用变量的方法</span></span><br></pre></td></tr></table></figure><hr /><h1 id="在类中创建热键并绑定类方法"><a class="markdownIt-Anchor" href="#在类中创建热键并绑定类方法"></a> 在类中创建热键并绑定类方法</h1><p>使用面向对象的思想编写代码的话，我们或许需要在类中创建热键及其响应逻辑的方法：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    <span class="comment">; 自定义的一个方法，用于加载类中所有的热键</span></span><br><span class="line">    loadHotKey() &#123;</span><br><span class="line">        <span class="comment">; 创建响应方法的方法引用</span></span><br><span class="line">        varFunctionA := ObjBindMethod(this, <span class="string">&quot;functionA&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">; 创建 Alt + A 的热键以及绑定其响应方法</span></span><br><span class="line"><span class="built_in">        HotKey,</span> !A, % varFunctionA, On</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    functionA() &#123;</span><br><span class="line">    <span class="comment">; 热键的响应逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码便在类中创建了一个使用类中方法作为响应逻辑的热键。其中：</p><ol><li><code>varFunctionA := ObjBindMethod(this, &quot;functionA&quot;)</code> 部分：<ol><li><code>&quot;functionA&quot;</code> 中双引号必须保留，双引号中间内容为对应的方法名。</li><li><code>varFunctionName</code> 为自定义的变量名称，与第7行第3个参数相对应。</li></ol></li><li><code>HotKey, !A, % varFunctionA, On</code> 部分：<ol><li><code>!A</code> 为热键的内容，具体可以参考文档中 <strong>热键</strong> 部分内容。</li><li><code>% varFunctionA</code> 中百分号必须保留，后面的内容对应上面一行自定义的变量名。</li></ol></li></ol><p>热键的使用：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> A().loadHotKey()</span><br></pre></td></tr></table></figure><p>通过对该类的实例化并调用实例化对象的 <code>loadHotKey</code> 方法即可。</p><hr /><h1 id="在类中绘制-ui-并绑定类方法"><a class="markdownIt-Anchor" href="#在类中绘制-ui-并绑定类方法"></a> 在类中绘制 <code>UI</code> 并绑定类方法</h1><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class B &#123;</span><br><span class="line">    <span class="comment">; 自定义的一个方法，用于绘制 UI 以及绑定响应的方法</span></span><br><span class="line">    loadView() &#123;</span><br><span class="line">        <span class="comment">; 绘制了一个按钮</span></span><br><span class="line"><span class="built_in">        Gui,</span> Add, Button, w200 h35 hwndHFuncB, This is a button.</span><br><span class="line"></span><br><span class="line">        <span class="comment">; 创建了响应方法的方法引用</span></span><br><span class="line">        varFuncB := ObjBindMethod(this, <span class="string">&quot;functionB&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">; 通过 HWND 将按钮与方法绑定</span></span><br><span class="line"><span class="built_in">        GuiControl,</span> +g, <span class="variable">%HFuncB%</span>, % varFuncB</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    functionB() &#123;</span><br><span class="line">        <span class="comment">; 按钮的响应逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>Gui, Add, Button, w200 h35 hwndHFuncB, This is a button.</code> 中 <code>hwndHFuncB</code> 部分：<ol><li>形式为 <code>hwnd + 自定义变量名</code></li><li>自定义变量名与第9行中第3个参数相对应。</li></ol></li><li><code>varFuncB := ObjBindMethod(this, &quot;functionB&quot;)</code> 部分：<ol><li><code>varFuncB</code> 为另一个自定义变量名，与第9行中第4个变量名相对应。</li><li><code>&quot;functionB&quot;</code> 中双引号必须保留，双引号中间内容为对应的方法名。</li></ol></li><li><code>GuiControl, +g, %HFuncB%, % varFuncB</code> 中第3、4个参数分别为上述的两个自定义变量名。</li></ol><hr /><h1 id="代码示例"><a class="markdownIt-Anchor" href="#代码示例"></a> 代码示例</h1><blockquote><p>使用面向对象思想重构 <a href="https://luoyu-ying.github.io/posts/050a11a7817a/">通过 AutoHotKey 简化 Hexo 操作 | 洛语 の Blog (luoyu-ying.github.io)</a> 中 Deploy 部分的操作。</p></blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 加载类的 UI 以及热键</span></span><br><span class="line"><span class="keyword">new</span> Deploy().load()</span><br><span class="line"></span><br><span class="line"><span class="comment">; -------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 类的创建</span></span><br><span class="line">class Deploy &#123;</span><br><span class="line"></span><br><span class="line">    load() &#123;</span><br><span class="line">        this.loadView()</span><br><span class="line">        this.loadHotKey()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">; 本代码中 GAD -&gt; generate and deploy</span></span><br><span class="line">    </span><br><span class="line">    loadView() &#123;</span><br><span class="line"><span class="built_in">        Gui,</span> Add, Button, w200 h35 hwndHGAD, Generate &amp;&amp; Deploy</span><br><span class="line">        </span><br><span class="line">        varGAD := ObjBindMethod(this, <span class="string">&quot;generateDeploy&quot;</span>)</span><br><span class="line"><span class="built_in">        </span></span><br><span class="line"><span class="built_in">        GuiControl,</span> +g, <span class="variable">%HGAD%</span>, % varGAD</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadHotKey() &#123;</span><br><span class="line">        varGAD := ObjBindMethod(this, <span class="string">&quot;generateDeploy&quot;</span>)</span><br><span class="line"><span class="built_in">        </span></span><br><span class="line"><span class="built_in">        Hotkey,</span> CapsLock &amp; G, % varGAD, On</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    generateDeploy() &#123;</span><br><span class="line"><span class="built_in">        Run,</span> <span class="variable">%comSpec%</span> /c hexo g &amp;&amp; hexo d, , Min</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录一下自己在使用 AutoHotKey_v1 中类的方法绑定类中定义的热键以及 GUI 的方法。</summary>
    
    
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/categories/AutoHotKey/"/>
    
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/tags/AutoHotKey/"/>
    
  </entry>
  
  <entry>
    <title>AutoHotHey 问题解决记录</title>
    <link href="https://luoyu-ying.github.io/posts/8f286d636eff/"/>
    <id>https://luoyu-ying.github.io/posts/8f286d636eff/</id>
    <published>2022-07-11T06:41:25.000Z</published>
    <updated>2022-07-11T06:41:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>更多的资料请参考 AHK 官方技术文档以及 AHK 社区。</p></blockquote><hr /><h1 id="代码中有些代码总是无法运行"><a class="markdownIt-Anchor" href="#代码中有些代码总是无法运行"></a> 代码中有些代码总是无法运行</h1><blockquote><p>处理方法参考自：</p><ul><li><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Scripts.htm#auto">脚本 - 定义与使用 | AutoHotkey (autoahk.com)</a></li></ul></blockquote><blockquote><p>下文中的所有链接皆为 AHK 技术文档中该词条的链接，可正常使用。</p></blockquote><p><strong><font size="4"><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Scripts.htm#auto">脚本顶部(自动执行段)</a></font></strong></p><p>脚本加载完成后, 它会从顶行开始执行, 直到遇到 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Return.htm">Return</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Exit.htm">Exit</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Hotkeys.htm">热键/热字串标签</a> 或脚本的底部(无论最先遇到哪个). 脚本的这个顶端部分被称为 <em>自动执行段</em>.</p><blockquote><p><strong>注意:</strong> 虽然脚本的 <em>第一个</em> 热键/热字串标签与 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Return.htm">return(返回)</a> 的效果相同, 但其他热键和标签却没有.</p></blockquote><p>如果脚本不是<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/_Persistent.htm">持续运行的</a>, 它将在自动执行部分完成后终止. 否则, 它会以空闲状态持续运行, 从而对诸如<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Hotkeys.htm">热键</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/Hotstrings.htm">热字串</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Gui.htm#label">GUI 事件</a>, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Menu.htm">自定义菜单项</a>和<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/SetTimer.htm">计时器</a>等事件做出响应. 如果一个脚本包含了热键, 热字串, <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/OnMessage.htm">OnMessage()</a> 或 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Gui.htm">GUI</a>, 以及一些其他情况, 它就会自动变为持续运行的. 也可以用 <a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/_Persistent.htm">#Persistent</a> 指令来显式地使脚本持续运行.</p><hr /><h1 id="通过函数创建热键"><a class="markdownIt-Anchor" href="#通过函数创建热键"></a> 通过函数创建热键</h1><p>通过 <code>HotKey</code> 函数动态的创建一个热键。</p><blockquote><p>具体参数可以查看文档：<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Hotkey.htm">Hotkey | AutoHotkey (autoahk.com)</a></p></blockquote><p>示例：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 创建一个 CapsLock + K 的一个热键，效果为 Sfunction Lable 中的内容</span></span><br><span class="line"><span class="built_in">HotKey,</span> CapsLocks &amp; K, function</span><br><span class="line"></span><br><span class="line">function() &#123;</span><br><span class="line"><span class="built_in">MsgBox,</span> <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="通过函数创建热字串"><a class="markdownIt-Anchor" href="#通过函数创建热字串"></a> 通过函数创建热字串</h1><p>通过 <code>HotString</code> 函数动态的创建一个热字串。</p><blockquote><p>具体的参数可以查看文档：<a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/commands/Hotstring.htm">Hotstring() | AutoHotkey (autoahk.com)</a></p></blockquote><hr /><h1 id="无法正常使用分号注释符号"><a class="markdownIt-Anchor" href="#无法正常使用分号注释符号"></a> 无法正常使用分号（注释符号）</h1><p>当我们想要使用 分号 作为热键中的一部分时，我们可以使用 <code>SC027</code> 替换分号的位置，以达到分号的作用、</p><p>示例：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; 创建一个 CapsLock + K 的一个热键，效果为 function Lable 中的内容</span></span><br><span class="line"><span class="built_in">HotKey,</span> CapsLocks &amp; SC027, function </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录了一些在编写 AutoHotKey 代码中遇到的问题以及解决的方案。</summary>
    
    
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/categories/AutoHotKey/"/>
    
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/tags/AutoHotKey/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Lambda 表达式</title>
    <link href="https://luoyu-ying.github.io/posts/0ca5222da5ff/"/>
    <id>https://luoyu-ying.github.io/posts/0ca5222da5ff/</id>
    <published>2022-07-10T03:19:09.000Z</published>
    <updated>2022-07-10T03:19:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li>《第一行代码 Android 第3版》</li><li><a href="https://time.geekbang.org/course/intro/100009801">快速上手 Kotlin 开发 (geekbang.org)</a></li><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li></ul></blockquote><hr /><h1 id="lambda-定义"><a class="markdownIt-Anchor" href="#lambda-定义"></a> <code>Lambda</code> 定义</h1><p><code>Lambda</code> 就是一小段可以作为参数传递的代码，也可以认为是函数的简写形式。</p><hr /><h1 id="lambda-表达式的语法结构"><a class="markdownIt-Anchor" href="#lambda-表达式的语法结构"></a> <code>Lambda</code> 表达式的语法结构</h1><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;参数名<span class="number">1</span>: 参数类型, 参数名<span class="number">2</span>: 参数类型, ..., 参数名n: 参数类型 -&gt; 函数体&#125;</span><br></pre></td></tr></table></figure><p>这是 <code>Lambda</code> 表达式最完整的语法结构定义。</p><p>首先最外层是一对大括号，如果有参数传入到 <code>Lambda</code> 表达式中的话，我们还需要声明参数列表，参数列表的结尾使用一个 <code>-&gt;</code> 符号，表示参数列表的结束以及函数体的开始。</p><p>函数体中可以编写任意行代码（虽然不建议编写太长的代码)，<strong>并且最后一行代码会自动作为 <code>Lambda</code> 表达式的返回值</strong>，即 <code>return 最后一行代码</code>。</p><p>所以我们也可以用变量获取 <code>Lambda</code> 表达式的结果，即 <code>val result = &#123;... -&gt; ...&#125;</code> 。</p><hr /><h1 id="lambda-表达式的特点"><a class="markdownIt-Anchor" href="#lambda-表达式的特点"></a> <code>Lambda</code> 表达式的特点</h1><ol><li>最后一行代码会自动作为 <code>Lambda</code> 表达式的返回值（隐式 <code>return</code>）。</li><li>如果 <code>Lambda</code> 没有参数，那么可以省略箭头符号 <code>-&gt;</code>。</li><li>如果 <code>Lambda</code> 是函数的最后一个参数，那么可以将大括号放在小括号的外面。</li><li>如果函数只有一个参数并且这个参数就是 <code>Lambda</code> ，则可以省略小括号。</li></ol><hr /><h1 id="sam-转换"><a class="markdownIt-Anchor" href="#sam-转换"></a> <code>SAM</code> 转换</h1><blockquote><p>当一个函数的参数是 SAM 的情况下，我们同样也可以使用 Lambda 作为参数。</p><p>通过 SAM 转换，我们就可以在 Kotlin 中便携的编写如 setOnClickListener 之类的方法了。</p></blockquote><p><code>SAM</code> 是 Single Abstract Method 的缩写，意思就是只有一个抽象方法的类或者接口。但在 Kotlin 和 Java 8 里，<strong>SAM 代表着只有一个抽象方法的接口</strong>。只要是符合 SAM 要求的接口，编译器就能进行 SAM 转换，也就是我们可以使用 Lambda 表达式，来简写接口类的参数。</p><p>注意，Java 8 中的 SAM 有明确的名称，叫做函数式接口（FunctionalInterface）。FunctionalInterface 的限制如下，缺一不可：</p><ol><li>必须是接口，抽象类不行；</li><li>该接口有且仅有一个抽象的方法，抽象方法个数必须是 1，默认实现的方法可以有多个。</li></ol><p>也就是说，对于 View.java 来说，它虽然是 Java 代码，但 Kotlin 编译器知道它的参数 OnClickListener 符合 SAM 转换的条件，所以会自动做以下转换。</p><p>转换前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOnClickListener</span><span class="params">(OnClickListener l)</span></span><br></pre></td></tr></table></figure><p>转换后：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(l: (<span class="type">View</span>) -&gt; <span class="type">Unit</span>)</span></span></span><br><span class="line"><span class="comment">// 实际上是这样：</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setOnClickListener</span><span class="params">(l: ((<span class="type">View</span>!) -&gt; <span class="type">Unit</span>)?)</span></span></span><br></pre></td></tr></table></figure><p>其中，((View!) -&gt; Unit)? 代表的是这个参数可能为空。</p><hr /><h1 id="lambda-表达式的写法"><a class="markdownIt-Anchor" href="#lambda-表达式的写法"></a> <code>Lambda</code> 表达式的写法</h1><p>当一个函数的参数是 <code>SAM</code> 的情况下，我们同样也可以使用 <code>Lambda</code> 作为参数。所以，我们既可以用匿名内部类的方式传参，也可以使用 <code>Lambda</code> 的方式传参。</p><p>从匿名内部类的写法到 <code>Lambda</code> 表达式最终的精简形式，在这两种写法的中间，还有 6 种“过渡状态”的写法。</p><p>下面将从匿名内部类的写法开始，一步步的过渡到 <code>Lambda</code> 的写法。</p><p><strong><font size="4">第 1 种写法</font></strong></p><p>这是原始代码，它的本质是用 <code>object</code> 关键字定义了一个匿名内部类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(<span class="keyword">object</span>: View.OnClickListener &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onClick</span><span class="params">(v: <span class="type">View</span>?)</span></span> &#123;</span><br><span class="line">        gotoPreview(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 2 种写法</font></strong></p><p>在这种情况下，<code>object</code> 关键字可以被省略。这时候它在语法层面就不再是匿名内部类了，它更像是 <code>Lambda</code> 表达式了，因此它里面 <code>override</code> 的方法也要跟着删掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(View.OnClickListener &#123; v: View? -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的 <code>View.OnClickListener</code> 被称为 <code>SAM Constructor</code>（SAM 构造器），它是编译器为我们生成的。</p><p>这段代码明显简化了很多，既可以实现同样的功能，又不会造成任何歧义。因为 <code>View.OnClickListener</code> 中只有一个待实现方法,即使这里没有显式地重写 onClick() 方法，<code>Kotlin</code> 也能自动明白 <code>View.OnClickListener</code> 后面的 <code>Lambda</code> 表达式就是要在 <code>onClick()</code> 方法中实现的内容。</p><p><strong><font size="4">第 3 种写法</font></strong></p><p>如果一个 <code>Java</code> 方法的参数列表中不存在一个以上 <code>Java</code> 单抽象方法接口参数，我们还可以将接口名进行省略（且<code>Kotlin</code> 的 <code>Lambda</code> 表达式是不需要 <code>SAM Constructor</code> 的），所以它也可以被删掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123; v: View? -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 4 种写法</font></strong></p><p>由于 <code>Kotlin</code> 支持类型推导，所以 <code>View</code> 可以被删掉：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123; v -&gt;</span><br><span class="line">    gotoPreview(v)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 5 种写法</font></strong></p><p>当 <code>Kotlin</code> <code>Lambda</code> 表达式只有一个参数的时候，它可以被写成 <code>it</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123; it -&gt;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 6 种写法</font></strong></p><p><code>Kotlin</code> <code>Lambda</code> 的 <code>it</code> 是可以被省略的：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener(&#123;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 7 种写法</font></strong></p><p>当 <code>Kotlin</code> <code>Lambda</code> 作为函数的最后一个参数时，<code>Lambda</code> 可以被挪到外面：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener() &#123;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font size="4">第 8 种写法</font></strong></p><p>当 <code>Kotlin</code> 只有一个 <code>Lambda</code> 作为函数参数时，<code>()</code> 可以被省略：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.setOnClickListener &#123;</span><br><span class="line">    gotoPreview(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，将这 8 种写法的演进过程以动图的形式展现了出来，让你对 <code>Lambda</code> 这几种写法的差异有一个更加直观的认识。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/e441323968c0c061898257fd06db37bf.gif" alt="img" style="zoom: 50%;" />]]></content>
    
    
    <summary type="html">学习并整理了 Kotlin 中 Lambda 表达式的使用方法。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 函数嵌套</title>
    <link href="https://luoyu-ying.github.io/posts/47063eb1b5ed/"/>
    <id>https://luoyu-ying.github.io/posts/47063eb1b5ed/</id>
    <published>2022-07-09T15:24:11.000Z</published>
    <updated>2022-07-10T04:58:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li><a href="https://time.geekbang.org/column/intro/100103401">朱涛 · Kotlin 编程第一课 (geekbang.org)</a></li><li><a href="https://www.cnblogs.com/Anker/archive/2013/03/04/2943498.html">递归与尾递归总结 - Rabbit_Dale - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/zsp765098084/article/details/90901260">kotlin学习笔记之尾递归优化（tailrec）_mictoy_朱的博客-CSDN博客_kotlin tailrec</a></li></ul></blockquote><hr /><h1 id="使用方法"><a class="markdownIt-Anchor" href="#使用方法"></a> 使用方法</h1><p>在 <code>Kotlin</code> 中，我们可以在函数的代码块中创建另一个新的函数并使用该函数。并且该函数可以使用外部函数的变量。</p><p>如下方的代码；</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">outerMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算 1 + 2 + 3 + ...</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">innerMethod</span><span class="params">(c: <span class="type">Int</span> = <span class="number">10</span>)</span></span> &#123;</span><br><span class="line">        sum += c</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0</span>)</span><br><span class="line">        innerMethod(c - <span class="number">1</span>)</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    innerMethod()</span><br><span class="line">  println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    outerMethod()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr /><h1 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h1><p>函数嵌套在工程中应尽量少的使用，容易造成代码可读性的降低。</p><p>但是在两种情况下可以创建内部函数：</p><ol><li>在某些情况下需要临时使用 <strong>递归</strong> 函数，如上文中的代码。</li><li>不希望被外部函数访问到的函数。</li></ol><hr /><h1 id="尾递归"><a class="markdownIt-Anchor" href="#尾递归"></a> 尾递归</h1><p>实际上，在函数式编程当中，我们有时候也会使用递归来替代循环。</p><p>我们知道，递归都是有调用栈开销的，所以我们应该尽量使用 <strong>尾递归</strong>。对于这种类型的递归，在经过栈复用优化以后，它的开销就可以忽略不计了，我们可以认为它的空间复杂度是 O(1)。</p><blockquote><p>尾递归就是从最后开始计算，每递归一次就算出相应的结果，也就是说, 函数调用出现在调用者函数的尾部，因为是尾部，所以根本没有必要去保存任何局部变量，直接让被调用的函数返回时越过调用者，返回到调用者的调用者去。</p><p><strong>尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数</strong>，深层函数所面对的不是越来越简单的问题，而是越来越复杂的问题，因为参数里带有前面若干步的运算路径。</p><p>尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。</p></blockquote><h2 id="尾递归的特点"><a class="markdownIt-Anchor" href="#尾递归的特点"></a> 尾递归的特点</h2><ul><li>递归的一种特殊形式</li><li>调用自身后无其他操作</li><li><code>tailrec</code> 关键字提示编译器尾递归优化</li></ul><p>示例代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>(<span class="keyword">val</span> value:<span class="built_in">Int</span>,<span class="keyword">var</span> next:ListNode? = <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">findListNode</span><span class="params">(head:<span class="type">ListNode</span>?,value:<span class="type">Int</span>)</span></span>:ListNode?&#123; <span class="comment">//定义一个递归函数</span></span><br><span class="line">    head?:<span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (head.value == value) <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">return</span> findListNode(head.next,value)    <span class="comment">//return除了调用自己，没有多余的操作，所以是尾递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾递归优化的使用"><a class="markdownIt-Anchor" href="#尾递归优化的使用"></a> 尾递归优化的使用</h2><p>在 <code>Kotlin</code> 语言中，我们即使写出了符合尾递归的递归函数，编译器也不会自动帮我们进行优化。</p><p>我们需要在 <code>fun</code> 关键字前面加上 <code>tailrec</code> 关键字以表示我们需要进行尾递归优化。</p><p>示例代码1：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span></span>(<span class="keyword">val</span> value:<span class="built_in">Int</span>,<span class="keyword">var</span> next:ListNode? = <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">findListNode</span><span class="params">(head:<span class="type">ListNode</span>?,value:<span class="type">Int</span>)</span></span>:ListNode?&#123; <span class="comment">//定义一个递归函数</span></span><br><span class="line">    head?:<span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (head.value == value) <span class="keyword">return</span> head</span><br><span class="line">    <span class="keyword">return</span> findListNode(head.next,value)    <span class="comment">//return除了调用自己，没有多余的操作，所以是尾递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码2：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">recursionLoop</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line"><span class="comment">// 变化在这里</span></span><br><span class="line"><span class="comment">//     ↓</span></span><br><span class="line">    <span class="keyword">tailrec</span> <span class="function"><span class="keyword">fun</span> <span class="title">go</span><span class="params">(i: <span class="type">Int</span>, sum: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> =</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">10</span>) sum <span class="keyword">else</span> go(i + <span class="number">1</span>, sum + i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> go(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="尾递归优化的实质"><a class="markdownIt-Anchor" href="#尾递归优化的实质"></a> 尾递归优化的实质</h2><p>通过对上文中的 <code>findListNode</code> 方法对 <strong>加了 <code>tailrec</code> 关键字</strong> 与 <strong>去除 <code>tailrec</code> 关键字</strong> 的两份代码分别进行反编译，我们发现：</p><ul><li><p>没有优化的 <code>findListNode</code> 对应的 <code>Java</code> 代码依然是递归函数，并且递归运行次数较大时出现了 <code>StackOverflowError</code> 错误；</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135701617.png" alt="img" style="zoom: 90%;" /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135611929.png" alt="img" style="zoom:87%;" /></li><li><p>优化后（即添加了 <code>tailrec</code> 关键字）的 <code>findListNode</code> 方法对应的 <code>Java</code> 代码已经不再是递归函数，而是通过循环来实现功能，这样就不会再出现 <code>stackoverflowerror</code> 了。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20190605135710491.png" alt="img" style="zoom:90%;" /></li></ul><p>这样我们就在 <code>Kotlin</code> 中既实现了递归函数代码简洁的优势，又规避了在 <code>Java</code> 中使用递归函数容易出出现的问题。</p>]]></content>
    
    
    <summary type="html">学习了 Kotlin 中函数嵌套的使用方法。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin 空指针检查</title>
    <link href="https://luoyu-ying.github.io/posts/4c7d77851d24/"/>
    <id>https://luoyu-ying.github.io/posts/4c7d77851d24/</id>
    <published>2022-07-09T11:32:31.000Z</published>
    <updated>2022-07-09T11:32:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自：</p><ul><li>《第一行代码 Android 第3版》</li></ul></blockquote><hr /><h1 id="可空类型系统"><a class="markdownIt-Anchor" href="#可空类型系统"></a> 可空类型系统</h1><p>因为 <code>Kotlin</code> 默认所有的参数和变量都不可为空，所以我们直接使用定义任何变量和参数并使用的话，是没有任何的空指针风险的。</p><p>例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>)</span></span> &#123;</span><br><span class="line">    study.readBooks()</span><br><span class="line">    study.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码是没有空指针异常的，如果我们尝试向 <code>doStudy</code> 函数中传递 <code>null</code> 参数，便会直接提示错误：<code>Null can not be a value of a non-null type Study</code>。</p><p>也就是说，<code>Kotlin</code> 将空指针异常的检查提前到了编译时期，如果我们的程序存在空指针异常的风险，那么在编译的时候会直接报错，修正之后才能成功运行，这样就可以保证程序在运行时期不会出现空指针异常了。</p><p>那么如何使得这些类型变为可为空的类型系统呢？</p><p><strong>很简单，就是在类名的后面加上一个问号。</strong></p><p>比如说，<code>Int</code> 表示不可为空的整形，而 <code>Int?</code> 则表示可为空的整形；<code>String</code> 表示不可为空的字符串，而 <code>String?</code> 就表示可以为空的字符串。</p><p>当我们希望上述的代码可以传入 <code>null</code> 参数，那么我们就需要将 <code>Study</code> 改成 <code>Study?</code> ，如下文所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    study.readBooks()</span><br><span class="line">    study.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上述的代码仍然有些许错误，即使我们能够正常的传入 <code>null</code> 参数，但是 <code>null</code> 是无法调用 <code>readBooks()</code> 以及 <code>doHomework()</code> 函数的。所以我们仍需要对 <code>study</code> 进行进一步的判断：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (study != <span class="literal">null</span>) &#123;</span><br><span class="line">        study.readBooks()</span><br><span class="line">        study.doHomework()    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这样的写法，我们可能会在代码中写入大量的 <code>if</code> 语句仅仅只是为了判断变量或者参数是否为空，这样会让代码变得比较啰嗦。为此，<code>Kotlin</code> 专门提供了一系列的辅助工具，方便我们更加轻松以及快速地进行判空处理。</p><hr /><h1 id="判空辅助工具"><a class="markdownIt-Anchor" href="#判空辅助工具"></a> 判空辅助工具</h1><h2 id="操作符"><a class="markdownIt-Anchor" href="#操作符"></a> <code>?.</code> 操作符</h2><p><code>?.</code> 操作符的作用就是当对象不为空的时候正常调用相应的函数，当对象为空时则什么都不做。</p><p>如下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a != <span class="literal">null</span>) &#123;</span><br><span class="line">    a.doSomething()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 <code>?.</code> 操作符，我们便可以将其简化成：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a?.doSomething()</span><br></pre></td></tr></table></figure><p>现在我们便可以对上文中的代码进行优化了：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">doStudy</span><span class="params">(study: <span class="type">Study</span>?)</span></span> &#123;</span><br><span class="line">    study?.readBooks()</span><br><span class="line">    study?.doHomework()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作符-2"><a class="markdownIt-Anchor" href="#操作符-2"></a> <code>?:</code> 操作符</h2><p><code>?:</code> 操作符的左右两边都接受一个表达式，如果左边表达式的结果不为空就返回左边表达式的结果，否则就返回右边表达式的结果。</p><p>如下面的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = <span class="keyword">if</span> (a != <span class="literal">null</span>) a <span class="keyword">else</span> b</span><br></pre></td></tr></table></figure><p>便可以简化成为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = a ?: b</span><br></pre></td></tr></table></figure><h2 id="操作符-3"><a class="markdownIt-Anchor" href="#操作符-3"></a> <code>!!.</code> 操作符</h2><p>如果我们想要一遍变量在使用的过程中不进行空指针检查，并在遇到空指针的时候主动的抛出空指针异常（有的时候我们可能从逻辑上已经将空指针异常处理了，但是 <code>Kotlin</code> 的编译器并不知道，这个时候它还是会编译失败），那么我们可以通过使用 <code>!!.</code> 操作符（非空断言工具）强行通过编译。写法是在对象的后面加上 <code>!!.</code>。</p><p>例如以下的代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg: String? = <span class="string">&quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg != <span class="literal">null</span>) &#123;</span><br><span class="line">        printUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printUpperCase</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> upperCase = msg!!.toUpperCase()</span><br><span class="line">    println(upperCase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上文中，<code>printUpperCase</code> 函数的调用一定发生在 <code>msg</code> 不为空的情况，所以我们可以使用非空断言工具让其不进行空指针判断。</p><p>这是一种有风险的写法，意在告诉 <code>Kotlin</code>，我非常确信这里的对象不会为空，所以不用你来帮我做空指针检查了，如果出现问题，你可以直接抛出空指针异常，后果由我自己承担。</p><p>虽然这样编写代码确实可以通过编译，但是当你想要使用非空断言工具的时候，最好提醒一下自己，是不是还有更好的实现方式。</p><p><strong>你最自信这个对象不会为空的时候，其实可能就是一个潜在空指针异常发生的时候。</strong></p><hr /><h1 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h1><p>标准函数中 <code>let</code> 函数是可以处理全局变量的判空问题的，而 <code>if</code> 语句则无法做到这一点。</p><p>比如我们将 <code>doStudy()</code> 中的参数变成一个全局变量，使用 <code>let</code> 函数仍然可以正常工作，但是使用 <code>if</code> 语句则会提示错误：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220709203415002.png" alt="image" style="zoom:80%;" /><p>之所以这里会报错，是因为全局变量的值随时都有可能被其他线程所修改，即使做了判空处理，仍然无法保证 <code>if</code> 语句中的<code>study</code> 变量没有空指针风险。从这一点上也能体现出 <code>let</code> 函数的优势。</p>]]></content>
    
    
    <summary type="html">学习了 Kotlin 中空指针相关的运算符。</summary>
    
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/categories/Kotlin/"/>
    
    
    <category term="Kotlin" scheme="https://luoyu-ying.github.io/tags/Kotlin/"/>
    
  </entry>
  
</feed>
