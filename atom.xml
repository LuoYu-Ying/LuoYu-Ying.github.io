<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洛语 の Blog</title>
  
  
  <link href="https://luoyu-ying.github.io/atom.xml" rel="self"/>
  
  <link href="https://luoyu-ying.github.io/"/>
  <updated>2022-06-07T11:42:00.000Z</updated>
  <id>https://luoyu-ying.github.io/</id>
  
  <author>
    <name>LuoYu-Ying</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PicGo 问题解决记录</title>
    <link href="https://luoyu-ying.github.io/posts/052b259f25f7/"/>
    <id>https://luoyu-ying.github.io/posts/052b259f25f7/</id>
    <published>2022-06-07T11:42:00.000Z</published>
    <updated>2022-06-07T11:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>更多 FAQ 请查看官方文档：</p><ul><li><a href="https://github.com/Molunerfinn/PicGo/blob/dev/FAQ.md">PicGo/FAQ.md at dev · Molunerfinn/PicGo (github.com)</a></li><li><a href="https://github.com/Molunerfinn/PicGo/issues">Issues · Molunerfinn/PicGo (github.com)</a></li></ul></blockquote><h1 id="相册突然无法显示图片或者上传后相册不更新"><a class="markdownIt-Anchor" href="#相册突然无法显示图片或者上传后相册不更新"></a> 相册突然无法显示图片或者上传后相册不更新</h1><p>这个原因可能是相册存储文件损坏导致的。可以找到 PicGo 配置文件所在路径下的 <code>picgo.db</code> ，将其删掉（删掉前建议备份一遍），再重启 PicGo 试试。 注意同时看看日志文件里有没有什么error，必要时可以提issue。</p><h1 id="github-图床有时能上传有时上传失败"><a class="markdownIt-Anchor" href="#github-图床有时能上传有时上传失败"></a> GitHub 图床有时能上传，有时上传失败</h1><ol><li>GitHub 图床不支持上传同名文件，如果有同名文件上传，会报错。建议开启 <code>时间戳重命名</code> 避免同名文件。</li><li>GitHub 服务器和国内 GFW 的问题会导致有时上传成功，有时上传失败，无解。想要稳定请使用付费云存储，如阿里云、腾讯云等，价格也不会贵。</li></ol><h1 id="上传失败或者是服务器出错"><a class="markdownIt-Anchor" href="#上传失败或者是服务器出错"></a> 上传失败，或者是服务器出错</h1><ol><li>PicGo 自带的图床都经过测试，上传出错一般都不是 PicGo 自身的原因。如果你用的是 GitHub 图床请参考上面的问题。</li><li>检查 PicGo 的日志（报错日志可以在 PicGo 设置 -&gt; 设置日志文件 -&gt; 点击打开 后找到），看看 <code>[PicGo Error]</code> 的报错信息里有什么关键信息<ol><li>先自行搜索 error 里的报错信息，往往你能百度或者谷歌出问题原因，不必开 issue。</li><li>如果有带有 <code>401</code> 、<code>403</code> 等 <code>40X</code> 状态码字样的，不用怀疑，就是你配置写错了，仔细检查配置，看看是否多了空格之类的。</li><li>如果带有 <code>HttpError</code>、<code>RequestError</code> 、 <code>socket hang up</code> 等字样的说明这是网络问题，我无法帮你解决网络问题，请检查你自己的网络，是否有代理，DNS 设置是否正常等。</li></ol></li></ol>]]></content>
    
    
    <summary type="html">记录一下在使用 PicGo 中遇到的问题和解决方法。</summary>
    
    
    
    <category term="PicGo" scheme="https://luoyu-ying.github.io/categories/PicGo/"/>
    
    
    <category term="PicGo" scheme="https://luoyu-ying.github.io/tags/PicGo/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络-知识整理</title>
    <link href="https://luoyu-ying.github.io/posts/79ac60e18500/"/>
    <id>https://luoyu-ying.github.io/posts/79ac60e18500/</id>
    <published>2022-06-07T00:06:33.000Z</published>
    <updated>2022-06-07T00:06:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>答案参考自：</p><ul><li><a href="http://www.cyc2018.xyz/">CS-Notes (cyc2018.xyz)</a></li></ul></blockquote><h1 id="主机之间的通信方式"><a class="markdownIt-Anchor" href="#主机之间的通信方式"></a> 主机之间的通信方式</h1><ul><li>客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/914894c2-0bc4-46b5-bef9-0316a69ef521.jpg" alt="img" style="zoom: 67%;" /><ul><li>对等（P2P）：不区分客户和服务器。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/42430e94-3137-48c0-bdb6-3cebaf9102e3.jpg" alt="img" style="zoom: 67%;" /><h1 id="计算机网络体系结构"><a class="markdownIt-Anchor" href="#计算机网络体系结构"></a> 计算机网络体系结构</h1><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png" alt="img" style="zoom:80%;" /><h2 id="五层协议"><a class="markdownIt-Anchor" href="#五层协议"></a> 五层协议</h2><ul><li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</li><li><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：<strong>传输控制协议 TCP</strong> ，提供面向连接、可靠的数据传输服务，数据单位为报文段：<strong>用户数据报协议 UDP</strong> ，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li><li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><h2 id="osi"><a class="markdownIt-Anchor" href="#osi"></a> OSI</h2><p>其中表示层和会话层用途如下：</p><ul><li><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li><li><strong>会话层</strong> ：建立及管理会话。</li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><h2 id="tcpip"><a class="markdownIt-Anchor" href="#tcpip"></a> TCP/IP</h2><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/48d79be8-085b-4862-8a9d-18402eb93b31.png" alt="img" style="zoom:67%;" /><h2 id="数据在各层之间的传递过程"><a class="markdownIt-Anchor" href="#数据在各层之间的传递过程"></a> 数据在各层之间的传递过程</h2><p>在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。</p><p>路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。</p><h1 id="物理层"><a class="markdownIt-Anchor" href="#物理层"></a> 物理层</h1><h2 id="通信方式"><a class="markdownIt-Anchor" href="#通信方式"></a> 通信方式</h2><p>根据信息在传输线上的传送方向，分为以下三种通信方式：</p><ul><li>单工通信：单向传输</li><li>半双工通信：双向交替传输</li><li>全双工通信：双向同时传输</li></ul><h1 id="数据链路层"><a class="markdownIt-Anchor" href="#数据链路层"></a> 数据链路层</h1><h2 id="封装成帧"><a class="markdownIt-Anchor" href="#封装成帧"></a> 封装成帧</h2><p>将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/29a14735-e154-4f60-9a04-c9628e5d09f4.png" alt="img" style="zoom:67%;" /><h2 id="透明传输"><a class="markdownIt-Anchor" href="#透明传输"></a> 透明传输</h2><p>透明表示一个实际存在的事物看起来好像不存在一样。</p><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/e738a3d2-f42e-4755-ae13-ca23497e7a97.png" alt="img" style="zoom: 50%;" /><h2 id="差错检测"><a class="markdownIt-Anchor" href="#差错检测"></a> 差错检测</h2><p>目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。</p><h2 id="信道分类"><a class="markdownIt-Anchor" href="#信道分类"></a> 信道分类</h2><h3 id="广播信道"><a class="markdownIt-Anchor" href="#广播信道"></a> 广播信道</h3><p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</p><h3 id="点对点信道"><a class="markdownIt-Anchor" href="#点对点信道"></a> 点对点信道</h3><p>一对一通信。</p><p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p><h2 id="信道复用技术"><a class="markdownIt-Anchor" href="#信道复用技术"></a> 信道复用技术</h2><h3 id="频分复用"><a class="markdownIt-Anchor" href="#频分复用"></a> 频分复用</h3><p>频分复用的所有主机在相同的时间占用不同的频率带宽资源。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/4aa5e057-bc57-4719-ab57-c6fbc861c505.png" alt="img" style="zoom:50%;" /><h3 id="时分复用"><a class="markdownIt-Anchor" href="#时分复用"></a> 时分复用</h3><p>时分复用的所有主机在不同的时间占用相同的频率带宽资源。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/67582ade-d44a-46a6-8757-3c1296cc1ef9.png" alt="img" style="zoom:50%;" /><p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，<strong>因此这两种方式对信道的利用率都不高</strong> 。</p><h3 id="统计时分复用"><a class="markdownIt-Anchor" href="#统计时分复用"></a> 统计时分复用</h3><p>是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/6283be2a-814a-4a10-84bf-9592533fe6bc.png" alt="img" style="zoom:50%;" /><h3 id="波分复用"><a class="markdownIt-Anchor" href="#波分复用"></a> 波分复用</h3><p>光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。</p><h3 id="码分复用"><a class="markdownIt-Anchor" href="#码分复用"></a> 码分复用</h3><h1 id="网络层"><a class="markdownIt-Anchor" href="#网络层"></a> 网络层</h1><p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><h2 id="ip-数据报格式"><a class="markdownIt-Anchor" href="#ip-数据报格式"></a> IP 数据报格式</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/85c05fb1-5546-4c50-9221-21f231cdc8c5.jpg" alt="img" style="zoom:80%;" /><ul><li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li><li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li><li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li><li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li></ul><h1 id="传输层"><a class="markdownIt-Anchor" href="#传输层"></a> 传输层</h1><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。</p><h2 id="udp-和-tcp-的特点"><a class="markdownIt-Anchor" href="#udp-和-tcp-的特点"></a> UDP 和 TCP 的特点</h2><ul><li><strong>用户数据报协议 UDP（User Datagram Protocol）</strong> 是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），<strong>支持一对一、一对多、多对一和多对多的交互通信</strong> 。</li><li><strong>传输控制协议 TCP（Transmission Control Protocol）</strong> 是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），<strong>每一条 TCP 连接只能是点对点的（一对一）</strong> 。</li></ul><h2 id="udp-首部格式"><a class="markdownIt-Anchor" href="#udp-首部格式"></a> UDP 首部格式</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg" alt="img" style="zoom:80%;" /><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><h2 id="tcp-首部格式"><a class="markdownIt-Anchor" href="#tcp-首部格式"></a> TCP 首部格式</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/55dc4e84-573d-4c13-a765-52ed1dd251f9.png" alt="img" style="zoom:80%;" /><ul><li><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li><li><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li><li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li><li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li><li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ul><h2 id="tcp-的三次握手"><a class="markdownIt-Anchor" href="#tcp-的三次握手"></a> TCP 的三次握手</h2><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/e92d0ebc-7d46-413b-aec1-34a39602f787.png" alt="img" /></p><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><p><strong>三次握手的原因</strong></p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>]]></content>
    
    
    <summary type="html">整理了面试需要的部分计算机网络知识点。</summary>
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="计算机网络" scheme="https://luoyu-ying.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="计算机网络" scheme="https://luoyu-ying.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 美化教程 博客整理</title>
    <link href="https://luoyu-ying.github.io/posts/07af833ec811/"/>
    <id>https://luoyu-ying.github.io/posts/07af833ec811/</id>
    <published>2022-06-06T14:19:47.000Z</published>
    <updated>2022-06-06T14:19:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><em>本文持续更新中~</em></p></blockquote><h1 id="字体更改"><a class="markdownIt-Anchor" href="#字体更改"></a> 字体更改</h1><ul><li><a href="https://www.yanchengxu.top/hexo-font-modification/">【Hexo-Butterfly】字体修改 | yanchengxu</a></li></ul>]]></content>
    
    
    <summary type="html">记录了自己在美化博客时收集的各个大佬的教程。</summary>
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>计算机操作系统-知识整理</title>
    <link href="https://luoyu-ying.github.io/posts/75b6e1fc4978/"/>
    <id>https://luoyu-ying.github.io/posts/75b6e1fc4978/</id>
    <published>2022-06-02T08:41:53.000Z</published>
    <updated>2022-06-05T08:41:53.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文整理自：</p><ul><li><a href="http://www.cyc2018.xyz/">CS-Notes (cyc2018.xyz)</a></li></ul></blockquote><h1 id="四个基本特征"><a class="markdownIt-Anchor" href="#四个基本特征"></a> 四个基本特征</h1><ol><li><p>并发</p><p>并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</p><p>并行需要硬件支持，如多流水线、多核处理器或者分布式计算系统。</p><p>操作系统通过引入进程和线程，使得程序能够并发运行。</p></li><li><p>共享</p><p>共享是指系统中的资源可以被多个并发进程共同使用。</p><p>有两种共享方式：互斥共享和同时共享。</p><p>互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。</p></li><li><p>虚拟</p><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。</p><p>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p></li><li><p>异步</p><p>异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p></li></ol><h1 id="基本功能"><a class="markdownIt-Anchor" href="#基本功能"></a> 基本功能</h1><ol><li><p>进程管理</p><p>进程控制、进程同步、进程通信、死锁处理、处理机调度等。</p></li><li><p>内存管理</p><p>内存分配、地址映射、内存保护与共享、虚拟内存等。</p></li><li><p>文件管理</p><p>文件存储空间的管理、目录管理、文件读写管理和保护等。</p></li><li><p>设备管理</p><p>完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。</p><p>主要包括缓冲管理、设备分配、设备处理、虛拟设备等。</p></li></ol><h1 id="系统调用"><a class="markdownIt-Anchor" href="#系统调用"></a> 系统调用</h1><p>如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/tGPV0.png" alt="img" /></p><h1 id="进程和线程"><a class="markdownIt-Anchor" href="#进程和线程"></a> 进程和线程</h1><h2 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h2><p><strong>进程是资源分配的最小单位。</strong></p><p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p><p>下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/a6ac2b08-3861-4e85-baa8-382287bfee9f.png" alt="img" /></p><h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2><p><strong>线程是独立调度的基本单位。</strong></p><p>一个进程中可以有多个线程，它们共享进程资源。</p><h2 id="区别"><a class="markdownIt-Anchor" href="#区别"></a> 区别</h2><ol><li><p>拥有资源</p><p>进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p></li><li><p>调度</p><p>线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</p></li><li><p>系统开销</p><p>由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。</p></li><li><p>通信方面</p><p>线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。</p></li></ol><h1 id="进程状态的切换"><a class="markdownIt-Anchor" href="#进程状态的切换"></a> 进程状态的切换</h1><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ProcessState.png" alt="img" /></p><ul><li>就绪状态（ready）：等待被调度</li><li>运行状态（running）</li><li>阻塞状态（waiting）：等待资源</li></ul><p>注意：</p><ul><li>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</li><li>阻塞状态是由于缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。</li></ul><h1 id="进程调度算法"><a class="markdownIt-Anchor" href="#进程调度算法"></a> 进程调度算法</h1><p>不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。</p><h2 id="交互式系统"><a class="markdownIt-Anchor" href="#交互式系统"></a> 交互式系统</h2><p>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</p><h3 id="时间片轮转"><a class="markdownIt-Anchor" href="#时间片轮转"></a> 时间片轮转</h3><blockquote><p><strong>先来先服务 first-come first-serverd（FCFS）</strong></p><p>批处理系统中非抢占式的调度算法，按照请求的顺序进行调度。</p><p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p></blockquote><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><h3 id="优先级调度"><a class="markdownIt-Anchor" href="#优先级调度"></a> 优先级调度</h3><p>为每个进程分配一个优先级，按优先级进行调度。</p><p>为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><h3 id="多级反馈队列"><a class="markdownIt-Anchor" href="#多级反馈队列"></a> 多级反馈队列</h3><p>一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p>多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,…。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。</p><p>每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p>可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/042cf928-3c8e-4815-ae9c-f2780202c68f.png" alt="img" /></p><h2 id="批处理系统-实时系统"><a class="markdownIt-Anchor" href="#批处理系统-实时系统"></a> 批处理系统、实时系统</h2><p>具体内容查看本文上方的参考文章。</p><h1 id="进程同步"><a class="markdownIt-Anchor" href="#进程同步"></a> 进程同步</h1><h2 id="临界区"><a class="markdownIt-Anchor" href="#临界区"></a> 临界区</h2><p>对临界资源进行访问的那段代码称为临界区。</p><p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section;</span><br><span class="line">// exit section</span><br></pre></td></tr></table></figure><h2 id="同步与互斥"><a class="markdownIt-Anchor" href="#同步与互斥"></a> 同步与互斥</h2><ul><li>同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。</li><li>互斥：多个进程在同一时刻只有一个进程能进入临界区。</li></ul><h2 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h2><p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p><ul><li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li><li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li></ul><p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p><p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">P2</span><span class="params">()</span> &#123;</span><br><span class="line">    down(&amp;mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="管程"><a class="markdownIt-Anchor" href="#管程"></a> 管程</h2><p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p><p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p><h1 id="经典同步问题"><a class="markdownIt-Anchor" href="#经典同步问题"></a> 经典同步问题</h1><h2 id="哲学家进餐问题"><a class="markdownIt-Anchor" href="#哲学家进餐问题"></a> 哲学家进餐问题</h2><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p><p>一种错误的解法，如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p><p>为了防止死锁的发生，可以设置两个条件：</p><ul><li>必须同时拿起左右两根筷子；</li><li>只有在两个邻居都没有进餐的情况下才允许进餐。</li></ul><h2 id="读者-写者问题"><a class="markdownIt-Anchor" href="#读者-写者问题"></a> 读者-写者问题</h2><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p><p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p><h1 id="进程通信"><a class="markdownIt-Anchor" href="#进程通信"></a> 进程通信</h1><p>进程同步与进程通信很容易混淆，它们的区别在于：</p><ul><li>进程同步：控制多个进程按一定顺序执行；</li><li>进程通信：进程间传输信息。</li></ul><p>进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。</p><h2 id="共享存储"><a class="markdownIt-Anchor" href="#共享存储"></a> 共享存储</h2><p>允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。</p><p>需要使用信号量用来同步对共享存储的访问。</p><p>多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用内存的匿名段。</p><h2 id="信号量-2"><a class="markdownIt-Anchor" href="#信号量-2"></a> 信号量</h2><p>它是一个计数器，用于为多个进程提供对共享数据对象的访问。</p><h1 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h1><h2 id="死锁的必要条件"><a class="markdownIt-Anchor" href="#死锁的必要条件"></a> 死锁的必要条件</h2><ol><li>互斥</li><li>占有且等待</li><li>不可抢占</li><li>循环等待</li></ol><h2 id="已发生死锁后的处理方法"><a class="markdownIt-Anchor" href="#已发生死锁后的处理方法"></a> 已发生死锁后的处理方法</h2><p>主要有以下四种方法：</p><ul><li>鸵鸟策略</li><li>死锁检测与死锁恢复</li><li>死锁预防</li><li>死锁避免</li></ul><h3 id="鸵鸟策略"><a class="markdownIt-Anchor" href="#鸵鸟策略"></a> 鸵鸟策略</h3><p>把头埋在沙子里，假装根本没发生问题。</p><p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p><p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p><p>大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p><h3 id="死锁检测与死锁恢复"><a class="markdownIt-Anchor" href="#死锁检测与死锁恢复"></a> 死锁检测与死锁恢复</h3><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p><p><strong>死锁检测：</strong></p><p>每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。</p><p><strong>死锁恢复：</strong></p><ul><li>利用抢占恢复</li><li>利用回滚恢复</li><li>通过杀死进程恢复</li></ul><h2 id="死锁预防"><a class="markdownIt-Anchor" href="#死锁预防"></a> 死锁预防</h2><p>我们只要<strong>破坏产生死锁的四个条件中的其中一个就可以了</strong>。</p><ol><li><p><strong>破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p></li><li><p><strong>破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p></li><li><p><strong>破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p></li><li><p><strong>破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p></li></ol><h2 id="死锁避免"><a class="markdownIt-Anchor" href="#死锁避免"></a> 死锁避免</h2><h3 id="安全状态"><a class="markdownIt-Anchor" href="#安全状态"></a> 安全状态</h3><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ed523051-608f-4c3f-b343-383e2d194470.png" alt="img" /></p><p>图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p><p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p><p>安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。</p><h3 id="单个资源的银行家算法"><a class="markdownIt-Anchor" href="#单个资源的银行家算法"></a> 单个资源的银行家算法</h3><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png" alt="img" /></p><p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p><h3 id="多个资源的银行家算法"><a class="markdownIt-Anchor" href="#多个资源的银行家算法"></a> 多个资源的银行家算法</h3><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png" alt="img" /></p><p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p><p><strong>检查一个状态是否安全的算法如下：</strong></p><ul><li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li><li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li><li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li></ul><p>如果一个状态不是安全的，需要拒绝进入这个状态。</p><h1 id="虚拟内存"><a class="markdownIt-Anchor" href="#虚拟内存"></a> 虚拟内存</h1><blockquote><p>参考视频：</p><ul><li><a href="https://www.bilibili.com/video/BV18v411a7Vk">【操作系统】内存管理——虚拟内存 _ 哔哩哔哩_bilibili</a></li></ul></blockquote><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/7b281b1e-0595-402b-ae35-8c91084c33c1.png" alt="img" /></p><h1 id="分页系统地址映射"><a class="markdownIt-Anchor" href="#分页系统地址映射"></a> 分页系统地址映射</h1><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p><p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p><p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/cf4386a1-58c9-4eca-a17f-e12b1e9770eb.png" alt="img" style="zoom:67%;" /><h1 id="页面置换算法"><a class="markdownIt-Anchor" href="#页面置换算法"></a> 页面置换算法</h1><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h2 id="最佳"><a class="markdownIt-Anchor" href="#最佳"></a> 最佳</h2><blockquote><p>OPT, Optimal replacement algorithm</p></blockquote><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p><p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p><h2 id="最近最久未使用"><a class="markdownIt-Anchor" href="#最近最久未使用"></a> 最近最久未使用</h2><blockquote><p>LRU, Least Recently Used</p></blockquote><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p><p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p><h2 id="先进先出"><a class="markdownIt-Anchor" href="#先进先出"></a> 先进先出</h2><blockquote><p>FIFO, First In First Out</p></blockquote><p>选择换出的页面是最先进入的页面。</p><p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p><h2 id="第二次机会算法"><a class="markdownIt-Anchor" href="#第二次机会算法"></a> 第二次机会算法</h2><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ecf8ad5d-5403-48b9-b6e7-f2e20ffe8fca.png" alt="img" /></p><h2 id="时钟"><a class="markdownIt-Anchor" href="#时钟"></a> 时钟</h2><blockquote><p>Clock</p></blockquote><p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/5f5ef0b6-98ea-497c-a007-f6c55288eab1.png" alt="img" /></p><h2 id="最近未使用"><a class="markdownIt-Anchor" href="#最近未使用"></a> 最近未使用</h2><blockquote><p>NRU, Not Recently Used</p></blockquote><p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p><ul><li>R=0，M=0</li><li>R=0，M=1</li><li>R=1，M=0</li><li>R=1，M=1</li></ul><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p><p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p><h1 id="分段"><a class="markdownIt-Anchor" href="#分段"></a> 分段</h1><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p><p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/22de0538-7c6e-4365-bd3b-8ce3c5900216.png" alt="img" /></p><p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><h1 id="段页式"><a class="markdownIt-Anchor" href="#段页式"></a> 段页式</h1><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><h1 id="分页与分段的比较"><a class="markdownIt-Anchor" href="#分页与分段的比较"></a> 分页与分段的比较</h1><ul><li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li><li>地址空间的维度：分页是一维地址空间，分段是二维的。</li><li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li><li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul>]]></content>
    
    
    <summary type="html">整理了面试中常见的部分计算机操作系统的知识点。</summary>
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="操作系统" scheme="https://luoyu-ying.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="操作系统" scheme="https://luoyu-ying.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 一篇文章添加多个分类</title>
    <link href="https://luoyu-ying.github.io/posts/08fcea026748/"/>
    <id>https://luoyu-ying.github.io/posts/08fcea026748/</id>
    <published>2022-05-29T14:13:34.000Z</published>
    <updated>2022-05-29T14:13:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类和标签"><a class="markdownIt-Anchor" href="#分类和标签"></a> 分类和标签</h1><p>Hexo 博客中只有文章支持分类和标签，您可以在 Front-matter 中设置。</p><p>在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="string">Diary</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PS3</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Games</span></span><br></pre></td></tr></table></figure><h1 id="分类方法的分歧"><a class="markdownIt-Anchor" href="#分类方法的分歧"></a> 分类方法的分歧</h1><p>如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Diary</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Life</span></span><br></pre></td></tr></table></figure><p>会使分类 Life 成为 Diary 的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p><p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> [<span class="string">Diary</span>, <span class="string">PlayStation</span>]</span><br><span class="line">  <span class="bullet">-</span> [<span class="string">Diary</span>, <span class="string">Games</span>]</span><br><span class="line">  <span class="bullet">-</span> [<span class="string">Life</span>]</span><br></pre></td></tr></table></figure><p>此时这篇文章同时包括三个分类： PlayStation 和 Games 分别都是父分类 Diary 的子分类，同时 Life 是一个没有子分类的分类。</p><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><a href="https://hexo.io/zh-cn/docs/front-matter.html">Front-matter | Hexo</a></li></ul>]]></content>
    
    
    <summary type="html">记录了如何使得 Hexo 的一篇文章可以添加多个分类。</summary>
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo Front-matter 格式记录</title>
    <link href="https://luoyu-ying.github.io/posts/a6d8264a3704/"/>
    <id>https://luoyu-ying.github.io/posts/a6d8264a3704/</id>
    <published>2022-05-29T13:53:32.000Z</published>
    <updated>2022-05-29T13:53:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-front-matter"><a class="markdownIt-Anchor" href="#什么是-front-matter"></a> 什么是 Front-matter</h1><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2013/7/13 20:46:25</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="部分参数"><a class="markdownIt-Anchor" href="#部分参数"></a> 部分参数</h1><blockquote><p>以下参数不一定全部使用与所有主题的博客，请自行尝试。</p></blockquote><h2 id="page-front-matter"><a class="markdownIt-Anchor" href="#page-front-matter"></a> Page Front-matter</h2><table><thead><tr><th style="text-align:center">Type</th><th style="text-align:center">Explanation</th><th style="text-align:center">Example</th></tr></thead><tbody><tr><td style="text-align:center">title</td><td style="text-align:center">标题</td><td style="text-align:center">title: hello, world</td></tr><tr><td style="text-align:center">date</td><td style="text-align:center">创建日期，默认系统时间</td><td style="text-align:center">date: 2020-7-19</td></tr><tr><td style="text-align:center">updated</td><td style="text-align:center">更新日期，默认再次创建日期</td><td style="text-align:center">update: 2020-7-20</td></tr><tr><td style="text-align:center">type</td><td style="text-align:center">页面类型，tags、link、categories 这三个页面需要配置</td><td style="text-align:center">type: tags</td></tr><tr><td style="text-align:center">comments</td><td style="text-align:center">是否显示评论，默认 true</td><td style="text-align:center">comments: false</td></tr><tr><td style="text-align:center">description</td><td style="text-align:center">描述，没使用过，暂时不太清楚效果</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">top_img</td><td style="text-align:center">顶部图，默认为系统default配置的图</td><td style="text-align:center">top_img: 图片URL或者博客相对路径</td></tr><tr><td style="text-align:center">mathjax</td><td style="text-align:center">数学公式是否显示，默认为 false ，不显示</td><td style="text-align:center">mathjax: true</td></tr><tr><td style="text-align:center">katex</td><td style="text-align:center">数学公式是否显示，默认为 false ，不显示</td><td style="text-align:center">mathjax: true</td></tr><tr><td style="text-align:center">aside</td><td style="text-align:center">true 表示显示右边信息卡片，默认值；false 表示不显示</td><td style="text-align:center">aside: true</td></tr><tr><td style="text-align:center">aplayer</td><td style="text-align:center">在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">highlight_shrink</td><td style="text-align:center">配置代码框是否展开，默认为设置中 highlight_shrink 的配置</td><td style="text-align:center">–</td></tr></tbody></table><h2 id="post-front-matter"><a class="markdownIt-Anchor" href="#post-front-matter"></a> Post Front-matter</h2><table><thead><tr><th style="text-align:center">Type</th><th style="text-align:center">Explanation</th><th style="text-align:center">Example</th></tr></thead><tbody><tr><td style="text-align:center">title</td><td style="text-align:center">标题</td><td style="text-align:center">title: Hello,World！</td></tr><tr><td style="text-align:center">date</td><td style="text-align:center">创建日期，默认系统时间</td><td style="text-align:center">date: 2020-7-19</td></tr><tr><td style="text-align:center">updated</td><td style="text-align:center">更新日期，默认再次创建日期</td><td style="text-align:center">update: 2020-7-20</td></tr><tr><td style="text-align:center">tags</td><td style="text-align:center">标签，用 - 列出标签，一个 - 表示一个标签，注意换行以及 - 后面有个空格</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">categories</td><td style="text-align:center">分类，同样用 - 区别多个分类，注意换行以及 - 后面有个空格</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">keywords</td><td style="text-align:center">关键字</td><td style="text-align:center">keywords: ‘a, b’</td></tr><tr><td style="text-align:center">description</td><td style="text-align:center">描述，没使用过，暂时不太清楚效果</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">top_img</td><td style="text-align:center">顶部图，可选项，不写则按缩略图的图片显示</td><td style="text-align:center">top_img: 图片URL或者博客中图片的相对路径</td></tr><tr><td style="text-align:center">comments</td><td style="text-align:center">是否显示评论，默认 true。</td><td style="text-align:center">comments: false</td></tr><tr><td style="text-align:center">cover</td><td style="text-align:center">缩略图</td><td style="text-align:center">cover: 图片URL或者博客中图片的相对路径</td></tr><tr><td style="text-align:center">toc</td><td style="text-align:center">是否显示 toc ，默认 true 显示</td><td style="text-align:center">toc: false</td></tr><tr><td style="text-align:center">toc_number</td><td style="text-align:center">是否显示 toc 数字，默认 true 显示</td><td style="text-align:center">toc_number: false</td></tr><tr><td style="text-align:center">auto_open</td><td style="text-align:center">是否自动打开 TOC (默认为设置中 toc 的 auto_open 配置)</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">copyright</td><td style="text-align:center">是否显示版权，默认 true 显示</td><td style="text-align:center">copyright: false</td></tr><tr><td style="text-align:center">mathjax</td><td style="text-align:center">数学公式是否显示，默认为 false ，不显示</td><td style="text-align:center">mathjax: true</td></tr><tr><td style="text-align:center">katex</td><td style="text-align:center">数学公式是否显示，默认为 false ，不显示</td><td style="text-align:center">mathjax: true</td></tr><tr><td style="text-align:center">hidden或hide</td><td style="text-align:center">是否隐藏，需安装hide或者indexed插件，true表示隐藏</td><td style="text-align:center">hidden: true</td></tr><tr><td style="text-align:center">sticky</td><td style="text-align:center">文章置顶，数值越大越靠前，需安装indexed插件，默认值为0</td><td style="text-align:center">sticky: 10</td></tr><tr><td style="text-align:center">top</td><td style="text-align:center">文章置顶，需安装index-pin-top 插件，默认值为false，同时为置顶则按时间先后顺序</td><td style="text-align:center">top: true</td></tr><tr><td style="text-align:center">aplayer</td><td style="text-align:center">在需要的页面加载 aplayer 的 js 和 css, 请参考文章下面的音乐 配置</td><td style="text-align:center">–</td></tr><tr><td style="text-align:center">highlight_shrink</td><td style="text-align:center">配置代码框是否展开，默认为设置中 highlight_shrink 的配置</td><td style="text-align:center">–</td></tr></tbody></table><h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1><ul><li><p><a href="https://hexo.io/zh-cn/docs/front-matter.html">Front-matter | Hexo</a></p></li><li><p><a href="https://caczhtus.github.io/posts/64237/">【Hexo】关于 Hexo-ButterFly 主题的使用记录 | Caczhtus</a></p></li><li><p><a href="https://blog.csdn.net/qq_42549254/article/details/102721177">hexo学习——文章 Front-matter_WMXNLFD的博客-CSDN博客</a></p></li></ul>]]></content>
    
    
    <summary type="html">记录了 Hexo 博客的 Front-matter 格式，以及其中的部分参数。</summary>
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>多线程-Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/6797cb29bf4c/"/>
    <id>https://luoyu-ying.github.io/posts/6797cb29bf4c/</id>
    <published>2022-05-29T01:44:28.000Z</published>
    <updated>2022-05-29T01:44:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> TODO</h1><ol><li>synchronized和Lock的使用、区别,原理；</li><li>锁的分类，锁的几种状态，CAS原理</li><li>为什么会有线程安全？如何保证线程安全</li><li>锁池,等待池</li><li>Java多线程通信</li><li>为什么Java用线程池</li><li>Java中的线程池参数,共有几种</li><li>其他你知道的并发容器</li></ol><h1 id="java中创建线程的方式"><a class="markdownIt-Anchor" href="#java中创建线程的方式"></a> <code>Java</code>中创建线程的方式</h1><blockquote><p><code>Future</code>, <code>FutureTask</code>的实现方式暂未学习，待补充。</p></blockquote><ol><li>写一个类继承自<code>Thread</code>类，重写<code>run</code>方法。用<code>start</code>方法启动线程。</li><li>写一个类实现<code>Runnable</code>接口，实现<code>run</code>方法。用<code>new Thread(Runnable target).start</code>方法来启动。</li></ol><h1 id="线程的几种状态"><a class="markdownIt-Anchor" href="#线程的几种状态"></a> 线程的几种状态</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/pange1991/article/details/53860651/">Java线程的6种状态及切换(透彻讲解)_潘建南的博客-CSDN博客_线程状态</a></li></ul></blockquote><p><code>Java</code>中的线程的状态总共有6种。</p><blockquote><ol><li><strong>初始(<code>NEW</code>)：</strong> 新创建了一个线程对象，但还没有调用start()方法。</li><li><strong>运行(<code>RUNNABLE</code>)：</strong> Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br />线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li><li><strong>阻塞(<code>BLOCKED</code>)：</strong> 表示线程阻塞于锁。</li><li><strong>等待(<code>WAITING</code>)：</strong> 进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li><strong>超时等待(<code>TIMED_WAITING</code>)：</strong> 该状态不同于<code>WAITING</code>，它可以在指定的时间后自行返回。</li><li><strong>终止(<code>TERMINATED</code>)：</strong> 表示该线程已经执行完毕。</li></ol></blockquote><p>这6种状态定义在<code>Thread</code>类的<code>State</code>枚举中，可查看源码进行一一对应。</p><p><strong><font size="4">线程状态图</font></strong></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20181120173640764.jpeg" alt="线程状态图" /></p><p><strong><font size="4">状态详细说明</font></strong></p><ol><li><p><strong>初始状态(<code>NEW</code>)</strong><br />实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</p></li><li><p><strong>运行状态(<code>RUNNABLE</code>)</strong></p><ol><li><strong>就绪状态(<code>RUNNABLE</code>之<code>READY</code>)</strong><ul><li>就绪状态只是说你有资格运行，调度程序没有挑选到你，你就永远是就绪状态。</li><li>调用线程的start()方法，此线程进入就绪状态。</li><li>当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。</li><li>当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。</li><li>锁池里的线程拿到对象锁后，进入就绪状态。</li></ul></li><li><strong>运行中状态(<code>RUNNABLE</code>之<code>RUNNING</code>)</strong><br />线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一的一种方式。</li></ol></li><li><p><strong>阻塞状态(<code>BLOCKED</code>)</strong><br />阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。</p></li><li><p><strong>等待(<code>WAITING</code>)</strong><br />处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</p></li><li><p><strong>超时等待(<code>TIMED_WAITING</code>)</strong><br />处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</p></li><li><p><strong>终止状态(<code>TERMINATED</code>)</strong><br />当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。<br />在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p></li></ol><h1 id="threadsleep与objectwait的区别"><a class="markdownIt-Anchor" href="#threadsleep与objectwait的区别"></a> <code>Thread#sleep</code>与<code>Object#wait</code>的区别</h1><p><strong><font size="4"><code>Thread#sleep</code></font></strong></p><p><code>Thread.sleep(long millis)</code>，一定是当前线程调用此方法，当前线程进入<code>TIMED_WAITING</code>状态，但<strong>不释放对象锁</strong>，<code>millis</code>后线程自动苏醒进入就绪状态。</p><p>作用：给其它线程执行机会的最佳方式。</p><p><strong><font size="4"><code>Object#wait</code></font></strong></p><p>当前线程调用对象的<code>wait</code>方法，当前线程<strong>释放对象锁</strong>，进入等待队列。</p><p>依靠<code>notify/notifyAll</code>唤醒或者<code>wait(long timeout)</code>， <code>timeout</code>时间到自动唤醒。</p><p><strong><font size="4">总结</font></strong></p><p>可以发现，两者的区别为当前的线程是否会释放对象锁。</p><h1 id="objectnotify和objectnotifyall的区别"><a class="markdownIt-Anchor" href="#objectnotify和objectnotifyall的区别"></a> <code>Object#notify</code>和<code>Object#notifyAll</code>的区别</h1><p><code>Object#notify</code>唤醒在此对象监视器上等待的<strong>单个线程</strong>，<strong>选择是任意性的</strong>。</p><p><code>Object#notifyAll</code>唤醒在此对象监视器上等待的<strong>所有线程</strong>。</p><h1 id="threadrun和threadstart的区别"><a class="markdownIt-Anchor" href="#threadrun和threadstart的区别"></a> <code>Thread#run</code>和<code>Thread#start</code>的区别</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/renhui/p/6066750.html">Java Thread 的 run() 与 start() 的区别 - 灰色飘零 - 博客园 (cnblogs.com)</a></li></ul></blockquote><ol><li><p>调用<code>start</code>方法方可启动线程，而<code>run</code>方法只是<code>Thread</code>的一个普通方法调用，还是在主线程里执行。</p></li><li><p>把需要并行处理的代码放在<code>run</code>方法中，<code>start</code>方法启动线程将自动调用 <code>run</code>方法，这是由<code>JVM</code>的内存机制规定的。并且<code>run</code>方法必须是<code>public</code>访问权限，返回值类型为<code>void</code>。</p></li></ol><h1 id="线程死锁如何有效的避免线程死锁"><a class="markdownIt-Anchor" href="#线程死锁如何有效的避免线程死锁"></a> 线程死锁，如何有效的避免线程死锁？</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://developer.aliyun.com/article/763004">什么是线程死锁？形成条件是什么？如何避免？-阿里云开发者社区 (aliyun.com)</a></li></ul></blockquote><h2 id="什么是线程死锁"><a class="markdownIt-Anchor" href="#什么是线程死锁"></a> 什么是线程死锁</h2><p>死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。</p><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/cff16df19c2ffe9621333dd219990df69664a007.png" alt="image" /></p><p>如上图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><h2 id="形成死锁的四个必要条件"><a class="markdownIt-Anchor" href="#形成死锁的四个必要条件"></a> 形成死锁的四个必要条件</h2><ol><li><strong>互斥条件：</strong> 线程(进程)对于所分配到的资源具有排它性，即一个资源只能被一个线程(进程)占用，直到被该线程(进程)释放。</li><li><strong>请求与保持条件：</strong> 一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</li><li><strong>不可剥夺条件：</strong> 线程(进程)已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li><strong>循环等待条件：</strong> 当发生死锁时，所等待的线程(进程)必定会形成一个环路（类似于死循环），造成永久阻塞。</li></ol><h2 id="如何避免线程死锁"><a class="markdownIt-Anchor" href="#如何避免线程死锁"></a> 如何避免线程死锁</h2><p>我们只要<strong>破坏产生死锁的四个条件中的其中一个就可以了</strong>。</p><ol><li><p><strong>破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p></li><li><p><strong>破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p></li><li><p><strong>破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p></li><li><p><strong>破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p></li></ol><h1 id="如何实现多线程中的同步"><a class="markdownIt-Anchor" href="#如何实现多线程中的同步"></a> 如何实现多线程中的同步</h1><blockquote><p><strong>同步(synchronization)<strong>就是</strong>指一个线程访问数据时，其它线程不得对同一个数据进行访问，即同一时刻只能有一个线程访问该数据，当这一线程访问结束时其它线程才能对这它进行访问</strong> 。同步最常见的方式就是使用锁(Lock)，也称为<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E9%94%81&amp;spm=1001.2101.3001.7020">线程锁</a>。锁是一种非强制机制，每一个线程在访问数据或资源之前，首先试图获取(Acquire)锁，并在访问结束之后释放(Release)锁。 <strong>在锁被占用时试图获取锁，线程会进入等待状态，直到锁被释放再次变为可用。</strong></p></blockquote><h2 id="synchronized"><a class="markdownIt-Anchor" href="#synchronized"></a> synchronized</h2><h2 id="lock"><a class="markdownIt-Anchor" href="#lock"></a> Lock</h2><h1 id="volatile"><a class="markdownIt-Anchor" href="#volatile"></a> <code>volatile</code></h1><blockquote><p>答案参考自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/138819184">volatile 关键字，你真的理解吗？ - 知乎 (zhihu.com)</a></li></ul></blockquote><h2 id="volatile-的作用"><a class="markdownIt-Anchor" href="#volatile-的作用"></a> volatile 的作用</h2><ul><li>保证了变量的内存可见性。</li><li>禁止指令的重排序。</li></ul><h2 id="java-内存模型jmm"><a class="markdownIt-Anchor" href="#java-内存模型jmm"></a> Java 内存模型（JMM）</h2><p>JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。</p><p><strong><font size="4">JMM 的规定：</font></strong></p><ul><li><p>所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p></li><li><p>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p></li><li><p>线程对变量的所有的操作（读，取）都必须在工作内存中完成，而不能直接读写主内存中的变量。</p></li><li><p>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</p></li></ul><p><strong><font size="4">JMM 的抽象示意图：</font></strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-3d312429710bd6a11eca171858f67751_720w.jpg" alt="img" style="zoom:80%;" /><h2 id="内存可见性"><a class="markdownIt-Anchor" href="#内存可见性"></a> 内存可见性</h2><p>内存可见性是指当一个线程修改了某个变量的值，其它线程总是能知道这个变量变化。</p><p>也就是说，如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。</p><h2 id="内存可见行的解决方案"><a class="markdownIt-Anchor" href="#内存可见行的解决方案"></a> 内存可见行的解决方案</h2><p>使用 <code>volatile</code> 关键字，或者加锁。</p><p><strong><font size="4">加锁</font></strong></p><blockquote><p><strong>为什么加锁后就保证了变量的内存可见性了？</strong></p></blockquote><p>因为当一个线程进入 <code>synchronized</code> 代码块后，线程获取到锁，会清空本地内存，然后从主内存中拷贝共享变量的最新值到本地内存作为副本，执行代码，又将修改后的副本值刷新到主内存中，最后线程释放锁。</p><p>这里除了 <code>synchronized</code> 外，其它锁也能保证变量的内存可见性。</p><p><strong><font size="4">使用 volatile 关键字</font></strong></p><p>使用 <code>volatile</code> 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，当线程操作变量副本并写回主内存后，会通过 <strong><code>CPU</code> 总线嗅探机制</strong>告知其他线程该变量副本已经失效，需要重新从主内存中读取。</p><p><code>volatile</code> 保证了不同线程对共享变量操作的可见性，也就是说一个线程修改了 <code>volatile</code> 修饰的变量，当修改后的变量写回主内存时，其他线程能立即看到最新值。</p><p><strong><font size="4">总结</font></strong></p><p>使用 <code>volatile</code> 和 <code>synchronized</code> 锁都可以保证共享变量的可见性。相比 <code>synchronized</code> 而言，<code>volatile</code> 可以看作是一个轻量级锁，所以使用 <code>volatile</code> 的成本更低，因为它不会引起线程上下文的切换和调度。</p><p>但 <code>volatile</code> 无法像 <code>synchronized</code> 一样保证操作的原子性。</p><h2 id="volatile-的原子性问题"><a class="markdownIt-Anchor" href="#volatile-的原子性问题"></a> <code>volatile</code> 的原子性问题</h2><blockquote><p>原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。</p></blockquote><p>在多线程环境下，<code>volatile</code> 关键字可以保证共享数据的可见性，但是并不能保证对数据操作的原子性。也就是说，多线程环境下，使用 <code>volatile</code> 修饰的变量是<strong>线程不安全的</strong>。</p><p>要解决这个问题，我们可以使用锁机制，或者使用原子类（如 <code>AtomicInteger</code>）。</p><p>这里特别说一下，对任意单个使用 <code>volatile</code> 修饰的变量的读 / 写是具有原子性，但类似于 <code>flag = !flag</code> 这种复合操作不具有原子性。简单地说就是，<strong>单纯的赋值操作是原子性的</strong>。</p><h2 id="重排序"><a class="markdownIt-Anchor" href="#重排序"></a> 重排序</h2><p>为了提高性能，在遵守 <code>as-if-serial</code> 语义（即不管怎么重排序，单线程下程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守。）的情况下，编译器和处理器常常会对指令做重排序。</p><p>一般重排序可以分为如下三种类型：</p><ul><li>编译器优化重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul> <img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-8655d85c8a9df1bc2262485248b07d4d_720w.jpg" alt="img" style="zoom: 80%;" /><h1 id="synchronized和volatile的区别"><a class="markdownIt-Anchor" href="#synchronized和volatile的区别"></a> synchronized和volatile的区别？</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/suifeng3051/article/details/52611233">volatile和synchronized的区别_Heaven-Wang的博客-CSDN博客_synchronized和volatile区别</a></li></ul></blockquote><ol><li><p>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定。</p></li><li><p>当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p></li><li><p>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的</p></li><li><p>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性</p></li><li><p>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</p></li><li><p>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</p></li></ol><h1 id="为何不用volatile替代synchronized"><a class="markdownIt-Anchor" href="#为何不用volatile替代synchronized"></a> 为何不用volatile替代synchronized？</h1><p>因为 volatile 不能保证原子性，当有多个线程修改同一个变量时，例如++操作，无法保证线程同步。</p><h1 id="synchronized和lock的使用"><a class="markdownIt-Anchor" href="#synchronized和lock的使用"></a> synchronized和Lock的使用</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;todo&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#todo&quot;&gt;&lt;/a&gt; TODO&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;synchronized和Lock的使用、区别,原理；&lt;/li&gt;
&lt;li&gt;锁的分类，锁的几种状态，CAS原理&lt;/li&gt;
</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="Java" scheme="https://luoyu-ying.github.io/categories/Java/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="多线程" scheme="https://luoyu-ying.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/d479c1bb49e9/"/>
    <id>https://luoyu-ying.github.io/posts/d479c1bb49e9/</id>
    <published>2022-05-27T12:18:37.000Z</published>
    <updated>2022-05-27T12:18:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jvm-的体系结构"><a class="markdownIt-Anchor" href="#jvm-的体系结构"></a> <code>JVM</code> 的体系结构</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/102702428">十分钟带你了解JVM的结构体系 - 知乎 (zhihu.com)</a></li></ul></blockquote><p><code>JVM</code>的组成：</p><ul><li>类加载子系统 Class loader</li><li>运行时数据区</li><li>执行引擎</li></ul><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-f3141f2dd349b87c98543fbc9fc00495_720w.jpg" alt="img" /></p><h1 id="类加载器"><a class="markdownIt-Anchor" href="#类加载器"></a> 类加载器</h1><ul><li>负责加载 <code>class</code>文件(<code>class</code>文件在文件开头有特定的文件标识)，将 <code>class</code>文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构。</li><li><code>ClassLoader</code>只负责加载 <code>class</code>文件的加载，至于它是否可以运行，则由<code>Execution Engine</code>决定。</li></ul><p>在 Java 9 以前，一共有三种类加载器：</p><ul><li>启动类加载器（<strong><code>BootStrap ClassLoader</code></strong>）</li><li>扩展类加载器（<strong><code>Extension ClassLoader</code></strong>）</li><li>应用类加载器（<strong><code>Application ClassLoader</code></strong>）</li></ul><p>在 Java 9 之后，经过更改后变成了两种：</p><ul><li>启动类加载器</li><li>平台类加载器</li></ul><p>启动类加载器是所有类加载器的祖先，由 C++ 编程，没有对应的 Java 对象，因此在 Java 中用 <code>null</code> 来指代。</p><p>除了启动类加载器，其他的加载器都有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。</p><h1 id="双亲委派机制及其优势"><a class="markdownIt-Anchor" href="#双亲委派机制及其优势"></a> 双亲委派机制及其优势</h1><ul><li><p><strong>全盘负责：</strong></p><p>当前线程的类加载器负责加载某个<code>Class</code>时，该<code>Class</code>所依赖的和引用的其他<code>Class</code>也将由该类加载器负责载入，除非显示使用<code>CLassLoader.loadClass()</code>指定类加载器来载入。</p></li><li><p><strong>父类委托：</strong></p><p>先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。所以我们在开发中尽量不要使用与JDK相同的类（例如自定义一个<code>java.lang.System</code>类），因为父类加载器中已经有一份<code>java.lang.System</code>类了，它会直接将该类给程序使用，而你自定义的类压根就不会被加载。</p></li><li><p><strong>双亲委派模型：</strong></p><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中。</p><p>只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p></li><li><p><strong>双亲委派模型的工作流程：</strong></p><ol><li><p>当<code>AppClassLoader</code>加载一个<code>class</code>时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</p></li><li><p>当<code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrap ClassLoader</code>去完成。</p></li><li><p>如果<code>BootStrap ClassLoader</code>加载失败（例如在<code>$JAVA_HOME/jre/lib</code>里未查找到该<code>class</code>），会使用<code>ExtClassLoader</code>来尝试加载。</p></li><li><p>若<code>ExtClassLoader</code>也加载失败，则会使用<code>AppClassLoader</code>来加载，如果<code>AppClassLoader</code>也加载失败，则会报出异常<code>ClassNotFoundException</code>。</p></li></ol></li><li><p><strong>双亲委派模型的优势：</strong></p><ol><li>系统类防止内存中出现多份同样的字节码</li><li>保证<code>Java</code>程序安全稳定运行</li></ol></li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/408997874.png" alt="img" style="zoom:67%;" /><h1 id="内存模型"><a class="markdownIt-Anchor" href="#内存模型"></a> 内存模型</h1><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-205a2605346856d95aec826ed9263c03_720w.jpg" alt="img" /></p><h2 id="线程私有内存"><a class="markdownIt-Anchor" href="#线程私有内存"></a> 线程私有内存</h2><p><strong><font size="5">程序计数器(Program Counter Register)</font></strong></p><p>程序计数器可以看作是<strong>当前线程所执行的字节码的行号指示器</strong>。</p><p>字节码解释器工作是就是通过改变程序计数器的值来选取下一条需要执行的字节码指令（执行本地方法的时候，程序计数器的值为 <code>null</code>）。</p><p><strong>每条线程都需要有一个独立的程序计数器</strong>，各条的程序计数器互不影响，独立存储。</p><p>此内存区域是唯一一个没有规定任何 <code>OutOfMemoryError</code> 情况的区域。</p><p><strong><font size="5">Java 虚拟机栈(VM Stack)</font></strong></p><p>Java 虚拟机栈为虚拟机执行 Java 方法服务。</p><p><strong>Java 虚拟机栈的生命周期和线程相同。</strong></p><p>虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会在虚拟机栈中同步创建一个 <strong>栈帧</strong> 用于存储局部变量表、操作数栈、方法出口等信息。</p><p>每一个方法被调用直至执行完毕的过程，就对应这一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graphsubgraph 栈帧    局部变量表    操作数栈    动态链接    方法出口    ...end  </pre></div><p><strong><font size="5">本地方法栈(Native Method Stack)</font></strong></p><p>本地方法栈为虚拟机使用本地<code>Native</code>方法服务。</p><h2 id="线程共享内存"><a class="markdownIt-Anchor" href="#线程共享内存"></a> 线程共享内存</h2><p><strong><font size="5">Java 堆(Java Heap)</font></strong></p><p>Java 堆是虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p><p><strong>此内存区域的唯一目的就是存放对象实例</strong>，Java 世界里“几乎”所有的对象实例都在这里分配内存。</p><p>Java 堆是垃圾收集器管理的内存区域，因此一些资料中它也被称作“GC堆”。</p><p>Java 堆可以处于物理上不连续的内存空间中，但在逻辑上都连续存放。</p><p>从分配内存的角度看，所有线程共享的 Java 堆中可以划分出多个线程私有的分配缓冲区，以提升对象分配时的效率。无论如何划分，无论是那个区域，存储的都只能是对象的实例。</p><p><strong>Java 堆既可以实现成固定大小的，也可以是扩展的。</strong> 如果在 Java 堆中没有内存完成对象分配时，并且堆也无法再扩展时，Java 虚拟机将会抛出 <code>OutOfMemoryError</code> 异常。</p><p><strong><font size="5">方法区(Method Area)</font></strong></p><p>方法区与 Java 堆一样，是各个线程共享的内存区域，<strong>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</strong></p><p>如果方法区无法满足新的内存分配需求时，将抛出 <code>OutOfMemoryError</code> 异常。</p><p>在 JDK 1.8 之前，<code>HotSpot</code> 虚拟机把它当作永久代进行垃圾回收。</p><p>在 JDK 1.8 以后，移除永久代，并将永久代拆分至堆和元空间。元空间位于本地内存中，而不是虚拟机内存中，存储类的元数据；堆中则额外存放方法区的静态变量和常量池等。</p><p><strong><font size="4">运行时常量池(Runtime Constant Pool)</font></strong></p><p>运行时常量池是方法区的一部分。</p><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译器生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</p><p>除了 <strong>保存 Class 文件中描述的符号引用</strong> 外，还会把符号引用翻译出来的直接引用也存储再运行时常量池中。</p><p>运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 异常。</p><h1 id="类加载机制的几个阶段"><a class="markdownIt-Anchor" href="#类加载机制的几个阶段"></a> 类加载机制的几个阶段</h1><blockquote><p>Java 语言的类型可以分为两个大类：基本类型和引用类型。</p><p>其中的引用类型，Java 又将其细分为了四种：类、接口、数组类以及泛型参数。</p><p>其中，泛型参数会在编译过程中被擦除，数组类则是由 Java 虚拟机直接在内存中动态构造出来的。所以我们只讨论类和接口的加载过程。</p></blockquote><p><strong>类的加载过程：</strong></p><p><code>JVM</code> 将 <code>javac</code> 编译好的<code>class</code>字节码文件加载到内存中，并对该数据进行验证、解析和初始化、形成<code>JVM</code>可以直接使用的<code>JAVA</code>类，最终回收(卸载)的过程。</p><p><strong>字节码（<code>.class</code>）文件来源：</strong></p><ul><li>从本地系统中直接加载</li><li>通过网络下载<code>.class</code>文件</li><li>从<code>zip</code>, <code>jar</code>等归档文件中加载<code>.class</code>文件</li><li>从专有数据库中提取<code>.class</code>文件</li><li>将<code>Java</code>源文件动态编译为<code>.class</code>文件</li></ul><hr /><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/879896-20160414224549770-60006655.png" alt="img" style="zoom:70%;" /><p><strong><font size="5">加载</font></strong></p><p>加载阶段是类加载的第一个部分，在此阶段需要完成三件事情：</p><ol><li>通过类的完全限定名找到该类对应的二进制字节流。</li><li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li><li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li></ol><p>对于非数组类的其他类而言，Java 虚拟机需要通过类加载器来完成查找字节流的过程。</p><p><strong><font size="5">验证</font></strong></p><p>验证阶段是连接阶段的第一步，目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p><strong><font size="5">准备</font></strong></p><p>准备阶段是正式为<strong>类变量(类字段)</strong>（即静态变量，被 <code>static</code> 修饰的变量）分配内存并设置类变量初始值的阶段。</p><p>这些变量所使用的内存都将在方法区中分配，只包括类变量。</p><p>初始值“通常情况”下是数据类型的零值。</p><p>“特殊情况”下，如果类字段的字段属性表中存在 <code>ConstantValue</code> 属性（即被 <code>final</code> 修饰的变量），那么在准备阶段变量的值就会被初始化为 <code>ConstantValue</code> 属性所指定的值。</p><p><strong><font size="5">解析</font></strong></p><p>虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>这个过程可以在初始化阶段之后进行。</p><p><strong><font size="5">初始化</font></strong></p><p>类加载过程中的最后一步。</p><p>初始化阶段是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。</p><p><code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。</p><p><code>&lt;clinit&gt;()</code> 与类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行之前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</p><p>如果一个类没有声明任何的类变量，也没有静态代码块，那么可以没有类<code>&lt;clinit&gt;</code>方法。</p><p><code>JVM</code> 必须确保一个类在初始化的过程中，如果是多线程需要同时初始化它，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程(所以<strong>可以利用静态内部类实现线程安全的单例模式</strong>)。</p><p><strong>简单地说，初始化就是对类变量进行赋值及执行静态代码块。</strong></p><p><strong><font size="5">使用</font></strong></p><p>程序使用 <code>JVM</code> 加载的类。</p><p><strong><font size="5">卸载</font></strong></p><p>触发卸载的五个时机：</p><ul><li>执行了 <code>System.exit()</code> 方法</li><li><code>JVM</code>垃圾回收机制触发回收</li><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统出现错误而导致Java虚拟机进程终止</li></ul><h1 id="何时触发初始化"><a class="markdownIt-Anchor" href="#何时触发初始化"></a> 何时触发初始化</h1><ol><li><p>遇到 <code>new</code>，<code>getstatic</code>，<code>putstatic</code> 或 <code>invokestatic</code> 这4条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。<br />生成这4条指令的最常见的Java代码场景是：</p><ol><li>使用new关键字实例化对象的时候</li><li>读取或设置一个类的静态字段的时候</li><li>调用一个类的静态方法的时候</li></ol></li><li><p>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用的时候。</p></li><li><p>当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先出发父类的初始化。</p></li><li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含 <code>main()</code> 方法的那个类），虚拟机会先初始化这个主类。</p></li></ol><h1 id="对象实例化时的顺序"><a class="markdownIt-Anchor" href="#对象实例化时的顺序"></a> 对象实例化时的顺序</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/sc179/article/details/109779168">Java实例化对象时的初始化顺序_hellosc01的博客-CSDN博客</a></li></ul></blockquote><blockquote><p>注：（A，B）表示A和B为同一阶段初始化，执行顺序取决于它们在代码中的顺序。</p></blockquote><p><strong><font size="5">无继承</font></strong></p><p>（静态变量，静态代码块）-&gt; （实例变量，普通代码块） -&gt; 构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">staticField</span> <span class="operator">=</span> <span class="string">&quot;静态变量&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态语句块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">String</span> <span class="variable">field</span> <span class="operator">=</span> <span class="string">&quot;实例变量&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;普通语句块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InitialOrderTest</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;构造函数&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font size="5">有继承</font></strong></p><ol><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ol><h1 id="垃圾回收机制"><a class="markdownIt-Anchor" href="#垃圾回收机制"></a> 垃圾回收机制</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://time.geekbang.org/column/article/13091">11 | 垃圾回收（上） (geekbang.org)</a></li><li><a href="http://www.cyc2018.xyz/Java">Java 虚拟机 | CS-Notes (cyc2018.xyz)</a></li></ul></blockquote><h2 id="判断对象是否存活"><a class="markdownIt-Anchor" href="#判断对象是否存活"></a> 判断对象是否存活</h2><p><strong><font size="5">引用计数法</font></strong></p><p>它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。</p><p>它的具体实现是这样子的：如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。也就是说，我们<strong>需要截获所有的引用更新操作</strong>，并且相应地增减目标对象的引用计数器。</p><p>除了<strong>需要额外的空间来存储计数器</strong>，以及<strong>繁琐的更新操作</strong>，引用计数法还有一个重大的漏洞，那便是<strong>无法处理循环引用对象</strong>。举个例子，假设对象 a 与 b 相互引用，除此之外没有其他引用指向 a 或者 b。在这种情况下，a 和 b 实际上已经死了，但由于它们的引用计数器皆不为 0，在引用计数法的心中，这两个对象还活着。因此，这些循环引用对象所占据的空间将不可回收，从而造成了内存泄露。</p><p><strong><font size="5">可达性分析</font></strong></p><p>Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），然后<strong>从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中</strong>，这个过程我们也称之为标记（mark）。最终，<strong>未被探索到的对象便是死亡的，是可以回收的。</strong></p><p><strong><font size="4">GC Roots</font></strong></p><p>可以暂时理解为由堆外指向堆内的引用，一般而言，GC Roots 包括（但不限于）如下几种：</p><ul><li>Java 方法栈桢中的局部变量；</li><li>已加载类的静态变量；</li><li>JNI handles；</li><li>已启动且未停止的 Java 线程。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/83d909d2-3858-4fe1-8ff4-16471db0b180.png" alt="img" style="zoom: 67%;" /><p>可达性分析可以解决引用计数法所不能解决的循环引用问题。</p><p>虽然可达性分析的算法本身很简明，但是在实践中还是有不少其他问题需要解决的。</p><p>比如说，在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成<strong>误报</strong>（将引用设置为 null）或者<strong>漏报</strong>（将引用设置为未被访问过的对象）。</p><p>误报并没有什么伤害，Java 虚拟机至多损失了部分垃圾回收的机会。漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 Java 虚拟机崩溃。</p><p>怎么解决这个问题呢？在 Java 虚拟机里，传统的垃圾回收算法采用的是一种简单粗暴的方式，那便是 <strong>Stop-the-world</strong>，停止其他非垃圾回收线程的工作，直到完成垃圾回收。这也就造成了<strong>垃圾回收所谓的暂停时间（GC pause）</strong>。</p><h2 id="方法区的回收"><a class="markdownIt-Anchor" href="#方法区的回收"></a> 方法区的回收</h2><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p><p>主要是对常量池的回收和对类的卸载。</p><p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p><p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p><ul><li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>Class</code> 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ul><h2 id="finalize方法"><a class="markdownIt-Anchor" href="#finalize方法"></a> <code>finalize</code>方法</h2><p>类似 C++ 的析构函数，<strong>用于关闭外部资源</strong>。但是 try-finally 等方式可以做得更好，并且该方法<strong>运行代价很高，不确定性大</strong>，无法保证各个对象的调用顺序，因此<strong>最好不要使用</strong>。</p><h2 id="引用类型"><a class="markdownIt-Anchor" href="#引用类型"></a> 引用类型</h2><p>判定对象是否可被回收都与引用有关。</p><ol><li><p>强引用</p><p>被强引用关联的对象不会被回收。</p><p>使用 <code>new</code> 一个新对象的方式来创建强引用。</p></li><li><p>软引用</p><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>使用 <code>SoftReference</code> 类来创建软引用。</p></li><li><p>弱引用</p><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>使用 <code>WeakReference</code> 类来创建弱引用。</p></li><li><p>虚引用</p><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p><p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p><p>使用 <code>PhantomReference</code> 来创建虚引用。</p></li></ol><h2 id="垃圾回收的三种方式"><a class="markdownIt-Anchor" href="#垃圾回收的三种方式"></a> 垃圾回收的三种方式</h2><ol><li><p>标记-清除</p><p>即把死亡对象所占据的内存标记为空闲内存，并记录在一个空闲列表（free list）之中。当需要新建对象时，内存管理模块便会从该空闲列表中寻找空闲内存，并划分给新建的对象。</p><p>缺点：</p><ul><li>会造成内存碎片。由于 Java 虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。</li><li>分配效率较低。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java 虚拟机则需要逐个访问列表中的项，来查找能够放入新建对象的空闲内存。</li></ul><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/005b481b-502b-4e3f-985d-d043c2b330aa.png" alt="img" style="zoom: 67%;" /></li><li><p>标记-整理（压缩）</p><p>即把存活的对象聚集到内存区域的起始位置，从而留下一段连续的内存空间。这种做法能够解决内存碎片化的问题，但<strong>代价是压缩算法的性能开销</strong>。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/ccd773a5-ad38-4022-895c-7ac318f31437.png" alt="img" style="zoom:67%;" /></li><li><p>标记-复制</p><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p><p><strong>主要不足是只使用了内存的一半。</strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/b2b77b9e-958c-4016-8ae5-9c6edd83871e.png" alt="img" style="zoom:67%;" /><blockquote><p>现在的商业虚拟机都<strong>采用</strong>这种<strong>复制收集算法回收新生代</strong>，但是并不是划分为大小相等的两块，而是一块较大的 <code>Eden</code> 空间和两块较小的 <code>Survivor</code> 空间，每次使用 <code>Eden</code> 和其中一块 <code>Survivor</code>。在回收时，将 <code>Eden</code> 和 <code>Survivor</code> 中还存活着的对象全部复制到另一块 <code>Survivor</code> 上，最后清理 <code>Eden</code> 和使用过的那一块 <code>Survivor</code>。</p><p><code>HotSpot</code> 虚拟机的 <code>Eden</code> 和 <code>Survivor</code> 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 <code>Survivor</code> 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p></blockquote></li><li><p><strong>分代收集</strong></p><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p><p>一般将堆分为新生代和老年代。</p><ul><li>新生代使用：<strong>复制算法</strong></li><li>老年代使用：<strong>标记-清除</strong> 或者 <strong>标记-整理</strong> 算法</li></ul></li></ol><h2 id="垃圾收集器"><a class="markdownIt-Anchor" href="#垃圾收集器"></a> 垃圾收集器</h2><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/c625baa0-dde6-449e-93df-c3a67f2f430f.jpg" alt="img"  /><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。‘</p><p><strong><font size="4">基本概念</font></strong></p><ul><li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li><li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul><p>针对新生代的垃圾回收器共有三个：Serial，Parallel Scavenge 和 Parallel New。这三个采用的都是<strong>标记 - 复制</strong>算法。其中，Serial 是一个单线程的，Parallel New 可以看成 Serial 的多线程版本。Parallel Scavenge 和 Parallel New 类似，但更加注重吞吐率。此外，Parallel Scavenge 不能与 CMS 一起使用。</p><p>针对老年代的垃圾回收器也有三个：刚刚提到的 Serial Old 和 Parallel Old，以及 CMS。Serial Old 和 Parallel Old 都是<strong>标记 - 压缩</strong>算法。同样，前者是单线程的，而后者可以看成前者的多线程版本。</p><p>CMS 采用的是<strong>标记 - 清除</strong>算法，并且是并发的。除了少数几个操作需要 Stop-the-world 之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，Java 虚拟机会使用其他两个压缩型垃圾回收器进行一次垃圾回收。由于 G1 的出现，CMS 在 Java 9 中已被废弃。</p><p>G1（Garbage First）是一个横跨新生代和老年代的垃圾回收器。实际上，它已经打乱了前面所说的堆结构，直接将堆分成极其多个区域。每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。它采用的是<strong>标记 - 压缩</strong>算法，而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃圾回收。</p><p>G1 能够针对每个细分的区域来进行垃圾回收。<strong>在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。</strong> 这也是 G1 名字的由来。</p><h1 id="回收策略和内存分配策略"><a class="markdownIt-Anchor" href="#回收策略和内存分配策略"></a> 回收策略和内存分配策略</h1><p><strong><font size="4">Minor GC &amp; Full GC</font></strong></p><ul><li>Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li><li>Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li></ul><p><strong><font size="4">内存分配策略流程</font></strong></p><ol><li>一个人（对象）出来（new 出来）后会在Eden Space（伊甸园）无忧无虑的生活，直到GC到来打破了他们平静的生活。GC会逐一问清楚每个对象的情况，有没有钱（此对象的引用）啊，因为GC想赚钱呀，有钱的才可以敲诈嘛。然后富人就会进入Survivor Space（幸存者区），穷人的就直接kill掉。</li><li>并不是进入Survivor Space（幸存者区）后就保证人身是安全的，但至少可以活段时间。GC会定期（可以自定义）会对这些人进行敲诈，亿万富翁每次都给钱，GC很满意，就让其进入了Genured Gen(养老区)。万元户经不住几次敲诈就没钱了，GC看没有啥价值啦，就直接kill掉了。</li><li>进入到养老区的人基本就可以保证人身安全啦，但是亿万富豪有的也会挥霍成穷光蛋，只要钱没了，GC还是kill掉。</li></ol><p><strong><font size="4">内存分配策略总结</font></strong></p><ol><li><p>对象优先在 Eden 分配</p><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p></li><li><p>大对象直接进入老年代</p><p>大对象是指<strong>需要连续内存空间的对象</strong>，最典型的大对象是那种<strong>很长的字符串以及数组</strong>。</p><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p></li><li><p>长期存活的对象直接进入老年代</p><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p><p>Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15，那么该对象将被晋升（promote）至老年代。</p></li><li><p>动态对象年龄判定</p><p>另外，如果单个 Survivor 区已经被占用了 50%，那么较高复制次数的对象也会被晋升至老年代。</p></li><li><p>空间分配担保</p><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。否则会继续判断其他条件，选择是否进行Full GC。</p></li></ol><p><strong><font size="4">GC 触发条件</font></strong></p><p>对于 Minor GC，其触发条件非常简单，<strong>当 Eden 空间满时，就将触发一次 Minor GC。</strong> 而 Full GC 则相对复杂，有以下条件：</p><ol><li><p>调用 <code>System.gc()</code></p><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p></li><li><p>老年代空间不足</p><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p></li><li><p>空间分配担保失败</p><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。（可参考上文“内存分配策略总结”第5点。）</p></li><li><p>Concurrent Mode Failure</p><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。（可参考上文“垃圾收集器”部分。）</p></li></ol><h1 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> TODO</h1><ol><li>JVM中synchronized的实现</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;jvm-的体系结构&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#jvm-的体系结构&quot;&gt;&lt;/a&gt; &lt;code&gt;JVM&lt;/code&gt; 的体系结构&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;答案参考自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a hr</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="JVM" scheme="https://luoyu-ying.github.io/categories/JVM/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="JVM" scheme="https://luoyu-ying.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>设计模式 - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/bad4a287481b/"/>
    <id>https://luoyu-ying.github.io/posts/bad4a287481b/</id>
    <published>2022-05-26T12:28:41.000Z</published>
    <updated>2022-05-26T12:28:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式 | 菜鸟教程 (runoob.com)</a></li><li><a href="https://blog.csdn.net/hongyinanhai00/article/details/113971787">DCL之单例模式_浦江之猿的博客-CSDN博客_dcl单例模式</a></li><li>《Android源码设计模式解析与实战》</li></ul></blockquote><p><strong>意图：</strong> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>关键代码：</strong> 构造函数是私有的。</p><p><strong>优点：</strong></p><ol><li><p>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</p></li><li><p>避免对资源的多重占用（比如写文件操作）。</p></li></ol><h2 id="实现代码"><a class="markdownIt-Anchor" href="#实现代码"></a> 实现代码</h2><ol><li><p>饿汉式</p><p>优点：没有加锁，执行效率会提高。<br />缺点：类加载时就初始化，浪费内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DCL</p><p>优点：资源利用率高。</p><p>缺点：第一次加载的时候反应稍慢。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span> &#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;  </span><br><span class="line">                singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>volatile</code>是为了防止指令重排序问题，避免第8行代码被分配了控件但是值为<code>null</code>的情况。</p><p>使用<code>DCL</code>是为了防止两个线程如果都通过了第一个<code>if</code>语句后，出现两次赋值的过程。</p></li><li><p>静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次加载<code>Singleton</code>类的时候并不会初始化<code>instance</code>，只有在第一次调用<code>Singleton.getInstance</code>方法时才会初始化<code>instance</code>。因此第一次调用<code>getInstance</code>方法时也会导致虚拟机加载<code>SingletonHolder</code>类，这种方式不仅确保了线程安全，也能够保证单例模式对象的唯一性，同时也延迟了单例的实例化。</p></li></ol><h2 id="android源码中的单例模式"><a class="markdownIt-Anchor" href="#android源码中的单例模式"></a> Android源码中的单例模式</h2><p><strong><code>LayoutInflater</code>类</strong>。</p><p>在<code>ContextImpl</code>类中，<code>LayoutInflater</code>的获取被写进了该类的<code>static&#123;&#125;</code>，即静态语句块中。表示了只有在该类被加载的时候才会被执行一次且只会执行一次，保证了实例的唯一性。</p><h1 id="建造者模式"><a class="markdownIt-Anchor" href="#建造者模式"></a> 建造者模式</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.runoob.com/design-pattern/builder-pattern.html">建造者模式 | 菜鸟教程 (runoob.com)</a></li><li><a href="https://www.runoob.com/w3cnote/builder-pattern-2.html">设计模式：Builder模式 | 菜鸟教程 (runoob.com)</a></li></ul></blockquote><p><strong>意图：</strong> 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>何时使用：</strong> 一些基本部件不会变，而其组合经常变化的时候。</p><p><strong>优点：</strong></p><ol><li><p>建造者独立，易扩展。</p></li><li><p>便于控制细节风险。</p></li></ol><p><strong>缺点：</strong> 产品必须有共同点，范围有限制。</p><p><strong>注意事项：</strong> 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p><p><strong>用例：</strong></p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/1157683-20180626180216963-8235726.png" alt="img" /></p><p>调用者不需要知道<code>Director</code>类中方法的具体实现，而<code>Director</code>类同样也不需要知道<code>Builder</code>类中的具体实现。</p><p>当我们需求发生变动时，只需要单独修改<code>Director</code>或者<code>Builder</code>类的内部细节即可，不会影响到其他类的实现。</p><h2 id="android中的建造者模式"><a class="markdownIt-Anchor" href="#android中的建造者模式"></a> Android中的建造者模式</h2><ol><li><code>Java</code>的<code>StringBuilder</code>。</li><li><code>OkHttp</code>中的<code>OkHttpClient</code>。</li><li><code>Android</code>中的<code>AlterDialog</code>。</li></ol><h1 id="责任链模式"><a class="markdownIt-Anchor" href="#责任链模式"></a> 责任链模式</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html">责任链模式 | 菜鸟教程 (runoob.com)</a></li></ul></blockquote><p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p><p><strong>意图：</strong> 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><p><strong>主要解决：</strong> 职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><p><strong>何时使用：</strong> 在处理消息的时候需要过滤很多道。</p><p><strong>优点：</strong></p><ol><li><p>降低耦合度。它将请求的发送者和接收者解耦。</p></li><li><p>简化了对象。使得对象不需要知道链的结构。</p></li><li><p>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。</p></li><li><p>增加新的请求处理类很方便。</p></li></ol><p><strong>缺点：</strong></p><ol><li><p>不能保证请求一定被接收。</p></li><li><p>系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。</p></li><li><p>可能不容易观察运行时的特征，有碍于除错。</p></li></ol><h2 id="android中类似责任链模式的使用"><a class="markdownIt-Anchor" href="#android中类似责任链模式的使用"></a> Android中类似责任链模式的使用</h2><ol><li><code>OkHttp</code>的拦截器。</li><li>View事件分发的<code>dispatchTouchEvent</code>以及<code>dispatchTransformedTouchEvent</code>方法。</li></ol><h1 id="观察者模式"><a class="markdownIt-Anchor" href="#观察者模式"></a> 观察者模式</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/ec399a25e9d4">Android 观察者模式 - 简书 (jianshu.com)</a></li><li><a href="https://blog.csdn.net/niuzhijun66/article/details/80328642">RecyclerView中的观察者模式_niuzhijun66的博客-CSDN博客</a></li></ul></blockquote><p>定义一个被观察者和多个观察者，每当被观察者变化，所有观察者都会得到通知。</p><p><strong>要点：</strong> P用一个list把观察者保存起来，并提供add和remove观察者，在被观察者变化的时候就遍历并调用list里观察者的方法。<strong>核心就是一个list遍历</strong>。</p><p><strong>优点：</strong></p><ol><li><p>观察者和被观察者解耦</p></li><li><p>增强灵活性，解耦</p></li></ol><p><strong>缺点：</strong> 由于java代码的顺序执行，要考虑被察者的执行效率，多个观察者需要及时响应就得考虑异步的问题了。</p><h2 id="android源码中的观察者模式"><a class="markdownIt-Anchor" href="#android源码中的观察者模式"></a> Android源码中的观察者模式</h2><ol><li><p><code>RecyclerView</code>的<code>notifyDataChanged</code>方法。</p><p>当数据集发生变化，调用RecyclerView.Adapter的notifyDataSetChanged()时，发生变化的地方就会刷新，这个过程就涉及到了Java中的观察者模式。</p><p>在RecyclerView的使用中，最重要的两个类应该就是RecyclerView和RecyclerView.Adapter了。</p><p>RecyclerView内部维持了一个Observer(RecyclerViewDataObserver)。</p><p>Adapter内部维持了一个Observable(AdapterDataObservable)。</p><p>我们调用setAdapter(Adapter adapter)时，Adapter内的Observable会持有RecyclerView内部的Observer；当调用notifyDataSetChanged()时，Observable持有的Observer会依次调用onChanged()方法，而RecyclerView持有的Observer的onChanged()方法中实现了UI刷新。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220526214753683.png" alt="image-20220526214753683"  /></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单例模式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#单例模式&quot;&gt;&lt;/a&gt; 单例模式&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;答案参考自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.runoob.com/d</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="设计模式" scheme="https://luoyu-ying.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/fa6189c97401/"/>
    <id>https://luoyu-ying.github.io/posts/fa6189c97401/</id>
    <published>2022-05-25T08:46:46.000Z</published>
    <updated>2022-05-25T08:46:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="okhttp源码流程"><a class="markdownIt-Anchor" href="#okhttp源码流程"></a> <code>OkHttp</code>源码流程</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://luoyu-ying.github.io/posts/85849a386862/">OkHttp 解析 转载 | 洛语 の Blog (luoyu-ying.github.io)</a></li></ul></blockquote><p><strong><font size="5">基本流程</font></strong></p><ol><li>创建 OkHttpClient 对象</li><li>创建 Request 对象</li><li>创建 Call 对象</li><li>同步请求调用 call.execute()；异步请求调用 call.enqueue()</li></ol><h1 id="okhttp线程池"><a class="markdownIt-Anchor" href="#okhttp线程池"></a> <code>OkHttp</code>线程池</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/OneDeveloper/article/details/88381817">okhttp3 读书笔记——默认的线程池，addNetworkInterceptor() 与 addInterceptor() 的区别，复用连接池_OneDeveloper的博客-CSDN博客_okhttp 默认线程数</a></li></ul></blockquote><p><code>OkHttp</code> 的异步请求是基于其内部的默认的线程池实现的。</p><p>而默认的线程池是在 <code>Dispatcher</code> 被实例化的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title function_">executorService</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (executorService == <span class="literal">null</span>) &#123;</span><br><span class="line">    executorService = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;&gt;(), Util.threadFactory(<span class="string">&quot;OkHttp Dispatcher&quot;</span>, <span class="literal">false</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该线程池的核心线程数为 0，线程池最有能容纳 Integer.MAX_VALUE 个线程，且线程的空闲存活时间为 60s（可以理解为 okhttp 随时可以创建新的线程来满足需要。可以保证网络的 I/O 任务有线程来处理，不被阻塞）。</p><p>重点是使用的阻塞队列为 SynchronousQueue，参考：<br />[<a href="https://luoming1224.github.io/2018/03/19/%5Bjava1.8%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0%5DSynchronousQueue%E8%AF%A6%E8%A7%A3/">java1.8源码笔记]SynchronousQueue详解 | LuoMing’s Blog (luoming1224.github.io)</a></p><h1 id="okhttp拦截器"><a class="markdownIt-Anchor" href="#okhttp拦截器"></a> <code>OkHttp</code>拦截器</h1><p><strong><font size="4">getResponseWithInterceptorChain()</font></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Response <span class="title function_">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">   List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   interceptors.addAll(client.interceptors());</span><br><span class="line">   interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">   interceptors.add(<span class="keyword">new</span> <span class="title class_">BridgeInterceptor</span>(client.cookieJar()));</span><br><span class="line">   interceptors.add(<span class="keyword">new</span> <span class="title class_">CacheInterceptor</span>(client.internalCache()));</span><br><span class="line">   interceptors.add(<span class="keyword">new</span> <span class="title class_">ConnectInterceptor</span>(client));</span><br><span class="line">   <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">     interceptors.addAll(client.networkInterceptors());</span><br><span class="line">   &#125;</span><br><span class="line">   interceptors.add(<span class="keyword">new</span> <span class="title class_">CallServerInterceptor</span>(forWebSocket));</span><br><span class="line">   Interceptor.<span class="type">Chain</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">       interceptors, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">   <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，首先，他会将客户端的 interceptors 添加到 List 当中，接着，再添加 okhttp 里面的 interceptor，然后构建了一个 RealInterceptorChain 对象，并将我们的 List<Interceptor> 作为成员变量，最后调用 RealInterceptorChain 的 proceed 方法。</p><p>其中，client.interceptors() 为我们自己添加的请求拦截器，通常是做一些添加统一的token之类操作。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/4122684-67fcdd5d7e5f984e.jpg" alt="其余较重要的拦截器" /></p><p><strong>RetryAndFollowUpInterceptor 拦截器</strong></p><ul><li>RetryAndFollowUpInterceptor 此拦截器顾名思义就是主要负责失败重连工作，但是并不是所有的网络请求都会进行失败重连的,在此拦截器内部会进行网络请求的异常检测和响应码的判断,如果都在限制范围内,那么就可以进行失败重连。</li></ul><p><strong>CacheInterceptor 拦截器</strong></p><ul><li><p>如果当前未使用网络，并且缓存不可以使用，通过构建者模式创建一个 Response 响应,抛出504错误。</p></li><li><p>如果有缓存 但是不能使用网络 ，直接返回缓存结果。这是在进行网络请求之前所做的事情，当网络请求完成，得到下一个拦截器返回的 response 之后，判断 response 的响应码是否是 HTTP_NOT_MODIFIED = 304（未改变），是则从缓存中读取数据。</p></li></ul><h1 id="addinterceptor-和-addnetworkdinterceptor区别"><a class="markdownIt-Anchor" href="#addinterceptor-和-addnetworkdinterceptor区别"></a> <code>addInterceptor</code> 和 <code>addNetworkdInterceptor</code>区别</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/OneDeveloper/article/details/88381817">okhttp3 读书笔记——默认的线程池，addNetworkInterceptor() 与 addInterceptor() 的区别，复用连接池_OneDeveloper的博客-CSDN博客_okhttp 默认线程数</a></li></ul></blockquote><p>从上文构造拦截器链的过程，可以看到，通过 <code>addInterceptor()</code> 方法添加的拦截器是放在最前面的。</p><p>而通过 <code>addNetworkInterceptor()</code> 方法添加的网络拦截器，则是在非 WebSocket 请求时，添加在 ConnectInterceptor 和 CallServerInterceptor 之间的。</p><p><strong><font size="4">addInterceptor（应用拦截器）</font></strong></p><ol><li>不需要担心中间过程的响应,如重定向和重试.</li><li>总是只调用一次,即使HTTP响应是从缓存中获取.</li><li>观察应用程序的初衷. 不关心OkHttp注入的头信息如: If-None-Match.</li><li>允许短路而不调用 Chain.proceed(),即中止调用.</li><li>允许重试,使 Chain.proceed()调用多次.</li></ol><p><strong><font size="4">addNetworkInterceptor（网络拦截器）</font></strong></p><ol><li>能够操作中间过程的响应,如重定向和重试.</li><li>当网络短路而返回缓存响应时不被调用.</li><li>只观察在网络上传输的数据.</li><li>携带请求来访问连接.</li></ol><h1 id="okhttp责任链模式"><a class="markdownIt-Anchor" href="#okhttp责任链模式"></a> <code>OkHttp</code>责任链模式</h1><p><strong><font size="4">proceed()</font></strong></p><blockquote><p><code>proceed</code> <code>v.</code>继续做（或从事、进行）；接着做；继而做；行进</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Response <span class="title function_">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span><br><span class="line"><span class="params">    Connection connection)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 省略无关代码</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">//  生成 list 当中下一个 interceptot 的 chain 对象</span></span><br><span class="line">  <span class="type">RealInterceptorChain</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealInterceptorChain</span>(</span><br><span class="line">      interceptors, streamAllocation, httpCodec, connection, index + <span class="number">1</span>, request);</span><br><span class="line">  <span class="comment">// 当前的 interceptor</span></span><br><span class="line">  <span class="type">Interceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> interceptors.get(index);</span><br><span class="line">  <span class="comment">// 当前的 intercept 处理下一个 intercept 包装的 chain 对象</span></span><br><span class="line">  <span class="type">Response</span> <span class="variable">response</span> <span class="operator">=</span> interceptor.intercept(next);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proceed 方法也很简单，proceed方法每次从拦截器列表中取出拦截器，并调用 interceptor.intercept(next)。</p><p>熟悉 Okhttp 的应该都知道，我们在 addInterceptor 创建 Interceptor 实例，最终都会调用 chain.proceed(Request request),从而形成一种链式调用。这种便是责任链设计模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>.Builder().addInterceptor(<span class="keyword">new</span> <span class="title class_">Interceptor</span>() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Response <span class="title function_">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">         <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> chain.request();</span><br><span class="line">         Request.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> request.newBuilder().addHeader(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;test&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> chain.proceed(builder.build());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).build();</span><br></pre></td></tr></table></figure><p>而 OkHttp 是怎样结束循环调用的，这是因为最后一个拦截器 CallServerInterceptor 并没有调用 chain.proceed(request)，所以能够结束循环调用。</p><h1 id="okhttp缓存怎么处理"><a class="markdownIt-Anchor" href="#okhttp缓存怎么处理"></a> <code>OkHttp</code>缓存怎么处理</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/00d281c226f6">Okhttp解析（五）缓存的处理 - 简书 (jianshu.com)</a></li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;okhttp源码流程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#okhttp源码流程&quot;&gt;&lt;/a&gt; &lt;code&gt;OkHttp&lt;/code&gt;源码流程&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;答案参考自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="Android" scheme="https://luoyu-ying.github.io/categories/Android/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="OkHttp" scheme="https://luoyu-ying.github.io/tags/OkHttp/"/>
    
  </entry>
  
  <entry>
    <title>MVC &amp; MVP &amp; MVVM - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/95756e730237/"/>
    <id>https://luoyu-ying.github.io/posts/95756e730237/</id>
    <published>2022-05-25T04:18:37.000Z</published>
    <updated>2022-05-25T04:18:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mvc及其优缺点"><a class="markdownIt-Anchor" href="#mvc及其优缺点"></a> <code>MVC</code>及其优缺点</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/sunforraining/article/details/79015080">MVC的理解和优缺点的总结_sunforraining的博客-CSDN博客_mvc的缺点</a></li><li><a href="https://zhuanlan.zhihu.com/p/35680070">深入理解MVC - 知乎 (zhihu.com)</a></li></ul></blockquote><p><strong><font size="5">概念</font></strong></p><p>MVC全名是Model-View-Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范。</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/v2-30f72a70d6d84065d2147754bf2ad59f_1440w.jpg" alt="深入理解MVC" style="zoom: 50%;" /><p>MVC开始是存在于桌面程序中的，M是指业务模型，V是指用户界面，C则是控制器，使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。C存在的目的则是确保M和V的同步，一旦M改变，V应该同步更新。更好的调节M和V的搭配。</p><p>MVC是一种框架模式，说到底是一种框架，而不是一种设计模式，框架通常是代码重用，而设计模式是设计重用，而架构则介于两者之间，部分代码重用，部分设计重用，有时分析也可重用。</p><p><strong><font size="5">优点</font></strong></p><p>分层，结构清晰，耦合性低，大型项目代码的复用性得到极大的提高，开发人员分工明确，提高了开发的效率，维护方便，降低了维护成本。</p><p><strong><font size="5">缺点</font></strong></p><p>简单的小型项目，使用MVC设计反而会降低开发效率，层和层虽然相互分离，但是之间关联性太强，没有做到独立的重用。</p><h1 id="mvp及其优缺点"><a class="markdownIt-Anchor" href="#mvp及其优缺点"></a> <code>MVP</code>及其优缺点</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://juejin.cn/post/6844903752588066830">MVP 与 MVVM 优缺点总结 - 掘金 (juejin.cn)</a></li></ul></blockquote><p><strong><font size="5">概念</font></strong></p><p>实际上按照代码在 App 中所处位置，描述为 VPM 更合适，即 View -&gt; Presenter -&gt; Model：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/4/16818bbae077f9e3~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img" /></p><p>这个架构的核心就是 View 与 Presenter 都被抽象成了接口，是面向接口编程的一个实践。因为面向接口，所以实现了依赖隔离，即无需知道具体的 Class 类型。</p><p><strong><font size="5">优点</font></strong></p><ol><li><strong>模块职责划分明显</strong>,层次清晰,接口功能清晰，遵循了单一职责类的设计原则，提升了代码的可维护性.</li><li><strong>降低耦合度</strong>，Model层和View层分离,解耦.修改View而不影响Model.</li><li><strong>功能复用度高</strong>,方便.一个Presenter可以复用于多个View,而不用更改Presenter的逻辑.</li><li><strong>有利于测试驱动开发</strong>,以前的Android开发是难以进行单元测试.</li><li><strong>代码灵活性</strong>，如果后台接口还未写好,但已知返回数据类型的情况下,完全可以写出此接口完整的功能.</li></ol><p><strong><font size="5">缺点</font></strong></p><ol><li>其实这并不是 MVP 架构的痛点，而是整个 Android App 开发的痛点，那就是对 UI 的操作必须在 Activity 与 Fragment 的生命周期之内，更细致一点，最好在 <code>onStart()</code> 之后 <code>onPause()</code>之前，否则极其容易出现各种异常。而 MVP 架构中，Presenter 对 Activity 与 Fragment 的生命周期是无感知的，所以我们需要手动添加相应的生命周期方法，并进行特殊处理，以避免出现异常或内存泄露。</li><li>MVP中接口过多.</li><li>每一个功能,相比于MVC要多写好几个文件.</li><li>如果某一个界面中需要请求多个服务器接口,这个界面文件中会实现很多的回调接口,导致代码繁杂.</li><li>如果更改了数据源和请求中参数,会导致更多的代码修改.<br />额外的代码复杂度及学习成本.</li><li>由于对视图的渲染放在了Presenter中，所以视图和Presenter的交互会过于频繁。还有一点需要明白，如果Presenter过多地渲染了视图，往往会使得它与特定的视图的联系过于紧密。一旦视图需要变更，那么Presenter也需要变更了。</li></ol><h1 id="mvvm及其优缺点"><a class="markdownIt-Anchor" href="#mvvm及其优缺点"></a> <code>MVVM</code>及其优缺点</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://juejin.cn/post/6844903752588066830">MVP 与 MVVM 优缺点总结 - 掘金 (juejin.cn)</a></li></ul></blockquote><p><strong><font size="5">概念</font></strong></p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/254216d2594c43b3813739c5d0ecf0cd.png" alt="img" style="zoom:67%;" /><p>View可以独立于Model变化和修改，一个ViewModel可以绑定到不同的&quot;View&quot;上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</p><p>在MVVM中，数据是核心，由于ViewModel与View之间的双向绑定，操作了ViewModel中的数据，就会同步到DOM，我们透过DOM事件监控用户对DOM的改动，也会同步到ViewModel。</p><p>MVVM 架构相对复杂，核心是 LifecycleOwner、LifecycleObserver、LifecycleRegistry 组件，在此之上，Google 还开发了 DataBinding、ViewModel、LiveData 以实现完整的 MVVM 架构。相关组件已收纳至 <a href="https://link.juejin.cn?target=https%3A%2F%2Fdeveloper.android.google.cn%2Fjetpack%2Farch%2F">JetPack Architecture</a> 中。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/16818b1814a8a3f8.png" alt="img" /></p><p>这个架构的核心就是 ViewModel 和 LiveData。ViewModel 的作用是保证当设备因配置改变而重新创建 FragmentActivity(目前 ViewModel 仅支持 FragmentActivity 和 Fragment) 时，数据也不会丢失。LiveData 的作用是保证只在 FragmentActivity 或 Fragment 的生命周期状态为 [onStarted, onResumed] 时，回调 onChanged(T data)，所以我们可以在 onChanged() 中安全的更新 UI。下面简单介绍源码中是如何实现的：</p><p><strong><font size="5">优点</font></strong></p><ul><li><p>ViewModel：因设备配置改变导致 Activity 重建时，无需从 Model 中再次加载数据，减少了 IO 操作</p></li><li><p>LiveData：更新 UI 时，不用再关注生命周期问题</p></li><li><p>Data Binding： 可以有效减少模板代码的编写，而且目前已经支持双向绑定 (注意：不是所有的 UI 都需要使用 Data Binding，虽然通过 @BindingAdapter 我们真的可以“为所欲为”，最好还是只用于需要绑定 Bean 类的布局)</p></li></ul><p><strong><font size="5">缺点</font></strong></p><ul><li>LiveData 本身是没有 public 方法的，所以我们应该使用其子类 MutableLiveData。这样设计，我们就可以在 Model 中使用 MutableLiveData，在 ViewModel 中，只对 View 提供 LiveData，避免 View 去更新 LiveData。</li></ul><h1 id="mvp如何防止内存泄漏"><a class="markdownIt-Anchor" href="#mvp如何防止内存泄漏"></a> <code>MVP</code>如何防止内存泄漏</h1><ul><li><p>在<code>BasePresenter</code>中使用对<code>View</code>的弱引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BasePresenter</span>&lt;M <span class="keyword">extends</span> <span class="title class_">BaseModel</span>, V <span class="keyword">extends</span> <span class="title class_">BaseView</span>, CONTRACT&gt; &#123;</span><br><span class="line">    <span class="keyword">protected</span> M m;</span><br><span class="line">    <span class="keyword">protected</span> WeakReference&lt;V&gt; weakReference;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BasePresenter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.m = getModel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">bindView</span><span class="params">(V v)</span> &#123;</span><br><span class="line">        weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">unbindView</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (weakReference != <span class="literal">null</span>) &#123;</span><br><span class="line">            weakReference.clear();</span><br><span class="line">            weakReference = <span class="literal">null</span>;</span><br><span class="line">            System.gc();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> V <span class="title function_">getView</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (weakReference != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> weakReference.get();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> CONTRACT <span class="title function_">getContract</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> M <span class="title function_">getModel</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>BaseView</code>中<code>onCreate</code>和<code>onDestory</code>方法中主动绑定和解绑<code>Presenter</code>，防止内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">BaseView</span>&lt;P <span class="keyword">extends</span> <span class="title class_">BasePresenter</span>, CONTRACT&gt; <span class="keyword">extends</span> <span class="title class_">Activity</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> P p;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        p = getPresenter();</span><br><span class="line">        p.bindView(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onDestroy();</span><br><span class="line">        p.unbindView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> P <span class="title function_">getPresenter</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> CONTRACT <span class="title function_">getContract</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h1 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> TODO</h1><ol><li>MVP如何管理Presenter的生命周期，何时取消网络请求</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mvc及其优缺点&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#mvc及其优缺点&quot;&gt;&lt;/a&gt; &lt;code&gt;MVC&lt;/code&gt;及其优缺点&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;答案参考自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="Android" scheme="https://luoyu-ying.github.io/categories/Android/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Service - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/94ccd61d6796/"/>
    <id>https://luoyu-ying.github.io/posts/94ccd61d6796/</id>
    <published>2022-05-24T08:40:02.000Z</published>
    <updated>2022-05-29T06:55:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="service-的生命周期两种启动方式的区别"><a class="markdownIt-Anchor" href="#service-的生命周期两种启动方式的区别"></a> <code>Service</code> 的生命周期，两种启动方式的区别</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/jisheng/archive/2011/12/13/2286262.html">Service生命周期 - Hecker385 - 博客园 (cnblogs.com)</a></li><li><a href="https://www.cnblogs.com/Lwenlong/p/15939996.html">Android面试——Service篇 - 向着内核前进！ - 博客园 (cnblogs.com)</a></li><li><a href="https://www.jianshu.com/p/a58780595d2b">Service-服务(一)生命周期及使用方式 - 简书 (jianshu.com)</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/15821503-f7f98e2e43fa178b.png" alt="img" /></p><h2 id="使用contextstartservice-启动service"><a class="markdownIt-Anchor" href="#使用contextstartservice-启动service"></a> <strong>使用<code>context.startService</code> 启动<code>Service</code></strong></h2><p>其生命周期为<em>context.startService()</em> -&gt; <code>onCreate()</code>- &gt; <code>onStartCommand()</code>-&gt; <strong>Service</strong> <strong>running</strong> -&gt; <em>context.stopService()</em> | -&gt; <code>onDestroy()</code> -&gt; <strong>Service</strong> <strong>stop</strong></p><ol><li>如果<code>Service</code>还没有运行，则<code>Android</code>先调用<code>onCreate()</code>然后调用onStart()；</li><li>如果<code>Service</code>已经运行，则只调用<code>onStartCommand()</code>，所以一个<code>Service</code>的<code>onStartCommand</code>方法可能会重复调用多次。</li></ol><p><code>stopService</code>的时候直接<code>onDestroy</code>，如果是调用者自己直接退出而没有调用<code>stopService</code>的话，<code>Service</code>会一直在后台运行。该Service的调用者再启动起来后可以通过<code>stopService</code>关闭<code>Service</code>。</p><p><strong>所以调用<code>startService</code>的生命周期为：<code>onCreate</code> --&gt; <code>onStartCommand</code>(可多次调用) --&gt; <code>onDestroy</code></strong>。</p><h2 id="对于bindservice启动service会经历"><a class="markdownIt-Anchor" href="#对于bindservice启动service会经历"></a> <strong>对于<code>bindService</code>启动<code>Service</code>会经历：</strong></h2><p><em>context.bindService()</em> -&gt; <code>onCreate()</code>-&gt; <code>onBind()</code> -&gt;<strong>Service running</strong> -&gt; <code>onUnbind()</code> -&gt; <code>onDestroy()</code> -&gt; <strong>Service stop</strong></p><p><code>onBind</code>将返回给客户端一个<code>IBind</code>接口实例，<code>IBind</code>允许客户端回调服务的方法，比如得到<code>Service</code>运行的状态或其他操作。</p><p>这个时候把调用者（<code>Context</code>，例如<code>Activity</code>）会和<code>Service</code>绑定在一起，<code>Context</code>退出了，<code>Srevice</code>就会调用<code>onUnbind</code> -&gt; <code>onDestroy</code>相应退出。</p><p><strong>所以调用<code>bindService</code>的生命周期为：<code>onCreate</code> --&gt; <code>onBind</code>(只一次，不可多次绑定) --&gt; <code>onUnbind</code> --&gt; <code>onDestory</code>。</strong></p><p>一但销毁<code>activity</code>它就结束，如果按<code>home</code>把它放到后台，那他就不退出。</p><p><strong><font size="4">补充</font></strong></p><p>在Service每一次的开启关闭过程中，只有<code>onStartCommand</code>可被多次调用(通过多次<code>startService</code>调用)，<br />其他<code>onCreate</code>，<code>onBind</code>，<code>onUnbind</code>，<code>onDestory</code>在一个生命周期中只能被调用一次。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;service-的生命周期两种启动方式的区别&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#service-的生命周期两种启动方式的区别&quot;&gt;&lt;/a&gt; &lt;code&gt;Service&lt;/code&gt; 的生命周期，两种启动方式的区别&lt;/h1&gt;
&lt;</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="Android" scheme="https://luoyu-ying.github.io/categories/Android/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="Service" scheme="https://luoyu-ying.github.io/tags/Service/"/>
    
  </entry>
  
  <entry>
    <title>ContentProvider - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/bb5f9e1a55ea/"/>
    <id>https://luoyu-ying.github.io/posts/bb5f9e1a55ea/</id>
    <published>2022-05-24T08:09:38.000Z</published>
    <updated>2022-05-24T08:09:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/Lwenlong/p/15941998.html">Android面试——ContentProvider篇 - 向着内核前进！ - 博客园 (cnblogs.com)</a></li></ul></blockquote><h1 id="什么是contentprovider及其使用"><a class="markdownIt-Anchor" href="#什么是contentprovider及其使用"></a> 什么是<code>ContentProvider</code>及其使用</h1><ol><li><p><code>ContentProvider</code>通过Uri标识其他应用要访问的数据；</p></li><li><p>通过<code>ContentResolver</code>的增删改查方法实现对共享的数据的操作；</p></li><li><p>通过注册<code>ContentObserver</code>来监听数据是否发生了变化来对应的刷新页面</p></li></ol><p><strong><font size="4">作用</font></strong></p><p>为不同应用之间的数据共享提供统一的接口</p><h1 id="contentprovidercontentresolvercontentobserver之间的关系"><a class="markdownIt-Anchor" href="#contentprovidercontentresolvercontentobserver之间的关系"></a> <code>ContentProvider</code>,<code>ContentResolver</code>,<code>ContentObserver</code>之间的关系</h1><ol><li><p><code>ContentProvider</code></p><p>内容提供者：管理数据，提供数据的增删改查操作，数据源可以是数据库，文件，<code>xml</code>，网络等。</p></li><li><p><code>ContentResolver</code></p><p>内容解析者：外部进程通过内容解析者与内容提供者进行交互。</p></li><li><p><code>ContentObserver</code></p><p>内容观察者：观察内容提供者的数据变化，并将变化通知给外界。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;答案参考自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/Lwenlong/p/15941998.html&quot;&gt;Android面试——ContentProvider篇 - 向着内核前进！ - 博客园 (</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="Android" scheme="https://luoyu-ying.github.io/categories/Android/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="ContentProvider" scheme="https://luoyu-ying.github.io/tags/ContentProvider/"/>
    
  </entry>
  
  <entry>
    <title>BroadcastReceiver - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/90a21a97c0cb/"/>
    <id>https://luoyu-ying.github.io/posts/90a21a97c0cb/</id>
    <published>2022-05-24T07:34:00.000Z</published>
    <updated>2022-05-24T07:34:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="广播的分类和使用场景"><a class="markdownIt-Anchor" href="#广播的分类和使用场景"></a> 广播的分类和使用场景</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/Lwenlong/p/15940123.html">Android面试——BroadcastReceiver篇 - 向着内核前进！ - 博客园 (cnblogs.com)</a></li></ul></blockquote><p><strong><font size="4">分类</font></strong></p><ol><li><p>普通广播：通过Context.sendBroadcast()发送，可并行处理</p></li><li><p>系统广播：系统发送的广播，只需要注册广播接收器，并定义好action等待接收广播</p></li><li><p>有序广播：发出的广播会被接收器按照先后顺序进行接收，发送方式为sendOrderedBroadcast(intent)； 广播接受者接收的顺序规则：按照Priority属性值排序，Priority相同者，动态注册的广播优先；</p></li><li><p>APP应用内广播（Local Broadcast）：由于广播可以跨进程的特性，导致应用可能不断收到来自其他应用的广播，或者别的应用接收到当前应用的私密广播；解决方法为使用应用内广播；也称局部广播，接收者和发送者同属于一个APP，</p></li></ol><p><strong><font size="4">使用方法</font></strong></p><ul><li><p>方法1：注册广播时设置exported属性为false；在广播发送接收时，增加权限，用于权限验证；发送广播时执行广播接收器的包名</p></li><li><p>方法2：使用封装好的LocalBroadcastManager,这种方式的广播只能动态注册，不能静态注册</p></li></ul><p><strong><font size="4">使用场景</font></strong></p><ul><li><p>同一 App 内部的不同组件之间的消息通信（单个进程）；</p></li><li><p>不同 App 之间的组件之间消息通信；</p></li><li><p>Android系统在特定情况下与App之间的消息通信，如：网络变化、电池电量、屏幕开关等；</p></li></ul><h1 id="广播的两种注册方式的区别"><a class="markdownIt-Anchor" href="#广播的两种注册方式的区别"></a> 广播的两种注册方式的区别</h1><ul><li><p>静态注册</p><p>常驻系统，不受组件生命周期影响，即便应用退出，广播还是可以被接收，耗电、占内存。</p></li><li><p>动态注册</p><p>非常驻，跟随组件的生命变化，组件结束，广播结束。在组件结束前，需要先移除广播，否则容易造 成内存泄漏。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;广播的分类和使用场景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#广播的分类和使用场景&quot;&gt;&lt;/a&gt; 广播的分类和使用场景&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;答案参考自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="Android" scheme="https://luoyu-ying.github.io/categories/Android/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="Broadcast" scheme="https://luoyu-ying.github.io/tags/Broadcast/"/>
    
  </entry>
  
  <entry>
    <title>Fragment - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/b9e5d151a0cc/"/>
    <id>https://luoyu-ying.github.io/posts/b9e5d151a0cc/</id>
    <published>2022-05-24T03:25:44.000Z</published>
    <updated>2022-05-24T03:25:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fragment的生命周期"><a class="markdownIt-Anchor" href="#fragment的生命周期"></a> <code>Fragment</code>的生命周期</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/70d7bfae18f3">Fragment 生命周期和使用 - 简书 (jianshu.com)</a></li></ul></blockquote><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/1688279-0424d62f50035b43.png" alt="img" /></p><p>可以看到 Fragment 的生命周期和 Activity 很相似，只是多了一下几个方法：</p><ol><li><p><strong>onAttach()</strong></p><p>在Fragment 和 Activity 建立关联时调用（Activity 传递到此方法内）。</p></li><li><p><strong>onCreateView()</strong></p><p>当Fragment 创建视图时调用。</p></li><li><p><strong>onActivityCreated()</strong></p><p>在相关联的 Activity 的 onCreate() 方法已返回时调用。</p></li><li><p><strong>onDestroyView()</strong></p><p>当Fragment中的视图被移除时调用。</p></li><li><p><strong>onDetach()</strong></p><p>当Fragment 和 Activity 取消关联时调用。</p></li></ol><p>几种操作情况下Fragment 的生命周期变化</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/1688279-e34d09c9351c7084.png" alt="img" style="zoom:80%;" /><h1 id="结合activity的生命周期"><a class="markdownIt-Anchor" href="#结合activity的生命周期"></a> 结合<code>Activity</code>的生命周期</h1><p>管理 Fragment 生命周期和 Activity 生命周期很相似，同时 Activity 的生命周期对 Fragment 的生命周期也有一定的影响，如下图所示。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/1688279-e513845a80659860.png" alt="img" /></p><p>用下图（<a href="https://www.jianshu.com/p/184f0c8857d6">来源</a>）来表示 Activity 和 Fragment 的生命周期变化的先后过程是:</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/1688279-020ad51ed5443cce.png" alt="img" style="zoom:80%;" /><p>Fragment 生命周期与 Activity 生命周期的一个关键区别就在于，Fragment 的生命周期方法是由托管Activity而不是操作系统调用的。Activity 中生命周期方法都是 protected，而 Fragment 都是 public，也能印证了这一点，因为 Activity 需要调用 Fragment 那些方法并管理它。</p><h1 id="activity和fragment的通信方式"><a class="markdownIt-Anchor" href="#activity和fragment的通信方式"></a> <code>Activity</code>和<code>Fragment</code>的通信方式</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://developer.aliyun.com/article/637559">Fragment与Activity之间的通信-阿里云开发者社区 (aliyun.com)</a></li></ul></blockquote><p><strong>将Fragment添加到Activity之后，Fragment必须与Activity交互信息，这就需要Fragment能获取它所在的Activity，Activity也能获取它所包含的任意的Fragment。</strong></p><ul><li><p><strong><font size="4">Fragment获取它所在的Activtiy</font></strong></p><p>调用Fragment的getActivity()方法即可返回它所在的Activity。</p></li><li><p><strong><font size="4">Activity获取它包含的Fragment</font></strong></p><p>调用Activity关联的FragmentManager的findFragmentById(int id)或findFragmentByTag(String tag)方法即可获取指定的Fragment。</p></li></ul><p><strong>除此之外，Fragment与Activity可能还需要相互传递数据，可按如下方式进行。</strong></p><ul><li><p><strong><font size="4">Activity向Fragment传递数据</font></strong></p><p>在Activity中创建Bundle数据包，并调用Fragment的<strong>setArguments</strong>(Bundle bundle)方法即可将Bundle数据包传给Fragment。</p></li><li><p><strong><font size="4">Fragment向Activity传递数据或Activity需要在Fragment运行中进行实时通信</font></strong></p><p>在Fragment中定义一个<strong>内部回调接口</strong>，再让包含该Fragment的Activity实现该回调接口，这样Fragment即可调用该回调方法将数据传给Activity。</p></li></ul><p><strong>使用 FragmentManager 还可以执行的操作包括：</strong></p><ul><li>通过 findFragmentById 或 findFragmentByTag 获取 activity 中存在的 fragment 的实例</li><li>通过 popBackStack （<em>模拟用户点击返回按钮操作</em>）将 fragment 从返回栈中弹出</li><li>通过 addOnBackStackChangedListener() 注册一个监听返回栈改变的监听器</li><li>像上边生成 fragmentTransaction 的方法，可以使用 fragmentManager 生成一个 fragmentTransaction 来执行某些事务，比如添加、替换、移除、addToBackStack()等。</li></ul><h1 id="fragment之间如何进行通信"><a class="markdownIt-Anchor" href="#fragment之间如何进行通信"></a> <code>Fragment</code>之间如何进行通信</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh-cn#sharing">ViewModel 概览  | Android 开发者  | Android Developers (google.cn)</a></li></ul></blockquote><p>Activity 中的两个或更多 Fragment 需要相互通信是一种很常见的现象。想象一下拆分视图 (<code>list-detail</code>) Fragment 的常见情况，假设您有一个 Fragment，在该 Fragment 中，用户从列表中选择一项，还有另一个 Fragment，用于显示选定项的内容。这种情况不太容易处理，因为这两个 Fragment 都需要定义某种接口描述，并且所有者 Activity 必须将两者绑定在一起。此外，这两个 Fragment 都必须处理另一个 Fragment 尚未创建或不可见的情况。</p><p>可以使用 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel?hl=zh-cn"><code>ViewModel</code></a> 对象解决这一常见的难点。这两个 fragment 可以使用其 activity 范围共享 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModel?hl=zh-cn"><code>ViewModel</code></a> 来处理此类通信，如以下示例代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SharedViewModel</span> <span class="keyword">extends</span> <span class="title class_">ViewModel</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MutableLiveData&lt;Item&gt; selected = <span class="keyword">new</span> <span class="title class_">MutableLiveData</span>&lt;Item&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        selected.setValue(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LiveData&lt;Item&gt; <span class="title function_">getSelected</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> selected;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SharedViewModel model;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewCreated</span><span class="params">(<span class="meta">@NonNull</span> View view, Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">        model = <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>(requireActivity()).get(SharedViewModel.class);</span><br><span class="line">        itemSelector.setOnClickListener(item -&gt; &#123;</span><br><span class="line">            model.select(item);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DetailFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onViewCreated</span><span class="params">(<span class="meta">@NonNull</span> View view, Bundle savedInstanceState)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onViewCreated(view, savedInstanceState);</span><br><span class="line">        <span class="type">SharedViewModel</span> <span class="variable">model</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ViewModelProvider</span>(requireActivity()).get(SharedViewModel.class);</span><br><span class="line">        model.getSelected().observe(getViewLifecycleOwner(), item -&gt; &#123;</span><br><span class="line">           <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，这两个 Fragment 都会检索包含它们的 Activity。这样，当这两个 Fragment 各自获取 <a href="https://developer.android.google.cn/reference/androidx/lifecycle/ViewModelProvider?hl=zh-cn"><code>ViewModelProvider</code></a> 时，它们会收到相同的 <code>SharedViewModel</code> 实例（其范围限定为该 Activity）。</p><p>此方法具有以下优势：</p><ul><li>Activity 不需要执行任何操作，也不需要对此通信有任何了解。</li><li>除了 <code>SharedViewModel</code> 约定之外，Fragment 不需要相互了解。如果其中一个 Fragment 消失，另一个 Fragment 将继续照常工作。</li><li>每个 Fragment 都有自己的生命周期，而不受另一个 Fragment 的生命周期的影响。如果一个 Fragment 替换另一个 Fragment，界面将继续工作而没有任何问题。</li></ul><h1 id="为什么使用fragmentsetargumentsbundle传递参数"><a class="markdownIt-Anchor" href="#为什么使用fragmentsetargumentsbundle传递参数"></a> 为什么使用<code>Fragment.setArguments(Bundle)</code>传递参数</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/tu_bingbing/article/details/24143249">Android解惑 - 为什么要用Fragment.setArguments(Bundle bundle)来传递参数_pobi的博客-CSDN博客_fragment setarguments</a></li><li><a href="https://www.jianshu.com/p/c06efe090589">为什么要通过Fragment.setArguments(Bundle)传递参数 - 简书 (jianshu.com)</a></li></ul></blockquote><p>当我们实例化自定义Fragment时，为什么官方推荐Fragment.setArguments(Bundle bundle)这种方式来传递参数，而不推荐通过构造方法直接来传递参数呢？</p><p><strong>方式一：通过构造方法传递参数</strong></p><p>在创建Fragment的时候，使用 MyFragment fragment = new MyFragment(parameter) 来传递参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyFragment</span><span class="params">(Parameter p)</span>&#123;</span><br><span class="line">        <span class="comment">//将参数保存起来</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方式二：通过Fragment.setArguments(Bundle)传递参数</strong></p><p>在创建Fragment的时候，使用MyFragment fragment = MyFragment.newInstance(paramter) 来传递参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyFragment</span> <span class="keyword">extends</span> <span class="title class_">Fragment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MyFragment <span class="title function_">newInstance</span><span class="params">(Parameter p)</span> &#123;</span><br><span class="line">        <span class="type">MyFragment</span> <span class="variable">myFragment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyFragment</span>();</span><br><span class="line">        <span class="type">Bundle</span> <span class="variable">args</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">        args.putInt(<span class="string">&quot;someParameter&quot;</span>, p);</span><br><span class="line">        myFragment.setArguments(args);</span><br><span class="line">        <span class="keyword">return</span> myFragment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结论</strong></p><p>我们可以知道Activity重新创建时，会重新构建它所管理的Fragment，原先的Fragment的字段值将会全部丢失，但是通过 Fragment.setArguments(Bundle bundle)方法设置的bundle会保留下来。所以尽量使用Fragment.setArguments(Bundle bundle)方式来传递参数。</p><h1 id="fragment嵌套问题"><a class="markdownIt-Anchor" href="#fragment嵌套问题"></a> <code>Fragment</code>嵌套问题</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/yzwfeng/article/details/123535473">Android开发-Fragment嵌套Fragment的使用及常见错误_有点料的博客-CSDN博客_fragment 嵌套</a></li></ul></blockquote><p>嵌套Fragments (Nested Fragments), 是在Fragment内部又添加Fragment。</p><p><strong>使用时, 主要要依靠宿主Fragment的 getChildFragmentManager() 来获取FragmentManger。</strong> 虽然看起来和在activity中添加fragment差不多, 但因为fragment生命周期及管理恢复模式不同, 其中有一些需要特别注意的地方。</p><p>本文内容还包括了从Fragment迁移到v4.Fragment代码中需要改动的一些地方.</p><p><strong><font size="4">嵌套Fragments</font></strong></p><p>嵌套Fragments 是Android 4.2 API 17 引入的.</p><p>目的: 进一步增强动态复用。</p><p><strong><font size="4">嵌套Fragment的动态添加</font></strong></p><p>在宿主fragment里调用getChildFragmentManager()</p><p>即可用它来向这个fragment内部添加fragments。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Fragment</span> <span class="variable">videoFragment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VideoPlayerFragment</span>();</span><br><span class="line"><span class="type">FragmentTransaction</span> <span class="variable">transaction</span> <span class="operator">=</span> getChildFragmentManager().beginTransaction();</span><br><span class="line">transaction.add(R.id.video_fragment, videoFragment).commit();</span><br></pre></td></tr></table></figure><p><strong>同样, 对于内部的fragment来说, getParentFragment() 方法可以获取到fragment的宿主fragment.</strong></p><p><strong><font size="4">getChildFragmentManager() 和 getFragmentManager()</font></strong></p><p>getChildFragmentManager()是fragment中的方法, 返回的是管理当前fragment内部子fragments的manager.</p><p><strong>getFragmentManager()在activity和fragment中都有。</strong></p><p>在activity中, 如果用的是v4 support库, 方法应该用getSupportFragmentManager(), 返回的是管理activity中fragments的manager.</p><p><strong>在fragment中, 调用getFragmentManager(), 返回的是把自己加进来的那个manager.</strong></p><p>也即, 如果fragment在activity中, fragment.getFragmentManager()得到的是activity中管理fragments的那个manager.<br />如果fragment是嵌套在另一个fragment中, fragment.getFragmentManager()得到的是它的parent的getChildFragmentManager()。</p><p><strong>总结就是: getFragmentManager()是本级别管理者, getChildFragmentManager()是下一级别管理者。这实际上是一个树形管理结构。</strong></p><h1 id="todo"><a class="markdownIt-Anchor" href="#todo"></a> TODO</h1><ol><li><code>FragmentPageAdapter</code>和<code>FragmentStatePageAdapter</code>区别及使用场景</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;fragment的生命周期&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#fragment的生命周期&quot;&gt;&lt;/a&gt; &lt;code&gt;Fragment&lt;/code&gt;的生命周期&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;答案参考自：&lt;/p&gt;
&lt;u</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="Android" scheme="https://luoyu-ying.github.io/categories/Android/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="Fragment" scheme="https://luoyu-ying.github.io/tags/Fragment/"/>
    
  </entry>
  
  <entry>
    <title>通过注册表在微软输入法中加载小鹤双拼</title>
    <link href="https://luoyu-ying.github.io/posts/66c4123f82e6/"/>
    <id>https://luoyu-ying.github.io/posts/66c4123f82e6/</id>
    <published>2022-05-23T12:52:10.000Z</published>
    <updated>2022-05-23T12:52:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>在微软拼音输入法中快速使用小鹤双拼。</p><h1 id="操作步骤"><a class="markdownIt-Anchor" href="#操作步骤"></a> 操作步骤</h1><ol><li><p>通过<code>Win + R</code>，输入<code>regedit</code>打开注册表编辑器。</p></li><li><p>通过左侧的各级文件夹，到达<code>HKEY_CURRENT_USER\SOFTWARE\Microsoft\InputMethod\Settings\CHS</code>路径。</p></li><li><p>通过修改右侧的值项，来加载小鹤双拼输入法。</p><p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/image-20220107194851414.png" alt="image-20220107194851414" /></p></li></ol><p><strong>各项值：</strong></p><table><thead><tr><th>名称</th><th>类型</th><th>数据</th></tr></thead><tbody><tr><td><code>DoublePinyinScheme</code></td><td><code>DWORD</code></td><td><code>0x0000000a</code></td></tr><tr><td><code>Enable Double Pinyin</code></td><td><code>DWORD</code></td><td><code>0x00000001</code></td></tr><tr><td><code>EnableExtraDomainType</code></td><td><code>DWORD</code></td><td><code>0x00000001</code></td></tr><tr><td><code>UserDefinedDoublePinyinScheme0</code></td><td><code>SZ</code></td><td><code>小鹤双拼*2*^*iuvdjhcwfgrxmlnpbksqszxkrltvyovt</code></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;在微软拼音输入法中快速使用小鹤双拼。&lt;/p&gt;
&lt;h1 id=&quot;操作步骤&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;</summary>
      
    
    
    
    <category term="Windows OS" scheme="https://luoyu-ying.github.io/categories/Windows-OS/"/>
    
    
  </entry>
  
  <entry>
    <title>通过 AutoHotKey 简化 Hexo 操作</title>
    <link href="https://luoyu-ying.github.io/posts/050a11a7817a/"/>
    <id>https://luoyu-ying.github.io/posts/050a11a7817a/</id>
    <published>2022-05-22T08:33:12.000Z</published>
    <updated>2022-05-22T08:33:12.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>功能持续更新中！</p></blockquote><h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>通过 <code>AutoHotKey</code> 编写可视化界面以解决每一次部署博客都需要输入命令的情况。</p><p>使用的  <code>AutoHotKey</code> 版本：1.33</p><h1 id="效果"><a class="markdownIt-Anchor" href="#效果"></a> 效果</h1><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220522225631.png?x-oss-process=style/watermark" style="zoom: 50%;" /><p><strong>功能介绍：</strong></p><ol><li><p><strong>Open Blog</strong></p><p>打开自己的博客。</p></li><li><p><strong>New Post</strong></p><p>新建博文，点击后会弹出如下窗口：</p><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220522225716.png?x-oss-process=style/watermark" style="zoom: 50%;" /><p>在输入窗口中可以输入文章的标题，确认后会创建<code>.md</code>文件并打开。</p></li><li><p><strong>Open Root Folder</strong></p><p>打开根目录文件夹。</p></li><li><p><strong>Open Post Folder</strong></p><p>打开已发布文章的文件夹。</p></li><li><p><strong>Open Draft Folder</strong></p><p>打开草稿文章文件夹。</p></li><li><p><strong>Clean &amp; Generate &amp; Server</strong></p><p>部署到本地。</p></li><li><p><strong>Clean &amp; Generate &amp; Deploy</strong></p><p>部署到服务器（适用于对文章做出结构性更改）。</p></li><li><p><strong>Generate &amp; Deploy</strong></p><p>部署到服务器（适用于仅对文章内容做出更改）。</p></li><li><p><strong>Deploy</strong></p><p>部署到服务器（适用于部署失败时重新部署）。</p></li></ol><h1 id="实现步骤"><a class="markdownIt-Anchor" href="#实现步骤"></a> 实现步骤</h1><h2 id="下载-autohotkey"><a class="markdownIt-Anchor" href="#下载-autohotkey"></a> 下载 <code>AutoHotKey</code></h2><p>到 <a href="https://www.autohotkey.com/"><code>AutoHotKey</code> 官网</a>自行下载。</p><h2 id="新建-ahk-文件并复制以下代码"><a class="markdownIt-Anchor" href="#新建-ahk-文件并复制以下代码"></a> 新建 <code>.ahk</code> 文件并复制以下代码</h2><ol><li><p>桌面空白处鼠标右键 &gt;&gt; 新建 &gt;&gt; <code>AutoHotKey Script</code>。</p></li><li><p>对新建的<code>ahk</code>文件右键 &gt;&gt; <code>Edit Script</code>。</p></li><li><p>进入编辑界面后复制以下代码：</p></li></ol><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#SingleInstance, Force</span></span><br><span class="line"></span><br><span class="line">blogSite := <span class="string">&quot;https://XXX.github.io/&quot;</span> <span class="comment">; 更改为自己的博客网址</span></span><br><span class="line">rootFolderPath := <span class="string">&quot;E:\XXX\HexoBlog&quot;</span> <span class="comment">; 更改为自己的博客根目录地址</span></span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">SetWorkingDir,</span> <span class="variable">%rootFolderPath%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 控件添加</span></span><br><span class="line"><span class="built_in">Gui,</span> Add, Text , w200 h27 center section , `nHexo Blog Updater </span><br><span class="line"><span class="built_in">Gui,</span> Add, Text , w200 <span class="number">0</span>x10 <span class="comment">; 横向分割线</span></span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , <span class="keyword">New</span> Post</span><br><span class="line"><span class="built_in">Gui,</span> Add, Text , w200 <span class="number">0</span>x10 </span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Open Root Folder</span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Open Post Folder</span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Open Draft Folder</span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 ys , Open Blog</span><br><span class="line"><span class="built_in">Gui,</span> Add, Text , w200 <span class="number">0</span>x10</span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Clean &amp;&amp; Generate &amp;&amp; Server</span><br><span class="line"><span class="built_in">Gui,</span> Add, Text , w200 <span class="number">0</span>x10 </span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Clean &amp;&amp; Generate &amp;&amp; Deploy</span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Generate &amp;&amp; Deploy</span><br><span class="line"><span class="built_in">Gui,</span> Add, Button, w200 h35 , Deploy</span><br><span class="line"><span class="built_in"></span></span><br><span class="line"><span class="built_in">Gui,</span> Show, Center , Hexo Blog Updater</span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 按钮事件监听</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 打开博客</span></span><br><span class="line"><span class="title">ButtonOpenBlog:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%blogSite%</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 清理、生成和本地部署</span></span><br><span class="line"><span class="title">ButtonCleanGenerateServer:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%comSpec%</span> /c hexo clean &amp;&amp; hexo g &amp;&amp; hexo s &amp;&amp; <span class="keyword">pause</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 清理、生成和服务器部署</span></span><br><span class="line"><span class="title">ButtonCleanGenerateDeploy:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%comSpec%</span> /c hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &amp;&amp; <span class="keyword">pause</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 生成和服务器部署</span></span><br><span class="line"><span class="title">ButtonGenerateDeploy:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%comSpec%</span> /c hexo g &amp;&amp; hexo d &amp;&amp; <span class="keyword">pause</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 服务器部署</span></span><br><span class="line"><span class="title">ButtonDeploy:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%comSpec%</span> /c hexo d &amp;&amp; <span class="keyword">pause</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 打开根目录文件夹</span></span><br><span class="line"><span class="title">ButtonOpenRootFolder:</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%rootFolderPath%</span></span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 打开已发布文章文件夹</span></span><br><span class="line"><span class="title">ButtonOpenPostFolder:</span></span><br><span class="line"><span class="built_in">    Run,</span> source\_posts</span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 打开草稿文章文件夹</span></span><br><span class="line"><span class="title">ButtonOpenDraftFolder:</span></span><br><span class="line"><span class="built_in">    Run,</span> source\_drafts</span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 添加新文章</span></span><br><span class="line"><span class="title">ButtonNewPost:</span></span><br><span class="line"><span class="built_in">    InputBox,</span> FileName, NewPostTitle, Please enter the title of <span class="keyword">new</span> post., , , <span class="number">130</span></span><br><span class="line">    if <span class="built_in">ErrorLevel</span></span><br><span class="line">        <span class="keyword">Return</span></span><br><span class="line"><span class="built_in">    Gui,</span> Msg:+Disabled -SysMenu +Owner</span><br><span class="line"><span class="built_in">    Gui,</span> Msg:Add, Text, w200 center, File creating...`nPlease wait...</span><br><span class="line"><span class="built_in">    Gui,</span> Msg:Show, NoActivate <span class="comment">; NoActivate 让当前活动窗口继续保持活动状态.</span></span><br><span class="line"><span class="built_in">    RunWait,</span> <span class="variable">%comSpec%</span> /c hexo <span class="keyword">new</span> post <span class="string">&quot;%FileName%&quot;</span>, , Hide</span><br><span class="line"><span class="built_in">    Gui,</span> Msg:Destroy</span><br><span class="line">    newFileName := StrReplace(FileName, <span class="built_in">A_Space</span>, <span class="string">&quot;-&quot;</span>) <span class="string">&quot;.md&quot;</span></span><br><span class="line"><span class="built_in">    Run,</span> <span class="variable">%newFileName%</span>, source\_posts, Hide</span><br><span class="line"><span class="keyword">Return</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 退出程序</span></span><br><span class="line"><span class="title">GuiEscape:</span></span><br><span class="line"><span class="title">GuiClose:</span></span><br><span class="line"><span class="keyword">ExitApp</span></span><br></pre></td></tr></table></figure><h2 id="修改上述部分代码"><a class="markdownIt-Anchor" href="#修改上述部分代码"></a> 修改上述部分代码</h2><ol><li>代码<strong>第3行</strong>处更换为自己的<strong>博客网址</strong>。</li><li>代码<strong>第4行</strong>处更换为自己的<strong>博客根目录地址</strong>。</li></ol><p>修改完成后，保存以上代码。</p><h1 id="使用方式"><a class="markdownIt-Anchor" href="#使用方式"></a> 使用方式</h1><ol><li><p>双击该文件即可使用。</p></li><li><p>也可以对该文件右键并选择 <code>Compile Script</code>，生成<code>exe</code>文件使用。</p></li></ol><h1 id="autohotkey-学习资料"><a class="markdownIt-Anchor" href="#autohotkey-学习资料"></a> <code>AutoHotKey</code> 学习资料</h1><ul><li><p><a href="https://www.autoahk.com/help/autohotkey/zh-cn/docs/AutoHotkey.htm">快速参考 | AutoHotkey (autoahk.com)</a></p></li><li><p><a href="https://wyagd001.github.io/zh-cn/docs/AutoHotkey.htm">快速参考 | AutoHotkey (wyagd001.github.io)</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;功能持续更新中！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;通过 &lt;code&gt;AutoHotKey&lt;/code&gt; 编写</summary>
      
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/categories/AutoHotKey/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
    <category term="AutoHotKey" scheme="https://luoyu-ying.github.io/tags/AutoHotKey/"/>
    
  </entry>
  
  <entry>
    <title>Activity - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/4aa0626e110f/"/>
    <id>https://luoyu-ying.github.io/posts/4aa0626e110f/</id>
    <published>2022-05-21T08:40:02.000Z</published>
    <updated>2022-05-29T06:54:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="activity的启动流程"><a class="markdownIt-Anchor" href="#activity的启动流程"></a> <code>Activity</code>的启动流程</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/cpcpcp123/article/details/122055099">面试：Activity的启动流程简述_沙漠一只雕得儿得儿的博客-CSDN博客_activity启动流程面试</a></li><li><a href="https://www.jianshu.com/p/6c55c169ba54">Android 系统启动 - SystemServer 进程 - 简书 (jianshu.com)</a></li></ul></blockquote><p>大致为以下过程：</p><ol><li><code>Launcher</code> 通过 <code>startActivity</code> 方法调用 <code>AMS</code>。</li><li><code>AMS</code> 向 <code>Zygote</code> 进程发送创建应用进程的请求。</li><li><code>Zygote</code> 进程接受请求并在 <code>main</code> 方法中孵化应用进程。</li><li>应用进程通过<code>SystemServer#main</code>启动<code>ActivityThread</code>。</li><li><code>Activity</code>的入口是<code>ActivityThread</code>的<code>main</code>函数，在<code>main</code>函数中创建一个新的<code>ActivityThread</code>对象，开启消息循环(UI线程)后创建新的<code>Activity</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SystemServer#main</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemServer</span>().run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// Ensure binder calls into the system always run at foreground priority.</span></span><br><span class="line">    <span class="comment">// 确保当前进程的 binder 调用总是运行在前台优先级</span></span><br><span class="line">    BinderInternal.disableBackgroundScheduling(<span class="literal">true</span>);</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// 创建主线程 Looper</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize native services.</span></span><br><span class="line">    <span class="comment">// 加载android_servers.so库，该库包含的源码在frameworks/base/services/目录下</span></span><br><span class="line">    System.loadLibrary(<span class="string">&quot;android_servers&quot;</span>);</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// Initialize the system context.</span></span><br><span class="line">    <span class="comment">// 初始化系统上下文</span></span><br><span class="line">    createSystemContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the system service manager.</span></span><br><span class="line">    <span class="comment">//创建系统服务管理</span></span><br><span class="line">    mSystemServiceManager = <span class="keyword">new</span> <span class="title class_">SystemServiceManager</span>(mSystemContext);</span><br><span class="line">    <span class="comment">// 将mSystemServiceManager添加到本地服务的成员sLocalServiceObjects</span></span><br><span class="line">    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start services.</span></span><br><span class="line">    <span class="comment">//  启动各种系统服务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startBootstrapServices(); <span class="comment">// 启动引导服务</span></span><br><span class="line">        startCoreServices();      <span class="comment">// 启动核心服务</span></span><br><span class="line">        startOtherServices();     <span class="comment">// 启动其他服务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// Loop forever.</span></span><br><span class="line">    <span class="comment">// 启动 Looper 循环</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="onsaveinstancestate和onrestoreinstancestate的调用时机"><a class="markdownIt-Anchor" href="#onsaveinstancestate和onrestoreinstancestate的调用时机"></a> <code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>的调用时机</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/cpcpcp123/article/details/113396301">Android onSaveInstanceState和onRestoreInstanceState调用时机、及大小限制_沙漠一只雕得儿得儿的博客-CSDN博客_onsaveinstancestate</a></li></ul></blockquote><p><strong><font size = "5">onSaveInstanceState(Bundle outState)</font></strong></p><p>当 Activity 在不正常销毁的情况下，就会调用 onSaveInstanceState 方法，并将 Activity 中需要保存的数据（比如 View 状态 或者我们自己的数据）保存到这个方法的参数 Bundle 中。</p><p><strong>onSaveInstanceState(Bundle outState)会在以下情况被调用</strong>：</p><ol><li>当用户按下HOME键时。</li><li>从最近应用中选择运行其他的程序时。</li><li>按下电源按键（关闭屏幕显示）时。</li><li>从当前activity启动一个新的activity时。</li><li>屏幕方向切换时(无论竖屏切横屏还是横屏切竖屏都会调用)。</li></ol><p><strong>Activity的onSaveInstanceState回调时机，取决于app的targetSdkVersion</strong>：</p><ul><li><p>targetSdkVersion低于11的app，onSaveInstanceState方法会在Activity.onPause之前回调；</p></li><li><p>targetSdkVersion低于28的app，则会在onStop之前回调；</p></li><li><p><strong>28之后，onSaveInstanceState在onStop回调之后才回调。</strong></p></li></ul><p><strong><font size = "5">onRestoreInstanceState(Bundle savedInstanceState)</font></strong></p><p>onRestoreInstanceState(Bundle savedInstanceState)只有在activity确实是被系统回收，重新创建activity的情况下才会被调用。</p><p><strong>onRestoreInstanceState(Bundle outState)会在以下情况被调用</strong>：</p><ol><li>屏幕方向切换时（无论竖屏切横屏还是横屏切竖屏都会调用）</li><li>由于内存紧张导致后台运行的程序被kill掉时（这种不太好模拟）</li></ol><p><strong>onRestoreInstanceState(Bundle outState)</strong> 的回调时机：</p><p>回调发生在<code>onStart</code>回调之后。</p><h1 id="oncreate和onrestoreinstance方法中恢复数据时的区别"><a class="markdownIt-Anchor" href="#oncreate和onrestoreinstance方法中恢复数据时的区别"></a> <code>onCreate</code>和<code>onRestoreInstance</code>方法中恢复数据时的区别</h1><p>因为<code>onSaveInstanceState</code> 不一定会被调用，所以<code>onCreate</code>里的<code>Bundle</code>参数可能为空，如果使用<code>onCreate</code>来恢复数据，一定要做非空判断。</p><p>而<code>onRestoreInstanceState</code>的<code>Bundle</code>参数一定不会是空值，因为它只有在上次<code>activity</code>被回收了才会调用。</p><h1 id="activity的数据是怎么保存的进程被kill后保存的数据怎么恢复的"><a class="markdownIt-Anchor" href="#activity的数据是怎么保存的进程被kill后保存的数据怎么恢复的"></a> <code>Activity</code>的数据是怎么保存的,进程被<code>Kill</code>后,保存的数据怎么恢复的？</h1><blockquote><p>答案参考自：</p><ul><li>《Android 开发艺术探索》</li></ul></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220521185305.png" style="zoom:67%;" /><p>通过<code>onSaveInstanceState</code>方法和<code>onRestoreInstanceState</code>方法进行数据的保存和恢复。</p><p>在 <code>onSaveInstanceState</code>和 <code>onRestoreInstanceState</code>方法中，系统自动为我们做了一定的恢复工作。当 <code>Activity</code> 在异常情况下需要重新创建时，系统会默认为我们保存当前<code>Activity</code> 的视图结构，并且在<code>Activity</code>重启后为我们恢复这些数据，比如文本框中用户输入的数据、<code>ListView</code>滚动的位置等。</p><h1 id="activity的启动模式和使用场景"><a class="markdownIt-Anchor" href="#activity的启动模式和使用场景"></a> <code>Activity</code>的启动模式和使用场景</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/sinat_14849739/article/details/78072401">Android中Activity的启动模式（LaunchMode）和使用场景_Shawpoo的博客-CSDN博客_launchmode</a></li></ul></blockquote><p>Activity的启动模式有四种：<strong><code>standard</code>、<code>singleTop</code>、<code>singleTask</code>和<code>singleInstance</code></strong>。</p><p><strong><font size="5">standard：标准模式</font></strong></p><p>这种启动模式为标准模式，也是默认模式。每当我们启动一个Activity，系统就会相应的创建一个实例，不管这个实例是否已经存在。这种模式，一个栈中可以有多个实例，每个实例也都有自己的任务栈。而且是谁启动了此Activity，那么这个Activity就运行在启动它的Activity所在的栈中。</p><p><strong>分析总结</strong></p><p><strong>标准模式下，只要启动一次Activity，系统就会在当前任务栈新建一个实例。</strong></p><p><strong>使用场景</strong></p><p>正常的去打开一个新的页面，这种启动模式使用最多，最普通 。</p><p><strong><font size="5">singleTop：栈顶复用模式</font></strong></p><p>这种启动模式下，如果要启动的Activity已经处于栈的顶部，那么此时系统不会创建新的实例，而是直接打开此页面，同时它的onNewIntent()方法会被执行，我们可以通过Intent进行传值，而且它的onCreate()，onStart()方法不会被调用，因为它并没有发生任何变化。</p><p><strong>分析总结</strong></p><ol><li>当前栈中已有该Activity的实例并且该实例位于栈顶时，不会创建实例，而是复用栈顶的实例，并且会将Intent对象传入，回调onNewIntent()方法；</li><li>当前栈中已有该Activity的实例但是该实例不在栈顶时，其行为和standard启动模式一样，依然会创建一个新的实例；</li><li>当前栈中不存在该Activity的实例时，其行为同standard启动模式。</li></ol><p><strong>使用场景</strong></p><p>这种模式应用场景的话，假如一个新闻客户端，在通知栏收到了3条推送，点击每一条推送会打开新闻的详情页，如果为默认的启动模式的话，点击一次打开一个页面，会打开三个详情页，这肯定是不合理的。如果启动模式设置为singleTop，当点击第一条推送后，新闻详情页已经处于栈顶，当我们第二条和第三条推送的时候，只需要通过Intent传入相应的内容即可，并不会重新打开新的页面，这样就可以避免重复打开页面了。</p><p><strong><font size="5">singleTask：栈内复用模式</font></strong></p><p>在这个模式下，如果栈中存在这个Activity的实例就会复用这个Activity，不管它是否位于栈顶，复用时，会将它上面的Activity全部出栈，因为singleTask本身自带clearTop这种功能。并且会回调该实例的onNewIntent()方法。其实这个过程还存在一个任务栈的匹配，因为这个模式启动时，会在自己需要的任务栈中寻找实例，这个任务栈就是通过taskAffinity属性指定。如果这个任务栈不存在，则会创建这个任务栈。不设置taskAffinity属性的话，默认为应用的包名。</p><p><strong>分析总结</strong></p><p>在复用的时候，首先会根据taskAffinity去找对应的任务栈：</p><ol><li>如果不存在指定的任务栈，系统会新建对应的任务栈，并新建Activity实例压入栈中。</li><li>如果存在指定的任务栈，则会查找该任务栈中是否存在该Activity实例<ol><li>如果不存在该实例，则会在该任务栈中新建Activity实例。</li><li>如果存在该实例，则会直接引用，并且回调该实例的onNewIntent()方法。并且任务栈中该实例之上的Activity会被全部销毁。</li></ol></li></ol><p><strong>使用场景</strong></p><p>SingleTask这种启动模式最常使用的就是一个APP的首页，因为一般为一个APP的第一个页面，且长时间保留在栈中，所以最适合设置singleTask启动模式来复用。</p><p><strong><font size="5">singleInstance：单实例模式</font></strong></p><p>单实例模式，顾名思义，只有一个实例。该模式具备singleTask模式的所有特性外，与它的区别就是，这种模式下的<strong>Activity会单独占用一个Task栈，具有全局唯一性</strong>，即整个系统中就这么一个实例，由于栈内复用的特性，后续的请求均不会创建新的Activity实例，除非这个特殊的任务栈被销毁了。以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例。</p><p><strong>分析总结</strong></p><p>启动该模式Activity的时候，会查找系统中是否存在：</p><ol><li>不存在，首先会新建一个任务栈，其次创建该Activity实例。</li><li>存在，则会直接引用该实例，并且回调onNewIntent()方法。</li><li>特殊情况：该任务栈或该实例被销毁，系统会重新创建。</li></ol><p><strong>使用场景</strong></p><p>很常见的是，电话拨号盘页面，通过自己的应用或者其他应用打开拨打电话页面 ，只要系统的栈中存在该实例，那么就会直接调用。</p><p><strong><font size="5">总结</font></strong></p><p>在使用APP过程中，不可避免页面之间的跳转，那么就会涉及到启动模式。其实在对界面进行跳转时，Android系统既能在同一个任务中对Activity进行调度，也能以Task（任务栈）为单位进行整体调度。在启动模式为standard或singleTop时，一般是在同一个任务中对Activity进行调度，而在启动模式为singleTask或singleInstance是，一般会对Task进行整体调度。</p><h1 id="activity的onnewintent方法什么时候会执行"><a class="markdownIt-Anchor" href="#activity的onnewintent方法什么时候会执行"></a> <code>Activity</code>的<code>onNewIntent</code>方法什么时候会执行</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.jianshu.com/p/8897068505d8">Android中的onNewIntent()函数 - 简书 (jianshu.com)</a></li></ul></blockquote><p><strong>使用<code>SingleTask</code>以及<code>SingleInstance</code>启动模式的时候，会调用<code>onNewInstance</code>方法。</strong></p><p><code>Activity</code>第一次启动的时候执行<code>onCreate</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>等后续生命周期函数，也就时说第一次启动Activity并不会执行到<code>onNewIntent</code>。</p><p>而后面如果再有想启动<code>Activity</code>的时候，那就是执行 <strong><code>onNewIntent</code> -&gt; <code>onResart</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code></strong>。</p><p>如果Android系统由于内存不足把已存在<code>Activity</code>释放掉了，那么再次调用的时候会重新启动<code>Activity</code>即执行<code>onCreate</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>等。</p><p>当调用到<code>onNewIntent(intent)</code>的时候，需要在<code>onNewIntent</code>中使用<code>setIntent(intent)</code>赋值给<code>Activity</code>的<code>Intent</code>。否则，后续的<code>getIntent</code>都是得到旧的<code>Intent</code>。</p><h1 id="activity-生命周期"><a class="markdownIt-Anchor" href="#activity-生命周期"></a> <code>Activity</code> 生命周期</h1><blockquote><p>答案参考自：</p><ul><li><p>《Android 开发艺术探索》</p></li><li><p><a href="https://blog.csdn.net/xiajun2356033/article/details/78741121">activity生命周期（这篇足够了）_android_Mr_夏的博客-CSDN博客</a></p></li></ul></blockquote><img src="https://lly-blog-img.oss-cn-hangzhou.aliyuncs.com/images/20220521182943.png" alt="Activity的生命周期" style="zoom:67%;" /><ol><li><p><code>onCreate</code></p><p>表示 Activity 正在被创建，这是生命周期的第一个方法。在这个方法中,我们可以做一些<strong>初始化工作</strong>,比如调用<strong>setContentView</strong>去加载界面布局资源,初始化Activity所需数据等。</p></li><li><p><code>onStart</code></p><p>表示Activity正在被启动，即将开始，这时 Activity已经<strong>可见</strong>了，但是还<strong>没有出现在前台</strong>，还<strong>无法和用户交互</strong>。这个时候其实可以理解为Activity已经显示出来了，但是我们还<strong>看不到</strong>。</p></li><li><p><code>onResume</code></p><p>表示 Activity<strong>已经可见</strong>了，并且<strong>出现在前台并开始活动</strong>。</p><p>要注意这个和 onStart的对比, onStart和onResume都表示Activity已经可见,但是onStart的时候Activity还在后台，onResume的时候Activity才显示到前台。</p></li><li><p><code>onPause</code></p><p>表示Activity正在停止，正常情况下，紧接着onStop就会被调用。</p><p>在特殊情况下，如果这个时候快速地再回到当前Activity，那么onResume会被调用。笔者的理解是，这种情况属于极端情况，用户操作很难重现这一场景。</p><p><strong>当前Activity是可见的，但不能与用户交互状态（即不在前台）。</strong></p><p>此时可以做一些<strong>存储数据、停止动画</strong>等工作，但是注意<strong>不能太耗时</strong>，因为这会影响到新Activity的显示，<strong>onPause必须先执行完，新Activity 的onResume才会执行。</strong></p></li><li><p><code>onStop</code></p><p>表示Activity即将停止，此时Activity对用户是<strong>不可见</strong>的，可以做一些稍微重量级的回收工作，同样<strong>不能太耗时</strong>。</p><p>在系统内存紧张的情况下，有可能会被系统进行回收，所以一般在当前方法可做资源回收。</p></li><li><p><code>onDestroy</code></p><p>表示Activity即将被销毁，这是Activity生命周期中的最后一个回调,在这里我们可以做一些<strong>回收工作和最终的资源释放</strong>。</p></li><li><p><code>onRestart</code></p><p>表示Activity正在重新启动。一般情况下，当当前Activity 从<strong>不可见重新变为可见状态</strong>时，onRestart就会被调用。</p><p>这种情形一般是用户行为所导致的，比如用户按Home键切换到桌面或者用户打开了一个新的Activity，这时当前的Activity就会暂停，也就是onPause和 onStop被执行了，接着用户又回到了这个Activity，就会出现这种情况。</p></li></ol><p><strong>具体情况分析</strong>：</p><ol><li><p>针对一个特定的Activity,<strong>第一次启动</strong>,回调如下：<code>onCreate</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>。</p></li><li><p>当用户<strong>打开新的Activity</strong>或者<strong>切换到桌面</strong>的时候，回调如下： <code>onPause</code> -&gt; <code>onStop</code>。</p><p>这里有一种特殊情况,如果新Activity 采用了透明主题,那么当前Activity不会回调<code>onStop</code>。</p></li><li><p>当用户<strong>再次回到原Activity</strong> 时，回调如下： <code>onRestart</code> -&gt; <code>onStart</code> -&gt; <code>onResume</code>。</p></li><li><p>当用户<strong>按back键回退</strong>时，回调如下: <code>onPause</code> -&gt; <code>onStop</code> -&gt; <code>onDestroy</code>。</p></li><li><p>当<strong>Activity被系统回收后再次打开</strong>，生命周期方法回调过程和（1）一样，注意只是生命周期方法一样，不代表所有过程都一样，比如<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>的调用。</p></li><li><p>从<strong>Activity_A跳转到Activity_B</strong>，会先执行A活动的<code>onPause</code>，再执行B活动的<code>onResume</code>。</p></li><li><p>从<strong>整个生命周期</strong>来说，<code>onCreate</code>和 <code>onDestroy</code>是配对的，分别标识着Activity 的创建和销毁，并且只可能有一次调用。</p></li><li><p>从<strong>Activity是否可见</strong>来说，<code>onStart</code>和 <code>onStop</code>是配对的，随着用户的操作或者设备屏幕的点亮和熄灭，这两个方法可能被调用多次。</p></li><li><p>从 <strong>Activity是否在前台</strong>来说，<code>onResume</code>和 <code>onPause</code>是配对的,随着用户操作或者设备屏幕的点亮和熄灭，这两个方法可能被调用多次。</p></li></ol><table><thead><tr><th>生命周期</th><th>是否可见</th><th>是否在前台</th></tr></thead><tbody><tr><td><code>onStart</code></td><td>是</td><td>否</td></tr><tr><td><code>onResume</code></td><td>是</td><td>是</td></tr><tr><td><code>onPause</code></td><td>是</td><td>否</td></tr><tr><td><code>onStop</code></td><td>否</td><td>否</td></tr></tbody></table><h1 id="onstart-和-onresume-onpause-和-onstop-的区别"><a class="markdownIt-Anchor" href="#onstart-和-onresume-onpause-和-onstop-的区别"></a> <code>onStart</code> 和 <code>onResume</code>、<code>onPause</code> 和 <code>onStop</code> 的区别</h1><blockquote><p>答案参考自：</p><ul><li>《Android 开发艺术探索》</li></ul></blockquote><p>从实际使用过程来说，<code>onStart</code>和 <code>onResume</code>、<code>onPause</code>和 <code>onStop</code>看起来的确差不多，甚至我们可以只保留其中一对，比如只保留<code>onStart</code>和 <code>onStop</code>。既然如此,那为什么Android系统还要提供看起来重复的接口呢？</p><p>根据上面的分析，我们知道，这两个配对的回调分别表示不同的意义，<code>onStart</code>和 <code>onStop</code>是从<strong>Activity是否可见</strong>这个角度来回调的，而 <code>onResume</code>和 <code>onPause</code>是从<strong>Activity是否位于前台</strong>这个角度来回调的，除了这种区别，在实际使用中没有其他明显区别。</p><h1 id="activity的显式启动和隐式启动"><a class="markdownIt-Anchor" href="#activity的显式启动和隐式启动"></a> <code>Activity</code>的显式启动和隐式启动</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/lrq851215/article/details/62881056">显示和隐式启动Activity的方式_卩s秋灬的博客-CSDN博客</a></li></ul></blockquote><p>启动Activity主要是通过Intent（意图）来实现。主要分为显示的和隐式的两种。</p><p><strong><font size="4">隐式启动 <code>Activity</code></font></strong></p><p>优点：</p><ol><li>只要知道被启动<code>Activity</code>的<code>Action</code>和<code>Category</code>即可，不用知道对应的类名或者是包名。</li><li>只要<code>Activity</code>有对应的<code>Action</code>和<code>Category</code>都会被启动起来。然后提供给用户选择要启动哪一个。</li></ol><p>需要被启动的<code>Activity</code>，需要在自己的<code>AndroidManifest.xml</code>定义对应的<code>action</code> 和 <code>category</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;com.android.activity.demo.SecondActivity&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:label</span>=<span class="string">&quot;@string/second_activity_name&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.SECONDACTIVITY_START&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动<code>Activity</code>的地方，把对应的<code>Action</code>填入即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startSecondActivityByAction</span><span class="params">()</span> &#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;startSecondActivityByAction()&quot;</span>);</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">    intent.setAction(<span class="string">&quot;android.intent.action.SECONDACTIVITY_START&quot;</span>);</span><br><span class="line">    intent.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;start activity error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font size="4">显示启动 <code>Activity</code></font></strong></p><p>不足：</p><ol><li>被启动的应用的包名或者类名发生变化后，就会无法启动。</li></ol><p>通过类名类启动Activity， 一般是同一个APK里面使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startSecondActivityByClass</span><span class="params">()</span> &#123;</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;startSecondActivityByClass()&quot;</span>);</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(FirstActivity.<span class="built_in">this</span>, SecondActivity.class);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">&quot;start activity error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="activity间传递数据的方式"><a class="markdownIt-Anchor" href="#activity间传递数据的方式"></a> <code>Activity</code>间传递数据的方式</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/u010112268/article/details/83832021">关于Android Activity之间传递数据的6种方式_淼淼1111的博客-CSDN博客_activity传递数据</a></li></ul></blockquote><p>共六种传递数据的方式。</p><ol><li><p><strong>使用Intent的putExtra传递</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建意图对象</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>,TwoActivity.class);</span><br><span class="line"><span class="comment">//设置传递键值对</span></span><br><span class="line">intent.putExtra(<span class="string">&quot;data&quot;</span>,str);</span><br><span class="line"><span class="comment">//激活意图</span></span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>第二个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取意图对象</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line"><span class="comment">//获取传递的值</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;data&quot;</span>);</span><br><span class="line"><span class="comment">//设置值</span></span><br><span class="line">tv.setText(str);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用Intention的Bundle传递</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建意图对象</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>,TwoActivity.class);</span><br><span class="line"><span class="comment">//用数据捆传递数据</span></span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">bundle.putString(<span class="string">&quot;data&quot;</span>, str);</span><br><span class="line"><span class="comment">//把数据捆设置改意图</span></span><br><span class="line">intent.putExtra(<span class="string">&quot;bun&quot;</span>, bundle);</span><br><span class="line"><span class="comment">//激活意图</span></span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>第二个Activity</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Bundle</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> intent.getBundleExtra(<span class="string">&quot;bun&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> bundle.getString(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">tv.setText(str);</span><br></pre></td></tr></table></figure></li><li><p><strong>使用Activity销毁时传递数据(startActivityForResult)</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>,TwoActivity.class);</span><br><span class="line"><span class="comment">//用一种特殊方式开启Activity</span></span><br><span class="line">startActivityForResult(intent, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置数据</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onActivityResult</span><span class="params">(<span class="type">int</span> requestCode, <span class="type">int</span> resultCode, Intent data)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> data.getStringExtra(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">    tvOne.setText(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置返回的数据</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.putExtra(<span class="string">&quot;data&quot;</span>, edtOne.getText().toString().trim());</span><br><span class="line">setResult(<span class="number">3</span>, intent);</span><br><span class="line"><span class="comment">//关闭当前activity</span></span><br><span class="line">finish();</span><br></pre></td></tr></table></figure></li><li><p><strong>SharedPreferences传递数据</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SharedPreferences</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="built_in">this</span>.getSharedPreferences(<span class="string">&quot;info&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//获取sp编辑器</span></span><br><span class="line"><span class="type">Editor</span> <span class="variable">edit</span> <span class="operator">=</span> sp.edit();</span><br><span class="line">edit.putString(<span class="string">&quot;data&quot;</span>, str);</span><br><span class="line">edit.commit();</span><br><span class="line"><span class="comment">//创建意图对象</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>,TwoActivity.class);</span><br><span class="line"><span class="comment">//激活意图</span></span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>第二个activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SharedPreferences</span> <span class="variable">sp</span> <span class="operator">=</span> <span class="built_in">this</span>.getSharedPreferences(<span class="string">&quot;info&quot;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//设置数据</span></span><br><span class="line">tv.setText(sp.getString(<span class="string">&quot;data&quot;</span>, <span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p><strong>使用序列化对象Seriazable</strong></p><p>工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataBean</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建意图</span></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>,TwoActivity.class);</span><br><span class="line"><span class="type">DataBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataBean</span>();</span><br><span class="line"><span class="comment">//通过set方法把数据保存到DataBean对象中</span></span><br><span class="line">bean.setName(<span class="string">&quot;啦啦&quot;</span>);</span><br><span class="line">bean.setSex(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;key&quot;</span>, bean);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>第二个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line"><span class="comment">//反序列化数据对象</span></span><br><span class="line"><span class="type">Serializable</span> <span class="variable">se</span> <span class="operator">=</span> intent.getSerializableExtra(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(se <span class="keyword">instanceof</span> DataBean)&#123;</span><br><span class="line">    <span class="comment">//获取到携带数据的DataBean对象db</span></span><br><span class="line">    <span class="type">DataBean</span> <span class="variable">db</span> <span class="operator">=</span> (DataBean) se;</span><br><span class="line">    tv.setText(db.getName() + <span class="string">&quot;===&quot;</span> + db.getSex());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用静态变量传递数据</strong></p><p>第一个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(MainActivity.<span class="built_in">this</span>,TwoActivity.class);</span><br><span class="line">TwoActivity.name = <span class="string">&quot;NAME&quot;</span>;</span><br><span class="line">TwoActivity.str = <span class="string">&quot;STR&quot;</span>;</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><p>第二个Activity中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态变量</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> String name;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> String str;</span><br><span class="line">tv.setText(str + name);</span><br></pre></td></tr></table></figure></li></ol><h1 id="有哪些activity常用的标记位flags"><a class="markdownIt-Anchor" href="#有哪些activity常用的标记位flags"></a> 有哪些<code>Activity</code>常用的标记位<code>Flags</code></h1><ol><li><p><code>FLAG_ACTIVITY_NEW_TASK</code></p><p>指定启动模式为SingleTask</p></li><li><p><code>FLAG_ACTIVITY_SINGLE_TOP</code></p><p>指定启动模式为SingleTop</p></li><li><p><code>FLAG_ACTIVITY_CLEAR_TOP</code></p><p>一般与SingleTask启动模式一起出现，启动时位于它上方的Activity出栈，如果被启动的Activity实例已存在，系统则会调用它的onNewIntent</p></li></ol><h1 id="activity任务栈是什么"><a class="markdownIt-Anchor" href="#activity任务栈是什么"></a> <code>Activity</code>任务栈是什么</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/Lwenlong/p/15939583.html">Android面试——Activity篇 - 向着内核前进！ - 博客园 (cnblogs.com)</a></li></ul></blockquote><p>即Task，栈结构，存放Activity；退出应用程序时只有将所有任务栈找那个的所有Activity出栈，任务栈才能销毁。</p><p>任务栈可以移动到后台，在其中保留每一个Activity的状态。</p><p>对应的类：ActivityRecord、TaskRecord、ActivityStack。</p><h1 id="跨app启动activity的方式注意事项"><a class="markdownIt-Anchor" href="#跨app启动activity的方式注意事项"></a> 跨<code>App</code>启动<code>Activity</code>的方式,注意事项</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/Lwenlong/p/15939583.html">Android面试——Activity篇 - 向着内核前进！ - 博客园 (cnblogs.com)</a></li><li>《Android 开发艺术探索》</li></ul></blockquote><ol><li><p>指定打开的应用</p><p>通过Intent 隐式启动时，如果有多个action值相同的Activity，系统会让你选择启动哪个，解决办法时通过指定Intent-filter的 <code>data</code>属性，Intent 则要加上一个URI，该URI的scheme必须与data的scheme相同。</p><blockquote><p>data由两部分组成，mimeType和 URI。mimeType指媒体类型，比如 image/ijpeg.audio/mpeg4-generic和 video/*等，可以表示图片、文本、视频等不同的媒体格式，而URI中包含的数据就比较多了，下面是URI的结构：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]</span><br></pre></td></tr></table></figure><p>Scheme：URI的模式，比如 http、file、content等，如果URI中没有指定scheme，那么整个URI的其他参数无效，这也意味着URI是无效的。</p></blockquote></li><li><p>如何防止自己的Activity被外部非正常启动</p><p>给自己的Activity 添加<code>android:permission=”xxx.xxx.xx”</code>，那么想要访问你的Activity就必须声明<code>uses-permission xxx.xxx.xx</code></p></li></ol><h1 id="anr-的四种场景"><a class="markdownIt-Anchor" href="#anr-的四种场景"></a> <code>ANR</code> 的四种场景</h1><blockquote><p>答案参考自：</p><ul><li><a href="https://blog.csdn.net/xingyu19911016/article/details/122080235">ANR 的四种场景_橙子19911016的博客-CSDN博客_anr的四种场景</a></li></ul></blockquote><ol><li><p><code>Service TimeOut</code></p><p><code>Service</code>未在规定时间执行完成，前台服务20s，后台200s。</p></li><li><p><code>BroadCastQueue TimeOut</code></p><p>未在规定时间内未处理完广播，前台广播10s内，后台60s内。</p></li><li><p><code>ContentProvider TimeOut</code></p><p><code>publish</code>在10s内没有完成。</p></li><li><p><code>Input Dispatching timeout</code></p><p>5s内未响应键盘输入、触摸屏幕等事件。</p></li></ol><p>Activity的生命周期回调的阻塞并不在触发ANR的场景里面，所以并不会直接触发ANR。 只不过死循环阻塞了主线程，如果系统再有上述的四种事件发生，就无法在相应的时间内处理从而触发ANR。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;activity的启动流程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#activity的启动流程&quot;&gt;&lt;/a&gt; &lt;code&gt;Activity&lt;/code&gt;的启动流程&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;答案参考自：&lt;/p&gt;
&lt;u</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="Android" scheme="https://luoyu-ying.github.io/categories/Android/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="Activity" scheme="https://luoyu-ying.github.io/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 提交出现 FATAL err Error Spawn failed</title>
    <link href="https://luoyu-ying.github.io/posts/b6ee2f2e134b/"/>
    <id>https://luoyu-ying.github.io/posts/b6ee2f2e134b/</id>
    <published>2022-05-20T09:22:43.000Z</published>
    <updated>2022-05-20T09:22:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h1><p>当我们使用 <code>Hexo</code> 博客，在提交的时候可能会出现以下的错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FATAL &#123;</span><br><span class="line">    err: Error: Spawn failed</span><br><span class="line">        at ChildProcess.&lt;anonymous&gt; (node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">        at ChildProcess.emit (node:events:390:28)</span><br><span class="line">        at ChildProcess.cp.emit (node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">        at Process.ChildProcess._handle.onexit (node:internal/child_process:290:12) &#123;</span><br><span class="line">         code: 128</span><br><span class="line">     &#125;</span><br><span class="line">&#125; Something&#x27;s wrong. Maybe you can find the solution here: ...</span><br></pre></td></tr></table></figure><h1 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h1><p>打开博客根目录下的  <strong><code>_config.yml</code></strong> 文件，并找到以下段落：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/...</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>将原来 <code>repo</code> 处 <code>HTTPS</code> 格式的仓库地址（<code>https://github.com/...</code>）换成 <code>SSH</code> 格式的仓库地址（<code>git@github.com:...</code>）后，重新推送即可解决。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在博客根目录下，通过 cmd 或 git 输入该命令重新推送。 </span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#问题描述&quot;&gt;&lt;/a&gt; 问题描述&lt;/h1&gt;
&lt;p&gt;当我们使用 &lt;code&gt;Hexo&lt;/code&gt; 博客，在提交的时候可能会出现以下的错误：&lt;/p&gt;
&lt;figure class=&quot;hi</summary>
      
    
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://luoyu-ying.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>序列化 - Android校招面试整理</title>
    <link href="https://luoyu-ying.github.io/posts/1718d96306cd/"/>
    <id>https://luoyu-ying.github.io/posts/1718d96306cd/</id>
    <published>2022-05-20T08:44:02.000Z</published>
    <updated>2022-05-20T08:45:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>答案参考自：</p><ul><li><a href="https://www.cnblogs.com/douzi520/p/9497889.html">Java中序列化的好处及意义 - 久孤丶 - 博客园 (cnblogs.com)</a></li><li><a href="https://www.jianshu.com/p/2ed41bb7aa3a">Serializable和Parcelable区别 - 简书 (jianshu.com)</a></li></ul></blockquote><h1 id="什么是序列化"><a class="markdownIt-Anchor" href="#什么是序列化"></a> 什么是序列化？</h1><p><strong>序列化：</strong> 把对象转化为可传输的字节序列过程称为序列化。</p><p><strong>反序列化：</strong> 把字节序列还原为对象的过程称为反序列化。</p><h1 id="为什么需要使用序列化和反序列化"><a class="markdownIt-Anchor" href="#为什么需要使用序列化和反序列化"></a> 为什么需要使用序列化和反序列化？</h1><p>目的是为了对象可以<strong>跨平台存储，和进行网络传输</strong>。</p><h1 id="序列化的有哪些好处"><a class="markdownIt-Anchor" href="#序列化的有哪些好处"></a> 序列化的有哪些好处</h1><p>对对象进行序列化操作，可以极大程度的方便传输。</p><h1 id="什么情况下需要序列化"><a class="markdownIt-Anchor" href="#什么情况下需要序列化"></a> 什么情况下需要序列化</h1><ol><li>当你想把的内存中的对象保存到一个文件中或者数据库中时候。</li><li>当你想用序列化在网络上传送对象的时候。</li></ol><h1 id="什么是serialversionuid"><a class="markdownIt-Anchor" href="#什么是serialversionuid"></a> 什么是<code>serialVersionUID</code></h1><p><code>serialVersionUID</code>是用来辅助序列化和反序列化的过程。原则上序列化后的数据中的<code>serialVersionUID</code>只有和当前类的<code>serialVersionUID</code>一致才能成功的反序列化。</p><h1 id="为什么还要显示指定serialversionuid的值"><a class="markdownIt-Anchor" href="#为什么还要显示指定serialversionuid的值"></a> 为什么还要显示指定<code>serialVersionUID</code>的值?</h1><p><code>serialVersionUID</code>的详细工作机制是这样的：</p><p>序列化的时候系统会把当前类的<code>serialVersionUID</code>写入序列化的文件中(也可能是其他中介)。当反序列化的时候系统会去检测文件中的<code>serialVersionUID</code>，看它是否和当前类的<code>serialVersionUID</code>一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则就说明当前类和序列化的类相比发生了某些变换，比如成员变量的数量、类型可能会发生变化，这时候就无法正常的反序列化。</p><p>以一般来说，我们应该手动去指定<code>serialVersionUID</code>的值，比如&quot;1L&quot;,也可以让IDE根据当前类的结构去生成对应的<code>hash</code>值，这样序列化和反序列化时两者的<code>serialVersionUID</code>是相同的，因此可以正常的进行反序列化。如果不不设置<code>serialVersionUID</code>，系统在序列化的时候默认会根据类的结构在生成对应的<code>serialVersionUID</code>，在反序列化的时候，如果当类有变化，比如增加或者减少字段，这时候当前的类的<code>serialVersionUID</code>和序列化的时候的<code>serialVersionUID</code>就不一样了，就会出现反序列化失败，如果没有捕获异常会导致<code>crash</code>。</p><p><strong>所以当我们手动指定了它之后，就可以很大程度上避免了反序列化过程的失败。</strong></p><p>比如当版本升级以后，我们可能删除了某个成员变量也可能增加一些新的成员变量，这个时候我们的反序列化过程仍然可以成功，程序仍然能够最大限度地恢复数据。相反 如果我们没有指定<code>serialVersionUID</code>的话，程序就会挂掉。</p><p>当然我们也要考虑到另外一种情况，如果类结构发生了非常规性的改变，比如修改了类名，修改了成员变量的类型，这个时候尽管<code>serialVersionUID</code>验证通过了，但是反序列化过程还是会失败，因为类的而结构有了重大改变，根本无法从老版本的数据还原出一个新的类结构对象。</p><p><strong>注意</strong></p><ol><li><p>静态成员变量属于类，不属于对象，所以不会参与序列化的过程</p></li><li><p>用transient关键字编辑的成员变量不参与序列化的过程。</p></li><li><p>可以通过重写<code>writeObject</code>和<code>readObject</code>两个方法来重写系统默认的序列化和反序列化的过程。不过并不推荐。</p></li></ol><h1 id="serializable-和-parcelable-的区别"><a class="markdownIt-Anchor" href="#serializable-和-parcelable-的区别"></a> <code>Serializable</code> 和 <code>Parcelable</code> 的区别</h1><p><strong>1、平台区别</strong></p><ul><li><code>Serializable</code>是属于 <code>Java</code> 自带的，表示一个对象可以转换成可存储或者可传输的状态，序列化后的对象可以在网络上进行传输，也可以存储到本地。</li><li><code>Parcelable</code> 是属于 <code>Android</code> 专用。不过不同于<code>Serializable</code>，<code>Parcelable</code>实现的原理是将一个完整的对象进行分解。而分解后的每一部分都是Intent所支持的数据类型。</li></ul><p><strong>2、编写上的区别</strong></p><ul><li><code>Serializable</code>代码量少，写起来方便</li><li><code>Parcelable</code>代码多一些，略复杂</li></ul><p><strong>3、选择的原则</strong></p><ul><li>如果是仅仅在内存中使用，比如<code>activity</code>、<code>service</code>之间进行对象的传递，强烈推荐使用<code>Parcelable</code>，因为<code>Parcelable</code>比<code>Serializable</code>性能高很多。因为<code>Serializable</code>在序列化的时候会产生大量的临时变量， 从而引起频繁的<code>GC</code>。</li><li>如果是持久化操作，推荐<code>Serializable</code>，虽然<code>Serializable</code>效率比较低，但是还是要选择它，因为在外界有变化的情况下，<code>Parcelable</code>不能很好的保存数据的持续性。</li></ul><p><strong>4、本质的区别</strong></p><ul><li><code>Serializable</code>的本质是使用了反射，序列化的过程比较慢，这种机制在序列化的时候会创建很多临时的对象，比引起频繁的GC、</li><li><code>Parcelable</code>方式的本质是将一个完整的对象进行分解，而分解后的每一部分都是<code>Intent</code>所支持的类型，这样就实现了传递对象的功能了。</li></ul><h1 id="java-transient-解析"><a class="markdownIt-Anchor" href="#java-transient-解析"></a> Java <code>transient</code> 解析</h1><ol><li><code>transient</code> 关键字<strong>只能修饰变量，而不能修饰方法和类</strong>。注意，本地变量是不能被 <code>transient</code> 关键字修饰的。变量如果是用户自定义的类变量，则该类是要实现 <code>Serializable</code> 接口。</li><li>一旦变量被 <code>transient</code> 修饰，变量将不是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li><li>静态变量不管是否被 <code>transient</code> 修饰，都无法被序列化。</li></ol><p><strong>注意： 被 <code>transient</code> 修饰的变量也是可以被序列化的。</strong></p><p>Java 中，对象的序列化可以通过实现两个接口实现：</p><ul><li>若实现的是 <code>Serializable</code> 接口，则所有的序列化都将会自动进行，被 <code>transient</code> 修饰的变量将不会被序列化。</li><li>若实现的是 <code>Externalizable</code> 接口，则任何东西都需要自己在 <code>writeExternal</code> 方法中自己手动指定需要序列化的变量。任何变量都可以序列化，与变量是否被 <code>transient</code> 修饰无关。</li></ul><h1 id="其他注意事项"><a class="markdownIt-Anchor" href="#其他注意事项"></a> 其他注意事项</h1><ol><li>当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</li><li>当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</li><li>并非所有的对象都可以序列化，,至于为什么不可以，有很多原因了。比如：<ol><li>安全方面的原因，比如一个对象拥有<code>private</code>，<code>public</code>等<code>field</code>，对于一个要传输的对象，比如写到文件，或者进行<code>RMI</code>传输 等等，在序列化进行传输的过程中，这个对象的<code>private</code>等域是不受保护的。</li><li>资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;答案参考自：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/douzi520/p/9497889.html&quot;&gt;Java中序列化的好处及意义 - 久孤丶 - 博客园 (cnblogs.com)&lt;/a&gt;&lt;/</summary>
      
    
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/categories/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="Android" scheme="https://luoyu-ying.github.io/categories/Android/"/>
    
    
    <category term="校招面试整理" scheme="https://luoyu-ying.github.io/tags/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    
    <category term="序列化" scheme="https://luoyu-ying.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
</feed>
