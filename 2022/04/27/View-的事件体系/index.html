<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>View 的事件体系 | 洛语 の Blog</title><meta name="keywords" content="Android,View"><meta name="author" content="LuoYu-Ying"><meta name="copyright" content="LuoYu-Ying"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="View基础知识  一、View的相关坐标和位置  先来了解一个概念： view动画不改变view的真实位置，就是肉眼看上去，view位置发生了变化，但是它的点击区域还是在原来的位置。 为了方便描述，下文中的的 真实View，表示真实位置的View，看到的View，表示肉眼看到的View。 属性动画和 setTranslationX &#x2F; setTranslationY ，会改变显示位置和真实位置">
<meta property="og:type" content="article">
<meta property="og:title" content="View 的事件体系">
<meta property="og:url" content="https://luoyu-ying.github.io/2022/04/27/View-%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/index.html">
<meta property="og:site_name" content="洛语 の Blog">
<meta property="og:description" content="View基础知识  一、View的相关坐标和位置  先来了解一个概念： view动画不改变view的真实位置，就是肉眼看上去，view位置发生了变化，但是它的点击区域还是在原来的位置。 为了方便描述，下文中的的 真实View，表示真实位置的View，看到的View，表示肉眼看到的View。 属性动画和 setTranslationX &#x2F; setTranslationY ，会改变显示位置和真实位置">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/id=2318466(じむ(kaji).jpg">
<meta property="article:published_time" content="2022-04-27T11:49:25.000Z">
<meta property="article:modified_time" content="2022-04-27T13:08:48.350Z">
<meta property="article:author" content="LuoYu-Ying">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="View">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/id=2318466(じむ(kaji).jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://luoyu-ying.github.io/2022/04/27/View-%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'View 的事件体系',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-27 21:08:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/post-transparent.css"><style>#article-container.post-content h1:before, h2:before, h3:before, h4:before, h5:before, h6:before { -webkit-animation: avatar_turn_around 1s linear infinite; -moz-animation: avatar_turn_around 1s linear infinite; -o-animation: avatar_turn_around 1s linear infinite; -ms-animation: avatar_turn_around 1s linear infinite; animation: avatar_turn_around 1s linear infinite; }</style><link rel="stylesheet" href="/css/white-code-box.css"><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="洛语 の Blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/default-cover.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 日常</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/toolbox/"><i class="fa-fw fas fa-box"></i><span> 工具箱</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/id=2318466(じむ(kaji).jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">洛语 の Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 日常</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/toolbox/"><i class="fa-fw fas fa-box"></i><span> 工具箱</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">View 的事件体系</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-27T11:49:25.000Z" title="发表于 2022-04-27 19:49:25">2022-04-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-27T13:08:48.350Z" title="更新于 2022-04-27 21:08:48">2022-04-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="View 的事件体系"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="view基础知识"><a class="markdownIt-Anchor" href="#view基础知识"></a> View基础知识</h1>
<h2 id="一-view的相关坐标和位置"><a class="markdownIt-Anchor" href="#一-view的相关坐标和位置"></a> 一、<code>View</code>的相关坐标和位置</h2>
<img src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/20180802114150486" alt="这里写图片描述" style="zoom: 80%;" />
<p><strong>先来了解一个概念：</strong></p>
<p><code>view动画</code>不改变<code>view</code>的真实位置，就是肉眼看上去，<code>view</code>位置发生了变化，但是它的点击区域还是在原来的位置。</p>
<p>为了方便描述，下文中的的 <code>真实View</code>，表示真实位置的<code>View</code>，<code>看到的View</code>，表示肉眼看到的<code>View</code>。</p>
<p>属性动画和 <code>setTranslationX</code> / <code>setTranslationY</code> ，会改变显示位置和真实位置。</p>
<p>上图中<code>view1</code>是初始位置，通过执行<code>setTranslation</code>函数，得到的<code>view2</code>位置，其中<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>这几个值不会改变。</p>
<h3 id="lefttoprightbottom"><a class="markdownIt-Anchor" href="#lefttoprightbottom"></a> <code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code></h3>
<p><code>View</code>的位置主要由它的四个顶点的位置来决定，分别对应 View 的四个属性：<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>。对应的函数是<code>getLeft</code>，<code>getTop</code>，<code>getRight</code>，<code>getBottom</code>。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>left</code></td>
<td><code>View</code> 左上顶点相对于父容器的横坐标</td>
</tr>
<tr>
<td><code>top</code></td>
<td><code>View</code> 左上顶点相对于父容器的纵坐标</td>
</tr>
<tr>
<td><code>right</code></td>
<td><code>View</code> 右下顶点相对于父容器的横坐标</td>
</tr>
<tr>
<td><code>bottom</code></td>
<td><code>View</code> 右下顶点相对于父容器的纵坐标</td>
</tr>
</tbody>
</table>
<p>这几个值表示的是View的真身位置，它表示哪里，点击区域就在哪里。和肉眼在屏幕上看到的位置可能不一样。</p>
<h3 id="xy"><a class="markdownIt-Anchor" href="#xy"></a> <code>X</code>，<code>Y</code></h3>
<p>上面说到view动画不改变<code>view</code>的真实位置（也就是不改变<code>view</code>的<code>left</code>，<code>top</code>，<code>right</code>，<code>bottom</code>）。</p>
<p>看到的view相对于真实<code>view</code>，位置发生了变化，但是它的点击区域还是在真实view的位置。</p>
<p>从 Android 3.0 开始，<code>View</code> 增加了 x，y，<code>translationX</code> 和 <code>translationY</code>。</p>
<p>x，y 是看到的<code>view</code>的左上角相对父容器的坐标，但不同于 left 和 top ，这两个坐标点的值并一定都是相等的。</p>
<p>真实<code>view</code> 和 看到<code>view</code>的偏差用 <code>translationX</code> 和 <code>translationY</code> <code>来表示</code>。</p>
<h3 id="translationxtranslationy"><a class="markdownIt-Anchor" href="#translationxtranslationy"></a> <code>translationX</code>，<code>translationY</code></h3>
<p>**android开发艺术探索中，关于<code>translationX</code>的讲解是错误的。**真实情况是，<code>translationX</code>是<code>真实view</code> 相对于<code>看到view</code>的 x 方向偏移量。</p>
<p>从上图可以得知：<code>x</code> = <code>left</code> + <code>translationX</code>。</p>
<h2 id="二-点击事件的xy坐标"><a class="markdownIt-Anchor" href="#二-点击事件的xy坐标"></a> 二、点击事件的<code>XY</code>坐标</h2>
<img src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/20180802143219331" style="zoom:50%;" />
<h2 id="三-motionevent"><a class="markdownIt-Anchor" href="#三-motionevent"></a> 三、<code>MotionEvent</code></h2>
<p>常见的触摸动作一共有三个：</p>
<ol>
<li><code>ACTION_DOWN</code>手指按下动作</li>
<li><code>ACTION_MOVE</code>手指滑动动作</li>
<li><code>ACTION_UP</code>    手指抬起动作</li>
</ol>
<h2 id="四-gesturedetector"><a class="markdownIt-Anchor" href="#四-gesturedetector"></a> 四、<code>GestureDetector</code></h2>
<p>手势检测，检测用户的单击、双击、长按等操作。</p>
<p>通过创建<code>GestureDetector</code>对象并实现<code>OnGestureListener</code>接口（检测单击相关手势）或者<code>OnDoubleTapListener</code>接口（检测双击相关动作）。</p>
<h2 id="五-touchslop"><a class="markdownIt-Anchor" href="#五-touchslop"></a> 五、<code>TouchSlop</code></h2>
<p>不同安卓设备认为的最小的滑动距离，低于此距离，将不认为用户在滑动，开发者可自行更改，默认为<code>8dp</code>。</p>
<h2 id="六-velocitytracker"><a class="markdownIt-Anchor" href="#六-velocitytracker"></a> 六、<code>VelocityTracker</code></h2>
<p>速度检测，可以计算出用户的手势的滑动速度。</p>
<p>注意，在<code>VelocityTracker#computeCurrentVelocity(int time)</code>中的<code>time</code>参数是我们计算速度的单位时间，相同的速度用不同的单位时间会有不同的表示方法。</p>
<h2 id="七-scroller"><a class="markdownIt-Anchor" href="#七-scroller"></a> 七、<code>Scroller</code></h2>
<p>弹性滑动对象，由于View中的<code>scrollTo/scrollBy</code>都是瞬间完成位移的。对用户的使用体验不太友好，所以引入弹性滑动对象，使得<code>View</code>的滑动变得可视化。</p>
<h1 id="view的滑动"><a class="markdownIt-Anchor" href="#view的滑动"></a> View的滑动</h1>
<h2 id="一-scrolltoscrollby"><a class="markdownIt-Anchor" href="#一-scrolltoscrollby"></a> 一、<code>scrollTo</code>/<code>scrollBy</code></h2>
<p>View有专门的方法实现滑动，即<code>scrollTo()</code>, <code>scrollBy()</code>;</p>
<p>这两个函数只能将<code>View</code>中间的内容进行位移，但是不能改变<code>View</code>本身的位置。</p>
<p>可以方便的实现滑动效果并且不影响内部元素的点击事件。</p>
<p><code>scrollTo(int destX, int destY)</code>直接让View出现在目标位置，无中间动画。</p>
<p>参数变量的单位都是像素级。</p>
<h2 id="二-使用动画"><a class="markdownIt-Anchor" href="#二-使用动画"></a> 二、使用动画</h2>
<p>有两种动画的使用方法。</p>
<ol>
<li>
<p><code>View</code>动画</p>
<p>在<code>XML</code>文件里面通过改变<code>translationX</code>/<code>translationY</code>的方式来实现View的移动效果。</p>
</li>
<li>
<p>属性动画</p>
<p>在<code>Android3.0</code>版本以上，可以使用<code>ObjectAnimator</code>类来实现属性动画的效果。</p>
<p>在<code>Android3.0</code>以下的版本中，我们需要自己加载开源动画库<code>NineOldAndroids</code>。</p>
</li>
</ol>
<p>在<code>XML</code>文件中，有一个<code>andoird:fillAfter=&quot;true|false&quot;</code>的选项。</p>
<p>当为<code>true</code>的时候，View在动画结束后，图像将停留在目标位置上。</p>
<p>当为<code>false</code>的时候，View会在动画结束后，从末位置消失，重新在初位置出现。</p>
<p>不论是<code>true</code>还是<code>false</code>，View的点击事件的坐标还是在原先的初始位置上，并不会随着<code>View</code>的移动而移动。</p>
<p>在<code>Android3.0</code>以上使用属性动画可以解决这样的问题。</p>
<h2 id="三-改变布局参数"><a class="markdownIt-Anchor" href="#三-改变布局参数"></a> 三、改变布局参数</h2>
<p>通过修改<code>View</code>的<code>marginLeft</code>等等布局参数，以此来达到<code>View</code>滑动的效果。</p>
<h1 id="弹性滑动"><a class="markdownIt-Anchor" href="#弹性滑动"></a> 弹性滑动</h1>
<h2 id="一-scroller"><a class="markdownIt-Anchor" href="#一-scroller"></a> 一、<code>Scroller</code></h2>
<p><code>Scroller#smoothScrollTo(int destX, int destY)</code>将<strong>目标位置与初始位置的偏移值delta</strong>计算后调用<code>startScroller()</code>方法存储相关参数，并开始使用<code>invalidate()</code>方法重绘<code>View</code>。重绘<code>View</code>时的<code>draw()</code>方法会调用<code>computeScroll()</code>方法，其中又会调用<code>invalidate</code>方法重绘<code>View</code>，不断的循环。由于<code>scrollTo(int destX, int destY)</code>直接让View出现在目标位置，所以我们在<code>computeScroll()</code>方法中采取微分法的做法，即将一段长距离拆分成许多微小的距离。不断通过<code>scrollTo()</code>的直接滑动以及<code>computeScrollOffset()</code>的重新计算下一个短距离的相关参数以及<code>postInvalidate()</code>的重绘View，最终达到弹性滑动的效果。</p>
<p><code>computeScrollOffset()</code>方法通过计算目前已经位移的百分比来计算下一次的位移目标以及是否已经完成的滑动，不通过计时器等工具。</p>
<div class="mermaid-wrap"><pre class="mermaid-src" hidden>
  flowchart TD
A[startScroll]
B[invalidate]
C[computeScroll]
D[computeScrollOffset : boolean]
E[invalidate]

A --&gt; B --&gt;|draw| C --&gt; D --&gt;|not finish| E --&gt;|draw| C
D --&gt;|finish| F[finish]
  </pre></div>
<h2 id="二-通过动画"><a class="markdownIt-Anchor" href="#二-通过动画"></a> 二、通过动画</h2>
<p>通过<code>ObjectAnimator类</code>我们可以直接的通过动画完成<code>View</code>的弹性滑动。</p>
<p>我们也可以通过<code>onAnimatorUpdate</code>方法还自定义自己想要的动画效果。</p>
<h2 id="三-使用延时策略"><a class="markdownIt-Anchor" href="#三-使用延时策略"></a> 三、使用延时策略</h2>
<p>可以通过<code>Thread#sleep</code>或者<code>Handler#postDelayed</code>方法来达到间隔一定的时间就改变一次微小位置变化的操作。</p>
<p>在此次的<code>scrollTo</code>方法执行结束后，通过<code>sleep|postDelayed</code>方法暂停一定的时间，然后重复执行<code>scrollTo</code>的方法，以此来达到弹性滑动的效果。</p>
<p>**注意：**无法在精准的时间内移动固定的位移，因为系统的消息调度（<code>sleep|postDelayed</code>）也是需要时间的。</p>
<h1 id="view的事件分发机制"><a class="markdownIt-Anchor" href="#view的事件分发机制"></a> <code>View</code>的事件分发机制</h1>
<h2 id="一-点击事件的传递规则"><a class="markdownIt-Anchor" href="#一-点击事件的传递规则"></a> 一、点击事件的传递规则</h2>
<p>点击事件分发过程，即将一系列的<code>MotionEvent</code>事件序列（由<code>ACTION_DOWN</code>开始到<code>ACTION_UP</code>结束的一连串操作）交给一个<code>View</code>执行的过程。</p>
<p>点击事件的分发主要由三个重要方法构成：<code>dispatchTouchEvent</code>, <code>onInterceptTouchEvent</code>,<code>onTouchEvent</code>。</p>
<p>三个方法的执行顺序如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123; <span class="comment">// 对当前的View进行事件的分发</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">consume</span> <span class="operator">=</span> <span class="literal">false</span>;                        <span class="comment">// 判断是否可以消耗这个事件序列</span></span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(ev)) &#123;                <span class="comment">// 如果准备拦截此次事件序列</span></span><br><span class="line">        consume = onTouchEvent(ev);                 <span class="comment">// 事件由该View执行，并返回结果</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        consume = child.dispatchTouchEvent(ev);     <span class="comment">// 若不准备拦截，则交给子View进行判断</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> consume;                                 <span class="comment">// 向父级返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中执行事件序列的不同方法中同样由优先顺序：<code>onTouchListener &gt; onTouchEvent &gt; onClickListener</code></p>
<p>当点击事件发生后，它的传递过程会遵循以下的顺序：<code>Activity　-&gt; Window -&gt; DecorView -&gt; View -&gt; ...</code>、</p>
<p>同时，如果子级发现无法执行这个事件的时候，那么它的父容器的<code>onTouchEvent</code>就会重新调用，直到<code>Activity</code>。</p>
<p>其中，<code>ViewGroup</code>默认不拦截任何事件，<code>View</code>没有<code>onInterceptTouchEvent</code>方法。</p>
<h2 id="二-事件分发解析"><a class="markdownIt-Anchor" href="#二-事件分发解析"></a> 二、事件分发解析</h2>
<h3 id="activity对点击事件的分发"><a class="markdownIt-Anchor" href="#activity对点击事件的分发"></a> <code>Activity</code>对点击事件的分发</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">diapatchTouchEvent</span><span class="params">(MotionEvent ev)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) <span class="comment">// 如果Window可以处理点击事件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev); <span class="comment">// 返回Activity自己处理点击事件的结果(true|false)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="window对点击事件的分发"><a class="markdownIt-Anchor" href="#window对点击事件的分发"></a> <code>Window</code>对点击事件的分发</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> PhoneWindow#superDispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">  	<span class="keyword">return</span> mDecor.superDispatchTouchEvent(ev); <span class="comment">// 返回DecorView的处理结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="顶级view对点击事件的分发"><a class="markdownIt-Anchor" href="#顶级view对点击事件的分发"></a> <code>顶级View</code>对点击事件的分发</h3>
<p>由此开始，将执行（一）所讲述的事件传递规则。其主要的部分是<code>ViewGroup</code>的事件传递。<code>顶级View</code>一般来说都是<code>ViewGroup</code>。</p>
<h4 id="判断当前viewgroup是否拦截点击事件"><a class="markdownIt-Anchor" href="#判断当前viewgroup是否拦截点击事件"></a> 判断当前<code>ViewGroup</code>是否拦截点击事件</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION.DOWN || mFirstTouchTarget != NULL) &#123; <span class="comment">// 意思见下方文字</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">disallowIntercept</span> <span class="operator">=</span> (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>; <span class="comment">// 判断是否允许屏蔽自身的onInterceptTouchEvent方法</span></span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123; <span class="comment">// 如果允许拦截</span></span><br><span class="line">        intercepted = onInterceptTouchEvent(ev); <span class="comment">// 询问能否拦截并赋值</span></span><br><span class="line">        ev.setAction(action); <span class="comment">// 防止事件被修改，存储事件的动作</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="literal">false</span>; <span class="comment">// 由于不允许拦截，则直接赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    intercepted = <span class="literal">true</span>; <span class="comment">// 由于直接拦截，则不用询问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的几个变量的作用：</p>
<ol>
<li>
<p>当事件由<code>ViewGroup</code>的子元素处理成功时，<code>mFirstTouchTarget</code>就会被赋值并指向子元素，此时的<code>mFirstTouchTarget != NULL</code>。</p>
</li>
<li>
<p><code>FLAG_DISALLOW_INTERCEPT</code>一旦被设置后，那么当前的<code>ViewGroup</code>就无法拦截<code>ACTION_MOVE</code>以及<code>ACTION_UP</code>。</p>
<p>由于事件为<code>ACTION_DOWN</code>的时候，<code>ViewGroup</code>会重置<code>FLAG_DISALLOW_INTERCEPT</code>，所以每次事件为<code>ACTION_DOWN</code>的时候，都会执行一次<code>onInterceptTouchEvent</code>方法。</p>
</li>
</ol>
<p>第3行的判断语句的意思为：</p>
<ol>
<li>如果当前的事件为<code>ACTION_DOWN</code>时，作为一个点击事件的开始，需要向子元素传递，返回<code>true</code>。允许向子元素传递。</li>
<li>如果当前的事件为<code>ACTION_MOVE</code>或者<code>ACTION_UP</code>的时候，如果<code>ACTION_DOWN</code>已经被子元素处理了（<code>mFirstTouchTarget != NULL</code>），那么由于一系列的点击事件都要有同一个<code>View</code>处理，则不能在此拦截，故返回<code>true</code>。反之，如果<code>mFirstTouchTarget == NULL</code>，则代表<code>ACTION_DOWN</code>是由<code>ViewGroup</code>自身处理的，则不能向下传递，返回<code>false</code>。</li>
</ol>
<h4 id="viewgroup在action_down到来时的重置操作"><a class="markdownIt-Anchor" href="#viewgroup在action_down到来时的重置操作"></a> <code>ViewGroup</code>在<code>ACTION_DOWN</code>到来时的重置操作</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle an initial down.</span></span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">	cancelAndClearTouchTargets(ev);</span><br><span class="line">	resetTouchState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>resetTouchState</code>方法中会对<code>FLAG_DISALLOW_INTERCEPT</code>进行重置。</p>
<p>因此<code>子View</code>的<code>requestDisallowInterceptTouchEvent</code>方法并不能影响<code>ViewGroup</code>对<code>ACTION_DOWN</code>事件的处理。</p>
<h4 id="viewgroup不拦截事件时对点击事件的分发"><a class="markdownIt-Anchor" href="#viewgroup不拦截事件时对点击事件的分发"></a> <code>ViewGroup</code>不拦截事件时，对点击事件的分发</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> View[] = mChildren;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 获取每一个子View的位置以及其他信息</span></span><br><span class="line">    <span class="keyword">if</span> (子元素正在播放动画 || 点击事件的坐标落在当前子元素的区域外) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    newTouchTarget = getTouchTarget(child); </span><br><span class="line">    <span class="keyword">if</span> (newTouchTarget != NULL) &#123; <span class="comment">// 如果不是NULL的话(该child之前初始化过)，就直接向其中添加元素就行了</span></span><br><span class="line">        newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果 newTouchTarget == NULL, 那么就初始化 + 添加第一个可用子元素</span></span><br><span class="line">    resetCancelNextUpFlag(child);</span><br><span class="line">    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="literal">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">        ...</span><br><span class="line">        newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">        alreadyDispatchedToNewTouchTarget = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不断的遍历当前<code>ViewGroup</code>的所有子元素，如果<strong>子元素不在播放动画</strong>以及<strong>点击事件的坐标落在当前子元素的区域内</strong>，那么这个子元素就是一个可以传递的。</p>
<blockquote>
<p>由<code>TouchTarget</code>源码可知：</p>
<p><code>TouchTarget</code>保存了响应触摸事件的子<code>view</code>和该子view上的触摸点ID集合，表示一个触摸事件派发目标。通过<code>next</code>成员可以看出，它支持作为一个链表节点储存。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TouchTarget</span> &#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The touched child view.</span></span><br><span class="line">    <span class="comment">// 被触摸的子元素</span></span><br><span class="line">    <span class="meta">@UnsupportedAppUsage</span></span><br><span class="line">    <span class="keyword">public</span> View child;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The combined bit mask of pointer ids for all pointers captured by the target.</span></span><br><span class="line">    <span class="comment">// 指针 id 的位的掩码组合，用于目标捕获的所有指针</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> pointerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The next target in the target list.</span></span><br><span class="line">    <span class="comment">// 目标列表中的下一个目标</span></span><br><span class="line">    <span class="keyword">public</span> TouchTarget next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「分则能成」的原创文章，遵循CC <span class="number">4.0</span> BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/dehang0/article/details/104317611</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果是第一个可传递元素，那么就会进入初始化部分，其中的<code>dispatchTransformedTouchEvent</code>方法实际上就是调用的子元素的<code>dispatchTouchEvent</code>方法。在该方法中有如下的一段内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == NULL) &#123;</span><br><span class="line">    handled = <span class="built_in">super</span>.dispatchTouchTarget(event);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handled = child.dispatchTouchTarget(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于前面的代码中<code>dispatchTransformedTouchEvent</code>方法的第三个参数为<code>child</code>，所以会执行子元素的<code>dispatchTouchEvent</code>方法，点击事件交由子元素处理，从而完成了一轮事件的分发。</p>
<p>当子元素的<code>dispatchTouchEvent</code>方法返回<code>true</code>时，<code>dispatchTransformedTouchEvent</code>方法同样也会返回<code>true</code>，接着便执行<code>if语句</code>的代码块部分了。如果<code>dispatchTouchEvent</code>方法返回<code>false</code>的话，<code>ViewGroup</code>就会把事件向后遍历，寻找新的可传递的子元素。在<code>if语句</code>的代码块中，<code>mFirstTouchTarget</code>会被赋值同时跳出<code>for循环</code>。</p>
<p>其中<code>mFirstTouchTarget</code>的赋值由<code>addTouchTarget</code>方法完成，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TouchTarget <span class="title function_">addTouchTarget</span><span class="params">(View child, <span class="type">int</span> pointerIdBits)</span> &#123;</span><br><span class="line">    <span class="type">TouchTarget</span> <span class="variable">target</span> <span class="operator">=</span> TouchTarget.obtain(child, pointerIdBits);</span><br><span class="line">   	target.next = mFirstTouchTarget;</span><br><span class="line">    mFirstTouchTarget = target;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以很容易的看出，<code>mFirstTouchTarget</code>其实是一个<strong>单链表结构</strong>，<code>mFirstTouchTarget</code>是否被赋值，将直接影响<code>ViewGroup</code>对事件的拦截策略。</p>
<h4 id="viewgroup中没有合适的子元素"><a class="markdownIt-Anchor" href="#viewgroup中没有合适的子元素"></a> <code>ViewGroup</code>中没有合适的子元素</h4>
<p>有两种情况，<code>ViewGroup</code>中会没有合适的子元素可以传递：</p>
<ol>
<li><code>ViewGroup</code>没有子元素</li>
<li>子元素处理了点击事件，但是<code>dispatchTouchEvent</code>方法返回了<code>false</code>，这一般是因为子元素在<code>onTouchEvent</code>中返回了<code>false</code>。</li>
</ol>
<p>在这两种情况中，<code>ViewGroup</code>都会自己处理点击事件。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mFirstTouchTarget == NULL) &#123;</span><br><span class="line">	<span class="comment">// 没有可分发子元素，就当其是一个普通的View</span></span><br><span class="line">	handled = dispatchTransformedTouchEvent(ev, canceled, <span class="literal">null</span>, TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，代码中的<code>dispatchTransformedTouchEvent</code>方法的第三个参数将其设置为<code>null</code>，此时它就会调用<code>super.dispatchTouchTarget</code>方法了。</p>
<h3 id="view对点击事件的处理过程"><a class="markdownIt-Anchor" href="#view对点击事件的处理过程"></a> <code>View</code>对点击事件的处理过程</h3>
<p>这里的<code>View</code>不包含<code>ViewGroup</code>，因为没有子元素，所以不用向下分发事件，只能自己处理事件。</p>
<p>先看它的<code>dispatchTouchEvent</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">        <span class="type">ListenerInfo</span> <span class="variable">li</span> <span class="operator">=</span> mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="literal">null</span> &amp;&amp; li.mOnTouchListener != <span class="literal">null</span> &amp;&amp; .li.mOnTouchListener.onTouch(<span class="built_in">this</span>, event) &amp;&amp; ...) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面的代码可以看出，<code>View</code>对点击事件的处理流程中，首先会判断有没有设置<code>onTouchListener</code>，如果有且其中的<code>onTouch</code>方法返回<code>true</code>，则<code>onTouchEvent</code>方法就不会被调用。</p>
<p>从其他的代码中也可以得出的一些结论：</p>
<ol>
<li>如果<code>View</code>的<code>CLICKABLE</code>以及<code>LONG_CLICKABLE</code>中有一个为<code>true</code>，不论<code>View</code>是否为<code>DISABLE</code>，都会消耗事件（也就是即使<code>View</code>看起来没有任何的反应，但是也消耗了点击事件）。</li>
<li><code>View</code>的<code>LONG_CLICKABLE</code>默认为<code>false</code>，而<code>CLICKABLE</code>是否为<code>false</code>与其<code>View</code>有关，如<code>button</code>的默认为<code>true</code>、<code>textview</code>的默认为<code>false</code>。</li>
<li>当<code>ACTION_UP</code>事件发生时，会触发<code>performClick</code>方法，如果<code>View</code>设置了<code>OnClickListener</code>，那么<code>performClick</code>方法就会调用它的<code>onClick</code>方法。（即<code>onClick</code>的触发前提时<code>View</code>是可点击的，且收到了<code>DOWN</code>和<code>UP</code>的点击事件。）</li>
<li><code>setOnClickListener</code>方法会自动将<code>CLICKABLE</code>设置为<code>true</code>，<code>setOnLongClickListener</code>方法会自动将<code>LONG_CLICKABLE</code>设置为<code>true</code>。</li>
</ol>
<h1 id="view的滑动冲突"><a class="markdownIt-Anchor" href="#view的滑动冲突"></a> <code>View</code>的滑动冲突</h1>
<p>总共会出现三种滑动冲突的情况：</p>
<ol>
<li><code>内部View</code>与<code>外部View</code>的滑动方向相反。</li>
<li><code>内部View</code>与<code>外部View</code>的滑动方向相同。</li>
<li>前两种情况的嵌套。</li>
</ol>
<p>三种情况的处理思路：</p>
<ol>
<li>通过手势滑动的角度判断滑动的方向。</li>
<li>通过当前处于的不同的页面状态来判断应该滑动的<code>View</code>。</li>
<li>通过前两种的综合使用。</li>
</ol>
<h2 id="滑动冲突的解决方式"><a class="markdownIt-Anchor" href="#滑动冲突的解决方式"></a> 滑动冲突的解决方式</h2>
<h3 id="外部拦截法"><a class="markdownIt-Anchor" href="#外部拦截法"></a> 外部拦截法</h3>
<p>通过重写<strong>父容器的</strong><code>onInterceptTouchEvent</code>方法，所有的事件都先经过父容器的筛选，对其中父容器需要的事件进行拦截。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">intercepted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) event.getX();</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) event.getY();</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN : &#123;</span><br><span class="line">            intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE : &#123;</span><br><span class="line">            <span class="keyword">if</span> (父容器需要当前的点击事件)</span><br><span class="line">                intercepted = <span class="literal">true</span>;</span><br><span class="line">           	<span class="keyword">else</span> </span><br><span class="line">                intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP : &#123;</span><br><span class="line">            intercepted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastXIntercept = x;</span><br><span class="line">    mLastYIntercept = y;</span><br><span class="line">    <span class="keyword">return</span> intercepted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内部拦截法"><a class="markdownIt-Anchor" href="#内部拦截法"></a> 内部拦截法</h3>
<p>父元素拦截除<code>ACTION_DOWN</code>以外的其他事件，当事件到达子元素后，由子元素判断是否需要这些事件，不需要的事件将重新交由父容器来处理。这种方法和Android的事件分发机制不一致，需要配合<code>requestDisallowInterceptTouchEvent</code>方法才能正常的工作。</p>
<p>相关阅读链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/fe3d109eb27e">Android TouchEvent之requestDisallowInterceptTouchEvent - 简书 (jianshu.com)</a></p>
<h4 id="子元素的dispatchtouchevent方法"><a class="markdownIt-Anchor" href="#子元素的dispatchtouchevent方法"></a> 子元素的<code>dispatchTouchEvent</code>方法</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) event.getX();</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (<span class="type">int</span>) event.getY();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN : &#123;</span><br><span class="line">            parent.requestDisallowInterceptTouchEvent(<span class="literal">true</span>); <span class="comment">// 此子View的所有父ViewGroup会跳过onInterceptTouchEvent回调</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE : &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">deltaX</span> <span class="operator">=</span> x - mLastX;</span><br><span class="line">            <span class="type">int</span> <span class="variable">deltaY</span> <span class="operator">=</span> y - mLastY;</span><br><span class="line">            <span class="keyword">if</span> (父容器需要当前的点击事件) &#123;</span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP : &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span> : </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mLastX = x;</span><br><span class="line">    mLastY = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="父容器的onintercepttouchevent方法"><a class="markdownIt-Anchor" href="#父容器的onintercepttouchevent方法"></a> 父容器的<code>onInterceptTouchEvent</code>方法：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> event.getAction();</span><br><span class="line">    <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">LuoYu-Ying</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://luoyu-ying.github.io/2022/04/27/View-%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/">https://luoyu-ying.github.io/2022/04/27/View-%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://luoyu-ying.github.io" target="_blank">洛语 の Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a><a class="post-meta__tags" href="/tags/View/">View</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/id=2318466(じむ(kaji).jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/28/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/007YMVZbgy1gmk0eknrqnj316h0x2qa3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">字符串哈希</div></div></a></div><div class="next-post pull-right"><a href="/2022/04/23/XCPC-%E8%AF%BB%E5%85%A5%E6%93%8D%E4%BD%9C%E6%A8%A1%E6%9D%BF/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/necömi@3日目東シ32a ID=67786060.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">XCPC 读入操作模板</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/04/18/View-%E7%9A%84%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/" title="View 的绘制原理"><img class="cover" src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/id=46014079(oright).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-18</div><div class="title">View 的绘制原理</div></div></a></div><div><a href="/2022/04/17/Android-%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/" title="Android 动画深入分析"><img class="cover" src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/id=55325876(loundraw).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-17</div><div class="title">Android 动画深入分析</div></div></a></div><div><a href="/2022/04/16/Drawable-%E8%A7%A3%E6%9E%90/" title="Drawable 解析"><img class="cover" src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/pic6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-16</div><div class="title">Drawable 解析</div></div></a></div><div><a href="/2022/04/16/Handler-%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/" title="Handler 机制解析"><img class="cover" src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/pic10.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-16</div><div class="title">Handler 机制解析</div></div></a></div><div><a href="/2022/04/16/ThreadLocal-%E8%A7%A3%E6%9E%90-%E8%BD%AC%E8%BD%BD/" title="ThreadLocal 解析 [转载]"><img class="cover" src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/id=66934796(Y_Y).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-16</div><div class="title">ThreadLocal 解析 [转载]</div></div></a></div><div><a href="/2022/04/17/%E7%90%86%E8%A7%A3-Window-%E5%92%8C-WindowManager/" title="理解 Window 和 WindowManager [转载]"><img class="cover" src="https://cdn.jsdelivr.net/gh/LuoYu-Ying/Blog_img/id=37311279(凹).jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-17</div><div class="title">理解 Window 和 WindowManager [转载]</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#view%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text"> View基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-view%E7%9A%84%E7%9B%B8%E5%85%B3%E5%9D%90%E6%A0%87%E5%92%8C%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.1.</span> <span class="toc-text"> 一、View的相关坐标和位置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lefttoprightbottom"><span class="toc-number">1.1.1.</span> <span class="toc-text"> left，top，right，bottom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xy"><span class="toc-number">1.1.2.</span> <span class="toc-text"> X，Y</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#translationxtranslationy"><span class="toc-number">1.1.3.</span> <span class="toc-text"> translationX，translationY</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84xy%E5%9D%90%E6%A0%87"><span class="toc-number">1.2.</span> <span class="toc-text"> 二、点击事件的XY坐标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-motionevent"><span class="toc-number">1.3.</span> <span class="toc-text"> 三、MotionEvent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-gesturedetector"><span class="toc-number">1.4.</span> <span class="toc-text"> 四、GestureDetector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-touchslop"><span class="toc-number">1.5.</span> <span class="toc-text"> 五、TouchSlop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-velocitytracker"><span class="toc-number">1.6.</span> <span class="toc-text"> 六、VelocityTracker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-scroller"><span class="toc-number">1.7.</span> <span class="toc-text"> 七、Scroller</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#view%E7%9A%84%E6%BB%91%E5%8A%A8"><span class="toc-number">2.</span> <span class="toc-text"> View的滑动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-scrolltoscrollby"><span class="toc-number">2.1.</span> <span class="toc-text"> 一、scrollTo&#x2F;scrollBy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E4%BD%BF%E7%94%A8%E5%8A%A8%E7%94%BB"><span class="toc-number">2.2.</span> <span class="toc-text"> 二、使用动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E6%94%B9%E5%8F%98%E5%B8%83%E5%B1%80%E5%8F%82%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text"> 三、改变布局参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%B9%E6%80%A7%E6%BB%91%E5%8A%A8"><span class="toc-number">3.</span> <span class="toc-text"> 弹性滑动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-scroller"><span class="toc-number">3.1.</span> <span class="toc-text"> 一、Scroller</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E9%80%9A%E8%BF%87%E5%8A%A8%E7%94%BB"><span class="toc-number">3.2.</span> <span class="toc-text"> 二、通过动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E4%BD%BF%E7%94%A8%E5%BB%B6%E6%97%B6%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.</span> <span class="toc-text"> 三、使用延时策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#view%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text"> View的事件分发机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E9%80%92%E8%A7%84%E5%88%99"><span class="toc-number">4.1.</span> <span class="toc-text"> 一、点击事件的传递规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E8%A7%A3%E6%9E%90"><span class="toc-number">4.2.</span> <span class="toc-text"> 二、事件分发解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#activity%E5%AF%B9%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91"><span class="toc-number">4.2.1.</span> <span class="toc-text"> Activity对点击事件的分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window%E5%AF%B9%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91"><span class="toc-number">4.2.2.</span> <span class="toc-text"> Window对点击事件的分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%BA%A7view%E5%AF%B9%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91"><span class="toc-number">4.2.3.</span> <span class="toc-text"> 顶级View对点击事件的分发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8Dviewgroup%E6%98%AF%E5%90%A6%E6%8B%A6%E6%88%AA%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.2.3.1.</span> <span class="toc-text"> 判断当前ViewGroup是否拦截点击事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#viewgroup%E5%9C%A8action_down%E5%88%B0%E6%9D%A5%E6%97%B6%E7%9A%84%E9%87%8D%E7%BD%AE%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.3.2.</span> <span class="toc-text"> ViewGroup在ACTION_DOWN到来时的重置操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#viewgroup%E4%B8%8D%E6%8B%A6%E6%88%AA%E4%BA%8B%E4%BB%B6%E6%97%B6%E5%AF%B9%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%88%86%E5%8F%91"><span class="toc-number">4.2.3.3.</span> <span class="toc-text"> ViewGroup不拦截事件时，对点击事件的分发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#viewgroup%E4%B8%AD%E6%B2%A1%E6%9C%89%E5%90%88%E9%80%82%E7%9A%84%E5%AD%90%E5%85%83%E7%B4%A0"><span class="toc-number">4.2.3.4.</span> <span class="toc-text"> ViewGroup中没有合适的子元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#view%E5%AF%B9%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">4.2.4.</span> <span class="toc-text"> View对点击事件的处理过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#view%E7%9A%84%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81"><span class="toc-number">5.</span> <span class="toc-text"> View的滑动冲突</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text"> 滑动冲突的解决方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8B%A6%E6%88%AA%E6%B3%95"><span class="toc-number">5.1.1.</span> <span class="toc-text"> 外部拦截法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%8B%A6%E6%88%AA%E6%B3%95"><span class="toc-number">5.1.2.</span> <span class="toc-text"> 内部拦截法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E5%85%83%E7%B4%A0%E7%9A%84dispatchtouchevent%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.2.1.</span> <span class="toc-text"> 子元素的dispatchTouchEvent方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%B6%E5%AE%B9%E5%99%A8%E7%9A%84onintercepttouchevent%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.2.2.</span> <span class="toc-text"> 父容器的onInterceptTouchEvent方法：</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By LuoYu-Ying</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>